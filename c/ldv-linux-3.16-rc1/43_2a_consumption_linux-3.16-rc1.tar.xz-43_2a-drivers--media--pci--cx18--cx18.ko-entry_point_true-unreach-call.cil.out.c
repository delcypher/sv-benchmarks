extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 163 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 168 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 327 "./arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_17 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_18 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_19 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion_ldv_2850_16 {
   struct __anonstruct_futex_17 futex ;
   struct __anonstruct_nanosleep_18 nanosleep ;
   struct __anonstruct_poll_19 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_2850_16 ldv_2850 ;
};
#line 26 "include/asm-generic/getorder.h"
struct exec_domain;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 26 "include/linux/personality.h"
struct map_segment;
#line 26 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 617 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_29 {
   unsigned long seg ;
};
#line 617 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_29 mm_segment_t;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
#line 433 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 72 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 167 "./arch/x86/include/asm/fixmap.h"
struct notifier_block;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 906 "include/linux/mmzone.h"
struct ctl_table;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13760_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13762_128 {
   struct __anonstruct_ldv_13760_129 ldv_13760 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13762_128 ldv_13762 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 24 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14006_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14010_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_14011_135 {
   struct __anonstruct_ldv_14006_136 ldv_14006 ;
   struct __anonstruct_ldv_14010_137 ldv_14010 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14011_135 ldv_14011 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14120_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14126_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14136_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14138_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14136_144 ldv_14136 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14140_142 {
   union __anonunion_ldv_14138_143 ldv_14138 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14142_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14140_142 ldv_14140 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14143_139 {
   union __anonunion_ldv_14126_140 ldv_14126 ;
   union __anonunion_ldv_14142_141 ldv_14142 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14150_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14155_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14150_146 ldv_14150 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14161_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 ldv_14120 ;
   struct __anonstruct_ldv_14143_139 ldv_14143 ;
   union __anonunion_ldv_14155_145 ldv_14155 ;
   union __anonunion_ldv_14161_147 ldv_14161 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14524_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14524_153 ldv_14524 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14668_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14668_154 ldv_14668 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15343_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15343_155 ldv_15343 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15963_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15969_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_15970_156 {
   struct __anonstruct_ldv_15963_157 ldv_15963 ;
   struct __anonstruct_ldv_15969_158 ldv_15969 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15970_156 ldv_15970 ;
};
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev;
#line 26
struct videobuf_buffer;
#line 34
struct v4l2_encoder_cmd;
#line 36
struct videobuf_queue;
#line 37
struct v4l2_buffer;
#line 39
struct cx2341x_handler;
#line 42
struct v4l2_format;
#line 45
struct v4l2_sliced_vbi_format;
#line 74
struct v4l2_audio;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 218 "include/linux/capability.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_160 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_160 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_162 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_163 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_164 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_166 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_167 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_168 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_161 {
   int _pad[28U] ;
   struct __anonstruct__kill_162 _kill ;
   struct __anonstruct__timer_163 _timer ;
   struct __anonstruct__rt_164 _rt ;
   struct __anonstruct__sigchld_165 _sigchld ;
   struct __anonstruct__sigfault_166 _sigfault ;
   struct __anonstruct__sigpoll_167 _sigpoll ;
   struct __anonstruct__sigsys_168 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_161 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 11 "include/linux/signal.h"
struct user_struct;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 459
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 466
struct pid_namespace;
#line 466 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_17679_171 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_17687_172 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_17700_174 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_17701_173 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_17700_174 ldv_17700 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_175 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_177 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_17716_176 {
   union __anonunion_payload_177 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_17679_171 ldv_17679 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_17687_172 ldv_17687 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_17701_173 ldv_17701 ;
   union __anonunion_type_data_175 type_data ;
   union __anonunion_ldv_17716_176 ldv_17716 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct tty_struct;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct backing_dev_info;
#line 779
struct reclaim_state;
#line 780 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1026
struct io_context;
#line 1060
struct pipe_inode_info;
#line 1061
struct uts_namespace;
#line 1062 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct files_struct;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_19510_180 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_19511_179 {
   struct __anonstruct_ldv_19510_180 ldv_19510 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_19511_179 ldv_19511 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct_ldv_19535_182 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion_ldv_19537_181 {
   struct __anonstruct_ldv_19535_182 ldv_19535 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_19537_181 ldv_19537 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_183 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_183 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_19898_185 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_19900_184 {
   struct __anonstruct_ldv_19898_185 ldv_19898 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_19900_184 ldv_19900 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 70
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct iovec;
#line 62
struct kiocb;
#line 63
struct poll_table_struct;
#line 64
struct kstatfs;
#line 65
struct swap_info_struct;
#line 66
struct iov_iter;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_186 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_186 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_20450_187 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_20450_187 ldv_20450 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 411
struct writeback_control;
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_20865_190 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_20885_191 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_20902_192 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_20865_190 ldv_20865 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_20885_191 ldv_20885 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_20902_192 ldv_20902 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_193 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_193 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 855
struct net;
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_195 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_194 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_195 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_194 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 262 "include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 628
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
struct hotplug_slot;
#line 69 "include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 109 "include/linux/pci.h"
typedef int pci_power_t;
#line 136 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 137
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 162 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 185 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 242
struct pcie_link_state;
#line 243
struct pci_vpd;
#line 244
struct pci_sriov;
#line 245
struct pci_ats;
#line 246
struct proc_dir_entry;
#line 246
struct pci_driver;
#line 246 "include/linux/pci.h"
union __anonunion_ldv_24556_199 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 246 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_24556_199 ldv_24556 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 436
struct pci_ops;
#line 436
struct msi_chip;
#line 436 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 553 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 574 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 588 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 598 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 631 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1153 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 450 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 42 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 783 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_adapter;
#line 41
struct i2c_client;
#line 198 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
};
#line 335 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
};
#line 381 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_bus_recovery_info * ) ;
   void (*unprepare_recovery)(struct i2c_bus_recovery_info * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 420 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
};
#line 578 "include/linux/i2c.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
#line 666 "include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 163 "include/linux/poll.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 34 "include/linux/cdev.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 549 "./include/uapi/linux/v4l2-common.h"
enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9
} ;
#line 562
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 585
enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4
} ;
#line 603
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 611 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 216 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 221 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 242 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 291 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 460 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 473 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 482 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33087_203 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 482 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion_ldv_33087_203 ldv_33087 ;
   __u32 reserved[2U] ;
};
#line 501 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 510 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33106_204 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 510 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion_ldv_33106_204 ldv_33106 ;
   __u32 reserved[2U] ;
};
#line 525 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 539 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 568 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 593 "include/uapi/linux/videodev2.h"
union __anonunion_m_205 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 593 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_205 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 625 "include/uapi/linux/videodev2.h"
union __anonunion_m_206 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 625 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_206 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 678 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 737 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct v4l2_pix_format fmt ;
};
#line 749 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 771 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 781 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 793 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 806 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 816 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 821 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 848 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1040 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33239_207 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1040 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_ldv_33239_207 ldv_33239 ;
};
#line 1102 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1120 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1143 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33262_208 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1143 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion_ldv_33262_208 ldv_33262 ;
};
#line 1168 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1184 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1248 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33293_209 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
};
#line 1248 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion_ldv_33293_209 ldv_33293 ;
};
#line 1259 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1267
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9
} ;
#line 1279 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1296 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33326_210 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1296 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion_ldv_33326_210 ldv_33326 ;
   __u32 reserved ;
};
#line 1307 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1343 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1353 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1392 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1407 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1428 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1450 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1465 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1492 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_212 {
   __u32 data[8U] ;
};
#line 1492 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33403_211 {
   struct __anonstruct_raw_212 raw ;
};
#line 1492 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_33403_211 ldv_33403 ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_214 {
   __u64 pts ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_215 {
   __s32 speed ;
   __u32 format ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_216 {
   __u32 data[16U] ;
};
#line 1511 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33418_213 {
   struct __anonstruct_stop_214 stop ;
   struct __anonstruct_start_215 start ;
   struct __anonstruct_raw_216 raw ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_33418_213 ldv_33418 ;
};
#line 1560 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1580 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1602 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1626 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1681 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u16 bytesperline ;
   __u16 reserved[7U] ;
};
#line 1698 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 reserved[11U] ;
};
#line 1720 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u8 reserved[28U] ;
};
#line 1729 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_218 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1729 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_218 fmt ;
};
#line 1752 "include/uapi/linux/videodev2.h"
union __anonunion_parm_219 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1752 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_219 parm ;
};
#line 1826 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 1836 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_33532_222 {
   __u32 addr ;
   char name[32U] ;
};
#line 1836 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_ldv_33532_222 ldv_33532 ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 1869 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 1880 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 129 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 132
struct media_pad;
#line 132 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 53
struct media_device;
#line 53 "include/media/media-entity.h"
struct __anonstruct_v4l_228 {
   u32 major ;
   u32 minor ;
};
#line 53 "include/media/media-entity.h"
struct __anonstruct_fb_229 {
   u32 major ;
   u32 minor ;
};
#line 53 "include/media/media-entity.h"
struct __anonstruct_alsa_230 {
   u32 card ;
   u32 device ;
   u32 subdevice ;
};
#line 53 "include/media/media-entity.h"
union __anonunion_info_227 {
   struct __anonstruct_v4l_228 v4l ;
   struct __anonstruct_fb_229 fb ;
   struct __anonstruct_alsa_230 alsa ;
   int dvb ;
};
#line 53 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_227 info ;
};
#line 156
struct video_device;
#line 157
struct v4l2_device;
#line 158
struct v4l2_ctrl_handler;
#line 159 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 63 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 81
struct vb2_queue;
#line 81
struct v4l2_ioctl_ops;
#line 81 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 101 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 162 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 206
struct v4l2_fh;
#line 207 "include/media/v4l2-common.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_g_priority)(struct file * , void * , enum v4l2_priority * ) ;
   int (*vidioc_s_priority)(struct file * , void * , enum v4l2_priority  ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 329 "include/media/v4l2-ioctl.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
enum v4l2_mbus_pixelcode {
    V4L2_MBUS_FMT_FIXED = 1,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_BE = 4097,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE = 4098,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE = 4099,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE = 4100,
    V4L2_MBUS_FMT_BGR565_2X8_BE = 4101,
    V4L2_MBUS_FMT_BGR565_2X8_LE = 4102,
    V4L2_MBUS_FMT_RGB565_2X8_BE = 4103,
    V4L2_MBUS_FMT_RGB565_2X8_LE = 4104,
    V4L2_MBUS_FMT_RGB666_1X18 = 4105,
    V4L2_MBUS_FMT_RGB888_1X24 = 4106,
    V4L2_MBUS_FMT_RGB888_2X12_BE = 4107,
    V4L2_MBUS_FMT_RGB888_2X12_LE = 4108,
    V4L2_MBUS_FMT_ARGB8888_1X32 = 4109,
    V4L2_MBUS_FMT_Y8_1X8 = 8193,
    V4L2_MBUS_FMT_UV8_1X8 = 8213,
    V4L2_MBUS_FMT_UYVY8_1_5X8 = 8194,
    V4L2_MBUS_FMT_VYUY8_1_5X8 = 8195,
    V4L2_MBUS_FMT_YUYV8_1_5X8 = 8196,
    V4L2_MBUS_FMT_YVYU8_1_5X8 = 8197,
    V4L2_MBUS_FMT_UYVY8_2X8 = 8198,
    V4L2_MBUS_FMT_VYUY8_2X8 = 8199,
    V4L2_MBUS_FMT_YUYV8_2X8 = 8200,
    V4L2_MBUS_FMT_YVYU8_2X8 = 8201,
    V4L2_MBUS_FMT_Y10_1X10 = 8202,
    V4L2_MBUS_FMT_UYVY10_2X10 = 8216,
    V4L2_MBUS_FMT_VYUY10_2X10 = 8217,
    V4L2_MBUS_FMT_YUYV10_2X10 = 8203,
    V4L2_MBUS_FMT_YVYU10_2X10 = 8204,
    V4L2_MBUS_FMT_Y12_1X12 = 8211,
    V4L2_MBUS_FMT_UYVY8_1X16 = 8207,
    V4L2_MBUS_FMT_VYUY8_1X16 = 8208,
    V4L2_MBUS_FMT_YUYV8_1X16 = 8209,
    V4L2_MBUS_FMT_YVYU8_1X16 = 8210,
    V4L2_MBUS_FMT_YDYUYDYV8_1X16 = 8212,
    V4L2_MBUS_FMT_UYVY10_1X20 = 8218,
    V4L2_MBUS_FMT_VYUY10_1X20 = 8219,
    V4L2_MBUS_FMT_YUYV10_1X20 = 8205,
    V4L2_MBUS_FMT_YVYU10_1X20 = 8206,
    V4L2_MBUS_FMT_YUV10_1X30 = 8214,
    V4L2_MBUS_FMT_AYUV8_1X32 = 8215,
    V4L2_MBUS_FMT_UYVY12_2X12 = 8220,
    V4L2_MBUS_FMT_VYUY12_2X12 = 8221,
    V4L2_MBUS_FMT_YUYV12_2X12 = 8222,
    V4L2_MBUS_FMT_YVYU12_2X12 = 8223,
    V4L2_MBUS_FMT_UYVY12_1X24 = 8224,
    V4L2_MBUS_FMT_VYUY12_1X24 = 8225,
    V4L2_MBUS_FMT_YUYV12_1X24 = 8226,
    V4L2_MBUS_FMT_YVYU12_1X24 = 8227,
    V4L2_MBUS_FMT_SBGGR8_1X8 = 12289,
    V4L2_MBUS_FMT_SGBRG8_1X8 = 12307,
    V4L2_MBUS_FMT_SGRBG8_1X8 = 12290,
    V4L2_MBUS_FMT_SRGGB8_1X8 = 12308,
    V4L2_MBUS_FMT_SBGGR10_ALAW8_1X8 = 12309,
    V4L2_MBUS_FMT_SGBRG10_ALAW8_1X8 = 12310,
    V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8 = 12311,
    V4L2_MBUS_FMT_SRGGB10_ALAW8_1X8 = 12312,
    V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8 = 12299,
    V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8 = 12300,
    V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8 = 12297,
    V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8 = 12301,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE = 12291,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE = 12292,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE = 12293,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE = 12294,
    V4L2_MBUS_FMT_SBGGR10_1X10 = 12295,
    V4L2_MBUS_FMT_SGBRG10_1X10 = 12302,
    V4L2_MBUS_FMT_SGRBG10_1X10 = 12298,
    V4L2_MBUS_FMT_SRGGB10_1X10 = 12303,
    V4L2_MBUS_FMT_SBGGR12_1X12 = 12296,
    V4L2_MBUS_FMT_SGBRG12_1X12 = 12304,
    V4L2_MBUS_FMT_SGRBG12_1X12 = 12305,
    V4L2_MBUS_FMT_SRGGB12_1X12 = 12306,
    V4L2_MBUS_FMT_JPEG_1X8 = 16385,
    V4L2_MBUS_FMT_S5C_UYVY_JPEG_1X8 = 20481,
    V4L2_MBUS_FMT_AHSV8888_1X32 = 24577
} ;
#line 177 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u32 reserved[7U] ;
};
#line 151 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 53 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_crop {
   __u32 which ;
   __u32 pad ;
   struct v4l2_rect rect ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 reserved[9U] ;
};
#line 79 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 reserved[9U] ;
};
#line 96 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 107 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 126 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 150
struct v4l2_async_notifier;
#line 151
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 158 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_233 {
   struct device_node  const  *node ;
};
#line 158 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_234 {
   char const   *name ;
};
#line 158 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_235 {
   int adapter_id ;
   unsigned short address ;
};
#line 158 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_236 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 158 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_232 {
   struct __anonstruct_of_233 of ;
   struct __anonstruct_device_name_234 device_name ;
   struct __anonstruct_i2c_235 i2c ;
   struct __anonstruct_custom_236 custom ;
};
#line 158 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_232 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
struct v4l2_m2m_ctx;
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 109 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 110
struct tuner_setup;
#line 111
struct v4l2_mbus_frame_desc;
#line 112 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 61 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 117 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 178 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 205 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 232 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 253 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 265 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*enum_framesizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*enum_frameintervals)(struct v4l2_subdev * , struct v4l2_frmivalenum * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*enum_mbus_fmt)(struct v4l2_subdev * , unsigned int  , enum v4l2_mbus_pixelcode * ) ;
   int (*enum_mbus_fsizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*g_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*try_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*s_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 359 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 399 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 414
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 418 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 466 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 485 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 529 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 541 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 562
struct regulator_bulk_data;
#line 563 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 584 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 622 "include/media/v4l2-subdev.h"
struct __anonstruct_pad_237 {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 622 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct __anonstruct_pad_237 *pad ;
};
#line 691 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct mutex ioctl_lock ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 135 "include/media/v4l2-device.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 30 "include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 995 "include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1005 "include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1024 "include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1034 "include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1046 "include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1067 "include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1098 "include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1111 "include/uapi/linux/input.h"
union __anonunion_u_241 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1111 "include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_241 u ;
};
#line 1150 "include/uapi/linux/input.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 532
enum rc_type {
    RC_TYPE_UNKNOWN = 0,
    RC_TYPE_OTHER = 1,
    RC_TYPE_LIRC = 2,
    RC_TYPE_RC5 = 3,
    RC_TYPE_RC5X = 4,
    RC_TYPE_RC5_SZ = 5,
    RC_TYPE_JVC = 6,
    RC_TYPE_SONY12 = 7,
    RC_TYPE_SONY15 = 8,
    RC_TYPE_SONY20 = 9,
    RC_TYPE_NEC = 10,
    RC_TYPE_SANYO = 11,
    RC_TYPE_MCE_KBD = 12,
    RC_TYPE_RC6_0 = 13,
    RC_TYPE_RC6_6A_20 = 14,
    RC_TYPE_RC6_6A_24 = 15,
    RC_TYPE_RC6_6A_32 = 16,
    RC_TYPE_RC6_MCE = 17,
    RC_TYPE_SHARP = 18
} ;
#line 554 "include/linux/input.h"
struct rc_map_table {
   u32 scancode ;
   u32 keycode ;
};
#line 69 "include/media/rc-map.h"
struct rc_map {
   struct rc_map_table *scan ;
   unsigned int size ;
   unsigned int len ;
   unsigned int alloc ;
   enum rc_type rc_type ;
   char const   *name ;
   spinlock_t lock ;
};
#line 26 "include/media/rc-core.h"
enum rc_driver_type {
    RC_DRIVER_SCANCODE = 0,
    RC_DRIVER_IR_RAW = 1
} ;
#line 31 "include/media/rc-core.h"
struct rc_scancode_filter {
   u32 data ;
   u32 mask ;
};
#line 52
struct ir_raw_event_ctrl;
#line 52 "include/media/rc-core.h"
struct rc_dev {
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[5U] ;
   char const   *input_name ;
   char const   *input_phys ;
   struct input_id input_id ;
   char *driver_name ;
   char const   *map_name ;
   struct rc_map rc_map ;
   struct mutex lock ;
   unsigned long devno ;
   struct ir_raw_event_ctrl *raw ;
   struct input_dev *input_dev ;
   enum rc_driver_type driver_type ;
   bool idle ;
   u64 allowed_protocols[2U] ;
   u64 enabled_protocols[2U] ;
   u32 users ;
   u32 scanmask ;
   void *priv ;
   spinlock_t keylock ;
   bool keypressed ;
   unsigned long keyup_jiffies ;
   struct timer_list timer_keyup ;
   u32 last_keycode ;
   u32 last_scancode ;
   u8 last_toggle ;
   u32 timeout ;
   u32 min_timeout ;
   u32 max_timeout ;
   u32 rx_resolution ;
   u32 tx_resolution ;
   struct rc_scancode_filter scancode_filters[2U] ;
   int (*change_protocol)(struct rc_dev * , u64 * ) ;
   int (*change_wakeup_protocol)(struct rc_dev * , u64 * ) ;
   int (*open)(struct rc_dev * ) ;
   void (*close)(struct rc_dev * ) ;
   int (*s_tx_mask)(struct rc_dev * , u32  ) ;
   int (*s_tx_carrier)(struct rc_dev * , u32  ) ;
   int (*s_tx_duty_cycle)(struct rc_dev * , u32  ) ;
   int (*s_rx_carrier_range)(struct rc_dev * , u32  , u32  ) ;
   int (*tx_ir)(struct rc_dev * , unsigned int * , unsigned int  ) ;
   void (*s_idle)(struct rc_dev * , bool  ) ;
   int (*s_learning_mode)(struct rc_dev * , int  ) ;
   int (*s_carrier_report)(struct rc_dev * , int  ) ;
   int (*s_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
   int (*s_wakeup_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
};
#line 308
struct IR_i2c;
#line 309 "include/media/rc-core.h"
struct IR_i2c {
   char *ir_codes ;
   struct i2c_client *c ;
   struct rc_dev *rc ;
   unsigned char old ;
   u32 polling_interval ;
   struct delayed_work work ;
   char name[32U] ;
   char phys[32U] ;
   int (*get_key)(struct IR_i2c * , u32 * , u32 * ) ;
};
#line 25 "include/media/ir-kbd-i2c.h"
enum ir_kbd_get_key_fn {
    IR_KBD_GET_KEY_CUSTOM = 0,
    IR_KBD_GET_KEY_PIXELVIEW = 1,
    IR_KBD_GET_KEY_HAUP = 2,
    IR_KBD_GET_KEY_KNC1 = 3,
    IR_KBD_GET_KEY_FUSIONHDTV = 4,
    IR_KBD_GET_KEY_HAUP_XVR = 5,
    IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 6
} ;
#line 35 "include/media/ir-kbd-i2c.h"
struct IR_i2c_init_data {
   char *ir_codes ;
   char const   *name ;
   u64 type ;
   u32 polling_interval ;
   int (*get_key)(struct IR_i2c * , u32 * , u32 * ) ;
   enum ir_kbd_get_key_fn internal_get_key_func ;
   struct rc_dev *rc_dev ;
};
#line 52
struct cx18;
#line 53 "include/media/ir-kbd-i2c.h"
struct cx18_mdl_ack {
   u32 id ;
   u32 data_used ;
};
#line 51 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
struct cx18_mailbox {
   u32 request ;
   u32 ack ;
   u32 reserved[6U] ;
   u32 cmd ;
   u32 args[6U] ;
   u32 error ;
};
#line 81
struct cx18_stream;
#line 94
struct v4l2_ctrl_helper;
#line 95
struct v4l2_ctrl;
#line 97 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_36490_244 {
   u32 step ;
   u32 menu_skip_mask ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_36494_245 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_cur_246 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_36505_247 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s32 minimum ;
   s32 maximum ;
   s32 default_value ;
   union __anonunion_ldv_36490_244 ldv_36490 ;
   union __anonunion_ldv_36494_245 ldv_36494 ;
   unsigned long flags ;
   union __anonunion_cur_246 cur ;
   union __anonunion_ldv_36505_247 ldv_36505 ;
   void *priv ;
};
#line 156 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 173 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 688
enum cx18_av_video_input {
    CX18_AV_COMPOSITE1 = 1,
    CX18_AV_COMPOSITE2 = 2,
    CX18_AV_COMPOSITE3 = 3,
    CX18_AV_COMPOSITE4 = 4,
    CX18_AV_COMPOSITE5 = 5,
    CX18_AV_COMPOSITE6 = 6,
    CX18_AV_COMPOSITE7 = 7,
    CX18_AV_COMPOSITE8 = 8,
    CX18_AV_SVIDEO_LUMA1 = 16,
    CX18_AV_SVIDEO_LUMA2 = 32,
    CX18_AV_SVIDEO_LUMA3 = 48,
    CX18_AV_SVIDEO_LUMA4 = 64,
    CX18_AV_SVIDEO_LUMA5 = 80,
    CX18_AV_SVIDEO_LUMA6 = 96,
    CX18_AV_SVIDEO_LUMA7 = 112,
    CX18_AV_SVIDEO_LUMA8 = 128,
    CX18_AV_SVIDEO_CHROMA4 = 1024,
    CX18_AV_SVIDEO_CHROMA5 = 1280,
    CX18_AV_SVIDEO_CHROMA6 = 1536,
    CX18_AV_SVIDEO_CHROMA7 = 1792,
    CX18_AV_SVIDEO_CHROMA8 = 2048,
    CX18_AV_SVIDEO1 = 1296,
    CX18_AV_SVIDEO2 = 1568,
    CX18_AV_SVIDEO3 = 1840,
    CX18_AV_SVIDEO4 = 2112,
    CX18_AV_COMPONENT_LUMA1 = 4096,
    CX18_AV_COMPONENT_LUMA2 = 8192,
    CX18_AV_COMPONENT_LUMA3 = 12288,
    CX18_AV_COMPONENT_LUMA4 = 16384,
    CX18_AV_COMPONENT_LUMA5 = 20480,
    CX18_AV_COMPONENT_LUMA6 = 24576,
    CX18_AV_COMPONENT_LUMA7 = 28672,
    CX18_AV_COMPONENT_LUMA8 = 32768,
    CX18_AV_COMPONENT_R_CHROMA4 = 262144,
    CX18_AV_COMPONENT_R_CHROMA5 = 327680,
    CX18_AV_COMPONENT_R_CHROMA6 = 393216,
    CX18_AV_COMPONENT_B_CHROMA7 = 7340032,
    CX18_AV_COMPONENT_B_CHROMA8 = 8388608,
    CX18_AV_COMPONENT1 = 8785920
} ;
#line 730
enum cx18_av_audio_input {
    CX18_AV_AUDIO_SERIAL1 = 0,
    CX18_AV_AUDIO_SERIAL2 = 1,
    CX18_AV_AUDIO4 = 4,
    CX18_AV_AUDIO5 = 5,
    CX18_AV_AUDIO6 = 6,
    CX18_AV_AUDIO7 = 7,
    CX18_AV_AUDIO8 = 8
} ;
#line 740 "include/media/v4l2-ctrls.h"
struct cx18_av_state {
   struct v4l2_subdev sd ;
   struct v4l2_ctrl_handler hdl ;
   struct v4l2_ctrl *volume ;
   int radio ;
   v4l2_std_id std ;
   enum cx18_av_video_input vid_input ;
   enum cx18_av_audio_input aud_input ;
   u32 audclk_freq ;
   int audmode ;
   u32 rev ;
   int is_initialized ;
   int slicer_line_delay ;
   int slicer_line_offset ;
};
#line 389 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-av-core.h"
enum cx2341x_port {
    CX2341X_PORT_MEMORY = 0,
    CX2341X_PORT_STREAMING = 1,
    CX2341X_PORT_SERIAL = 2
} ;
#line 103 "include/media/cx2341x.h"
struct cx2341x_handler_ops {
   int (*s_audio_sampling_freq)(struct cx2341x_handler * , u32  ) ;
   int (*s_audio_mode)(struct cx2341x_handler * , u32  ) ;
   int (*s_video_encoding)(struct cx2341x_handler * , u32  ) ;
   int (*s_stream_vbi_fmt)(struct cx2341x_handler * , u32  ) ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36957_248 {
   struct v4l2_ctrl *audio_sampling_freq ;
   struct v4l2_ctrl *audio_encoding ;
   struct v4l2_ctrl *audio_l2_bitrate ;
   struct v4l2_ctrl *audio_mode ;
   struct v4l2_ctrl *audio_mode_extension ;
   struct v4l2_ctrl *audio_emphasis ;
   struct v4l2_ctrl *audio_crc ;
   struct v4l2_ctrl *audio_ac3_bitrate ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36961_249 {
   struct v4l2_ctrl *video_b_frames ;
   struct v4l2_ctrl *video_gop_size ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36968_250 {
   struct v4l2_ctrl *stream_type ;
   struct v4l2_ctrl *video_encoding ;
   struct v4l2_ctrl *video_bitrate_mode ;
   struct v4l2_ctrl *video_bitrate ;
   struct v4l2_ctrl *video_bitrate_peak ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36972_251 {
   struct v4l2_ctrl *video_mute ;
   struct v4l2_ctrl *video_mute_yuv ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36977_252 {
   struct v4l2_ctrl *video_spatial_filter_mode ;
   struct v4l2_ctrl *video_temporal_filter_mode ;
   struct v4l2_ctrl *video_median_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36981_253 {
   struct v4l2_ctrl *video_luma_spatial_filter_type ;
   struct v4l2_ctrl *video_chroma_spatial_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36985_254 {
   struct v4l2_ctrl *video_spatial_filter ;
   struct v4l2_ctrl *video_temporal_filter ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct_ldv_36991_255 {
   struct v4l2_ctrl *video_luma_median_filter_top ;
   struct v4l2_ctrl *video_luma_median_filter_bottom ;
   struct v4l2_ctrl *video_chroma_median_filter_top ;
   struct v4l2_ctrl *video_chroma_median_filter_bottom ;
};
#line 116 "include/media/cx2341x.h"
struct cx2341x_handler {
   u32 capabilities ;
   enum cx2341x_port port ;
   u16 width ;
   u16 height ;
   u16 is_50hz ;
   u32 audio_properties ;
   struct v4l2_ctrl_handler hdl ;
   void *priv ;
   int (*func)(void * , u32  , int  , int  , u32 * ) ;
   struct cx2341x_handler_ops  const  *ops ;
   struct v4l2_ctrl *stream_vbi_fmt ;
   struct __anonstruct_ldv_36957_248 ldv_36957 ;
   struct __anonstruct_ldv_36961_249 ldv_36961 ;
   struct __anonstruct_ldv_36968_250 ldv_36968 ;
   struct __anonstruct_ldv_36972_251 ldv_36972 ;
   struct __anonstruct_ldv_36977_252 ldv_36977 ;
   struct __anonstruct_ldv_36981_253 ldv_36981 ;
   struct __anonstruct_ldv_36985_254 ldv_36985 ;
   struct __anonstruct_ldv_36991_255 ldv_36991 ;
};
#line 44 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_output_t;
#line 51 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_input_t;
#line 52
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 81 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 82 "./include/uapi/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16U] ;
   __u8 mask[16U] ;
   __u8 mode[16U] ;
};
#line 95 "./include/uapi/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 96 "./include/uapi/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 105 "./include/uapi/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 119 "./include/uapi/linux/dvb/dmx.h"
struct dmx_caps {
   __u32 caps ;
   int num_decoders ;
};
#line 134 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_source_t;
#line 141
enum dmx_success {
    DMX_OK = 0,
    DMX_LENGTH_ERROR = 1,
    DMX_OVERRUN_ERROR = 2,
    DMX_CRC_ERROR = 3,
    DMX_FRAME_ERROR = 4,
    DMX_FIFO_ERROR = 5,
    DMX_MISSED_ERROR = 6
} ;
#line 151
struct dmx_demux;
#line 151 "./include/uapi/linux/dvb/dmx.h"
struct dmx_ts_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int (*set)(struct dmx_ts_feed * , u16  , int  , enum dmx_ts_pes  , size_t  , struct timespec  ) ;
   int (*start_filtering)(struct dmx_ts_feed * ) ;
   int (*stop_filtering)(struct dmx_ts_feed * ) ;
};
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed;
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_filter {
   u8 filter_value[18U] ;
   u8 filter_mask[18U] ;
   u8 filter_mode[18U] ;
   struct dmx_section_feed *parent ;
   void *priv ;
};
#line 111 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int check_crc ;
   u32 crc_val ;
   u8 *secbuf ;
   u8 secbuf_base[4284U] ;
   u16 secbufp ;
   u16 seclen ;
   u16 tsfeedp ;
   int (*set)(struct dmx_section_feed * , u16  , size_t  , int  ) ;
   int (*allocate_filter)(struct dmx_section_feed * , struct dmx_section_filter ** ) ;
   int (*release_filter)(struct dmx_section_feed * , struct dmx_section_filter * ) ;
   int (*start_filtering)(struct dmx_section_feed * ) ;
   int (*stop_filtering)(struct dmx_section_feed * ) ;
};
#line 148
enum dmx_frontend_source {
    DMX_MEMORY_FE = 0,
    DMX_FRONTEND_0 = 1,
    DMX_FRONTEND_1 = 2,
    DMX_FRONTEND_2 = 3,
    DMX_FRONTEND_3 = 4,
    DMX_STREAM_0 = 5,
    DMX_STREAM_1 = 6,
    DMX_STREAM_2 = 7,
    DMX_STREAM_3 = 8
} ;
#line 160 "drivers/media/dvb-core/demux.h"
struct dmx_frontend {
   struct list_head connectivity_list ;
   enum dmx_frontend_source source ;
};
#line 176 "drivers/media/dvb-core/demux.h"
struct dmx_demux {
   u32 capabilities ;
   struct dmx_frontend *frontend ;
   void *priv ;
   int (*open)(struct dmx_demux * ) ;
   int (*close)(struct dmx_demux * ) ;
   int (*write)(struct dmx_demux * , char const   * , size_t  ) ;
   int (*allocate_ts_feed)(struct dmx_demux * , struct dmx_ts_feed ** , int (*)(u8 const   * ,
                                                                                size_t  ,
                                                                                u8 const   * ,
                                                                                size_t  ,
                                                                                struct dmx_ts_feed * ,
                                                                                enum dmx_success  ) ) ;
   int (*release_ts_feed)(struct dmx_demux * , struct dmx_ts_feed * ) ;
   int (*allocate_section_feed)(struct dmx_demux * , struct dmx_section_feed ** ,
                                int (*)(u8 const   * , size_t  , u8 const   * , size_t  ,
                                        struct dmx_section_filter * , enum dmx_success  ) ) ;
   int (*release_section_feed)(struct dmx_demux * , struct dmx_section_feed * ) ;
   int (*add_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*remove_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   struct list_head *(*get_frontends)(struct dmx_demux * ) ;
   int (*connect_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*disconnect_frontend)(struct dmx_demux * ) ;
   int (*get_pes_pids)(struct dmx_demux * , u16 * ) ;
   int (*get_caps)(struct dmx_demux * , struct dmx_caps * ) ;
   int (*set_source)(struct dmx_demux * , dmx_source_t const   * ) ;
   int (*get_stc)(struct dmx_demux * , unsigned int  , u64 * , unsigned int * ) ;
};
#line 239
struct dvb_frontend;
#line 240
struct dvb_device;
#line 240 "drivers/media/dvb-core/demux.h"
struct dvb_adapter {
   int num ;
   struct list_head list_head ;
   struct list_head device_list ;
   char const   *name ;
   u8 proposed_mac[6U] ;
   void *priv ;
   struct device *device ;
   struct module *module ;
   int mfe_shared ;
   struct dvb_device *mfe_dvbdev ;
   struct mutex mfe_lock ;
};
#line 75 "drivers/media/dvb-core/dvbdev.h"
struct dvb_device {
   struct list_head list_head ;
   struct file_operations  const  *fops ;
   struct dvb_adapter *adapter ;
   int type ;
   int minor ;
   u32 id ;
   int readers ;
   int writers ;
   int users ;
   wait_queue_head_t wait_queue ;
   int (*kernel_ioctl)(struct file * , unsigned int  , void * ) ;
   void *priv ;
};
#line 122 "drivers/media/dvb-core/dvbdev.h"
struct dvb_ringbuffer {
   u8 *data ;
   ssize_t size ;
   ssize_t pread ;
   ssize_t pwrite ;
   int error ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
};
#line 184 "drivers/media/dvb-core/dvb_ringbuffer.h"
enum dmxdev_type {
    DMXDEV_TYPE_NONE = 0,
    DMXDEV_TYPE_SEC = 1,
    DMXDEV_TYPE_PES = 2
} ;
#line 190
enum dmxdev_state {
    DMXDEV_STATE_FREE = 0,
    DMXDEV_STATE_ALLOCATED = 1,
    DMXDEV_STATE_SET = 2,
    DMXDEV_STATE_GO = 3,
    DMXDEV_STATE_DONE = 4,
    DMXDEV_STATE_TIMEDOUT = 5
} ;
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_filter_256 {
   struct dmx_section_filter *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_feed_257 {
   struct list_head ts ;
   struct dmx_section_feed *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_params_258 {
   struct dmx_sct_filter_params sec ;
   struct dmx_pes_filter_params pes ;
};
#line 63
struct dmxdev;
#line 63 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev_filter {
   union __anonunion_filter_256 filter ;
   union __anonunion_feed_257 feed ;
   union __anonunion_params_258 params ;
   enum dmxdev_type type ;
   enum dmxdev_state state ;
   struct dmxdev *dev ;
   struct dvb_ringbuffer buffer ;
   struct mutex mutex ;
   struct timer_list timer ;
   int todo ;
   u8 secheader[3U] ;
};
#line 92 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev {
   struct dvb_device *dvbdev ;
   struct dvb_device *dvr_dvbdev ;
   struct dmxdev_filter *filter ;
   struct dmx_demux *demux ;
   int filternum ;
   int capabilities ;
   unsigned char exit : 1 ;
   struct dmx_frontend *dvr_orig_fe ;
   struct dvb_ringbuffer dvr_buffer ;
   struct mutex mutex ;
   spinlock_t lock ;
};
#line 118
struct dvb_demux_feed;
#line 118 "drivers/media/dvb-core/dmxdev.h"
struct dvb_demux_filter {
   struct dmx_section_filter filter ;
   u8 maskandmode[18U] ;
   u8 maskandnotmode[18U] ;
   int doneq ;
   struct dvb_demux_filter *next ;
   struct dvb_demux_feed *feed ;
   int index ;
   int state ;
   int type ;
   u16 hw_handle ;
   struct timer_list timer ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_feed_259 {
   struct dmx_ts_feed ts ;
   struct dmx_section_feed sec ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_cb_260 {
   int (*ts)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_ts_feed * ,
             enum dmx_success  ) ;
   int (*sec)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_section_filter * ,
              enum dmx_success  ) ;
};
#line 64
struct dvb_demux;
#line 64 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux_feed {
   union __anonunion_feed_259 feed ;
   union __anonunion_cb_260 cb ;
   struct dvb_demux *demux ;
   void *priv ;
   int type ;
   int state ;
   u16 pid ;
   u8 *buffer ;
   int buffer_size ;
   struct timespec timeout ;
   struct dvb_demux_filter *filter ;
   int ts_type ;
   enum dmx_ts_pes pes_type ;
   int cc ;
   int pusi_seen ;
   u16 peslen ;
   struct list_head list_head ;
   unsigned int index ;
};
#line 100 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux {
   struct dmx_demux dmx ;
   void *priv ;
   int filternum ;
   int feednum ;
   int (*start_feed)(struct dvb_demux_feed * ) ;
   int (*stop_feed)(struct dvb_demux_feed * ) ;
   int (*write_to_decoder)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   u32 (*check_crc32)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   void (*memcopy)(struct dvb_demux_feed * , u8 * , u8 const   * , size_t  ) ;
   int users ;
   struct dvb_demux_filter *filter ;
   struct dvb_demux_feed *feed ;
   struct list_head frontend_list ;
   struct dvb_demux_feed *pesfilter[20U] ;
   u16 pids[20U] ;
   int playing ;
   int recording ;
   struct list_head feed_list ;
   u8 tsbuf[204U] ;
   int tsbufp ;
   struct mutex mutex ;
   spinlock_t lock ;
   uint8_t *cnt_storage ;
   struct timespec speed_last_time ;
   uint32_t speed_pkts_cnt ;
};
#line 149
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 36 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_type fe_type_t;
#line 37
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 71 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_caps fe_caps_t;
#line 72 "./include/uapi/linux/dvb/frontend.h"
struct dvb_frontend_info {
   char name[128U] ;
   fe_type_t type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   fe_caps_t caps ;
};
#line 87 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6U] ;
   __u8 msg_len ;
};
#line 97 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_slave_reply {
   __u8 msg[4U] ;
   __u8 msg_len ;
   int timeout ;
};
#line 104
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 110 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_voltage fe_sec_voltage_t;
#line 111
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 116 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_tone_mode fe_sec_tone_mode_t;
#line 117
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 122 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_mini_cmd fe_sec_mini_cmd_t;
#line 123
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 145 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_status fe_status_t;
#line 146
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 151 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_spectral_inversion fe_spectral_inversion_t;
#line 152
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 168 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_code_rate fe_code_rate_t;
#line 169
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 186 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_modulation fe_modulation_t;
#line 187
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 198 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_transmit_mode fe_transmit_mode_t;
#line 199
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 224 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_guard_interval fe_guard_interval_t;
#line 225
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 233 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_hierarchy fe_hierarchy_t;
#line 234
enum fe_interleaving {
    INTERLEAVING_NONE = 0,
    INTERLEAVING_AUTO = 1,
    INTERLEAVING_240 = 2,
    INTERLEAVING_720 = 3
} ;
#line 241
enum fe_pilot {
    PILOT_ON = 0,
    PILOT_OFF = 1,
    PILOT_AUTO = 2
} ;
#line 384 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_pilot fe_pilot_t;
#line 385
enum fe_rolloff {
    ROLLOFF_35 = 0,
    ROLLOFF_20 = 1,
    ROLLOFF_25 = 2,
    ROLLOFF_AUTO = 3
} ;
#line 391 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_rolloff fe_rolloff_t;
#line 392
enum fe_delivery_system {
    SYS_UNDEFINED = 0,
    SYS_DVBC_ANNEX_A = 1,
    SYS_DVBC_ANNEX_B = 2,
    SYS_DVBT = 3,
    SYS_DSS = 4,
    SYS_DVBS = 5,
    SYS_DVBS2 = 6,
    SYS_DVBH = 7,
    SYS_ISDBT = 8,
    SYS_ISDBS = 9,
    SYS_ISDBC = 10,
    SYS_ATSC = 11,
    SYS_ATSCMH = 12,
    SYS_DTMB = 13,
    SYS_CMMB = 14,
    SYS_DAB = 15,
    SYS_DVBT2 = 16,
    SYS_TURBO = 17,
    SYS_DVBC_ANNEX_C = 18
} ;
#line 413 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_delivery_system fe_delivery_system_t;
#line 471 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_ldv_37694_261 {
   __u64 uvalue ;
   __s64 svalue ;
};
#line 471 "./include/uapi/linux/dvb/frontend.h"
struct dtv_stats {
   __u8 scale ;
   union __anonunion_ldv_37694_261 ldv_37694 ;
};
#line 522 "./include/uapi/linux/dvb/frontend.h"
struct dtv_fe_stats {
   __u8 len ;
   struct dtv_stats stat[4U] ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
struct __anonstruct_buffer_263 {
   __u8 data[32U] ;
   __u32 len ;
   __u32 reserved1[3U] ;
   void *reserved2 ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_u_262 {
   __u32 data ;
   struct dtv_fe_stats st ;
   struct __anonstruct_buffer_263 buffer ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
struct dtv_property {
   __u32 cmd ;
   __u32 reserved[3U] ;
   union __anonunion_u_262 u ;
   int result ;
};
#line 554 "./include/uapi/linux/dvb/frontend.h"
struct dvb_frontend_tune_settings {
   int min_delay_ms ;
   int step_size ;
   int max_drift ;
};
#line 56 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_info {
   char name[128U] ;
   u32 frequency_min ;
   u32 frequency_max ;
   u32 frequency_step ;
   u32 bandwidth_min ;
   u32 bandwidth_max ;
   u32 bandwidth_step ;
};
#line 70 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_parameters {
   unsigned int frequency ;
   unsigned int mode ;
   unsigned int audmode ;
   u64 std ;
};
#line 113
enum tuner_param {
    DVBFE_TUNER_FREQUENCY = 1,
    DVBFE_TUNER_TUNERSTEP = 2,
    DVBFE_TUNER_IFFREQ = 4,
    DVBFE_TUNER_BANDWIDTH = 8,
    DVBFE_TUNER_REFCLOCK = 16,
    DVBFE_TUNER_IQSENSE = 32,
    DVBFE_TUNER_DUMMY = (-0x7FFFFFFF-1)
} ;
#line 123
enum dvbfe_algo {
    DVBFE_ALGO_HW = 1,
    DVBFE_ALGO_SW = 2,
    DVBFE_ALGO_CUSTOM = 4,
    DVBFE_ALGO_RECOVERY = (-0x7FFFFFFF-1)
} ;
#line 130 "drivers/media/dvb-core/dvb_frontend.h"
struct tuner_state {
   u32 frequency ;
   u32 tunerstep ;
   u32 ifreq ;
   u32 bandwidth ;
   u32 iqsense ;
   u32 refclock ;
};
#line 164
enum dvbfe_search {
    DVBFE_ALGO_SEARCH_SUCCESS = 1,
    DVBFE_ALGO_SEARCH_ASLEEP = 2,
    DVBFE_ALGO_SEARCH_FAILED = 4,
    DVBFE_ALGO_SEARCH_INVALID = 8,
    DVBFE_ALGO_SEARCH_AGAIN = 16,
    DVBFE_ALGO_SEARCH_ERROR = (-0x7FFFFFFF-1)
} ;
#line 173 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_ops {
   struct dvb_tuner_info info ;
   int (*release)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*set_params)(struct dvb_frontend * ) ;
   int (*set_analog_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*calc_regs)(struct dvb_frontend * , u8 * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
   int (*get_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_bandwidth)(struct dvb_frontend * , u32 * ) ;
   int (*get_if_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_status)(struct dvb_frontend * , u32 * ) ;
   int (*get_rf_strength)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   int (*set_frequency)(struct dvb_frontend * , u32  ) ;
   int (*set_bandwidth)(struct dvb_frontend * , u32  ) ;
   int (*set_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
   int (*get_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
};
#line 237 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_info {
   char *name ;
};
#line 241 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_ops {
   struct analog_demod_info info ;
   void (*set_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*has_signal)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   void (*tuner_status)(struct dvb_frontend * ) ;
   void (*standby)(struct dvb_frontend * ) ;
   void (*release)(struct dvb_frontend * ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
};
#line 258
struct dtv_frontend_properties;
#line 259 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend_ops {
   struct dvb_frontend_info info ;
   u8 delsys[8U] ;
   void (*release)(struct dvb_frontend * ) ;
   void (*release_sec)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*write)(struct dvb_frontend * , u8 const   * , int  ) ;
   int (*tune)(struct dvb_frontend * , bool  , unsigned int  , unsigned int * , fe_status_t * ) ;
   enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend * ) ;
   int (*set_frontend)(struct dvb_frontend * ) ;
   int (*get_tune_settings)(struct dvb_frontend * , struct dvb_frontend_tune_settings * ) ;
   int (*get_frontend)(struct dvb_frontend * ) ;
   int (*read_status)(struct dvb_frontend * , fe_status_t * ) ;
   int (*read_ber)(struct dvb_frontend * , u32 * ) ;
   int (*read_signal_strength)(struct dvb_frontend * , u16 * ) ;
   int (*read_snr)(struct dvb_frontend * , u16 * ) ;
   int (*read_ucblocks)(struct dvb_frontend * , u32 * ) ;
   int (*diseqc_reset_overload)(struct dvb_frontend * ) ;
   int (*diseqc_send_master_cmd)(struct dvb_frontend * , struct dvb_diseqc_master_cmd * ) ;
   int (*diseqc_recv_slave_reply)(struct dvb_frontend * , struct dvb_diseqc_slave_reply * ) ;
   int (*diseqc_send_burst)(struct dvb_frontend * , fe_sec_mini_cmd_t  ) ;
   int (*set_tone)(struct dvb_frontend * , fe_sec_tone_mode_t  ) ;
   int (*set_voltage)(struct dvb_frontend * , fe_sec_voltage_t  ) ;
   int (*enable_high_lnb_voltage)(struct dvb_frontend * , long  ) ;
   int (*dishnetwork_send_legacy_command)(struct dvb_frontend * , unsigned long  ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*ts_bus_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_lna)(struct dvb_frontend * ) ;
   enum dvbfe_search (*search)(struct dvb_frontend * ) ;
   struct dvb_tuner_ops tuner_ops ;
   struct analog_demod_ops analog_ops ;
   int (*set_property)(struct dvb_frontend * , struct dtv_property * ) ;
   int (*get_property)(struct dvb_frontend * , struct dtv_property * ) ;
};
#line 319 "drivers/media/dvb-core/dvb_frontend.h"
struct __anonstruct_layer_264 {
   u8 segment_count ;
   fe_code_rate_t fec ;
   fe_modulation_t modulation ;
   u8 interleaving ;
};
#line 319 "drivers/media/dvb-core/dvb_frontend.h"
struct dtv_frontend_properties {
   u32 state ;
   u32 frequency ;
   fe_modulation_t modulation ;
   fe_sec_voltage_t voltage ;
   fe_sec_tone_mode_t sectone ;
   fe_spectral_inversion_t inversion ;
   fe_code_rate_t fec_inner ;
   fe_transmit_mode_t transmission_mode ;
   u32 bandwidth_hz ;
   fe_guard_interval_t guard_interval ;
   fe_hierarchy_t hierarchy ;
   u32 symbol_rate ;
   fe_code_rate_t code_rate_HP ;
   fe_code_rate_t code_rate_LP ;
   fe_pilot_t pilot ;
   fe_rolloff_t rolloff ;
   fe_delivery_system_t delivery_system ;
   enum fe_interleaving interleaving ;
   u8 isdbt_partial_reception ;
   u8 isdbt_sb_mode ;
   u8 isdbt_sb_subchannel ;
   u32 isdbt_sb_segment_idx ;
   u32 isdbt_sb_segment_count ;
   u8 isdbt_layer_enabled ;
   struct __anonstruct_layer_264 layer[3U] ;
   u32 stream_id ;
   u8 atscmh_fic_ver ;
   u8 atscmh_parade_id ;
   u8 atscmh_nog ;
   u8 atscmh_tnog ;
   u8 atscmh_sgn ;
   u8 atscmh_prc ;
   u8 atscmh_rs_frame_mode ;
   u8 atscmh_rs_frame_ensemble ;
   u8 atscmh_rs_code_mode_pri ;
   u8 atscmh_rs_code_mode_sec ;
   u8 atscmh_sccc_block_mode ;
   u8 atscmh_sccc_code_mode_a ;
   u8 atscmh_sccc_code_mode_b ;
   u8 atscmh_sccc_code_mode_c ;
   u8 atscmh_sccc_code_mode_d ;
   u32 lna ;
   struct dtv_fe_stats strength ;
   struct dtv_fe_stats cnr ;
   struct dtv_fe_stats pre_bit_error ;
   struct dtv_fe_stats pre_bit_count ;
   struct dtv_fe_stats post_bit_error ;
   struct dtv_fe_stats post_bit_count ;
   struct dtv_fe_stats block_error ;
   struct dtv_fe_stats block_count ;
};
#line 407 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend {
   struct dvb_frontend_ops ops ;
   struct dvb_adapter *dvb ;
   void *demodulator_priv ;
   void *tuner_priv ;
   void *frontend_priv ;
   void *sec_priv ;
   void *analog_demod_priv ;
   struct dtv_frontend_properties dtv_property_cache ;
   int (*callback)(void * , int  , int  , int  ) ;
   int id ;
};
#line 84 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 48 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 53
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 59 "include/linux/pm_qos.h"
union __anonunion_data_265 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 59 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_265 data ;
   struct device *dev ;
};
#line 68
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 74 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 88 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 93 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 220 "include/linux/pm_qos.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion_ldv_38227_266 {
   struct iovec  const  *iov ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_38227_266 ldv_38227 ;
   unsigned long nr_segs ;
};
#line 38 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1153 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_268 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_268 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_269 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_269 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_270 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_270 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_271 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_271 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_272 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_272 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_273 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_273 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_274 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_274 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_275 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_275 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_276 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_277 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_276 ifr_ifrn ;
   union __anonunion_ifr_ifru_277 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 18 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 137 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 147 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 360 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 361 "include/linux/skbuff.h"
struct __anonstruct_ldv_40913_296 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 361 "include/linux/skbuff.h"
union __anonunion_ldv_40914_295 {
   u64 v64 ;
   struct __anonstruct_ldv_40913_296 ldv_40913 ;
};
#line 361 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_ldv_40914_295 ldv_40914 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_40933_297 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 414
struct sec_path;
#line 414 "include/linux/skbuff.h"
struct __anonstruct_ldv_40949_299 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_40950_298 {
   __wsum csum ;
   struct __anonstruct_ldv_40949_299 ldv_40949 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_40989_300 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_40995_301 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 414 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_40933_297 ldv_40933 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_40950_298 ldv_40950 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_40989_300 ldv_40989 ;
   __u32 secmark ;
   union __anonunion_ldv_40995_301 ldv_40995 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 641
struct dst_entry;
#line 3161 "include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 187 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 211 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 259 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 288 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 305 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 441 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 469 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 568 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 600 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 642 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 675 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 691 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 711 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 722 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 741 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 767 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 933 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 941 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1017 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[103U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 102
struct neighbour;
#line 102 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 35 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 35
struct rt6_info;
#line 35
struct rt6_statistics;
#line 35
struct fib6_table;
#line 35 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 80 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 86 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
#line 21
struct sctp_mib;
#line 22 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 324 "include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 24 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 29 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 43 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 48 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 53 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 64 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 72
struct ip_conntrack_stat;
#line 72
struct nf_ct_event_notifier;
#line 72
struct nf_exp_event_notifier;
#line 72 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 111
struct nft_af_info;
#line 112 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 499 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 17 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 74
struct net_generic;
#line 75
struct netns_ipvs;
#line 76 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 400 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 205 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 919 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 3161 "include/linux/security.h"
struct mnt_namespace;
#line 3162
struct ipc_namespace;
#line 3163 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 180 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 547 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 28 "include/linux/if_link.h"
struct netpoll_info;
#line 29
struct phy_device;
#line 30
struct wireless_dev;
#line 61 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 106 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 125 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 186
struct neigh_parms;
#line 207 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 212 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 241 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 292 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 336
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 384 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 385 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 522
struct Qdisc;
#line 522 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 591 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 603 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 615 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 666 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 689 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 724 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 740 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 753 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_adj_list_313 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_314 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187
struct iw_handler_def;
#line 1187
struct iw_public_data;
#line 1187
struct forwarding_accel_ops;
#line 1187
struct vlan_info;
#line 1187
struct tipc_bearer;
#line 1187
struct in_device;
#line 1187
struct dn_dev;
#line 1187
struct inet6_dev;
#line 1187
struct cpu_rmap;
#line 1187
struct pcpu_lstats;
#line 1187
struct pcpu_sw_netstats;
#line 1187
struct pcpu_dstats;
#line 1187
struct pcpu_vstats;
#line 1187 "include/linux/netdevice.h"
union __anonunion_ldv_48768_315 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1187
struct garp_port;
#line 1187
struct mrp_port;
#line 1187
struct rtnl_link_ops;
#line 1187 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_313 adj_list ;
   struct __anonstruct_all_adj_list_314 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_48768_315 ldv_48768 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1806 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 93 "include/linux/rtnetlink.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[28U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20
struct ip_mc_list;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 386 "include/linux/etherdevice.h"
struct dvb_net {
   struct dvb_device *dvbdev ;
   struct net_device *device[10U] ;
   int state[10U] ;
   unsigned char exit : 1 ;
   struct dmx_demux *demux ;
   struct mutex ioctl_mutex ;
};
#line 48 "drivers/media/dvb-core/dvb_net.h"
struct videobuf_mapping {
   unsigned int count ;
   struct videobuf_queue *q ;
};
#line 55 "include/media/videobuf-core.h"
enum videobuf_state {
    VIDEOBUF_NEEDS_INIT = 0,
    VIDEOBUF_PREPARED = 1,
    VIDEOBUF_QUEUED = 2,
    VIDEOBUF_ACTIVE = 3,
    VIDEOBUF_DONE = 4,
    VIDEOBUF_ERROR = 5,
    VIDEOBUF_IDLE = 6
} ;
#line 65 "include/media/videobuf-core.h"
struct videobuf_buffer {
   unsigned int i ;
   u32 magic ;
   unsigned int width ;
   unsigned int height ;
   unsigned int bytesperline ;
   unsigned long size ;
   enum v4l2_field field ;
   enum videobuf_state state ;
   struct list_head stream ;
   struct list_head queue ;
   wait_queue_head_t done ;
   unsigned int field_count ;
   struct timeval ts ;
   enum v4l2_memory memory ;
   size_t bsize ;
   size_t boff ;
   unsigned long baddr ;
   struct videobuf_mapping *map ;
   int privsize ;
   void *priv ;
};
#line 104 "include/media/videobuf-core.h"
struct videobuf_queue_ops {
   int (*buf_setup)(struct videobuf_queue * , unsigned int * , unsigned int * ) ;
   int (*buf_prepare)(struct videobuf_queue * , struct videobuf_buffer * , enum v4l2_field  ) ;
   void (*buf_queue)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   void (*buf_release)(struct videobuf_queue * , struct videobuf_buffer * ) ;
};
#line 115 "include/media/videobuf-core.h"
struct videobuf_qtype_ops {
   u32 magic ;
   struct videobuf_buffer *(*alloc_vb)(size_t  ) ;
   void *(*vaddr)(struct videobuf_buffer * ) ;
   int (*iolock)(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
   int (*sync)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   int (*mmap_mapper)(struct videobuf_queue * , struct videobuf_buffer * , struct vm_area_struct * ) ;
};
#line 132 "include/media/videobuf-core.h"
struct videobuf_queue {
   struct mutex vb_lock ;
   struct mutex *ext_lock ;
   spinlock_t *irqlock ;
   struct device *dev ;
   wait_queue_head_t wait ;
   enum v4l2_buf_type type ;
   unsigned int msize ;
   enum v4l2_field field ;
   enum v4l2_field last ;
   struct videobuf_buffer *bufs[32U] ;
   struct videobuf_queue_ops  const  *ops ;
   struct videobuf_qtype_ops *int_ops ;
   unsigned char streaming : 1 ;
   unsigned char reading : 1 ;
   struct list_head stream ;
   unsigned int read_off ;
   struct videobuf_buffer *read_buf ;
   void *priv_data ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_options {
   int megabytes[7U] ;
   int cardtype ;
   int tuner ;
   int radio ;
};
#line 263 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_buffer {
   struct list_head list ;
   dma_addr_t dma_handle ;
   char *buf ;
   u32 bytesused ;
   u32 readpos ;
};
#line 309 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_mdl {
   struct list_head list ;
   u32 id ;
   unsigned int skipped ;
   unsigned long m_flags ;
   struct list_head buf_list ;
   struct cx18_buffer *curr_buf ;
   u32 bytesused ;
   u32 readpos ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_queue {
   struct list_head list ;
   atomic_t depth ;
   u32 bytesused ;
   spinlock_t lock ;
};
#line 330 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_dvb {
   struct cx18_stream *stream ;
   struct dmx_frontend hw_frontend ;
   struct dmx_frontend mem_frontend ;
   struct dmxdev dmxdev ;
   struct dvb_adapter dvb_adapter ;
   struct dvb_demux demux ;
   struct dvb_frontend *fe ;
   struct dvb_net dvbnet ;
   int enabled ;
   int feeding ;
   struct mutex feedlock ;
};
#line 346
struct cx18_scb;
#line 347 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_in_work_order {
   struct work_struct work ;
   atomic_t pending ;
   struct cx18 *cx ;
   unsigned long flags ;
   int rpu ;
   struct cx18_mailbox mb ;
   struct cx18_mdl_ack mdl_ack[2U] ;
   char *str ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_stream {
   struct video_device *video_dev ;
   struct cx18_dvb *dvb ;
   struct cx18 *cx ;
   char const   *name ;
   int type ;
   u32 handle ;
   unsigned int mdl_base_idx ;
   u32 id ;
   unsigned long s_flags ;
   int dma ;
   wait_queue_head_t waitq ;
   struct list_head buf_pool ;
   u32 buffers ;
   u32 buf_size ;
   u32 bufs_per_mdl ;
   u32 mdl_size ;
   struct cx18_queue q_free ;
   struct cx18_queue q_busy ;
   struct cx18_queue q_full ;
   struct cx18_queue q_idle ;
   struct work_struct out_work_order ;
   u32 pixelformat ;
   u32 vb_bytes_per_frame ;
   struct list_head vb_capture ;
   spinlock_t vb_lock ;
   struct timer_list vb_timeout ;
   struct videobuf_queue vbuf_q ;
   spinlock_t vbuf_q_lock ;
   enum v4l2_buf_type vb_type ;
};
#line 426 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_open_id {
   struct v4l2_fh fh ;
   u32 open_id ;
   int type ;
   struct cx18 *cx ;
};
#line 443
struct cx18_card;
#line 496 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct vbi_info {
   struct v4l2_format in ;
   struct v4l2_sliced_vbi_format *sliced_in ;
   u32 count ;
   u32 start[2U] ;
   u32 frame ;
   int insert_mpeg ;
   struct v4l2_sliced_vbi_data sliced_data[36U] ;
   u8 *sliced_mpeg_data[32U] ;
   u32 sliced_mpeg_size[32U] ;
   u32 inserted_frame ;
   struct cx18_mdl sliced_mpeg_mdl ;
   struct cx18_buffer sliced_mpeg_buf ;
};
#line 564 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_i2c_algo_callback_data {
   struct cx18 *cx ;
   int bus_index ;
};
#line 570
struct cx18_card_tuner_i2c;
#line 570
struct snd_cx18_card;
#line 570 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18 {
   int instance ;
   struct pci_dev *pci_dev ;
   struct v4l2_device v4l2_dev ;
   struct v4l2_subdev *sd_av ;
   struct v4l2_subdev *sd_extmux ;
   struct cx18_card  const  *card ;
   char const   *card_name ;
   struct cx18_card_tuner_i2c  const  *card_i2c ;
   u8 is_50hz ;
   u8 is_60hz ;
   u8 nof_inputs ;
   u8 nof_audio_inputs ;
   u32 v4l2_cap ;
   u32 hw_flags ;
   unsigned int free_mdl_idx ;
   struct cx18_scb *scb ;
   struct mutex epu2apu_mb_lock ;
   struct mutex epu2cpu_mb_lock ;
   struct cx18_av_state av_state ;
   struct cx2341x_handler cxhdl ;
   u32 filter_mode ;
   u32 temporal_strength ;
   u32 spatial_strength ;
   unsigned long dualwatch_jiffies ;
   u32 dualwatch_stereo_mode ;
   struct mutex serialize_lock ;
   struct cx18_options options ;
   int stream_buffers[7U] ;
   int stream_buf_size[7U] ;
   struct cx18_stream streams[7U] ;
   struct snd_cx18_card *alsa ;
   void (*pcm_announce_callback)(struct snd_cx18_card * , u8 * , size_t  ) ;
   unsigned long i_flags ;
   atomic_t ana_capturing ;
   atomic_t tot_capturing ;
   int search_pack_header ;
   int open_id ;
   resource_size_t base_addr ;
   u8 card_rev ;
   void *enc_mem ;
   void *reg_mem ;
   struct vbi_info vbi ;
   u64 mpg_data_received ;
   u64 vbi_data_inserted ;
   wait_queue_head_t mb_apu_waitq ;
   wait_queue_head_t mb_cpu_waitq ;
   wait_queue_head_t cap_w ;
   wait_queue_head_t dma_waitq ;
   u32 sw1_irq_mask ;
   u32 sw2_irq_mask ;
   u32 hw2_irq_mask ;
   struct workqueue_struct *in_work_queue ;
   char in_workq_name[11U] ;
   struct cx18_in_work_order in_work_order[70U] ;
   char epu_debug_str[256U] ;
   struct i2c_adapter i2c_adap[2U] ;
   struct i2c_algo_bit_data i2c_algo[2U] ;
   struct cx18_i2c_algo_callback_data i2c_algo_cb_data[2U] ;
   struct IR_i2c_init_data ir_i2c_init_data ;
   u32 gpio_dir ;
   u32 gpio_val ;
   struct mutex gpio_lock ;
   struct v4l2_subdev sd_gpiomux ;
   struct v4l2_subdev sd_resetctrl ;
   u32 audio_input ;
   u32 active_input ;
   v4l2_std_id std ;
   v4l2_std_id tuner_std ;
   struct work_struct request_module_wk ;
};
#line 691
struct tveeprom;
#line 190 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
struct cx18_card_video_input {
   u8 video_type ;
   u8 audio_index ;
   u32 video_input ;
};
#line 67 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_audio_input {
   u8 audio_type ;
   u32 audio_input ;
   u16 muxer_input ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_pci_info {
   u16 device ;
   u16 subsystem_vendor ;
   u16 subsystem_device ;
};
#line 80 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_init {
   u32 direction ;
   u32 initial_value ;
};
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_i2c_slave_reset {
   u32 active_lo_mask ;
   u32 active_hi_mask ;
   int msecs_asserted ;
   int msecs_recovery ;
   u32 ir_reset_mask ;
};
#line 97 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_audio_input {
   u32 mask ;
   u32 tuner ;
   u32 linein ;
   u32 radio ;
};
#line 104 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_tuner {
   v4l2_std_id std ;
   int tuner ;
};
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_tuner_i2c {
   unsigned short radio[2U] ;
   unsigned short demod[3U] ;
   unsigned short tv[4U] ;
};
#line 115 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_ddr {
   u32 chip_config ;
   u32 refresh ;
   u32 timing1 ;
   u32 timing2 ;
   u32 tune_lane ;
   u32 initial_emrs ;
};
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card {
   int type ;
   char *name ;
   char *comment ;
   u32 v4l2_capabilities ;
   u32 hw_audio_ctrl ;
   u32 hw_muxer ;
   u32 hw_all ;
   struct cx18_card_video_input video_inputs[6U] ;
   struct cx18_card_audio_input audio_inputs[3U] ;
   struct cx18_card_audio_input radio_input ;
   u8 xceive_pin ;
   struct cx18_gpio_init gpio_init ;
   struct cx18_gpio_i2c_slave_reset gpio_i2c_slave_reset ;
   struct cx18_gpio_audio_input gpio_audio_input ;
   struct cx18_card_tuner tuners[2U] ;
   struct cx18_card_tuner_i2c *i2c ;
   struct cx18_ddr ddr ;
   struct cx18_card_pci_info  const  *pci_list ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
struct cx18_mdl_ent {
   u32 paddr ;
   u32 length ;
};
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-scb.h"
struct cx18_scb {
   u32 ipc_offset ;
   u32 reserved01[7U] ;
   u32 cpu_code_offset ;
   u32 reserved02[3U] ;
   u32 apu_code_offset ;
   u32 reserved03[3U] ;
   u32 hpu_code_offset ;
   u32 reserved04[3U] ;
   u32 ppu_code_offset ;
   u32 reserved05[3U] ;
   u32 cpu_state ;
   u32 reserved1[7U] ;
   u32 apu2cpu_mb_offset ;
   u32 apu2cpu_irq ;
   u32 cpu2apu_irq_ack ;
   u32 reserved2[13U] ;
   u32 hpu2cpu_mb_offset ;
   u32 hpu2cpu_irq ;
   u32 cpu2hpu_irq_ack ;
   u32 reserved3[13U] ;
   u32 ppu2cpu_mb_offset ;
   u32 ppu2cpu_irq ;
   u32 cpu2ppu_irq_ack ;
   u32 reserved4[13U] ;
   u32 epu2cpu_mb_offset ;
   u32 epu2cpu_irq ;
   u32 cpu2epu_irq_ack ;
   u32 reserved5[13U] ;
   u32 reserved6[8U] ;
   u32 apu_state ;
   u32 reserved11[7U] ;
   u32 cpu2apu_mb_offset ;
   u32 cpu2apu_irq ;
   u32 apu2cpu_irq_ack ;
   u32 reserved12[13U] ;
   u32 hpu2apu_mb_offset ;
   u32 hpu2apu_irq ;
   u32 apu2hpu_irq_ack ;
   u32 reserved13[13U] ;
   u32 ppu2apu_mb_offset ;
   u32 ppu2apu_irq ;
   u32 apu2ppu_irq_ack ;
   u32 reserved14[13U] ;
   u32 epu2apu_mb_offset ;
   u32 epu2apu_irq ;
   u32 apu2epu_irq_ack ;
   u32 reserved15[13U] ;
   u32 reserved16[8U] ;
   u32 hpu_state ;
   u32 reserved21[7U] ;
   u32 cpu2hpu_mb_offset ;
   u32 cpu2hpu_irq ;
   u32 hpu2cpu_irq_ack ;
   u32 reserved22[13U] ;
   u32 apu2hpu_mb_offset ;
   u32 apu2hpu_irq ;
   u32 hpu2apu_irq_ack ;
   u32 reserved23[13U] ;
   u32 ppu2hpu_mb_offset ;
   u32 ppu2hpu_irq ;
   u32 hpu2ppu_irq_ack ;
   u32 reserved24[13U] ;
   u32 epu2hpu_mb_offset ;
   u32 epu2hpu_irq ;
   u32 hpu2epu_irq_ack ;
   u32 reserved25[13U] ;
   u32 reserved26[8U] ;
   u32 ppu_state ;
   u32 reserved31[7U] ;
   u32 cpu2ppu_mb_offset ;
   u32 cpu2ppu_irq ;
   u32 ppu2cpu_irq_ack ;
   u32 reserved32[13U] ;
   u32 apu2ppu_mb_offset ;
   u32 apu2ppu_irq ;
   u32 ppu2apu_irq_ack ;
   u32 reserved33[13U] ;
   u32 hpu2ppu_mb_offset ;
   u32 hpu2ppu_irq ;
   u32 ppu2hpu_irq_ack ;
   u32 reserved34[13U] ;
   u32 epu2ppu_mb_offset ;
   u32 epu2ppu_irq ;
   u32 ppu2epu_irq_ack ;
   u32 reserved35[13U] ;
   u32 reserved36[8U] ;
   u32 epu_state ;
   u32 reserved41[7U] ;
   u32 cpu2epu_mb_offset ;
   u32 cpu2epu_irq ;
   u32 epu2cpu_irq_ack ;
   u32 reserved42[13U] ;
   u32 apu2epu_mb_offset ;
   u32 apu2epu_irq ;
   u32 epu2apu_irq_ack ;
   u32 reserved43[13U] ;
   u32 hpu2epu_mb_offset ;
   u32 hpu2epu_irq ;
   u32 epu2hpu_irq_ack ;
   u32 reserved44[13U] ;
   u32 ppu2epu_mb_offset ;
   u32 ppu2epu_irq ;
   u32 epu2ppu_irq_ack ;
   u32 reserved45[13U] ;
   u32 reserved46[8U] ;
   u32 semaphores[8U] ;
   u32 reserved50[32U] ;
   struct cx18_mailbox apu2cpu_mb ;
   struct cx18_mailbox hpu2cpu_mb ;
   struct cx18_mailbox ppu2cpu_mb ;
   struct cx18_mailbox epu2cpu_mb ;
   struct cx18_mailbox cpu2apu_mb ;
   struct cx18_mailbox hpu2apu_mb ;
   struct cx18_mailbox ppu2apu_mb ;
   struct cx18_mailbox epu2apu_mb ;
   struct cx18_mailbox cpu2hpu_mb ;
   struct cx18_mailbox apu2hpu_mb ;
   struct cx18_mailbox ppu2hpu_mb ;
   struct cx18_mailbox epu2hpu_mb ;
   struct cx18_mailbox cpu2ppu_mb ;
   struct cx18_mailbox apu2ppu_mb ;
   struct cx18_mailbox hpu2ppu_mb ;
   struct cx18_mailbox epu2ppu_mb ;
   struct cx18_mailbox cpu2epu_mb ;
   struct cx18_mailbox apu2epu_mb ;
   struct cx18_mailbox hpu2epu_mb ;
   struct cx18_mailbox ppu2epu_mb ;
   struct cx18_mdl_ack cpu_mdl_ack[7U][2U] ;
   struct cx18_mdl_ent cpu_mdl[1U] ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-controls.h"
struct xc2028_ctrl {
   char *fname ;
   int max_len ;
   int msleep ;
   unsigned int scode_table ;
   unsigned char mts : 1 ;
   unsigned char input1 : 1 ;
   unsigned char vhfbw7 : 1 ;
   unsigned char uhfbw8 : 1 ;
   unsigned char disable_power_mgmt : 1 ;
   unsigned char read_not_reliable : 1 ;
   unsigned int demod ;
   unsigned char type : 2 ;
};
#line 68 "drivers/media/tuners/tuner-xc2028.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 2162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
struct i2c_board_info;
#line 248 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   int irq ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 73 "include/linux/firmware.h"
struct cx18_apu_rom_seghdr {
   u32 sync1 ;
   u32 sync2 ;
   u32 addr ;
   u32 size ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 419 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_videobuf_buffer {
   struct videobuf_buffer vb ;
   v4l2_std_id tvnorm ;
   u32 bytes_used ;
};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct __anonstruct_cx18_stream_info_319 {
   char const   *name ;
   int vfl_type ;
   int num_offset ;
   int dma ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 45 "include/media/videobuf-vmalloc.h"
struct cx18_enc_idx_entry {
   __le32 length ;
   __le32 offset_low ;
   __le32 offset_high ;
   __le32 flags ;
   __le32 pts_low ;
   __le32 pts_high ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c"
struct __va_list_tag;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c"
typedef struct __va_list_tag __va_list_tag;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct cx18_api_info {
   u32 cmd ;
   u8 flags ;
   u8 rpu ;
   char const   *name ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct vbi_data_hdr {
   __be32 magic ;
   __be32 unknown ;
   __be32 pts ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
enum analog_signal_type {
    NONE = 0,
    CVBS = 1,
    Y = 2,
    C = 3,
    SIF = 4,
    Pb = 5,
    Pr = 6
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct vbi_anc_data {
   u8 preamble[3U] ;
   u8 did ;
   u8 sdid ;
   u8 data_count ;
   u8 idid[2U] ;
   u8 payload[1U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-gpio.h"
struct s5h1409_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 gpio ;
   u16 qam_if ;
   u8 inversion ;
   u8 status_mode ;
   u16 mpeg_timing ;
   u8 hvr1600_opt ;
};
#line 72 "drivers/media/dvb-frontends/s5h1409.h"
struct mxl5005s_config {
   u8 i2c_address ;
   u32 if_freq ;
   u32 xtal_freq ;
   u8 agc_mode ;
   u8 tracking_filter ;
   u8 rssi_enable ;
   u8 cap_select ;
   u8 div_out ;
   u8 clock_out ;
   u32 output_load ;
   u32 top ;
   u8 mod_mode ;
   u8 if_mode ;
   u8 qam_gain ;
   u8 AgcMasterByte ;
};
#line 123 "drivers/media/tuners/mxl5005s.h"
struct s5h1411_config {
   u8 output_mode ;
   u8 gpio ;
   u16 mpeg_timing ;
   u16 qam_if ;
   u16 vsb_if ;
   u8 inversion ;
   u8 status_mode ;
};
#line 74 "drivers/media/dvb-frontends/s5h1411.h"
struct tda18271_std_map_item {
   u16 if_freq ;
   unsigned char agc_mode : 2 ;
   unsigned char std : 3 ;
   unsigned char fm_rfn : 1 ;
   unsigned char if_lvl : 3 ;
   unsigned char rfagc_top : 7 ;
};
#line 41 "drivers/media/tuners/tda18271.h"
struct tda18271_std_map {
   struct tda18271_std_map_item fm_radio ;
   struct tda18271_std_map_item atv_b ;
   struct tda18271_std_map_item atv_dk ;
   struct tda18271_std_map_item atv_gh ;
   struct tda18271_std_map_item atv_i ;
   struct tda18271_std_map_item atv_l ;
   struct tda18271_std_map_item atv_lc ;
   struct tda18271_std_map_item atv_mn ;
   struct tda18271_std_map_item atsc_6 ;
   struct tda18271_std_map_item dvbt_6 ;
   struct tda18271_std_map_item dvbt_7 ;
   struct tda18271_std_map_item dvbt_8 ;
   struct tda18271_std_map_item qam_6 ;
   struct tda18271_std_map_item qam_7 ;
   struct tda18271_std_map_item qam_8 ;
};
#line 59
enum tda18271_role {
    TDA18271_MASTER = 0,
    TDA18271_SLAVE = 1
} ;
#line 64
enum tda18271_i2c_gate {
    TDA18271_GATE_AUTO = 0,
    TDA18271_GATE_ANALOG = 1,
    TDA18271_GATE_DIGITAL = 2
} ;
#line 70
enum tda18271_output_options {
    TDA18271_OUTPUT_LT_XT_ON = 0,
    TDA18271_OUTPUT_LT_OFF = 1,
    TDA18271_OUTPUT_XT_OFF = 2
} ;
#line 76
enum tda18271_small_i2c {
    TDA18271_39_BYTE_CHUNK_INIT = 0,
    TDA18271_16_BYTE_CHUNK_INIT = 16,
    TDA18271_08_BYTE_CHUNK_INIT = 8,
    TDA18271_03_BYTE_CHUNK_INIT = 3
} ;
#line 83 "drivers/media/tuners/tda18271.h"
struct tda18271_config {
   struct tda18271_std_map *std_map ;
   enum tda18271_role role ;
   enum tda18271_i2c_gate gate ;
   enum tda18271_output_options output_opt ;
   enum tda18271_small_i2c small_i2c ;
   unsigned char rf_cal_on_startup : 1 ;
   unsigned char delay_cal : 1 ;
   unsigned int config ;
};
#line 126 "drivers/media/tuners/tda18271.h"
struct zl10353_config {
   u8 demod_address ;
   int adc_clock ;
   int if2 ;
   int no_tuner ;
   int parallel_ts ;
   unsigned char disable_i2c_gate_ctrl : 1 ;
   u8 clock_ctl_1 ;
   u8 pll_0 ;
};
#line 73 "include/linux/firmware.h"
struct mt352_config {
   u8 demod_address ;
   int adc_clock ;
   int if2 ;
   int no_tuner ;
   int (*demod_init)(struct dvb_frontend * ) ;
};
#line 47 "drivers/media/tuners/tuner-xc2028.h"
struct xc2028_config {
   struct i2c_adapter *i2c_adap ;
   u8 i2c_addr ;
   struct xc2028_ctrl *ctrl ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14126_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 391 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3067: ;
#line 14
  return (pfo_ret__);
}
}
#line 55 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 27
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5626: ;
#line 157
  return (__ret + i);
}
}
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit((long )flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 68 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 120 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 139 "include/linux/ioport.h"
extern struct resource iomem_resource ;
#line 192
extern struct resource *__request_region(struct resource * , resource_size_t  , resource_size_t  ,
                                         char const   * , int  ) ;
#line 203
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 303 "include/linux/jiffies.h"
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 180 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 355
extern struct workqueue_struct *system_wq ;
#line 364
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 424
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 431
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 446
extern bool flush_work(struct work_struct * ) ;
#line 447
extern bool cancel_work_sync(struct work_struct * ) ;
#line 471 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 474
  tmp = queue_work_on(8192, wq, work);
#line 474
  return (tmp);
}
}
#line 530 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 532
  tmp = queue_work(system_wq, work);
#line 532
  return (tmp);
}
}
#line 56 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 56
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 175
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 188
extern void iounmap(void volatile   * ) ;
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 316
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_8  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_15  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_vbi_ops_group1  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_20  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct file *cx18_ioctl_ops_group1  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct videobuf_buffer *cx18_videobuf_qops_group2  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_0  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_21  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_5  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *resetctrl_core_ops_group0  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct file *cx18_v4l2_enc_fops_group0  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_13  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_12  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_encoder_cmd *cx18_ioctl_ops_group4  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_14  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct videobuf_queue *cx18_videobuf_qops_group1  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_buffer *cx18_ioctl_ops_group2  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_17  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct cx2341x_handler *cx18_cxhdl_ops_group0  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_19  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_9  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_format *cx18_ioctl_ops_group0  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ref_cnt  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_sliced_vbi_format *cx18_av_vbi_ops_group0  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_1  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_7  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_video_ops_group0  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_10  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_audio_ops_group0  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_6  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_16  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_2  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_11  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_18  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct pci_dev *cx18_pci_driver_group0  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_general_ops_group0  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_3  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_audio *cx18_ioctl_ops_group3  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_tuner_ops_group0  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_4  ;
#line 77
void ldv_initialize_v4l2_file_operations_14(void) ;
#line 80
void ldv_initialize_v4l2_subdev_video_ops_6(void) ;
#line 82
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 83
void choose_interrupt_1(void) ;
#line 84
void ldv_initialize_cx2341x_handler_ops_11(void) ;
#line 85
void ldv_initialize_v4l2_subdev_audio_ops_7(void) ;
#line 86
void ldv_initialize_v4l2_subdev_core_ops_15(void) ;
#line 87
void ldv_initialize_v4l2_subdev_core_ops_9(void) ;
#line 88
void ldv_initialize_v4l2_subdev_tuner_ops_8(void) ;
#line 89
void ldv_initialize_v4l2_subdev_vbi_ops_5(void) ;
#line 90
void ldv_videobuf_queue_ops_13(void) ;
#line 92
void disable_suitable_irq_1(int line , void *data ) ;
#line 93
int ldv_irq_1(int state , int line , void *data ) ;
#line 94
void activate_suitable_irq_1(int line , void *data ) ;
#line 96
void ldv_initialize_pci_driver_21(void) ;
#line 97
void ldv_initialize_v4l2_ioctl_ops_12(void) ;
#line 377 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 2662 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2664
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2664
  return (tmp);
}
}
#line 2688 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2690
  tmp = test_tsk_thread_flag(p, 2);
#line 2690
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2690
  return ((int )tmp___0);
}
}
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 842 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 844
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 848
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 850
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 856 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 858
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 858
  return (tmp);
}
}
#line 860 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 862
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 862
  return (tmp);
}
}
#line 869 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 871
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 871
  return (tmp);
}
}
#line 873 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 875
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 875
  return (tmp);
}
}
#line 924
extern int pci_enable_device(struct pci_dev * ) ;
#line 941
extern void pci_disable_device(struct pci_dev * ) ;
#line 1107
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1116
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 61 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_set_mask(struct device * , u64  ) ;
#line 105 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 107
  tmp = dma_set_mask(& dev->dev, mask);
#line 107
  return (tmp);
}
}
#line 1426 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1428
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1428
  return (tmp);
}
}
#line 123 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_33(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 149
void ldv_free_irq_34(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 153
void ldv_free_irq_35(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 79 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 106
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 87 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_vapi(struct cx18 *cx , u32 cmd , int args  , ...) ;
#line 88
int cx18_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) ;
#line 93
void cx18_in_work_handler(struct work_struct *work ) ;
#line 308 "include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-av-core.h"
int cx18_av_probe(struct cx18 *cx ) ;
#line 193 "include/media/cx2341x.h"
extern int cx2341x_handler_init(struct cx2341x_handler * , unsigned int  ) ;
#line 195
extern void cx2341x_handler_set_50hz(struct cx2341x_handler * , int  ) ;
#line 756 "include/linux/skbuff.h"
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 759
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 765
extern struct sk_buff *skb_copy(struct sk_buff  const  * , gfp_t  ) ;
#line 768
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 778
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 781
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2016
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 255 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
int cx18_debug  ;
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples  =    1444U;
#line 676 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18 *to_cx18(struct v4l2_device *v4l2_dev ) 
{ 
  struct v4l2_device  const  *__mptr ;

  {
#line 678
  __mptr = (struct v4l2_device  const  *)v4l2_dev;
#line 678
  return ((struct cx18 *)__mptr + 0xfffffffffffffff0UL);
}
}
#line 682 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
int (*cx18_ext_init)(struct cx18 * )  ;
#line 685 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
int cx18_first_minor  ;
#line 690
int cx18_msleep_timeout(unsigned int msecs , int intr ) ;
#line 694
void cx18_read_eeprom(struct cx18 *cx , struct tveeprom *tv ) ;
#line 697
int cx18_init_on_first_open(struct cx18 *cx ) ;
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_readl(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned int tmp ;

  {
#line 62
  tmp = readl((void const volatile   *)addr);
#line 62
  return (tmp);
}
}
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_read_reg(struct cx18 *cx , u32 reg ) 
{ 
  u32 tmp ;

  {
#line 169
  tmp = cx18_readl(cx, (void const   *)cx->reg_mem + (unsigned long )reg);
#line 169
  return (tmp);
}
}
#line 185
void cx18_sw1_irq_disable(struct cx18 *cx , u32 val ) ;
#line 187
void cx18_sw2_irq_disable(struct cx18 *cx , u32 val ) ;
#line 157 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card  const  *cx18_get_card(u16 index ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-i2c.h"
int cx18_i2c_register(struct cx18 *cx , unsigned int idx ) ;
#line 25
struct v4l2_subdev *cx18_find_hw(struct cx18 *cx , u32 hw ) ;
#line 28
int init_cx18_i2c(struct cx18 *cx ) ;
#line 29
void exit_cx18_i2c(struct cx18 *cx ) ;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-irq.h"
irqreturn_t cx18_irq_handler(int irq , void *dev_id ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-gpio.h"
void cx18_gpio_init(struct cx18 *cx ) ;
#line 25
int cx18_gpio_register(struct cx18 *cx , u32 hw ) ;
#line 34
int cx18_reset_tuner_gpio(void *dev , int component , int cmd , int value ) ;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-firmware.h"
int cx18_firmware_init(struct cx18 *cx ) ;
#line 23
void cx18_halt_firmware(struct cx18 *cx ) ;
#line 24
void cx18_init_memory(struct cx18 *cx ) ;
#line 25
void cx18_init_power(struct cx18 *cx , int lowpwr ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
int cx18_streams_setup(struct cx18 *cx ) ;
#line 28
int cx18_streams_register(struct cx18 *cx ) ;
#line 29
void cx18_streams_cleanup(struct cx18 *cx , int unregister ) ;
#line 62
void cx18_stop_all_captures(struct cx18 *cx ) ;
#line 278 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-scb.h"
void cx18_init_scb(struct cx18 *cx ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
int cx18_s_std(struct file *file , void *fh , v4l2_std_id std ) ;
#line 30
int cx18_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) ;
#line 31
int cx18_s_input(struct file *file , void *fh , unsigned int inp ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-controls.h"
struct cx2341x_handler_ops cx18_cxhdl_ops ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 51
extern int tveeprom_read(struct i2c_client * , unsigned char * , int  ) ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static char const   __kstrtab_cx18_ext_init[14U]  = 
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
  {      'c',      'x',      '1',      '8', 
        '_',      'e',      'x',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 150
struct kernel_symbol  const  __ksymtab_cx18_ext_init ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_ext_init  =    {(unsigned long )(& cx18_ext_init), (char const   *)(& __kstrtab_cx18_ext_init)};
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static struct pci_device_id cx18_pci_tbl[2U]  = {      {5361U, 23418U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct pci_device_id  const  __mod_pci__cx18_pci_tbl_device_table  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static atomic_t cx18_instance  =    {0};
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cardtype[32U]  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int tuner[32U]  = 
#line 165
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int radio[32U]  = 
#line 169
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static char pal[3U]  = {      '-',      '-',      '\000'};
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static char secam[3U]  = {      '-',      '-',      '\000'};
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static char ntsc[2U]  = {      '-',      '\000'};
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_ts_buffers  =    1;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_mpg_buffers  =    2;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_idx_buffers  =    1;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_yuv_buffers  =    2;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_vbi_buffers  =    1;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_pcm_buffers  =    1;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_ts_bufsize  =    32;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_mpg_bufsize  =    32;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_idx_bufsize  =    2;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_yuv_bufsize  =    102;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_pcm_bufsize  =    4;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_ts_bufs  =    -1;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_mpg_bufs  =    -1;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_idx_bufs  =    63;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_yuv_bufs  =    -1;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_vbi_bufs  =    -1;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int enc_pcm_bufs  =    -1;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cx18_pci_latency  =    1;
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void request_module_async(struct work_struct *work ) 
{ 
  struct cx18 *dev ;
  struct work_struct  const  *__mptr ;

  {
#line 354
  __mptr = (struct work_struct  const  *)work;
#line 354
  dev = (struct cx18 *)__mptr + 0xffffffffffff73f0UL;
#line 357
  __request_module(1, "cx18-alsa");
#line 360
  if ((unsigned long )cx18_ext_init != (unsigned long )((int (*)(struct cx18 * ))0)) {
#line 361
    (*cx18_ext_init)(dev);
  } else {

  }
#line 362
  return;
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void request_modules(struct cx18 *dev ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 366
  __init_work(& dev->request_module_wk, 0);
#line 366
  __constr_expr_0.counter = 137438953408L;
#line 366
  dev->request_module_wk.data = __constr_expr_0;
#line 366
  lockdep_init_map(& dev->request_module_wk.lockdep_map, "(&dev->request_module_wk)",
                   & __key, 0);
#line 366
  INIT_LIST_HEAD(& dev->request_module_wk.entry);
#line 366
  dev->request_module_wk.func = & request_module_async;
#line 367
  schedule_work(& dev->request_module_wk);
#line 368
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void flush_request_modules(struct cx18 *dev ) 
{ 


  {
#line 372
  flush_work(& dev->request_module_wk);
#line 373
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int cx18_msleep_timeout(unsigned int msecs , int intr ) 
{ 
  long timeout ;
  unsigned long tmp ;
  int sig ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;

  {
#line 382
  tmp = msecs_to_jiffies(msecs);
#line 382
  timeout = (long )tmp;
  ldv_52344: 
#line 386
  __ret = intr != 0 ? 1L : 2L;
#line 386
  switch (8UL) {
  case 1UL: 
#line 386
  tmp___0 = get_current();
#line 386
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 386
  goto ldv_52338;
  case 2UL: 
#line 386
  tmp___1 = get_current();
#line 386
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 386
  goto ldv_52338;
  case 4UL: 
#line 386
  tmp___2 = get_current();
#line 386
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 386
  goto ldv_52338;
  case 8UL: 
#line 386
  tmp___3 = get_current();
#line 386
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 386
  goto ldv_52338;
  default: 
#line 386
  __xchg_wrong_size();
  }
  ldv_52338: 
#line 387
  timeout = schedule_timeout(timeout);
#line 388
  if (intr != 0) {
#line 388
    tmp___4 = get_current();
#line 388
    tmp___5 = signal_pending(tmp___4);
#line 388
    sig = tmp___5;
  } else {
#line 388
    sig = 0;
  }
#line 389
  if (sig == 0 && timeout != 0L) {
#line 391
    goto ldv_52344;
  } else {

  }

#line 390
  return (sig);
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_iounmap(struct cx18 *cx ) 
{ 


  {
#line 396
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 397
    return;
  } else {

  }
#line 400
  if ((unsigned long )cx->enc_mem != (unsigned long )((void *)0)) {
#line 401
    if ((cx18_debug & 2) != 0) {
#line 401
      printk("\016%s:  info: releasing enc_mem\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 402
    iounmap((void volatile   *)cx->enc_mem);
#line 403
    cx->enc_mem = (void *)0;
  } else {

  }
#line 405
  return;
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_eeprom_dump(struct cx18 *cx , unsigned char *eedata , int len ) 
{ 
  int i ;

  {
#line 411
  printk("\016%s: eeprom dump:\n", (char *)(& cx->v4l2_dev.name));
#line 412
  i = 0;
#line 412
  goto ldv_52356;
  ldv_52355: ;
#line 413
  if (((unsigned int )i & 15U) == 0U) {
#line 414
    printk("\016%s: eeprom %02x:", (char *)(& cx->v4l2_dev.name), i);
  } else {

  }
#line 415
  printk(" %02x", (int )*(eedata + (unsigned long )i));
#line 416
  if (i % 16 == 15) {
#line 417
    printk("\n");
  } else {

  }
#line 412
  i = i + 1;
  ldv_52356: ;
#line 412
  if (i < len) {
#line 414
    goto ldv_52355;
  } else {

  }

#line 419
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void cx18_read_eeprom(struct cx18 *cx , struct tveeprom *tv ) 
{ 
  struct i2c_client *c ;
  u8 eedata[256U] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 427
  memset((void *)tv, 0, 76UL);
#line 429
  tmp = kzalloc(1472UL, 208U);
#line 429
  c = (struct i2c_client *)tmp;
#line 430
  if ((unsigned long )c == (unsigned long )((struct i2c_client *)0)) {
#line 431
    return;
  } else {

  }
#line 433
  strlcpy((char *)(& c->name), "cx18 tveeprom tmp", 20UL);
#line 434
  c->adapter = (struct i2c_adapter *)(& cx->i2c_adap);
#line 435
  c->addr = 80U;
#line 437
  tmp___0 = tveeprom_read(c, (unsigned char *)(& eedata), 256);
#line 437
  if (tmp___0 != 0) {
#line 438
    goto ret;
  } else {

  }
#line 440
  switch ((cx->card)->type) {
  case 0: ;
  case 1: ;
  case 9: 
#line 444
  tveeprom_hauppauge_analog(c, tv, (unsigned char *)(& eedata));
#line 445
  goto ldv_52368;
  case 3: ;
  case 8: 
#line 448
  tv->model = 1816U;
#line 449
  cx18_eeprom_dump(cx, (unsigned char *)(& eedata), 256);
#line 450
  printk("\016%s: eeprom PCI ID: %02x%02x:%02x%02x\n", (char *)(& cx->v4l2_dev.name),
         (int )eedata[2], (int )eedata[1], (int )eedata[4], (int )eedata[3]);
#line 452
  goto ldv_52368;
  default: 
#line 454
  tv->model = 4294967295U;
#line 455
  cx18_eeprom_dump(cx, (unsigned char *)(& eedata), 256);
#line 456
  goto ldv_52368;
  }
  ldv_52368: ;
  ret: 
#line 460
  kfree((void const   *)c);
#line 461
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_process_eeprom(struct cx18 *cx ) 
{ 
  struct tveeprom tv ;

  {
#line 467
  cx18_read_eeprom(cx, & tv);
#line 474
  switch (tv.model) {
  case 74301U: ;
  case 74321U: ;
  case 74351U: ;
  case 74361U: 
#line 480
  cx->card = cx18_get_card(9);
#line 481
  goto ldv_52380;
  case 74021U: ;
  case 74031U: ;
  case 74041U: ;
  case 74141U: ;
  case 74541U: ;
  case 74551U: ;
  case 74591U: ;
  case 74651U: ;
  case 74691U: ;
  case 74751U: ;
  case 74891U: 
#line 494
  cx->card = cx18_get_card(0);
#line 495
  goto ldv_52380;
  case 1816U: ;
#line 497
  return;
  case 4294967295U: 
#line 499
  printk("\016%s: Unknown EEPROM encoding\n", (char *)(& cx->v4l2_dev.name));
#line 500
  return;
  case 0U: 
#line 502
  printk("\v%s: Invalid EEPROM\n", (char *)(& cx->v4l2_dev.name));
#line 503
  return;
  default: 
#line 505
  printk("\v%s: Unknown model %d, defaulting to original HVR-1600 (cardtype=1)\n",
         (char *)(& cx->v4l2_dev.name), tv.model);
#line 507
  cx->card = cx18_get_card(0);
#line 508
  goto ldv_52380;
  }
  ldv_52380: 
#line 511
  cx->v4l2_cap = (cx->card)->v4l2_capabilities;
#line 512
  cx->card_name = (char const   *)(cx->card)->name;
#line 513
  cx->card_i2c = (struct cx18_card_tuner_i2c  const  *)(cx->card)->i2c;
#line 515
  printk("\016%s: Autodetected %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 517
  if (tv.tuner_type == 4U) {
#line 518
    printk("\v%s: tveeprom cannot autodetect tuner!\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 520
  if (cx->options.tuner == -1) {
#line 521
    cx->options.tuner = (int )tv.tuner_type;
  } else {

  }
#line 522
  if (cx->options.radio == -1) {
#line 523
    cx->options.radio = tv.has_radio != 0U;
  } else {

  }
#line 525
  if (cx->std != 0ULL) {
#line 527
    return;
  } else {

  }
#line 535
  if (((unsigned long long )tv.tuner_formats & 16758783ULL) == 16758783ULL) {
#line 537
    if ((cx18_debug & 2) != 0) {
#line 537
      printk("\016%s:  info: Worldwide tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 538
    cx->std = 16777215ULL;
  } else
#line 539
  if (((unsigned long long )tv.tuner_formats & 255ULL) != 0ULL) {
#line 540
    if ((cx18_debug & 2) != 0) {
#line 540
      printk("\016%s:  info: PAL tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 541
    cx->std = cx->std | 15ULL;
  } else
#line 542
  if (((unsigned long long )tv.tuner_formats & 45056ULL) != 0ULL) {
#line 543
    if ((cx18_debug & 2) != 0) {
#line 543
      printk("\016%s:  info: NTSC tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 544
    cx->std = cx->std | 4096ULL;
  } else
#line 545
  if (((unsigned long long )tv.tuner_formats & 16711680ULL) != 0ULL) {
#line 546
    if ((cx18_debug & 2) != 0) {
#line 546
      printk("\016%s:  info: SECAM tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 547
    cx->std = cx->std | 4194304ULL;
  } else {
#line 549
    printk("\016%s: No tuner detected, default to NTSC-M\n", (char *)(& cx->v4l2_dev.name));
#line 550
    cx->std = cx->std | 4096ULL;
  }
#line 552
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static v4l2_std_id cx18_parse_std(struct cx18 *cx ) 
{ 


  {
#line 556
  switch ((int )pal[0]) {
  case 54: ;
#line 558
  return (2048ULL);
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
#line 563
  return (7ULL);
  case 104: ;
  case 72: ;
#line 566
  return (8ULL);
  case 110: ;
  case 78: ;
#line 569
  if ((int )((signed char )pal[1]) == 99 || (int )((signed char )pal[1]) == 67) {
#line 570
    return (1024ULL);
  } else {

  }
#line 571
  return (512ULL);
  case 105: ;
  case 73: ;
#line 574
  return (16ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: ;
#line 579
  return (224ULL);
  case 77: ;
  case 109: ;
#line 582
  return (256ULL);
  case 45: ;
#line 584
  goto ldv_52417;
  default: 
#line 586
  printk("\f%s: pal= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 587
  return (0ULL);
  }
  ldv_52417: ;
#line 590
  switch ((int )secam[0]) {
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
  case 104: ;
  case 72: ;
#line 597
  return (851968ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: ;
#line 602
  return (3276800ULL);
  case 108: ;
  case 76: ;
#line 605
  if ((int )((signed char )secam[1]) == 67 || (int )((signed char )secam[1]) == 99) {
#line 606
    return (8388608ULL);
  } else {

  }
#line 607
  return (4194304ULL);
  case 45: ;
#line 609
  goto ldv_52432;
  default: 
#line 611
  printk("\f%s: secam= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 612
  return (0ULL);
  }
  ldv_52432: ;
#line 615
  switch ((int )ntsc[0]) {
  case 109: ;
  case 77: ;
#line 618
  return (4096ULL);
  case 106: ;
  case 74: ;
#line 621
  return (8192ULL);
  case 107: ;
  case 75: ;
#line 624
  return (32768ULL);
  case 45: ;
#line 626
  goto ldv_52441;
  default: 
#line 628
  printk("\f%s: ntsc= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 629
  return (0ULL);
  }
  ldv_52441: ;
#line 633
  return (0ULL);
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_process_options(struct cx18 *cx ) 
{ 
  int i ;
  int j ;
  struct cx18_card  const  *tmp ;

  {
#line 640
  cx->options.megabytes[1] = enc_ts_buffers;
#line 641
  cx->options.megabytes[0] = enc_mpg_buffers;
#line 642
  cx->options.megabytes[5] = enc_idx_buffers;
#line 643
  cx->options.megabytes[2] = enc_yuv_buffers;
#line 644
  cx->options.megabytes[3] = enc_vbi_buffers;
#line 645
  cx->options.megabytes[4] = enc_pcm_buffers;
#line 646
  cx->options.megabytes[6] = 0;
#line 648
  cx->stream_buffers[1] = enc_ts_bufs;
#line 649
  cx->stream_buffers[0] = enc_mpg_bufs;
#line 650
  cx->stream_buffers[5] = enc_idx_bufs;
#line 651
  cx->stream_buffers[2] = enc_yuv_bufs;
#line 652
  cx->stream_buffers[3] = enc_vbi_bufs;
#line 653
  cx->stream_buffers[4] = enc_pcm_bufs;
#line 654
  cx->stream_buffers[6] = 0;
#line 656
  cx->stream_buf_size[1] = enc_ts_bufsize;
#line 657
  cx->stream_buf_size[0] = enc_mpg_bufsize;
#line 658
  cx->stream_buf_size[5] = enc_idx_bufsize;
#line 659
  cx->stream_buf_size[2] = enc_yuv_bufsize;
#line 660
  cx->stream_buf_size[3] = (int )((unsigned int )vbi_active_samples * 36U);
#line 661
  cx->stream_buf_size[4] = enc_pcm_bufsize;
#line 662
  cx->stream_buf_size[6] = 0;
#line 665
  i = 0;
#line 665
  goto ldv_52450;
  ldv_52449: ;
#line 666
  if ((cx->stream_buffers[i] == 0 || cx->options.megabytes[i] <= 0) || cx->stream_buf_size[i] <= 0) {
#line 669
    cx->options.megabytes[i] = 0;
#line 670
    cx->stream_buffers[i] = 0;
#line 671
    cx->stream_buf_size[i] = 0;
#line 672
    goto ldv_52448;
  } else {

  }
#line 684
  if (i == 2) {
#line 685
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
#line 686
    cx->stream_buf_size[i] = cx->stream_buf_size[i] - cx->stream_buf_size[i] % 34560;
#line 689
    if (cx->stream_buf_size[i] <= 34559) {
#line 690
      cx->stream_buf_size[i] = 34560;
    } else {

    }
  } else
#line 692
  if (i == 5) {
#line 693
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
#line 694
    cx->stream_buf_size[i] = (int )((unsigned int )cx->stream_buf_size[i] - (unsigned int )((unsigned long )cx->stream_buf_size[i] % 1536UL));
#line 697
    if ((unsigned int )cx->stream_buf_size[i] <= 1535U) {
#line 698
      cx->stream_buf_size[i] = 1536;
    } else {

    }
  } else {

  }
#line 707
  if ((i == 3 || i == 2) || i == 5) {
#line 710
    if (cx->stream_buffers[i] < 0) {
#line 711
      cx->stream_buffers[i] = (cx->options.megabytes[i] * 1048576) / cx->stream_buf_size[i];
    } else {
#line 716
      cx->options.megabytes[i] = (cx->stream_buffers[i] * cx->stream_buf_size[i]) / 1048576;
    }
  } else {
#line 722
    if (cx->stream_buffers[i] < 0) {
#line 723
      cx->stream_buffers[i] = (cx->options.megabytes[i] * 1024) / cx->stream_buf_size[i];
    } else {
#line 728
      cx->options.megabytes[i] = (cx->stream_buffers[i] * cx->stream_buf_size[i]) / 1024;
    }
#line 733
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
  }
#line 735
  if ((cx18_debug & 2) != 0) {
#line 735
    printk("\016%s:  info: Stream type %d options: %d MB, %d buffers, %d bytes\n",
           (char *)(& cx->v4l2_dev.name), i, cx->options.megabytes[i], cx->stream_buffers[i],
           cx->stream_buf_size[i]);
  } else {

  }
  ldv_52448: 
#line 665
  i = i + 1;
  ldv_52450: ;
#line 665
  if (i <= 6) {
#line 667
    goto ldv_52449;
  } else {

  }
#line 740
  cx->options.cardtype = cardtype[cx->instance];
#line 741
  cx->options.tuner = tuner[cx->instance];
#line 742
  cx->options.radio = radio[cx->instance];
#line 744
  cx->std = cx18_parse_std(cx);
#line 745
  if (cx->options.cardtype == -1) {
#line 746
    printk("\016%s: Ignore card\n", (char *)(& cx->v4l2_dev.name));
#line 747
    return;
  } else {

  }
#line 749
  cx->card = cx18_get_card((int )((unsigned int )((u16 )cx->options.cardtype) + 65535U));
#line 750
  if ((unsigned long )cx->card != (unsigned long )((struct cx18_card  const  *)0)) {
#line 751
    printk("\016%s: User specified %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
  } else
#line 752
  if (cx->options.cardtype != 0) {
#line 753
    printk("\v%s: Unknown user specified type, trying to autodetect card\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 754
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 755
    if ((unsigned int )(cx->pci_dev)->subsystem_vendor == 112U) {
#line 756
      cx->card = cx18_get_card(0);
#line 757
      printk("\016%s: Autodetected Hauppauge card\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 760
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 761
    i = 0;
#line 761
    goto ldv_52459;
    ldv_52458: ;
#line 762
    if ((unsigned long )(cx->card)->pci_list == (unsigned long )((struct cx18_card_pci_info  const  */* const  */)0)) {
#line 763
      goto ldv_52452;
    } else {

    }
#line 764
    j = 0;
#line 764
    goto ldv_52456;
    ldv_52455: ;
#line 765
    if ((int )(cx->pci_dev)->device != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->device)) {
#line 767
      goto ldv_52453;
    } else {

    }
#line 768
    if ((int )(cx->pci_dev)->subsystem_vendor != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->subsystem_vendor)) {
#line 770
      goto ldv_52453;
    } else {

    }
#line 771
    if ((int )(cx->pci_dev)->subsystem_device != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->subsystem_device)) {
#line 773
      goto ldv_52453;
    } else {

    }
#line 774
    printk("\016%s: Autodetected %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
#line 775
    goto done;
    ldv_52453: 
#line 764
    j = j + 1;
    ldv_52456: ;
#line 764
    if ((unsigned int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->device) != 0U) {
#line 766
      goto ldv_52455;
    } else {

    }

    ldv_52452: 
#line 761
    i = i + 1;
    ldv_52459: 
#line 761
    tmp = cx18_get_card((int )((u16 )i));
#line 761
    cx->card = tmp;
#line 761
    if ((unsigned long )tmp != (unsigned long )((struct cx18_card  const  *)0)) {
#line 763
      goto ldv_52458;
    } else {

    }

  } else {

  }
  done: ;
#line 781
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 782
    cx->card = cx18_get_card(0);
#line 783
    printk("\v%s: Unknown card: vendor/device: [%04x:%04x]\n", (char *)(& cx->v4l2_dev.name),
           (int )(cx->pci_dev)->vendor, (int )(cx->pci_dev)->device);
#line 785
    printk("\v%s:               subsystem vendor/device: [%04x:%04x]\n", (char *)(& cx->v4l2_dev.name),
           (int )(cx->pci_dev)->subsystem_vendor, (int )(cx->pci_dev)->subsystem_device);
#line 788
    printk("\v%s: Defaulting to %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
#line 789
    printk("\v%s: Please mail the vendor/device and subsystem vendor/device IDs and what kind of\n",
           (char *)(& cx->v4l2_dev.name));
#line 790
    printk("\v%s: card you have to the ivtv-devel mailinglist (www.ivtvdriver.org)\n",
           (char *)(& cx->v4l2_dev.name));
#line 791
    printk("\v%s: Prefix your subject line with [UNKNOWN CX18 CARD].\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 793
  cx->v4l2_cap = (cx->card)->v4l2_capabilities;
#line 794
  cx->card_name = (char const   *)(cx->card)->name;
#line 795
  cx->card_i2c = (struct cx18_card_tuner_i2c  const  *)(cx->card)->i2c;
#line 796
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cx18_create_in_workq(struct cx18 *cx ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 800
  snprintf((char *)(& cx->in_workq_name), 11UL, "%s-in", (char *)(& cx->v4l2_dev.name));
#line 802
  __lock_name = "\"%s\"cx->in_workq_name";
#line 802
  tmp = __alloc_workqueue_key("%s", 131074U, 1, & __key, __lock_name, (char *)(& cx->in_workq_name));
#line 802
  cx->in_work_queue = tmp;
#line 803
  if ((unsigned long )cx->in_work_queue == (unsigned long )((struct workqueue_struct *)0)) {
#line 804
    printk("\v%s: Unable to create incoming mailbox handler thread\n", (char *)(& cx->v4l2_dev.name));
#line 805
    return (-12);
  } else {

  }
#line 807
  return (0);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_init_in_work_orders(struct cx18 *cx ) 
{ 
  int i ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 813
  i = 0;
#line 813
  goto ldv_52474;
  ldv_52473: 
#line 814
  cx->in_work_order[i].cx = cx;
#line 815
  cx->in_work_order[i].str = (char *)(& cx->epu_debug_str);
#line 816
  __init_work(& cx->in_work_order[i].work, 0);
#line 816
  __constr_expr_0.counter = 137438953408L;
#line 816
  cx->in_work_order[i].work.data = __constr_expr_0;
#line 816
  lockdep_init_map(& cx->in_work_order[i].work.lockdep_map, "(&cx->in_work_order[i].work)",
                   & __key, 0);
#line 816
  INIT_LIST_HEAD(& cx->in_work_order[i].work.entry);
#line 816
  cx->in_work_order[i].work.func = & cx18_in_work_handler;
#line 813
  i = i + 1;
  ldv_52474: ;
#line 813
  if (i <= 69) {
#line 815
    goto ldv_52473;
  } else {

  }

#line 820
  return;
}
}
#line 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cx18_init_struct1(struct cx18 *cx ) 
{ 
  int ret ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;

  {
#line 829
  cx->base_addr = (cx->pci_dev)->resource[0].start;
#line 831
  __mutex_init(& cx->serialize_lock, "&cx->serialize_lock", & __key);
#line 832
  __mutex_init(& cx->gpio_lock, "&cx->gpio_lock", & __key___0);
#line 833
  __mutex_init(& cx->epu2apu_mb_lock, "&cx->epu2apu_mb_lock", & __key___1);
#line 834
  __mutex_init(& cx->epu2cpu_mb_lock, "&cx->epu2cpu_mb_lock", & __key___2);
#line 836
  ret = cx18_create_in_workq(cx);
#line 837
  if (ret != 0) {
#line 838
    return (ret);
  } else {

  }
#line 840
  cx18_init_in_work_orders(cx);
#line 843
  cx->open_id = 1;
#line 846
  cx->cxhdl.port = 0;
#line 847
  cx->cxhdl.capabilities = 3U;
#line 848
  cx->cxhdl.ops = (struct cx2341x_handler_ops  const  *)(& cx18_cxhdl_ops);
#line 849
  cx->cxhdl.func = & cx18_api_func;
#line 850
  cx->cxhdl.priv = (void *)(& cx->streams);
#line 851
  ret = cx2341x_handler_init(& cx->cxhdl, 50U);
#line 852
  if (ret != 0) {
#line 853
    return (ret);
  } else {

  }
#line 854
  cx->v4l2_dev.ctrl_handler = & cx->cxhdl.hdl;
#line 856
  cx->temporal_strength = (u32 )(cx->cxhdl.ldv_36985.video_temporal_filter)->cur.val;
#line 857
  cx->spatial_strength = (u32 )(cx->cxhdl.ldv_36985.video_spatial_filter)->cur.val;
#line 858
  cx->filter_mode = (u32 )(((cx->cxhdl.ldv_36977.video_spatial_filter_mode)->cur.val | ((cx->cxhdl.ldv_36977.video_temporal_filter_mode)->cur.val << 1)) | ((cx->cxhdl.ldv_36977.video_median_filter_type)->cur.val << 2));
#line 862
  __init_waitqueue_head(& cx->cap_w, "&cx->cap_w", & __key___3);
#line 863
  __init_waitqueue_head(& cx->mb_apu_waitq, "&cx->mb_apu_waitq", & __key___4);
#line 864
  __init_waitqueue_head(& cx->mb_cpu_waitq, "&cx->mb_cpu_waitq", & __key___5);
#line 865
  __init_waitqueue_head(& cx->dma_waitq, "&cx->dma_waitq", & __key___6);
#line 868
  cx->vbi.in.type = 4U;
#line 869
  cx->vbi.sliced_in = & cx->vbi.in.fmt.sliced;
#line 872
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_buf.list);
#line 873
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_mdl.list);
#line 874
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_mdl.buf_list);
#line 875
  list_add(& cx->vbi.sliced_mpeg_buf.list, & cx->vbi.sliced_mpeg_mdl.buf_list);
#line 877
  return (0);
}
}
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_init_struct2(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 886
  i = 0;
#line 886
  goto ldv_52494;
  ldv_52493: ;
#line 887
  if ((unsigned int )((unsigned char )(cx->card)->video_inputs[i].video_type) == 0U) {
#line 888
    goto ldv_52492;
  } else {

  }
#line 886
  i = i + 1;
  ldv_52494: ;
#line 886
  if (i <= 5) {
#line 888
    goto ldv_52493;
  } else {

  }
  ldv_52492: 
#line 889
  cx->nof_inputs = (u8 )i;
#line 890
  i = 0;
#line 890
  goto ldv_52497;
  ldv_52496: ;
#line 891
  if ((unsigned int )((unsigned char )(cx->card)->audio_inputs[i].audio_type) == 0U) {
#line 892
    goto ldv_52495;
  } else {

  }
#line 890
  i = i + 1;
  ldv_52497: ;
#line 890
  if (i <= 2) {
#line 892
    goto ldv_52496;
  } else {

  }
  ldv_52495: 
#line 893
  cx->nof_audio_inputs = (u8 )i;
#line 896
  i = 0;
#line 896
  goto ldv_52500;
  ldv_52499: ;
#line 897
  if ((unsigned int )((unsigned char )(cx->card)->video_inputs[i].video_type) == 1U) {
#line 899
    goto ldv_52498;
  } else {

  }
#line 896
  i = i + 1;
  ldv_52500: ;
#line 896
  if ((int )cx->nof_inputs > i) {
#line 898
    goto ldv_52499;
  } else {

  }
  ldv_52498: ;
#line 901
  if ((int )cx->nof_inputs == i) {
#line 902
    i = 0;
  } else {

  }
#line 903
  cx->active_input = (u32 )i;
#line 904
  cx->audio_input = (u32 )(cx->card)->video_inputs[i].audio_index;
#line 905
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cx18_setup_pci(struct cx18 *cx , struct pci_dev *pci_dev , struct pci_device_id  const  *pci_id ) 
{ 
  u16 cmd ;
  unsigned char pci_latency ;
  int tmp ;
  int tmp___0 ;
  struct resource *tmp___1 ;

  {
#line 913
  if ((cx18_debug & 2) != 0) {
#line 913
    printk("\016%s:  info: Enabling pci device\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 915
  tmp = pci_enable_device(pci_dev);
#line 915
  if (tmp != 0) {
#line 916
    printk("\v%s: Can\'t enable device %d!\n", (char *)(& cx->v4l2_dev.name), cx->instance);
#line 917
    return (-5);
  } else {

  }
#line 919
  tmp___0 = pci_set_dma_mask(pci_dev, 4294967295ULL);
#line 919
  if (tmp___0 != 0) {
#line 920
    printk("\v%s: No suitable DMA available, card %d\n", (char *)(& cx->v4l2_dev.name),
           cx->instance);
#line 921
    return (-5);
  } else {

  }
#line 923
  tmp___1 = __request_region(& iomem_resource, cx->base_addr, 67108864ULL, "cx18 encoder",
                             0);
#line 923
  if ((unsigned long )tmp___1 == (unsigned long )((struct resource *)0)) {
#line 924
    printk("\v%s: Cannot request encoder memory region, card %d\n", (char *)(& cx->v4l2_dev.name),
           cx->instance);
#line 926
    return (-5);
  } else {

  }
#line 930
  pci_read_config_word((struct pci_dev  const  *)pci_dev, 4, & cmd);
#line 931
  cmd = (u16 )((unsigned int )cmd | 6U);
#line 932
  pci_write_config_word((struct pci_dev  const  *)pci_dev, 4, (int )cmd);
#line 934
  cx->card_rev = pci_dev->revision;
#line 935
  pci_read_config_byte((struct pci_dev  const  *)pci_dev, 13, & pci_latency);
#line 937
  if ((unsigned int )pci_latency <= 63U && cx18_pci_latency != 0) {
#line 938
    printk("\016%s: Unreasonably low latency timer, setting to 64 (was %d)\n", (char *)(& cx->v4l2_dev.name),
           (int )pci_latency);
#line 940
    pci_write_config_byte((struct pci_dev  const  *)pci_dev, 13, 64);
#line 941
    pci_read_config_byte((struct pci_dev  const  *)pci_dev, 13, & pci_latency);
  } else {

  }
#line 944
  if ((cx18_debug & 2) != 0) {
#line 944
    printk("\016%s:  info: cx%d (rev %d) at %02x:%02x.%x, irq: %d, latency: %d, memory: 0x%llx\n",
           (char *)(& cx->v4l2_dev.name), (int )(cx->pci_dev)->device, (int )cx->card_rev,
           (int )(pci_dev->bus)->number, (pci_dev->devfn >> 3) & 31U, pci_dev->devfn & 7U,
           (cx->pci_dev)->irq, (int )pci_latency, cx->base_addr);
  } else {

  }
#line 950
  return (0);
}
}
#line 953 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_init_subdevs(struct cx18 *cx ) 
{ 
  u32 hw ;
  u32 device ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 955
  hw = (cx->card)->hw_all;
#line 959
  i = 0;
#line 959
  device = 1U;
#line 959
  goto ldv_52523;
  ldv_52522: ;
#line 961
  if ((device & hw) == 0U) {
#line 962
    goto ldv_52514;
  } else {

  }
#line 964
  switch (device) {
  case 8U: ;
  case 2U: 
#line 968
  cx->hw_flags = cx->hw_flags | device;
#line 969
  goto ldv_52517;
  case 16U: 
#line 973
  cx->hw_flags = cx->hw_flags | device;
#line 974
  goto ldv_52517;
  case 64U: ;
#line 980
  goto ldv_52517;
  case 32U: 
#line 982
  tmp = cx18_gpio_register(cx, device);
#line 982
  if (tmp == 0) {
#line 983
    cx->hw_flags = cx->hw_flags | device;
  } else {

  }
#line 984
  goto ldv_52517;
  default: 
#line 986
  tmp___0 = cx18_i2c_register(cx, (unsigned int )i);
#line 986
  if (tmp___0 == 0) {
#line 987
    cx->hw_flags = cx->hw_flags | device;
  } else {

  }
#line 988
  goto ldv_52517;
  }
  ldv_52517: ;
  ldv_52514: 
#line 959
  i = i + 1;
#line 959
  device = device << 1;
  ldv_52523: ;
#line 959
  if (i <= 31) {
#line 961
    goto ldv_52522;
  } else {

  }

#line 992
  if ((cx->hw_flags & 16U) != 0U) {
#line 993
    cx->sd_av = cx18_find_hw(cx, 16U);
  } else {

  }
#line 995
  if ((unsigned int )(cx->card)->hw_muxer != 0U) {
#line 996
    cx->sd_extmux = cx18_find_hw(cx, (cx->card)->hw_muxer);
  } else {

  }
#line 997
  return;
}
}
#line 999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int cx18_probe(struct pci_dev *pci_dev , struct pci_device_id  const  *pci_id ) 
{ 
  int retval ;
  int i ;
  u32 devtype ;
  struct cx18 *cx ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct cx18_card  const  *orig_card ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct tuner_setup setup ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct xc2028_ctrl ctrl ;
  struct v4l2_priv_tun_config cfg ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 1002
  retval = 0;
#line 1008
  tmp = atomic_add_return(1, & cx18_instance);
#line 1008
  i = tmp + -1;
#line 1009
  if (i > 31) {
#line 1010
    printk("\vcx18: cannot manage card %d, driver has a limit of 0 - %d\n", i, 31);
#line 1012
    return (-12);
  } else {

  }
#line 1015
  tmp___0 = kzalloc(35936UL, 32U);
#line 1015
  cx = (struct cx18 *)tmp___0;
#line 1016
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 1017
    printk("\vcx18: cannot manage card %d, out of memory\n", i);
#line 1019
    return (-12);
  } else {

  }
#line 1021
  cx->pci_dev = pci_dev;
#line 1022
  cx->instance = i;
#line 1024
  retval = v4l2_device_register(& pci_dev->dev, & cx->v4l2_dev);
#line 1025
  if (retval != 0) {
#line 1026
    printk("\vcx18: v4l2_device_register of card %d failed\n", cx->instance);
#line 1028
    kfree((void const   *)cx);
#line 1029
    return (retval);
  } else {

  }
#line 1031
  snprintf((char *)(& cx->v4l2_dev.name), 36UL, "cx18-%d", cx->instance);
#line 1033
  printk("\016%s: Initializing card %d\n", (char *)(& cx->v4l2_dev.name), cx->instance);
#line 1035
  cx18_process_options(cx);
#line 1036
  if (cx->options.cardtype == -1) {
#line 1037
    retval = -19;
#line 1038
    goto err;
  } else {

  }
#line 1041
  retval = cx18_init_struct1(cx);
#line 1042
  if (retval != 0) {
#line 1043
    goto err;
  } else {

  }
#line 1045
  if ((cx18_debug & 2) != 0) {
#line 1045
    printk("\016%s:  info: base addr: 0x%llx\n", (char *)(& cx->v4l2_dev.name), cx->base_addr);
  } else {

  }
#line 1048
  retval = cx18_setup_pci(cx, pci_dev, pci_id);
#line 1049
  if (retval != 0) {
#line 1050
    goto free_workqueues;
  } else {

  }
#line 1053
  if ((cx18_debug & 2) != 0) {
#line 1053
    printk("\016%s:  info: attempting ioremap at 0x%llx len 0x%08x\n", (char *)(& cx->v4l2_dev.name),
           cx->base_addr, 67108864);
  } else {

  }
#line 1055
  cx->enc_mem = ioremap_nocache(cx->base_addr, 67108864UL);
#line 1057
  if ((unsigned long )cx->enc_mem == (unsigned long )((void *)0)) {
#line 1058
    printk("\v%s: ioremap failed. Can\'t get a window into CX23418 memory and register space\n",
           (char *)(& cx->v4l2_dev.name));
#line 1060
    printk("\v%s: Each capture card with a CX23418 needs 64 MB of vmalloc address space for the window\n",
           (char *)(& cx->v4l2_dev.name));
#line 1062
    printk("\v%s: Check the output of \'grep Vmalloc /proc/meminfo\'\n", (char *)(& cx->v4l2_dev.name));
#line 1063
    printk("\v%s: Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\n",
           (char *)(& cx->v4l2_dev.name));
#line 1065
    retval = -12;
#line 1066
    goto free_mem;
  } else {

  }
#line 1068
  cx->reg_mem = cx->enc_mem + 33554432UL;
#line 1069
  devtype = cx18_read_reg(cx, 13049896U);
#line 1070
  switch (devtype & 4278190080U) {
  case 4278190080U: 
#line 1072
  printk("\016%s: cx23418 revision %08x (A)\n", (char *)(& cx->v4l2_dev.name), devtype);
#line 1073
  goto ldv_52537;
  case 16777216U: 
#line 1075
  printk("\016%s: cx23418 revision %08x (B)\n", (char *)(& cx->v4l2_dev.name), devtype);
#line 1076
  goto ldv_52537;
  default: 
#line 1078
  printk("\016%s: cx23418 revision %08x (Unknown)\n", (char *)(& cx->v4l2_dev.name),
         devtype);
#line 1079
  goto ldv_52537;
  }
  ldv_52537: 
#line 1082
  cx18_init_power(cx, 1);
#line 1083
  cx18_init_memory(cx);
#line 1085
  cx->scb = (struct cx18_scb *)cx->enc_mem + 14417920U;
#line 1086
  cx18_init_scb(cx);
#line 1088
  cx18_gpio_init(cx);
#line 1091
  retval = cx18_av_probe(cx);
#line 1092
  if (retval != 0) {
#line 1093
    printk("\v%s: Could not register A/V decoder subdevice\n", (char *)(& cx->v4l2_dev.name));
#line 1094
    goto free_map;
  } else {

  }
#line 1098
  if (((unsigned int )(cx->card)->hw_all & 64U) != 0U) {
#line 1099
    tmp___1 = cx18_gpio_register(cx, 64U);
#line 1099
    if (tmp___1 != 0) {
#line 1100
      printk("\f%s: Could not register GPIO reset controllersubdevice; proceeding anyway.\n",
             (char *)(& cx->v4l2_dev.name));
    } else {
#line 1103
      cx->hw_flags = cx->hw_flags | 64U;
    }
  } else {

  }
#line 1107
  if ((cx18_debug & 2) != 0) {
#line 1107
    printk("\016%s:  info: activating i2c...\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1108
  retval = init_cx18_i2c(cx);
#line 1109
  if (retval != 0) {
#line 1110
    printk("\v%s: Could not initialize i2c\n", (char *)(& cx->v4l2_dev.name));
#line 1111
    goto free_map;
  } else {

  }
#line 1114
  if (((unsigned int )(cx->card)->hw_all & 2U) != 0U) {
#line 1117
    orig_card = cx->card;
#line 1118
    cx18_process_eeprom(cx);
#line 1120
    if ((unsigned long )cx->card != (unsigned long )orig_card) {
#line 1122
      cx18_gpio_init(cx);
#line 1123
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1123
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 1123
      goto ldv_52548;
      ldv_52547: ;
#line 1123
      if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                             u32  ))0)) {
#line 1123
        (*(((__sd->ops)->core)->reset))(__sd, 0U);
      } else {

      }
#line 1123
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1123
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
      ldv_52548: ;
#line 1123
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1125
        goto ldv_52547;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1127
  if ((unsigned long )(cx->card)->comment != (unsigned long )((char */* const  */)0)) {
#line 1128
    printk("\016%s: %s", (char *)(& cx->v4l2_dev.name), (cx->card)->comment);
  } else {

  }
#line 1129
  if ((unsigned int )(cx->card)->v4l2_capabilities == 0U) {
#line 1130
    retval = -19;
#line 1131
    goto free_i2c;
  } else {

  }
#line 1133
  cx18_init_memory(cx);
#line 1134
  cx18_init_scb(cx);
#line 1137
  retval = ldv_request_irq_33((cx->pci_dev)->irq, & cx18_irq_handler, 128UL, (char const   *)(& cx->v4l2_dev.name),
                              (void *)cx);
#line 1139
  if (retval != 0) {
#line 1140
    printk("\v%s: Failed to register irq %d\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1141
    goto free_i2c;
  } else {

  }
#line 1144
  if (cx->std == 0ULL) {
#line 1145
    cx->std = 4096ULL;
  } else {

  }
#line 1147
  if (cx->options.tuner == -1) {
#line 1148
    i = 0;
#line 1148
    goto ldv_52554;
    ldv_52553: ;
#line 1149
    if ((cx->std & (unsigned long long )(cx->card)->tuners[i].std) == 0ULL) {
#line 1150
      goto ldv_52551;
    } else {

    }
#line 1151
    cx->options.tuner = (cx->card)->tuners[i].tuner;
#line 1152
    goto ldv_52552;
    ldv_52551: 
#line 1148
    i = i + 1;
    ldv_52554: ;
#line 1148
    if (i <= 1) {
#line 1150
      goto ldv_52553;
    } else {

    }
    ldv_52552: ;
  } else {

  }
#line 1156
  if (cx->options.tuner == -1 && (unsigned long long )(cx->card)->tuners[0].std != 0ULL) {
#line 1157
    cx->std = (cx->card)->tuners[0].std;
#line 1158
    if ((cx->std & 255ULL) != 0ULL) {
#line 1159
      cx->std = 15ULL;
    } else
#line 1160
    if ((cx->std & 45056ULL) != 0ULL) {
#line 1161
      cx->std = 4096ULL;
    } else
#line 1162
    if ((cx->std & 16711680ULL) != 0ULL) {
#line 1163
      cx->std = 4194304ULL;
    } else {

    }
#line 1164
    cx->options.tuner = (cx->card)->tuners[0].tuner;
  } else {

  }
#line 1166
  if (cx->options.radio == -1) {
#line 1167
    cx->options.radio = (unsigned int )((unsigned char )(cx->card)->radio_input.audio_type) != 0U;
  } else {

  }
#line 1171
  cx18_init_struct2(cx);
#line 1173
  cx18_init_subdevs(cx);
#line 1175
  if ((cx->std & 63744ULL) != 0ULL) {
#line 1176
    cx->is_60hz = 1U;
  } else {
#line 1178
    cx->is_50hz = 1U;
  }
#line 1180
  cx2341x_handler_set_50hz(& cx->cxhdl, (unsigned int )cx->is_60hz == 0U);
#line 1182
  if (cx->options.radio > 0) {
#line 1183
    cx->v4l2_cap = cx->v4l2_cap | 262144U;
  } else {

  }
#line 1185
  if (cx->options.tuner >= 0) {
#line 1188
    setup.addr = 255U;
#line 1189
    setup.type = (unsigned int )cx->options.tuner;
#line 1190
    setup.mode_mask = 4U;
#line 1191
    if (cx->options.radio > 0) {
#line 1192
      setup.mode_mask = setup.mode_mask | 2U;
    } else {

    }
#line 1193
    setup.tuner_callback = setup.type == 71U ? & cx18_reset_tuner_gpio : (int (*)(void * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  int  ))0;
#line 1195
    __mptr___1 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1195
    __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff80UL;
#line 1195
    goto ldv_52562;
    ldv_52561: ;
#line 1195
    if ((unsigned long )(__sd___0->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->tuner)->s_type_addr != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct tuner_setup * ))0)) {
#line 1195
      (*(((__sd___0->ops)->tuner)->s_type_addr))(__sd___0, & setup);
    } else {

    }
#line 1195
    __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1195
    __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff80UL;
    ldv_52562: ;
#line 1195
    if ((unsigned long )(& __sd___0->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1197
      goto ldv_52561;
    } else {

    }

#line 1196
    if (setup.type == 71U) {
#line 1197
      ctrl.fname = (char *)"xc3028-v27.fw";
#line 1197
      ctrl.max_len = 64;
#line 1197
      ctrl.msleep = 0;
#line 1197
      ctrl.scode_table = 0U;
#line 1197
      ctrl.mts = (unsigned char)0;
#line 1197
      ctrl.input1 = (unsigned char)0;
#line 1197
      ctrl.vhfbw7 = (unsigned char)0;
#line 1197
      ctrl.uhfbw8 = (unsigned char)0;
#line 1197
      ctrl.disable_power_mgmt = (unsigned char)0;
#line 1197
      ctrl.read_not_reliable = (unsigned char)0;
#line 1197
      ctrl.demod = 0U;
#line 1197
      ctrl.type = (unsigned char)0;
#line 1201
      cfg.tuner = cx->options.tuner;
#line 1201
      cfg.priv = (void *)(& ctrl);
#line 1205
      __mptr___3 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1205
      __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff80UL;
#line 1205
      goto ldv_52572;
      ldv_52571: ;
#line 1205
      if ((unsigned long )(__sd___1->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___1->ops)->tuner)->s_config != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_priv_tun_config  const  * ))0)) {
#line 1205
        (*(((__sd___1->ops)->tuner)->s_config))(__sd___1, (struct v4l2_priv_tun_config  const  *)(& cfg));
      } else {

      }
#line 1205
      __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 1205
      __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff80UL;
      ldv_52572: ;
#line 1205
      if ((unsigned long )(& __sd___1->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1207
        goto ldv_52571;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1211
  cx->tuner_std = cx->std;
#line 1212
  if (cx->std == 16777215ULL) {
#line 1213
    cx->std = 4096ULL;
  } else {

  }
#line 1215
  retval = cx18_streams_setup(cx);
#line 1216
  if (retval != 0) {
#line 1217
    printk("\v%s: Error %d setting up streams\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1218
    goto free_irq;
  } else {

  }
#line 1220
  retval = cx18_streams_register(cx);
#line 1221
  if (retval != 0) {
#line 1222
    printk("\v%s: Error %d registering devices\n", (char *)(& cx->v4l2_dev.name),
           retval);
#line 1223
    goto free_streams;
  } else {

  }
#line 1226
  printk("\016%s: Initialized card: %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 1229
  request_modules(cx);
#line 1230
  return (0);
  free_streams: 
#line 1233
  cx18_streams_cleanup(cx, 1);
  free_irq: 
#line 1235
  ldv_free_irq_34((cx->pci_dev)->irq, (void *)cx);
  free_i2c: 
#line 1237
  exit_cx18_i2c(cx);
  free_map: 
#line 1239
  cx18_iounmap(cx);
  free_mem: 
#line 1241
  __release_region(& iomem_resource, cx->base_addr, 67108864ULL);
  free_workqueues: 
#line 1243
  destroy_workqueue(cx->in_work_queue);
  err: ;
#line 1245
  if (retval == 0) {
#line 1246
    retval = -19;
  } else {

  }
#line 1247
  printk("\v%s: Error %d on initialization\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1249
  v4l2_device_unregister(& cx->v4l2_dev);
#line 1250
  kfree((void const   *)cx);
#line 1251
  return (retval);
}
}
#line 1254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int cx18_init_on_first_open(struct cx18 *cx ) 
{ 
  int video_input ;
  int fw_retry_count ;
  struct v4l2_frequency vf ;
  struct cx18_open_id fh ;
  v4l2_std_id std ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1257
  fw_retry_count = 3;
#line 1262
  fh.cx = cx;
#line 1264
  tmp = constant_test_bit(22L, (unsigned long const volatile   *)(& cx->i_flags));
#line 1264
  if (tmp != 0) {
#line 1265
    return (-6);
  } else {

  }
#line 1267
  tmp___0 = test_and_set_bit(21L, (unsigned long volatile   *)(& cx->i_flags));
#line 1267
  if (tmp___0 != 0) {
#line 1268
    return (0);
  } else {

  }
#line 1270
  goto ldv_52586;
  ldv_52585: 
#line 1272
  tmp___1 = cx18_firmware_init(cx);
#line 1272
  if (tmp___1 == 0) {
#line 1273
    goto ldv_52584;
  } else {

  }
#line 1274
  if (fw_retry_count > 1) {
#line 1275
    printk("\f%s: Retry loading firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
  ldv_52586: 
#line 1270
  fw_retry_count = fw_retry_count - 1;
#line 1270
  if (fw_retry_count > 0) {
#line 1272
    goto ldv_52585;
  } else {

  }
  ldv_52584: ;
#line 1278
  if (fw_retry_count == 0) {
#line 1279
    set_bit(22L, (unsigned long volatile   *)(& cx->i_flags));
#line 1280
    return (-6);
  } else {

  }
#line 1282
  set_bit(0L, (unsigned long volatile   *)(& cx->i_flags));
#line 1296
  cx18_vapi(cx, 268435457U, 2, 185, 0);
#line 1297
  cx18_vapi(cx, 268435461U, 0);
#line 1298
  cx18_vapi(cx, 268435458U, 1, 0);
#line 1300
  fw_retry_count = 3;
#line 1301
  goto ldv_52589;
  ldv_52588: 
#line 1303
  tmp___2 = cx18_firmware_init(cx);
#line 1303
  if (tmp___2 == 0) {
#line 1304
    goto ldv_52587;
  } else {

  }
#line 1305
  if (fw_retry_count > 1) {
#line 1306
    printk("\f%s: Retry loading firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
  ldv_52589: 
#line 1301
  fw_retry_count = fw_retry_count - 1;
#line 1301
  if (fw_retry_count > 0) {
#line 1303
    goto ldv_52588;
  } else {

  }
  ldv_52587: ;
#line 1309
  if (fw_retry_count == 0) {
#line 1310
    set_bit(22L, (unsigned long volatile   *)(& cx->i_flags));
#line 1311
    return (-6);
  } else {

  }
#line 1323
  cx18_vapi(cx, 268435457U, 2, 185, 0);
#line 1324
  cx18_vapi(cx, 268435461U, 0);
#line 1325
  cx18_vapi(cx, 268435458U, 1, 0);
#line 1328
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 1328
    if ((unsigned long )((cx->sd_av)->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->core)->load_fw != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1328
      (*((((cx->sd_av)->ops)->core)->load_fw))(cx->sd_av);
    } else {

    }
  } else {

  }
#line 1330
  vf.tuner = 0U;
#line 1331
  vf.type = 2U;
#line 1332
  vf.frequency = 6400U;
#line 1336
  if (cx->std == 8192ULL) {
#line 1337
    vf.frequency = 1460U;
  } else
#line 1338
  if ((cx->std & 4096ULL) != 0ULL) {
#line 1339
    vf.frequency = 1076U;
  } else {

  }
#line 1341
  video_input = (int )cx->active_input;
#line 1342
  cx->active_input = cx->active_input + 1U;
#line 1343
  cx18_s_input((struct file *)0, (void *)(& fh), (unsigned int )video_input);
#line 1347
  cx->std = cx->std + 1ULL;
#line 1348
  std = cx->tuner_std != 16777215ULL ? cx->tuner_std : 4096ULL;
#line 1349
  cx18_s_std((struct file *)0, (void *)(& fh), std);
#line 1350
  cx18_s_frequency((struct file *)0, (void *)(& fh), (struct v4l2_frequency  const  *)(& vf));
#line 1351
  return (0);
}
}
#line 1354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_cancel_in_work_orders(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 1357
  i = 0;
#line 1357
  goto ldv_52595;
  ldv_52594: 
#line 1358
  cancel_work_sync(& cx->in_work_order[i].work);
#line 1357
  i = i + 1;
  ldv_52595: ;
#line 1357
  if (i <= 69) {
#line 1359
    goto ldv_52594;
  } else {

  }

#line 1364
  return;
}
}
#line 1361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_cancel_out_work_orders(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 1364
  i = 0;
#line 1364
  goto ldv_52602;
  ldv_52601: ;
#line 1365
  if ((unsigned long )(& cx->streams[i].video_dev) != (unsigned long )((struct video_device **)0)) {
#line 1366
    cancel_work_sync(& cx->streams[i].out_work_order);
  } else {

  }
#line 1364
  i = i + 1;
  ldv_52602: ;
#line 1364
  if (i <= 6) {
#line 1366
    goto ldv_52601;
  } else {

  }

#line 1371
  return;
}
}
#line 1369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void cx18_remove(struct pci_dev *pci_dev ) 
{ 
  struct v4l2_device *v4l2_dev ;
  void *tmp ;
  struct cx18 *cx ;
  struct cx18 *tmp___0 ;
  int i ;
  int tmp___1 ;

  {
#line 1371
  tmp = pci_get_drvdata(pci_dev);
#line 1371
  v4l2_dev = (struct v4l2_device *)tmp;
#line 1372
  tmp___0 = to_cx18(v4l2_dev);
#line 1372
  cx = tmp___0;
#line 1375
  if ((cx18_debug & 2) != 0) {
#line 1375
    printk("\016%s:  info: Removing Card\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1377
  flush_request_modules(cx);
#line 1380
  if ((cx18_debug & 2) != 0) {
#line 1380
    printk("\016%s:  info: Stopping all streams\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1381
  tmp___1 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1381
  if (tmp___1 > 0) {
#line 1382
    cx18_stop_all_captures(cx);
  } else {

  }
#line 1385
  cx18_sw1_irq_disable(cx, 196608U);
#line 1388
  cx18_cancel_in_work_orders(cx);
#line 1389
  cx18_cancel_out_work_orders(cx);
#line 1392
  cx18_sw2_irq_disable(cx, 136U);
#line 1394
  cx18_halt_firmware(cx);
#line 1396
  destroy_workqueue(cx->in_work_queue);
#line 1398
  cx18_streams_cleanup(cx, 1);
#line 1400
  exit_cx18_i2c(cx);
#line 1402
  ldv_free_irq_35((cx->pci_dev)->irq, (void *)cx);
#line 1404
  cx18_iounmap(cx);
#line 1406
  __release_region(& iomem_resource, cx->base_addr, 67108864ULL);
#line 1408
  pci_disable_device(cx->pci_dev);
#line 1410
  if ((unsigned long )cx->vbi.sliced_mpeg_data[0] != (unsigned long )((u8 *)0U)) {
#line 1411
    i = 0;
#line 1411
    goto ldv_52611;
    ldv_52610: 
#line 1412
    kfree((void const   *)cx->vbi.sliced_mpeg_data[i]);
#line 1411
    i = i + 1;
    ldv_52611: ;
#line 1411
    if (i <= 31) {
#line 1413
      goto ldv_52610;
    } else {

    }

  } else {

  }
#line 1414
  v4l2_ctrl_handler_free(& cx->av_state.hdl);
#line 1416
  printk("\016%s: Removed %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 1418
  v4l2_device_unregister(v4l2_dev);
#line 1419
  kfree((void const   *)cx);
#line 1420
  return;
}
}
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static struct pci_driver cx18_pci_driver  = 
#line 1424
     {{0, 0}, "cx18", (struct pci_device_id  const  *)(& cx18_pci_tbl), & cx18_probe,
    & cx18_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                         0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0, {0, {0,
                                                                               0},
                                                                           0, 0, 0UL}}}},
                                                    {0, 0}}};
#line 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static int module_start(void) 
{ 
  int tmp ;

  {
#line 1433
  printk("\016cx18:  Start initialization, version %s\n", (char *)"1.5.1");
#line 1437
  if (cx18_first_minor < 0 || cx18_first_minor > 31) {
#line 1438
    printk("\vcx18:  Exiting, cx18_first_minor must be between 0 and %d\n", 31);
#line 1440
    return (-1);
  } else {

  }
#line 1443
  if (cx18_debug < 0 || cx18_debug > 511) {
#line 1444
    cx18_debug = 0;
#line 1445
    printk("\016cx18:   Debug value must be >= 0 and <= 511!\n");
  } else {

  }
#line 1448
  tmp = __pci_register_driver(& cx18_pci_driver, & __this_module, "cx18");
#line 1448
  if (tmp != 0) {
#line 1449
    printk("\vcx18:   Error detecting PCI card\n");
#line 1450
    return (-19);
  } else {

  }
#line 1452
  printk("\016cx18:  End initialization\n");
#line 1453
  return (0);
}
}
#line 1456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
static void module_cleanup(void) 
{ 


  {
#line 1458
  pci_unregister_driver(& cx18_pci_driver);
#line 1459
  return;
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_retval_0  ;
#line 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_retval_1  ;
#line 1467
extern void ldv_initialize(void) ;
#line 1468
extern void ldv_check_final_state(void) ;
#line 1471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 1472
  if ((unsigned long )handler == (unsigned long )(& cx18_irq_handler)) {
#line 1473
    return (1);
  } else {

  }
#line 1475
  return (0);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 1480
  tmp = __VERIFIER_nondet_int();
#line 1480
  switch (tmp) {
  case 0: 
#line 1482
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 1484
  goto ldv_52646;
  case 1: 
#line 1486
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 1488
  goto ldv_52646;
  case 2: 
#line 1490
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 1492
  goto ldv_52646;
  case 3: 
#line 1494
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 1496
  goto ldv_52646;
  default: 
#line 1497
  ldv_stop();
  }
  ldv_52646: ;
#line 1499
  return;
}
}
#line 1503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 1504
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 1505
    ldv_irq_1_0 = 0;
#line 1506
    return;
  } else {

  }
#line 1508
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 1509
    ldv_irq_1_1 = 0;
#line 1510
    return;
  } else {

  }
#line 1512
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 1513
    ldv_irq_1_2 = 0;
#line 1514
    return;
  } else {

  }
#line 1516
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 1517
    ldv_irq_1_3 = 0;
#line 1518
    return;
  } else {

  }
#line 1520
  return;
}
}
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;

  {
#line 1526
  if (state != 0) {
#line 1527
    tmp = __VERIFIER_nondet_int();
#line 1527
    switch (tmp) {
    case 0: ;
#line 1529
    if (state == 1) {
#line 1530
      LDV_IN_INTERRUPT = 2;
#line 1531
      irq_retval = cx18_irq_handler(line, data);
#line 1532
      LDV_IN_INTERRUPT = 1;
#line 1533
      return (state);
    } else {

    }
#line 1536
    goto ldv_52662;
    default: 
#line 1537
    ldv_stop();
    }
    ldv_52662: ;
  } else {

  }
#line 1540
  return (state);
}
}
#line 1544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 1545
  if (ldv_irq_1_0 == 0) {
#line 1546
    ldv_irq_line_1_0 = line;
#line 1547
    ldv_irq_data_1_0 = data;
#line 1548
    ldv_irq_1_0 = 1;
#line 1549
    return;
  } else {

  }
#line 1551
  if (ldv_irq_1_1 == 0) {
#line 1552
    ldv_irq_line_1_1 = line;
#line 1553
    ldv_irq_data_1_1 = data;
#line 1554
    ldv_irq_1_1 = 1;
#line 1555
    return;
  } else {

  }
#line 1557
  if (ldv_irq_1_2 == 0) {
#line 1558
    ldv_irq_line_1_2 = line;
#line 1559
    ldv_irq_data_1_2 = data;
#line 1560
    ldv_irq_1_2 = 1;
#line 1561
    return;
  } else {

  }
#line 1563
  if (ldv_irq_1_3 == 0) {
#line 1564
    ldv_irq_line_1_3 = line;
#line 1565
    ldv_irq_data_1_3 = data;
#line 1566
    ldv_irq_1_3 = 1;
#line 1567
    return;
  } else {

  }
#line 1569
  return;
}
}
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_initialize_pci_driver_21(void) 
{ 
  void *tmp ;

  {
#line 1575
  tmp = ldv_zalloc(2976UL);
#line 1575
  cx18_pci_driver_group0 = (struct pci_dev *)tmp;
#line 1576
  return;
}
}
#line 1579
void ldv_main_exported_12(void) ;
#line 1580
void ldv_main_exported_8(void) ;
#line 1581
void ldv_main_exported_6(void) ;
#line 1582
void ldv_main_exported_7(void) ;
#line 1583
void ldv_main_exported_10(void) ;
#line 1584
void ldv_main_exported_9(void) ;
#line 1585
void ldv_main_exported_5(void) ;
#line 1586
void ldv_main_exported_3(void) ;
#line 1589
void ldv_main_exported_20(void) ;
#line 1590
void ldv_main_exported_4(void) ;
#line 1591
void ldv_main_exported_13(void) ;
#line 1592
void ldv_main_exported_14(void) ;
#line 1593
void ldv_main_exported_18(void) ;
#line 1594
void ldv_main_exported_19(void) ;
#line 1595
void ldv_main_exported_16(void) ;
#line 1596
void ldv_main_exported_17(void) ;
#line 1597
void ldv_main_exported_15(void) ;
#line 1598
void ldv_main_exported_11(void) ;
#line 1602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int main(void) 
{ 
  struct pci_device_id *ldvarg4 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1605
  tmp = ldv_zalloc(32UL);
#line 1605
  ldvarg4 = (struct pci_device_id *)tmp;
#line 1603
  ldv_initialize();
#line 1607
  ldv_state_variable_11 = 0;
#line 1608
  ldv_state_variable_21 = 0;
#line 1609
  ldv_state_variable_7 = 0;
#line 1610
  ldv_state_variable_17 = 0;
#line 1612
  ldv_state_variable_2 = 1;
#line 1614
  ldv_state_variable_1 = 1;
#line 1615
  ldv_state_variable_18 = 0;
#line 1616
  ref_cnt = 0;
#line 1617
  ldv_state_variable_0 = 1;
#line 1618
  ldv_state_variable_16 = 0;
#line 1619
  ldv_state_variable_13 = 0;
#line 1620
  ldv_state_variable_6 = 0;
#line 1621
  ldv_state_variable_3 = 0;
#line 1622
  ldv_state_variable_9 = 0;
#line 1623
  ldv_state_variable_12 = 0;
#line 1624
  ldv_state_variable_20 = 0;
#line 1625
  ldv_state_variable_14 = 0;
#line 1626
  ldv_state_variable_15 = 0;
#line 1627
  ldv_state_variable_8 = 0;
#line 1628
  ldv_state_variable_4 = 0;
#line 1629
  ldv_state_variable_19 = 0;
#line 1630
  ldv_state_variable_10 = 0;
#line 1631
  ldv_state_variable_5 = 0;
  ldv_52750: 
#line 1633
  tmp___0 = __VERIFIER_nondet_int();
#line 1633
  switch (tmp___0) {
  case 0: ;
#line 1637
  if (ldv_state_variable_11 != 0) {
#line 1638
    ldv_main_exported_11();
  } else {

  }
#line 1641
  goto ldv_52718;
  case 1: ;
#line 1645
  if (ldv_state_variable_21 != 0) {
#line 1646
    tmp___1 = __VERIFIER_nondet_int();
#line 1646
    switch (tmp___1) {
    case 0: ;
#line 1649
    if (ldv_state_variable_21 == 1) {
#line 1651
      ldv_retval_0 = cx18_probe(cx18_pci_driver_group0, (struct pci_device_id  const  *)ldvarg4);
#line 1653
      if (ldv_retval_0 == 0) {
#line 1654
        ldv_state_variable_21 = 2;
#line 1655
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1659
    goto ldv_52721;
    case 1: ;
#line 1662
    if (ldv_state_variable_21 == 2) {
#line 1664
      cx18_remove(cx18_pci_driver_group0);
#line 1666
      ldv_state_variable_21 = 1;
#line 1667
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1670
    goto ldv_52721;
    default: 
#line 1671
    ldv_stop();
    }
    ldv_52721: ;
  } else {

  }
#line 1675
  goto ldv_52718;
  case 2: ;
#line 1679
  if (ldv_state_variable_7 != 0) {
#line 1680
    ldv_main_exported_7();
  } else {

  }
#line 1683
  goto ldv_52718;
  case 3: ;
#line 1687
  if (ldv_state_variable_17 != 0) {
#line 1688
    ldv_main_exported_17();
  } else {

  }
#line 1691
  goto ldv_52718;
  case 4: ;
#line 1698
  goto ldv_52718;
  case 5: ;
#line 1702
  if (ldv_state_variable_1 != 0) {
#line 1703
    choose_interrupt_1();
  } else {

  }
#line 1706
  goto ldv_52718;
  case 6: ;
#line 1710
  if (ldv_state_variable_18 != 0) {
#line 1711
    ldv_main_exported_18();
  } else {

  }
#line 1714
  goto ldv_52718;
  case 7: ;
#line 1718
  if (ldv_state_variable_0 != 0) {
#line 1719
    tmp___2 = __VERIFIER_nondet_int();
#line 1719
    switch (tmp___2) {
    case 0: ;
#line 1722
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1724
      module_cleanup();
#line 1725
      ldv_state_variable_0 = 2;
#line 1726
      goto ldv_final;
    } else {

    }
#line 1729
    goto ldv_52732;
    case 1: ;
#line 1732
    if (ldv_state_variable_0 == 1) {
#line 1734
      ldv_retval_1 = module_start();
#line 1736
      if (ldv_retval_1 == 0) {
#line 1737
        ldv_state_variable_0 = 3;
#line 1738
        ldv_state_variable_5 = 1;
#line 1739
        ldv_initialize_v4l2_subdev_vbi_ops_5();
#line 1740
        ldv_state_variable_19 = 1;
#line 1741
        ldv_state_variable_10 = 1;
#line 1742
        ldv_state_variable_4 = 1;
#line 1743
        ldv_state_variable_8 = 1;
#line 1744
        ldv_initialize_v4l2_subdev_tuner_ops_8();
#line 1745
        ldv_state_variable_15 = 1;
#line 1746
        ldv_initialize_v4l2_subdev_core_ops_15();
#line 1747
        ldv_state_variable_14 = 1;
#line 1748
        ldv_initialize_v4l2_file_operations_14();
#line 1749
        ldv_state_variable_20 = 1;
#line 1750
        ldv_state_variable_12 = 1;
#line 1751
        ldv_initialize_v4l2_ioctl_ops_12();
#line 1752
        ldv_state_variable_9 = 1;
#line 1753
        ldv_initialize_v4l2_subdev_core_ops_9();
#line 1754
        ldv_state_variable_3 = 1;
#line 1755
        ldv_state_variable_6 = 1;
#line 1756
        ldv_initialize_v4l2_subdev_video_ops_6();
#line 1757
        ldv_state_variable_13 = 1;
#line 1758
        ldv_videobuf_queue_ops_13();
#line 1759
        ldv_state_variable_16 = 1;
#line 1760
        ldv_state_variable_18 = 1;
#line 1761
        ldv_state_variable_17 = 1;
#line 1762
        ldv_state_variable_7 = 1;
#line 1763
        ldv_initialize_v4l2_subdev_audio_ops_7();
#line 1764
        ldv_state_variable_21 = 1;
#line 1765
        ldv_initialize_pci_driver_21();
#line 1766
        ldv_state_variable_11 = 1;
#line 1767
        ldv_initialize_cx2341x_handler_ops_11();
      } else {

      }
#line 1769
      if (ldv_retval_1 != 0) {
#line 1770
        ldv_state_variable_0 = 2;
#line 1771
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1775
    goto ldv_52732;
    default: 
#line 1776
    ldv_stop();
    }
    ldv_52732: ;
  } else {

  }
#line 1780
  goto ldv_52718;
  case 8: ;
#line 1784
  if (ldv_state_variable_16 != 0) {
#line 1785
    ldv_main_exported_16();
  } else {

  }
#line 1788
  goto ldv_52718;
  case 9: ;
#line 1792
  if (ldv_state_variable_13 != 0) {
#line 1793
    ldv_main_exported_13();
  } else {

  }
#line 1796
  goto ldv_52718;
  case 10: ;
#line 1800
  if (ldv_state_variable_6 != 0) {
#line 1801
    ldv_main_exported_6();
  } else {

  }
#line 1804
  goto ldv_52718;
  case 11: ;
#line 1808
  if (ldv_state_variable_3 != 0) {
#line 1809
    ldv_main_exported_3();
  } else {

  }
#line 1812
  goto ldv_52718;
  case 12: ;
#line 1816
  if (ldv_state_variable_9 != 0) {
#line 1817
    ldv_main_exported_9();
  } else {

  }
#line 1820
  goto ldv_52718;
  case 13: ;
#line 1824
  if (ldv_state_variable_12 != 0) {
#line 1825
    ldv_main_exported_12();
  } else {

  }
#line 1828
  goto ldv_52718;
  case 14: ;
#line 1832
  if (ldv_state_variable_20 != 0) {
#line 1833
    ldv_main_exported_20();
  } else {

  }
#line 1836
  goto ldv_52718;
  case 15: ;
#line 1840
  if (ldv_state_variable_14 != 0) {
#line 1841
    ldv_main_exported_14();
  } else {

  }
#line 1844
  goto ldv_52718;
  case 16: ;
#line 1848
  if (ldv_state_variable_15 != 0) {
#line 1849
    ldv_main_exported_15();
  } else {

  }
#line 1852
  goto ldv_52718;
  case 17: ;
#line 1856
  if (ldv_state_variable_8 != 0) {
#line 1857
    ldv_main_exported_8();
  } else {

  }
#line 1860
  goto ldv_52718;
  case 18: ;
#line 1864
  if (ldv_state_variable_4 != 0) {
#line 1865
    ldv_main_exported_4();
  } else {

  }
#line 1868
  goto ldv_52718;
  case 19: ;
#line 1872
  if (ldv_state_variable_19 != 0) {
#line 1873
    ldv_main_exported_19();
  } else {

  }
#line 1876
  goto ldv_52718;
  case 20: ;
#line 1880
  if (ldv_state_variable_10 != 0) {
#line 1881
    ldv_main_exported_10();
  } else {

  }
#line 1884
  goto ldv_52718;
  case 21: ;
#line 1888
  if (ldv_state_variable_5 != 0) {
#line 1889
    ldv_main_exported_5();
  } else {

  }
#line 1892
  goto ldv_52718;
  default: 
#line 1893
  ldv_stop();
  }
  ldv_52718: ;
#line 1895
  goto ldv_52750;
  ldv_final: 
#line 1897
  ldv_check_final_state();
#line 1898
  return 0;
}
}
#line 2028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2031
  ldv_check_alloc_flags(flags);
#line 2033
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2034
  return ((void *)0);
}
}
#line 2036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 2039
  ldv_check_alloc_flags(flags);
#line 2040
  return ((void *)0);
}
}
#line 2072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2075
  ldv_check_alloc_flags(flags);
#line 2077
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2077
  return (tmp);
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2091
  ldv_check_alloc_flags(flags);
#line 2093
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2093
  return (tmp);
}
}
#line 2104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2107
  ldv_check_alloc_flags(flags);
#line 2109
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2109
  return (tmp);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2115
  ldv_check_alloc_flags(flags);
#line 2117
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2117
  return (tmp);
}
}
#line 2120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2123
  ldv_check_alloc_flags(flags);
#line 2125
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2125
  return (tmp);
}
}
#line 2128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2131
  ldv_check_alloc_flags(flags);
#line 2133
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2133
  return (tmp);
}
}
#line 2136 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2139
  ldv_check_alloc_flags(flags);
#line 2141
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2141
  return (tmp);
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2147
  ldv_check_alloc_flags(flags);
#line 2149
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2149
  return (tmp);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2155
  ldv_check_alloc_flags(flags);
#line 2157
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2157
  return (tmp);
}
}
#line 2160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
__inline static int ldv_request_irq_33(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2164
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2164
  ldv_func_res = tmp;
#line 2166
  tmp___0 = reg_check_1(handler);
#line 2166
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2167
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 2170
  return (ldv_func_res);
}
}
#line 2173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_free_irq_34(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2176
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2178
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 2179
  return;
}
}
#line 2181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_free_irq_35(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2184
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2186
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 2187
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_64(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_72(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_74(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_70(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_79(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_75(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_76(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_77(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-cards.h"
int cx18_get_input(struct cx18 *cx , u16 index , struct v4l2_input *input ) ;
#line 156
int cx18_get_audio_input(struct cx18 *cx , u16 index , struct v4l2_audio *audio ) ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_tuner_i2c cx18_i2c_std  =    {{65534U}, {67U, 65534U}, {97U, 96U, 65534U}};
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_tuner_i2c cx18_i2c_nxp  =    {{65534U}, {66U, 67U, 65534U}, {97U, 96U, 65534U}};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_hvr1600_esmt  = 
#line 157
     {0, (char *)"Hauppauge HVR-1600", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    16973905U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {12289U, 12289U}, {12289U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_std, {3U, 780U, 1143082626U, 8U, 0U, 0U}, 0};
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_hvr1600_s5h1411  = 
#line 204
     {9, (char *)"Hauppauge HVR-1600", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    16973905U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {14337U, 14337U}, {14337U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_nxp, {3U, 780U, 1143082626U, 8U, 0U, 0U}, 0};
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_hvr1600_samsung  = 
#line 251
     {1, (char *)"Hauppauge HVR-1600 (Preproduction)", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    16973905U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {12289U, 12289U}, {12289U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_std, {3U, 780U, 589499251U, 8U, 0U, 2U}, 0};
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_h900[2U]  = {      {23418U, 6235U, 57600U}, 
        {0U, 0U, 0U}};
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_h900  = 
#line 307
     {2, (char *)"Compro VideoMate H900", (char *)"Analog TV capture supported\n", 16973905U,
    16U, 0U, 81U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U, 5U, 0U}, {2U,
                                                                                 0U,
                                                                                 0U}},
    {1U, 0U, 0U}, 15U, {0U, 0U}, {0U, 0U, 0, 0, 0U}, {0U, 0U, 0U, 0U}, {{16777215ULL,
                                                                         71}}, & cx18_i2c_std,
    {327683U, 1875U, 607325828U, 31U, 0U, 0U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_h900)};
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_mpc718[2U]  = {      {23418U, 4779U, 1816U}, 
        {0U, 0U, 0U}};
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_mpc718  = 
#line 354
     {3, (char *)"Yuan MPC718 MiniPCI DVB-T/Analog", (char *)"Experimenters needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    16973905U, 16U, 32U, 123U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U,
                                                                              2U,
                                                                              2160U},
                                {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                             1U}},
    {1U, 5U, 2U}, 0U, {3U, 1U}, {0U, 0U, 0, 0, 0U}, {3U, 1U, 3U, 1U}, {{16777215ULL,
                                                                        71}}, & cx18_i2c_std,
    {771U, 957U, 909248870U, 31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_mpc718)};
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_gotview_dvd3[2U]  = {      {23418U, 22612U, 13123U}, 
        {0U, 0U, 0U}};
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_gotview_dvd3  = 
#line 414
     {8, (char *)"GoTView PCI DVD3 Hybrid", (char *)"Experimenters needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    16973905U, 16U, 32U, 123U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U,
                                                                              2U,
                                                                              2160U},
                                {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                             1U}},
    {1U, 5U, 2U}, 0U, {3U, 1U}, {0U, 0U, 0, 0, 0U}, {3U, 1U, 2U, 1U}, {{16777215ULL,
                                                                        71}}, & cx18_i2c_std,
    {771U, 957U, 909248870U, 31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_gotview_dvd3)};
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_cnxt_raptor_pal[2U]  = {      {23418U, 5361U, 9U}, 
        {0U, 0U, 0U}};
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_cnxt_raptor_pal  = 
#line 474
     {4, (char *)"Conexant Raptor PAL/SECAM", (char *)"Analog TV capture supported\n",
    16973905U, 16U, 32U, 49U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U, 2U,
                                                                             2160U},
                               {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                            1U}},
    {1U, 0U, 2U}, (unsigned char)0, {61442U, 4098U}, {0U, 0U, 0, 0, 0U}, {61442U,
                                                                          4098U, 8192U,
                                                                          16386U},
    {{16711935ULL, 38}}, & cx18_i2c_std, {328454U, 1875U, 857868627U, 9U, 0U, 0U},
    (struct cx18_card_pci_info  const  *)(& cx18_pci_cnxt_raptor_pal)};
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_toshiba_qosmio_dvbt[2U]  = {      {23418U, 4473U, 272U}, 
        {0U, 0U, 0U}};
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_toshiba_qosmio_dvbt  = 
#line 528
     {5, (char *)"Toshiba Qosmio DVB-T/Analog", (char *)"Experimenters and photos needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    16973905U, 16U, 0U, 81U, {{1U, 0U, 6U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U,
                                                                              5U,
                                                                              0U},
                                                                             {2U,
                                                                              0U,
                                                                              1U}},
    {(unsigned char)0, 0U, (unsigned short)0}, 15U, {0U, 0U}, {0U, 0U, 0, 0, 0U},
    {0U, 0U, 0U, 0U}, {{16777215ULL, 71}}, & cx18_i2c_std, {514U, 955U, 858917475U,
                                                            10U, 0U, 66U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_toshiba_qosmio_dvbt)};
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_leadtek_pvr2100[2U]  = {      {23418U, 4221U, 28455U}, 
        {0U, 0U, 0U}};
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_leadtek_pvr2100  = 
#line 571
     {6, (char *)"Leadtek WinFast PVR2100", (char *)"Experimenters and photos needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    16973905U, 16U, 32U, 113U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 7U}, {6U,
                                                                              1U,
                                                                              8785920U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 5U, 2U}, 1U, {7U, 6U}, {0U, 0U, 0, 0, 0U},
    {7U, 6U, 2U, 2U}, {{16777215ULL, 71}}, & cx18_i2c_std, {771U, 955U, 606211715U,
                                                            31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_leadtek_pvr2100)};
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card_pci_info  const  cx18_pci_leadtek_dvr3100h[2U]  = {      {23418U, 4221U, 26256U}, 
        {0U, 0U, 0U}};
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  cx18_card_leadtek_dvr3100h  = 
#line 624
     {7, (char *)"Leadtek WinFast DVR3100 H", (char *)"Simultaneous DVB-T and Analog capture supported,\n\texcept when capturing Analog from the antenna input.\n",
    16973905U, 16U, 32U, 121U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 7U}, {6U,
                                                                              1U,
                                                                              8785920U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 5U, 2U}, 1U, {7U, 6U}, {0U, 0U, 0, 0, 0U},
    {7U, 6U, 2U, 2U}, {{16777215ULL, 71}}, & cx18_i2c_std, {771U, 955U, 606211715U,
                                                            31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_leadtek_dvr3100h)};
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
static struct cx18_card  const  *cx18_card_list[10U]  = 
#line 670
  {      & cx18_card_hvr1600_esmt,      & cx18_card_hvr1600_samsung,      & cx18_card_h900,      & cx18_card_mpc718, 
        & cx18_card_cnxt_raptor_pal,      & cx18_card_toshiba_qosmio_dvbt,      & cx18_card_leadtek_pvr2100,      & cx18_card_leadtek_dvr3100h, 
        & cx18_card_gotview_dvd3,      & cx18_card_hvr1600_s5h1411};
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct cx18_card  const  *cx18_get_card(u16 index ) 
{ 


  {
#line 685
  if ((unsigned int )index > 9U) {
#line 686
    return ((struct cx18_card  const  *)0);
  } else {

  }
#line 687
  return (cx18_card_list[(int )index]);
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int cx18_get_input(struct cx18 *cx , u16 index , struct v4l2_input *input ) 
{ 
  struct cx18_card_video_input  const  *card_input ;
  char const   *input_strs[6U] ;

  {
#line 692
  card_input = (struct cx18_card_video_input  const  *)(& (cx->card)->video_inputs) + (unsigned long )index;
#line 694
  input_strs[0] = "Tuner 1";
#line 694
  input_strs[1] = "S-Video 1";
#line 694
  input_strs[2] = "S-Video 2";
#line 694
  input_strs[3] = "Composite 1";
#line 694
  input_strs[4] = "Composite 2";
#line 694
  input_strs[5] = "Component 1";
#line 703
  if ((int )((unsigned short )cx->nof_inputs) <= (int )index) {
#line 704
    return (-22);
  } else {

  }
#line 705
  input->index = (__u32 )index;
#line 706
  strlcpy((char *)(& input->name), input_strs[(int )card_input->video_type + -1],
          32UL);
#line 708
  input->type = (unsigned int )((unsigned char )card_input->video_type) == 1U ? 1U : 2U;
#line 710
  input->audioset = (__u32 )((1 << (int )cx->nof_audio_inputs) + -1);
#line 711
  input->std = input->type == 1U ? cx->tuner_std : 16777215ULL;
#line 713
  return (0);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int cx18_get_audio_input(struct cx18 *cx , u16 index , struct v4l2_audio *audio ) 
{ 
  struct cx18_card_audio_input  const  *aud_input ;
  char const   *input_strs[3U] ;

  {
#line 718
  aud_input = (struct cx18_card_audio_input  const  *)(& (cx->card)->audio_inputs) + (unsigned long )index;
#line 720
  input_strs[0] = "Tuner 1";
#line 720
  input_strs[1] = "Line In 1";
#line 720
  input_strs[2] = "Line In 2";
#line 726
  memset((void *)audio, 0, 52UL);
#line 727
  if ((int )((unsigned short )cx->nof_audio_inputs) <= (int )index) {
#line 728
    return (-22);
  } else {

  }
#line 729
  strlcpy((char *)(& audio->name), input_strs[(int )aud_input->audio_type + -1], 32UL);
#line 731
  audio->index = (__u32 )index;
#line 732
  audio->capability = 1U;
#line 733
  return (0);
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void *ldv_kmem_cache_alloc_64(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 866
  ldv_check_alloc_flags(flags);
#line 868
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 869
  return ((void *)0);
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int ldv_pskb_expand_head_70(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 910
  ldv_check_alloc_flags(flags);
#line 912
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 912
  return (tmp);
}
}
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv_skb_clone_72(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 926
  ldv_check_alloc_flags(flags);
#line 928
  tmp = skb_clone(ldv_func_arg1, flags);
#line 928
  return (tmp);
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv_skb_copy_74(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 942
  ldv_check_alloc_flags(flags);
#line 944
  tmp = skb_copy(ldv_func_arg1, flags);
#line 944
  return (tmp);
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_75(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 950
  ldv_check_alloc_flags(flags);
#line 952
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 952
  return (tmp);
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_76(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 958
  ldv_check_alloc_flags(flags);
#line 960
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 960
  return (tmp);
}
}
#line 963 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_77(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 966
  ldv_check_alloc_flags(flags);
#line 968
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 968
  return (tmp);
}
}
#line 971 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 974
  ldv_check_alloc_flags(flags);
#line 976
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 976
  return (tmp);
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int ldv_pskb_expand_head_79(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 982
  ldv_check_alloc_flags(flags);
#line 984
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 984
  return (tmp);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 990
  ldv_check_alloc_flags(flags);
#line 992
  tmp = skb_clone(ldv_func_arg1, flags);
#line 992
  return (tmp);
}
}
#line 2 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 388 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 61 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 301 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_91(spinlock_t *lock ) 
{ 


  {
#line 303
  _raw_spin_lock(& lock->ldv_6347.rlock);
#line 304
  return;
}
}
#line 301
__inline static void spin_lock(spinlock_t *lock ) ;
#line 345 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_95(spinlock_t *lock ) 
{ 


  {
#line 347
  _raw_spin_unlock(& lock->ldv_6347.rlock);
#line 348
  return;
}
}
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 64 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_106(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 311 "include/linux/i2c.h"
extern struct i2c_client *i2c_new_probed_device(struct i2c_adapter * , struct i2c_board_info * ,
                                                unsigned short const   * , int (*)(struct i2c_adapter * ,
                                                                                   unsigned short  ) ) ;
#line 454 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 456
  dev_set_drvdata(& dev->dev, data);
#line 457
  return;
}
}
#line 506
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 51 "include/linux/i2c-algo-bit.h"
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
#line 117 "include/media/v4l2-common.h"
extern struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device * , struct i2c_adapter * ,
                                               char const   * , u8  , unsigned short const   * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_114(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_116(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_112(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_121(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_117(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_118(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 66 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_noretry(struct cx18 *cx , u32 val , void *addr ) 
{ 


  {
#line 68
  writel(val, (void volatile   *)addr);
#line 69
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_51294;
  ldv_51293: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_51292;
  } else {

  }
#line 74
  i = i + 1;
  ldv_51294: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_51293;
  } else {

  }
  ldv_51292: ;
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect(struct cx18 *cx , u32 val , void *addr , u32 eval ,
                                        u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_51307;
  ldv_51306: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_51304;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_51305;
  } else {

  }
  ldv_51304: 
#line 88
  i = i + 1;
  ldv_51307: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_51306;
  } else {

  }
  ldv_51305: ;
#line 95
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 158
  cx18_writel(cx, val, cx->reg_mem + (unsigned long )reg);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect(struct cx18 *cx , u32 val , u32 reg , u32 eval ,
                                           u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static u8 const   hw_addrs[9U]  = 
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
  {      0U,      0U,      76U,      0U, 
        0U,      0U,      0U,      112U, 
        113U};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static u8 const   hw_bus[9U]  = 
#line 157
  {      1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U};
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static char const   * const  hw_devicenames[9U]  = 
#line 170
  {      "tuner",      "tveeprom",      "cs5345",      "cx23418_DTV", 
        "cx23418_AV",      "gpio_mux",      "gpio_reset_ctrl",      "ir_tx_z8f0811_haup", 
        "ir_rx_z8f0811_haup"};
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static int cx18_i2c_new_ir(struct cx18 *cx , struct i2c_adapter *adap , u32 hw , char const   *type ,
                           u8 addr ) 
{ 
  struct i2c_board_info info ;
  struct IR_i2c_init_data *init_data ;
  unsigned short addr_list[2U] ;
  struct i2c_client *tmp ;

  {
#line 186
  init_data = & cx->ir_i2c_init_data;
#line 187
  addr_list[0] = (unsigned short )addr;
#line 187
  addr_list[1] = 65534U;
#line 189
  memset((void *)(& info), 0, 64UL);
#line 190
  strlcpy((char *)(& info.type), type, 20UL);
#line 193
  switch (hw) {
  case 256U: 
#line 195
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 196
  init_data->internal_get_key_func = 5;
#line 197
  init_data->type = 8ULL;
#line 198
  init_data->name = cx->card_name;
#line 199
  info.platform_data = (void *)init_data;
#line 200
  goto ldv_51513;
  }
  ldv_51513: 
#line 203
  tmp = i2c_new_probed_device(adap, & info, (unsigned short const   *)(& addr_list),
                              (int (*)(struct i2c_adapter * , unsigned short  ))0);
#line 203
  return ((unsigned long )tmp == (unsigned long )((struct i2c_client *)0) ? -1 : 0);
}
}
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int cx18_i2c_register(struct cx18 *cx , unsigned int idx ) 
{ 
  struct v4l2_subdev *sd ;
  int bus ;
  struct i2c_adapter *adap ;
  char const   *type ;
  u32 hw ;
  int tmp ;

  {
#line 210
  bus = (int )hw_bus[idx];
#line 211
  adap = (struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )bus;
#line 212
  type = hw_devicenames[idx];
#line 213
  hw = (u32 )(1 << (int )idx);
#line 215
  if (hw == 1U) {
#line 217
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->radio));
#line 219
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 220
      sd->grp_id = hw;
    } else {

    }
#line 221
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->demod));
#line 223
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 224
      sd->grp_id = hw;
    } else {

    }
#line 225
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->tv));
#line 227
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 228
      sd->grp_id = hw;
    } else {

    }
#line 229
    return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
  } else {

  }
#line 232
  if ((hw & 384U) != 0U) {
#line 233
    tmp = cx18_i2c_new_ir(cx, adap, hw, type, (int )hw_addrs[idx]);
#line 233
    return (tmp);
  } else {

  }
#line 236
  if ((unsigned int )((unsigned char )hw_addrs[idx]) == 0U) {
#line 237
    return (-1);
  } else {

  }
#line 240
  sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, (int )hw_addrs[idx], (unsigned short const   *)0U);
#line 242
  if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 243
    sd->grp_id = hw;
  } else {

  }
#line 244
  return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct v4l2_subdev *cx18_find_hw(struct cx18 *cx , u32 hw ) 
{ 
  struct v4l2_subdev *result ;
  struct v4l2_subdev *sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 250
  result = (struct v4l2_subdev *)0;
#line 253
  spin_lock(& cx->v4l2_dev.lock);
#line 254
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 254
  sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 254
  goto ldv_51535;
  ldv_51534: ;
#line 255
  if (sd->grp_id == hw) {
#line 256
    result = sd;
#line 257
    goto ldv_51533;
  } else {

  }
#line 254
  __mptr___0 = (struct list_head  const  *)sd->list.next;
#line 254
  sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51535: ;
#line 254
  if ((unsigned long )(& sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 256
    goto ldv_51534;
  } else {

  }
  ldv_51533: 
#line 260
  spin_unlock(& cx->v4l2_dev.lock);
#line 261
  return (result);
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static void cx18_setscl(void *data , int state ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 r ;
  u32 tmp ;

  {
#line 266
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 267
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 268
  addr = bus_index != 0 ? 15880448U : 15814656U;
#line 269
  tmp = cx18_read_reg(cx, addr);
#line 269
  r = tmp;
#line 271
  if (state != 0) {
#line 272
    cx18_write_reg(cx, r | 1U, addr);
  } else {
#line 274
    cx18_write_reg(cx, r & 4294967294U, addr);
  }
#line 275
  return;
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static void cx18_setsda(void *data , int state ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 r ;
  u32 tmp ;

  {
#line 279
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 280
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 281
  addr = bus_index != 0 ? 15880448U : 15814656U;
#line 282
  tmp = cx18_read_reg(cx, addr);
#line 282
  r = tmp;
#line 284
  if (state != 0) {
#line 285
    cx18_write_reg(cx, r | 2U, addr);
  } else {
#line 287
    cx18_write_reg(cx, r & 4294967293U, addr);
  }
#line 288
  return;
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static int cx18_getscl(void *data ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 tmp ;

  {
#line 292
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 293
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 294
  addr = bus_index != 0 ? 15880456U : 15814664U;
#line 296
  tmp = cx18_read_reg(cx, addr);
#line 296
  return ((int )tmp & 4);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static int cx18_getsda(void *data ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 tmp ;

  {
#line 301
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 302
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 303
  addr = bus_index != 0 ? 15880456U : 15814664U;
#line 305
  tmp = cx18_read_reg(cx, addr);
#line 305
  return ((int )tmp & 8);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static struct i2c_adapter cx18_i2c_adap_template  = 
#line 309
     {& __this_module, 0U, (struct i2c_algorithm  const  *)0, (void *)0, {{{{0U}}, 0U,
                                                                         0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                        {0}, 0, 0,
                                                                        0, 0, 0, 0,
                                                                        0}, 0, 0,
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, 0,
            {0, {0, 0}, 0, 0, 0UL}}, 0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0,
                                                  (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                                                  (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0U}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                                                  {0, 0}, {0U, {{{{{{0U}}, 0U, 0U,
                                                                   0, {0, {0, 0},
                                                                       0, 0, 0UL}}}},
                                                                {0, 0}}}, 0, (_Bool)0,
                                                  (_Bool)0, {{0, 0}, 0UL, 0, 0, 0UL,
                                                             0, 0, 0, {(char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0},
                                                             {0, {0, 0}, 0, 0, 0UL}},
                                                  0UL, {{0L}, {0, 0}, 0, {0, {0, 0},
                                                                          0, 0, 0UL}},
                                                  {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0},
                                                                          0, 0, 0UL}}}},
                                                   {0, 0}}, {0}, {0}, (unsigned char)0,
                                                  (unsigned char)0, (unsigned char)0,
                                                  (unsigned char)0, (unsigned char)0,
                                                  (unsigned char)0, (unsigned char)0,
                                                  (unsigned char)0, (unsigned char)0,
                                                  (unsigned char)0, (unsigned char)0,
                                                  0, 0, 0, 0, 0UL, 0UL, 0UL, 0UL,
                                                  0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL,
     0, {0, 0}, 0, 0, {0, 0}, 0, {0}, 0U, 0U, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0,
                                                                     0, 0UL}}}}, {0,
                                                                                  0},
     {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, {'c', 'x', '1', '8',
                                                              ' ', 'i', '2', 'c',
                                                              ' ', 'd', 'r', 'i',
                                                              'v', 'e', 'r', '\000'},
    {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                      {0, 0}, 0, 0,
                                                                      0, {0, {0, 0},
                                                                          0, 0, 0UL}},
    {0, 0}, 0};
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
static struct i2c_algo_bit_data cx18_i2c_algo_template  = 
#line 319
     {0, & cx18_setsda, & cx18_setscl, & cx18_getsda, & cx18_getscl, 0, 0, 5, 500};
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int init_cx18_i2c(struct cx18 *cx ) 
{ 
  int i ;
  int err ;
  size_t tmp ;
  u32 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  unsigned long __ms___0 ;
  unsigned long tmp___2 ;
  unsigned long __ms___1 ;
  unsigned long tmp___3 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 332
  if ((cx18_debug & 64) != 0) {
#line 332
    printk("\016%s:  i2c: i2c init\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 334
  i = 0;
#line 334
  goto ldv_51572;
  ldv_51571: 
#line 336
  cx->i2c_algo[i] = cx18_i2c_algo_template;
#line 337
  cx->i2c_algo_cb_data[i].cx = cx;
#line 338
  cx->i2c_algo_cb_data[i].bus_index = i;
#line 339
  cx->i2c_algo[i].data = (void *)(& cx->i2c_algo_cb_data) + (unsigned long )i;
#line 342
  cx->i2c_adap[i] = cx18_i2c_adap_template;
#line 343
  cx->i2c_adap[i].algo_data = (void *)(& cx->i2c_algo) + (unsigned long )i;
#line 344
  tmp = strlen((char const   *)(& cx->i2c_adap[i].name));
#line 344
  sprintf((char *)(& cx->i2c_adap[i].name) + tmp, " #%d-%d", cx->instance, i);
#line 346
  i2c_set_adapdata((struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )i, (void *)(& cx->v4l2_dev));
#line 347
  cx->i2c_adap[i].dev.parent = & (cx->pci_dev)->dev;
#line 334
  i = i + 1;
  ldv_51572: ;
#line 334
  if (i <= 1) {
#line 336
    goto ldv_51571;
  } else {

  }
#line 350
  tmp___0 = cx18_read_reg(cx, 15880448U);
#line 350
  if (tmp___0 != 245807U) {
#line 353
    cx18_write_reg_expect(cx, 268435456U, 13045764U, 0U, 268439552U);
#line 356
    cx18_write_reg_expect(cx, 268439552U, 13045796U, 4096U, 268439552U);
  } else {

  }
#line 360
  cx18_write_reg_expect(cx, 12582912U, 13041692U, 0U, 12583104U);
#line 361
  __ms = 10UL;
#line 361
  goto ldv_51576;
  ldv_51575: 
#line 361
  __const_udelay(4295000UL);
  ldv_51576: 
#line 361
  tmp___1 = __ms;
#line 361
  __ms = __ms - 1UL;
#line 361
  if (tmp___1 != 0UL) {
#line 363
    goto ldv_51575;
  } else {

  }
#line 362
  cx18_write_reg_expect(cx, 12583104U, 13041692U, 192U, 12583104U);
#line 363
  __ms___0 = 10UL;
#line 363
  goto ldv_51580;
  ldv_51579: 
#line 363
  __const_udelay(4295000UL);
  ldv_51580: 
#line 363
  tmp___2 = __ms___0;
#line 363
  __ms___0 = __ms___0 - 1UL;
#line 363
  if (tmp___2 != 0UL) {
#line 365
    goto ldv_51579;
  } else {

  }
#line 364
  cx18_write_reg_expect(cx, 12582912U, 13041692U, 0U, 12583104U);
#line 365
  __ms___1 = 10UL;
#line 365
  goto ldv_51584;
  ldv_51583: 
#line 365
  __const_udelay(4295000UL);
  ldv_51584: 
#line 365
  tmp___3 = __ms___1;
#line 365
  __ms___1 = __ms___1 - 1UL;
#line 365
  if (tmp___3 != 0UL) {
#line 367
    goto ldv_51583;
  } else {

  }
#line 368
  cx18_write_reg(cx, 12582912U, 13054152U);
#line 370
  cx18_write_reg_expect(cx, 12582912U, 13054148U, 4282384383U, 12582912U);
#line 374
  cx18_write_reg(cx, 138251U, 15814656U);
#line 375
  cx18_setscl((void *)(& cx->i2c_algo_cb_data), 1);
#line 376
  cx18_setsda((void *)(& cx->i2c_algo_cb_data), 1);
#line 379
  cx18_write_reg(cx, 138251U, 15880448U);
#line 380
  cx18_setscl((void *)(& cx->i2c_algo_cb_data) + 1U, 1);
#line 381
  cx18_setsda((void *)(& cx->i2c_algo_cb_data) + 1U, 1);
#line 383
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 383
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 383
  goto ldv_51592;
  ldv_51591: ;
#line 383
  if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                         u32  ))0)) {
#line 383
    (*(((__sd->ops)->core)->reset))(__sd, 0U);
  } else {

  }
#line 383
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 383
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51592: ;
#line 383
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 385
    goto ldv_51591;
  } else {

  }
#line 386
  err = i2c_bit_add_bus((struct i2c_adapter *)(& cx->i2c_adap));
#line 387
  if (err != 0) {
#line 388
    goto err;
  } else {

  }
#line 389
  err = i2c_bit_add_bus((struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 390
  if (err != 0) {
#line 391
    goto err_del_bus_0;
  } else {

  }
#line 392
  return (0);
  err_del_bus_0: 
#line 395
  i2c_del_adapter((struct i2c_adapter *)(& cx->i2c_adap));
  err: ;
#line 397
  return (err);
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void exit_cx18_i2c(struct cx18 *cx ) 
{ 
  int i ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 403
  if ((cx18_debug & 64) != 0) {
#line 403
    printk("\016%s:  i2c: i2c exit\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 404
  tmp = cx18_read_reg(cx, 15814656U);
#line 404
  cx18_write_reg(cx, tmp | 4U, 15814656U);
#line 406
  tmp___0 = cx18_read_reg(cx, 15880448U);
#line 406
  cx18_write_reg(cx, tmp___0 | 4U, 15880448U);
#line 409
  i = 0;
#line 409
  goto ldv_51601;
  ldv_51600: 
#line 410
  i2c_del_adapter((struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )i);
#line 409
  i = i + 1;
  ldv_51601: ;
#line 409
  if (i <= 1) {
#line 411
    goto ldv_51600;
  } else {

  }

#line 416
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  void *ldvarg99 ;
  void *tmp ;
  void *ldvarg96 ;
  void *tmp___0 ;
  void *ldvarg94 ;
  void *tmp___1 ;
  int ldvarg97 ;
  int tmp___2 ;
  int ldvarg95 ;
  int tmp___3 ;
  void *ldvarg98 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 425
  tmp = ldv_zalloc(1UL);
#line 425
  ldvarg99 = tmp;
#line 426
  tmp___0 = ldv_zalloc(1UL);
#line 426
  ldvarg96 = tmp___0;
#line 427
  tmp___1 = ldv_zalloc(1UL);
#line 427
  ldvarg94 = tmp___1;
#line 428
  tmp___2 = __VERIFIER_nondet_int();
#line 428
  ldvarg97 = tmp___2;
#line 429
  tmp___3 = __VERIFIER_nondet_int();
#line 429
  ldvarg95 = tmp___3;
#line 430
  tmp___4 = ldv_zalloc(1UL);
#line 430
  ldvarg98 = tmp___4;
#line 432
  tmp___5 = __VERIFIER_nondet_int();
#line 432
  switch (tmp___5) {
  case 0: ;
#line 435
  if (ldv_state_variable_20 == 1) {
#line 437
    cx18_getscl(ldvarg99);
#line 439
    ldv_state_variable_20 = 1;
  } else {

  }
#line 442
  goto ldv_51613;
  case 1: ;
#line 445
  if (ldv_state_variable_20 == 1) {
#line 447
    cx18_getsda(ldvarg98);
#line 449
    ldv_state_variable_20 = 1;
  } else {

  }
#line 452
  goto ldv_51613;
  case 2: ;
#line 455
  if (ldv_state_variable_20 == 1) {
#line 457
    cx18_setsda(ldvarg96, ldvarg97);
#line 459
    ldv_state_variable_20 = 1;
  } else {

  }
#line 462
  goto ldv_51613;
  case 3: ;
#line 465
  if (ldv_state_variable_20 == 1) {
#line 467
    cx18_setscl(ldvarg94, ldvarg95);
#line 469
    ldv_state_variable_20 = 1;
  } else {

  }
#line 472
  goto ldv_51613;
  default: 
#line 473
  ldv_stop();
  }
  ldv_51613: ;
#line 477
  return;
}
}
#line 478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 481
  ldv_spin_lock();
#line 483
  ldv_spin_lock_91(lock);
#line 484
  return;
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 516
  ldv_spin_unlock();
#line 518
  ldv_spin_unlock_95(lock);
#line 519
  return;
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void *ldv_kmem_cache_alloc_106(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 608
  ldv_check_alloc_flags(flags);
#line 610
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 611
  return ((void *)0);
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int ldv_pskb_expand_head_112(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 652
  ldv_check_alloc_flags(flags);
#line 654
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 654
  return (tmp);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv_skb_clone_114(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 668
  ldv_check_alloc_flags(flags);
#line 670
  tmp = skb_clone(ldv_func_arg1, flags);
#line 670
  return (tmp);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv_skb_copy_116(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 684
  ldv_check_alloc_flags(flags);
#line 686
  tmp = skb_copy(ldv_func_arg1, flags);
#line 686
  return (tmp);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_117(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 692
  ldv_check_alloc_flags(flags);
#line 694
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 694
  return (tmp);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_118(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 700
  ldv_check_alloc_flags(flags);
#line 702
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 702
  return (tmp);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 708
  ldv_check_alloc_flags(flags);
#line 710
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 710
  return (tmp);
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 716
  ldv_check_alloc_flags(flags);
#line 718
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 718
  return (tmp);
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int ldv_pskb_expand_head_121(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 724
  ldv_check_alloc_flags(flags);
#line 726
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 726
  return (tmp);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 732
  ldv_check_alloc_flags(flags);
#line 734
  tmp = skb_clone(ldv_func_arg1, flags);
#line 734
  return (tmp);
}
}
#line 60 "./arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 60
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 60
  return (ret);
}
}
#line 68 "./arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 68
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
#line 69
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_148(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 85 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_vapi_result(struct cx18 *cx , u32 *data , u32 cmd , int args  , ...) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_156(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_164(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_158(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_154(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_162(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_163(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_159(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_160(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_raw_readl(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned int tmp ;

  {
#line 40
  tmp = __readl((void const volatile   *)addr);
#line 40
  return (tmp);
}
}
#line 44 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_raw_writel_noretry(struct cx18 *cx , u32 val , void *addr ) 
{ 


  {
#line 46
  __writel(val, (void volatile   *)addr);
#line 47
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_raw_writel(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 52
  i = 0;
#line 52
  goto ldv_51276;
  ldv_51275: 
#line 53
  cx18_raw_writel_noretry(cx, val, addr);
#line 54
  tmp = cx18_raw_readl(cx, (void const   *)addr);
#line 54
  if (tmp == val) {
#line 55
    goto ldv_51274;
  } else {

  }
#line 52
  i = i + 1;
  ldv_51276: ;
#line 52
  if (i <= 9) {
#line 54
    goto ldv_51275;
  } else {

  }
  ldv_51274: ;
#line 59
  return;
}
}
#line 184
void cx18_sw1_irq_enable(struct cx18 *cx , u32 val ) ;
#line 186
void cx18_sw2_irq_enable(struct cx18 *cx , u32 val ) ;
#line 188
void cx18_sw2_irq_disable_cpu(struct cx18 *cx , u32 val ) ;
#line 189
void cx18_setup_page(struct cx18 *cx , u32 addr ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
static int load_cpu_fw_direct(char const   *fn , u8 *mem , struct cx18 *cx ) 
{ 
  struct firmware  const  *fw ;
  int i ;
  int j ;
  unsigned int size ;
  u32 *dst ;
  u32 const   *src ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 199
  fw = (struct firmware  const  *)0;
#line 202
  dst = (u32 *)mem;
#line 205
  tmp = request_firmware(& fw, fn, & (cx->pci_dev)->dev);
#line 205
  if (tmp != 0) {
#line 206
    printk("\v%s: Unable to open firmware %s\n", (char *)(& cx->v4l2_dev.name), fn);
#line 207
    printk("\v%s: Did you put the firmware in the hotplug firmware directory?\n",
           (char *)(& cx->v4l2_dev.name));
#line 208
    return (-12);
  } else {

  }
#line 211
  src = (u32 const   *)fw->data;
#line 213
  i = 0;
#line 213
  goto ldv_51665;
  ldv_51664: 
#line 214
  cx18_setup_page(cx, (u32 )i);
#line 215
  j = i;
#line 215
  goto ldv_51662;
  ldv_51661: 
#line 217
  cx18_raw_writel(cx, *src, (void *)dst);
#line 218
  tmp___0 = cx18_raw_readl(cx, (void const   *)dst);
#line 218
  if (tmp___0 != (u32 )*src) {
#line 219
    printk("\v%s: Mismatch at offset %x\n", (char *)(& cx->v4l2_dev.name), i);
#line 220
    release_firmware(fw);
#line 221
    cx18_setup_page(cx, 0U);
#line 222
    return (-5);
  } else {

  }
#line 224
  dst = dst + 1;
#line 225
  src = src + 1;
#line 215
  j = j + 4;
  ldv_51662: ;
#line 215
  if ((unsigned long )j < (unsigned long )fw->size && i + 4096 > j) {
#line 217
    goto ldv_51661;
  } else {

  }
#line 213
  i = i + 4096;
  ldv_51665: ;
#line 213
  if ((unsigned long )i < (unsigned long )fw->size) {
#line 215
    goto ldv_51664;
  } else {

  }
#line 228
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 228
  if (tmp___1 == 0) {
#line 229
    printk("\016%s: loaded %s firmware (%zd bytes)\n", (char *)(& cx->v4l2_dev.name),
           fn, fw->size);
  } else {

  }
#line 230
  size = (unsigned int )fw->size;
#line 231
  release_firmware(fw);
#line 232
  cx18_setup_page(cx, 14417920U);
#line 233
  return ((int )size);
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
static int load_apu_fw_direct(char const   *fn , u8 *dst , struct cx18 *cx , u32 *entry_addr ) 
{ 
  struct firmware  const  *fw ;
  int i ;
  int j ;
  unsigned int size ;
  u32 const   *src ;
  struct cx18_apu_rom_seghdr seghdr ;
  u8 const   *vers ;
  u32 offset ;
  u32 apu_version ;
  int sz ;
  int tmp ;
  u32 const   *shptr ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 239
  fw = (struct firmware  const  *)0;
#line 245
  offset = 0U;
#line 246
  apu_version = 0U;
#line 249
  tmp = request_firmware(& fw, fn, & (cx->pci_dev)->dev);
#line 249
  if (tmp != 0) {
#line 250
    printk("\v%s: unable to open firmware %s\n", (char *)(& cx->v4l2_dev.name), fn);
#line 251
    printk("\v%s: did you put the firmware in the hotplug firmware directory?\n",
           (char *)(& cx->v4l2_dev.name));
#line 252
    cx18_setup_page(cx, 0U);
#line 253
    return (-12);
  } else {

  }
#line 256
  *entry_addr = 0U;
#line 257
  src = (u32 const   *)fw->data;
#line 258
  vers = fw->data + 16UL;
#line 259
  sz = (int )fw->size;
#line 261
  apu_version = (u32 )((((int )*vers << 24) | ((int )*(vers + 4UL) << 16)) | (int )*(vers + 32UL));
#line 262
  goto ldv_51684;
  ldv_51692: 
#line 263
  shptr = src + (unsigned long )(offset / 4U);
#line 265
  seghdr.sync1 = *shptr;
#line 266
  seghdr.sync2 = *(shptr + 1UL);
#line 267
  seghdr.addr = *(shptr + 2UL);
#line 268
  seghdr.size = *(shptr + 3UL);
#line 270
  offset = offset + 16U;
#line 271
  if (seghdr.sync1 != 1835492691U || seghdr.sync2 != 1919182152U) {
#line 273
    offset = seghdr.size + offset;
#line 274
    goto ldv_51684;
  } else {

  }
#line 276
  if ((cx18_debug & 2) != 0) {
#line 276
    printk("\016%s:  info: load segment %x-%x\n", (char *)(& cx->v4l2_dev.name), seghdr.addr,
           (seghdr.addr + seghdr.size) - 1U);
  } else {

  }
#line 278
  if (*entry_addr == 0U) {
#line 279
    *entry_addr = seghdr.addr;
  } else {

  }
#line 280
  if (seghdr.size + offset > (u32 )sz) {
#line 281
    goto ldv_51685;
  } else {

  }
#line 282
  i = 0;
#line 282
  goto ldv_51690;
  ldv_51689: 
#line 283
  cx18_setup_page(cx, seghdr.addr + (u32 )i);
#line 284
  j = i;
#line 284
  goto ldv_51687;
  ldv_51686: 
#line 286
  cx18_raw_writel(cx, *(src + (unsigned long )((offset + (u32 )j) / 4U)), (void *)(dst + ((unsigned long )seghdr.addr + (unsigned long )j)));
#line 288
  tmp___0 = cx18_raw_readl(cx, (void const   *)(dst + ((unsigned long )seghdr.addr + (unsigned long )j)));
#line 288
  if (tmp___0 != (u32 )*(src + (unsigned long )((offset + (u32 )j) / 4U))) {
#line 290
    printk("\v%s: Mismatch at offset %x\n", (char *)(& cx->v4l2_dev.name), offset + (u32 )j);
#line 292
    release_firmware(fw);
#line 293
    cx18_setup_page(cx, 0U);
#line 294
    return (-5);
  } else {

  }
#line 284
  j = j + 4;
  ldv_51687: ;
#line 284
  if ((u32 )j < seghdr.size && i + 4096 > j) {
#line 286
    goto ldv_51686;
  } else {

  }
#line 282
  i = i + 4096;
  ldv_51690: ;
#line 282
  if ((u32 )i < seghdr.size) {
#line 284
    goto ldv_51689;
  } else {

  }
#line 298
  offset = seghdr.size + offset;
  ldv_51684: ;
#line 262
  if ((unsigned long )offset + 16UL < (unsigned long )fw->size) {
#line 264
    goto ldv_51692;
  } else {

  }
  ldv_51685: 
#line 300
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 300
  if (tmp___1 == 0) {
#line 301
    printk("\016%s: loaded %s firmware V%08x (%zd bytes)\n", (char *)(& cx->v4l2_dev.name),
           fn, apu_version, fw->size);
  } else {

  }
#line 303
  size = (unsigned int )fw->size;
#line 304
  release_firmware(fw);
#line 305
  cx18_setup_page(cx, 0U);
#line 306
  return ((int )size);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void cx18_halt_firmware(struct cx18 *cx ) 
{ 


  {
#line 311
  if ((cx18_debug & 2) != 0) {
#line 311
    printk("\016%s:  info: Preparing for firmware halt.\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 312
  cx18_write_reg_expect(cx, 983055U, 13041680U, 15U, 983055U);
#line 314
  cx18_write_reg_expect(cx, 131074U, 13074720U, 2U, 131074U);
#line 315
  return;
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void cx18_init_power(struct cx18 *cx , int lowpwr ) 
{ 


  {
#line 322
  cx18_write_reg(cx, 8U, 13074568U);
#line 325
  cx18_write_reg_expect(cx, 131072U, 13074720U, 0U, 131074U);
#line 367
  cx18_write_reg(cx, lowpwr != 0 ? 13U : 17U, 13074432U);
#line 368
  cx18_write_reg(cx, lowpwr != 0 ? 32489271U : 3728343U, 13074436U);
#line 371
  cx18_write_reg(cx, 2U, 13074440U);
#line 372
  cx18_write_reg(cx, 1U, 13074444U);
#line 373
  cx18_write_reg(cx, 4U, 13074448U);
#line 378
  cx18_write_reg(cx, lowpwr != 0 ? 13U : 12U, 13074452U);
#line 379
  cx18_write_reg(cx, lowpwr != 0 ? 3195716U : 19174015U, 13074456U);
#line 381
  cx18_write_reg(cx, 3U, 13074460U);
#line 385
  cx18_write_reg(cx, 15U, 13074496U);
#line 386
  cx18_write_reg(cx, 2876158U, 13074500U);
#line 387
  cx18_write_reg(cx, 8U, 13074504U);
#line 404
  if (lowpwr != 0) {
#line 405
    cx18_write_reg_expect(cx, 4294901792U, 13045760U, 32U, 4294967295U);
#line 407
    cx18_write_reg_expect(cx, 4294901764U, 13045764U, 4U, 4294967295U);
  } else {
#line 411
    cx18_write_reg_expect(cx, 393220U, 13045760U, 4U, 393222U);
#line 413
    cx18_write_reg_expect(cx, 393222U, 13045764U, 6U, 393222U);
  }
#line 417
  cx18_write_reg_expect(cx, 4294901762U, 13045768U, 2U, 4294967295U);
#line 419
  cx18_write_reg_expect(cx, 4294902020U, 13045772U, 260U, 4294967295U);
#line 421
  cx18_write_reg_expect(cx, 4294938662U, 13045792U, 36902U, 4294967295U);
#line 423
  cx18_write_reg_expect(cx, 4294914309U, 13045796U, 12549U, 4294967295U);
#line 424
  return;
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void cx18_init_memory(struct cx18 *cx ) 
{ 


  {
#line 429
  cx18_msleep_timeout(10U, 0);
#line 430
  cx18_write_reg_expect(cx, 65536U, 13041684U, 0U, 65537U);
#line 432
  cx18_msleep_timeout(10U, 0);
#line 434
  cx18_write_reg(cx, (cx->card)->ddr.chip_config, 13107204U);
#line 436
  cx18_msleep_timeout(10U, 0);
#line 438
  cx18_write_reg(cx, (cx->card)->ddr.refresh, 13107208U);
#line 439
  cx18_write_reg(cx, (cx->card)->ddr.timing1, 13107212U);
#line 440
  cx18_write_reg(cx, (cx->card)->ddr.timing2, 13107216U);
#line 442
  cx18_msleep_timeout(10U, 0);
#line 445
  cx18_write_reg(cx, (cx->card)->ddr.tune_lane, 13107272U);
#line 446
  cx18_write_reg(cx, (cx->card)->ddr.initial_emrs, 13107284U);
#line 448
  cx18_msleep_timeout(10U, 0);
#line 450
  cx18_write_reg_expect(cx, 131072U, 13041684U, 0U, 131074U);
#line 452
  cx18_msleep_timeout(10U, 0);
#line 455
  cx18_write_reg(cx, 16U, 13107228U);
#line 457
  cx18_write_reg_expect(cx, 65537U, 13049892U, 1U, 65537U);
#line 460
  cx18_write_reg(cx, 72U, 13107356U);
#line 461
  cx18_write_reg(cx, 917504U, 13108476U);
#line 463
  cx18_write_reg(cx, 257U, 13173000U);
#line 464
  cx18_write_reg(cx, 257U, 13173028U);
#line 465
  cx18_write_reg(cx, 257U, 13173012U);
#line 466
  cx18_write_reg(cx, 257U, 13173016U);
#line 467
  cx18_write_reg(cx, 257U, 13173020U);
#line 468
  cx18_write_reg(cx, 257U, 13173032U);
#line 469
  cx18_write_reg(cx, 257U, 13173040U);
#line 470
  cx18_write_reg(cx, 257U, 13173044U);
#line 471
  cx18_write_reg(cx, 257U, 13173036U);
#line 472
  cx18_write_reg(cx, 257U, 13173048U);
#line 473
  return;
}
}
#line 478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
int cx18_firmware_init(struct cx18 *cx ) 
{ 
  u32 fw_entry_addr ;
  int sz ;
  int retries ;
  u32 api_args[6U] ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
#line 485
  cx18_write_reg(cx, 5U, 13631564U);
#line 488
  cx18_write_reg_expect(cx, 983055U, 13041680U, 15U, 983055U);
#line 491
  cx18_msleep_timeout(1U, 0);
#line 494
  tmp = cx18_read_reg(cx, 13041680U);
#line 494
  if ((tmp & 8U) == 0U) {
#line 495
    printk("\v%s: %s: couldn\'t stop CPU to load firmware\n", (char *)(& cx->v4l2_dev.name),
           "cx18_firmware_init");
#line 496
    return (-5);
  } else {

  }
#line 499
  cx18_sw1_irq_enable(cx, 196608U);
#line 500
  cx18_sw2_irq_enable(cx, 136U);
#line 502
  sz = load_cpu_fw_direct("v4l-cx23418-cpu.fw", (u8 *)cx->enc_mem, cx);
#line 503
  if (sz <= 0) {
#line 504
    return (sz);
  } else {

  }
#line 507
  cx18_init_scb(cx);
#line 509
  fw_entry_addr = 0U;
#line 510
  sz = load_apu_fw_direct("v4l-cx23418-apu.fw", (u8 *)cx->enc_mem, cx, & fw_entry_addr);
#line 512
  if (sz <= 0) {
#line 513
    return (sz);
  } else {

  }
#line 516
  cx18_write_reg_expect(cx, 524288U, 13041680U, 0U, 524296U);
#line 520
  retries = 0;
#line 520
  goto ldv_51712;
  ldv_51711: 
#line 523
  cx18_msleep_timeout(10U, 0);
#line 522
  retries = retries + 1;
  ldv_51712: ;
#line 520
  if (retries <= 49) {
#line 520
    tmp___0 = cx18_read_reg(cx, 13041680U);
#line 520
    if ((int )tmp___0 & 1) {
#line 523
      goto ldv_51711;
    } else {
#line 526
      goto ldv_51713;
    }
  } else {

  }
  ldv_51713: 
#line 525
  cx18_msleep_timeout(200U, 0);
#line 527
  if (retries == 50) {
#line 527
    tmp___1 = cx18_read_reg(cx, 13041680U);
#line 527
    if ((int )tmp___1 & 1) {
#line 529
      printk("\v%s: Could not start the CPU\n", (char *)(& cx->v4l2_dev.name));
#line 530
      return (-5);
    } else {

    }
  } else {

  }
#line 542
  cx18_sw2_irq_disable_cpu(cx, 136U);
#line 545
  sz = cx18_vapi_result(cx, (u32 *)(& api_args), 536870915U, 1, 0);
#line 546
  if (sz < 0) {
#line 547
    return (sz);
  } else {

  }
#line 550
  cx18_write_reg_expect(cx, 335549440U, 13074704U, 5120U, 335549440U);
#line 551
  return (0);
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void *ldv_kmem_cache_alloc_148(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 687
  ldv_check_alloc_flags(flags);
#line 689
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 690
  return ((void *)0);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
int ldv_pskb_expand_head_154(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 731
  ldv_check_alloc_flags(flags);
#line 733
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 733
  return (tmp);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv_skb_clone_156(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 747
  ldv_check_alloc_flags(flags);
#line 749
  tmp = skb_clone(ldv_func_arg1, flags);
#line 749
  return (tmp);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv_skb_copy_158(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 763
  ldv_check_alloc_flags(flags);
#line 765
  tmp = skb_copy(ldv_func_arg1, flags);
#line 765
  return (tmp);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_159(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 771
  ldv_check_alloc_flags(flags);
#line 773
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 773
  return (tmp);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_160(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 779
  ldv_check_alloc_flags(flags);
#line 781
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 781
  return (tmp);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 787
  ldv_check_alloc_flags(flags);
#line 789
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 789
  return (tmp);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
int ldv_pskb_expand_head_162(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 795
  ldv_check_alloc_flags(flags);
#line 797
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 797
  return (tmp);
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
int ldv_pskb_expand_head_163(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 803
  ldv_check_alloc_flags(flags);
#line 805
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 805
  return (tmp);
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
struct sk_buff *ldv_skb_clone_164(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 811
  ldv_check_alloc_flags(flags);
#line 813
  tmp = skb_clone(ldv_func_arg1, flags);
#line 813
  return (tmp);
}
}
#line 139 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 175
extern void mutex_unlock(struct mutex * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_190(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 21 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern u32 __VERIFIER_nondet_u32(void) ;
#line 380 "include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long  ) ;
#line 663 "include/media/v4l2-subdev.h"
__inline static void v4l2_set_subdevdata(struct v4l2_subdev *sd , void *p ) 
{ 


  {
#line 665
  sd->dev_priv = p;
#line 666
  return;
}
}
#line 668 "include/media/v4l2-subdev.h"
__inline static void *v4l2_get_subdevdata(struct v4l2_subdev  const  *sd ) 
{ 


  {
#line 670
  return ((void *)sd->dev_priv);
}
}
#line 690
extern void v4l2_subdev_init(struct v4l2_subdev * , struct v4l2_subdev_ops  const  * ) ;
#line 111 "include/media/v4l2-device.h"
extern int v4l2_device_register_subdev(struct v4l2_device * , struct v4l2_subdev * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_198(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_206(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_200(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_196(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_204(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_205(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_201(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_202(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_203(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-gpio.h"
void cx18_reset_ir_gpio(void *data ) ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static void gpio_write(struct cx18 *cx ) 
{ 
  u32 dir_lo ;
  u32 val_lo ;
  u32 dir_hi ;
  u32 val_hi ;

  {
#line 150
  dir_lo = cx->gpio_dir & 65535U;
#line 151
  val_lo = cx->gpio_val & 65535U;
#line 152
  dir_hi = cx->gpio_dir >> 16;
#line 153
  val_hi = cx->gpio_val >> 16;
#line 155
  cx18_write_reg_expect(cx, dir_lo << 16, 13074696U, ~ dir_lo, dir_lo);
#line 157
  cx18_write_reg_expect(cx, (dir_lo << 16) | val_lo, 13074688U, val_lo, dir_lo);
#line 159
  cx18_write_reg_expect(cx, dir_hi << 16, 13074700U, ~ dir_hi, dir_hi);
#line 161
  cx18_write_reg_expect(cx, (dir_hi << 16) | val_hi, 13074692U, val_hi, dir_hi);
#line 162
  return;
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static void gpio_update(struct cx18 *cx , u32 mask , u32 data ) 
{ 


  {
#line 167
  if (mask == 0U) {
#line 168
    return;
  } else {

  }
#line 170
  mutex_lock_nested(& cx->gpio_lock, 0U);
#line 171
  cx->gpio_val = (cx->gpio_val & ~ mask) | (data & mask);
#line 172
  gpio_write(cx);
#line 173
  mutex_unlock(& cx->gpio_lock);
#line 174
  return;
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static void gpio_reset_seq(struct cx18 *cx , u32 active_lo , u32 active_hi , unsigned int assert_msecs ,
                           unsigned int recovery_msecs ) 
{ 
  u32 mask ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 182
  mask = active_lo | active_hi;
#line 183
  if (mask == 0U) {
#line 184
    return;
  } else {

  }
#line 193
  gpio_update(cx, mask, ~ active_lo);
#line 194
  tmp = msecs_to_jiffies(assert_msecs);
#line 194
  schedule_timeout_uninterruptible((long )tmp);
#line 197
  gpio_update(cx, mask, ~ active_hi);
#line 198
  tmp___0 = msecs_to_jiffies(recovery_msecs);
#line 198
  schedule_timeout_uninterruptible((long )tmp___0);
#line 199
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int gpiomux_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 206
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 206
  cx = (struct cx18 *)tmp;
#line 208
  mutex_lock_nested(& cx->gpio_lock, 0U);
#line 209
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& sd->name),
         cx->gpio_dir, cx->gpio_val);
#line 211
  mutex_unlock(& cx->gpio_lock);
#line 212
  return (0);
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int gpiomux_s_radio(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 217
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 217
  cx = (struct cx18 *)tmp;
#line 224
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, (cx->card)->gpio_audio_input.radio);
#line 226
  return (0);
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int gpiomux_s_std(struct v4l2_subdev *sd , v4l2_std_id norm ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 data ;

  {
#line 231
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 231
  cx = (struct cx18 *)tmp;
#line 234
  switch ((int )(cx->card)->audio_inputs[cx->audio_input].muxer_input) {
  case 1: 
#line 236
  data = (cx->card)->gpio_audio_input.linein;
#line 237
  goto ldv_51545;
  case 0: 
#line 239
  data = (cx->card)->gpio_audio_input.tuner;
#line 240
  goto ldv_51545;
  default: 
#line 247
  data = (cx->card)->gpio_audio_input.tuner;
#line 248
  goto ldv_51545;
  }
  ldv_51545: 
#line 250
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, data);
#line 251
  return (0);
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int gpiomux_s_audio_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 data ;

  {
#line 257
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 257
  cx = (struct cx18 *)tmp;
#line 260
  switch (input) {
  case 0U: 
#line 262
  data = (cx->card)->gpio_audio_input.tuner;
#line 263
  goto ldv_51557;
  case 1U: 
#line 265
  data = (cx->card)->gpio_audio_input.linein;
#line 266
  goto ldv_51557;
  case 2U: 
#line 268
  data = (cx->card)->gpio_audio_input.radio;
#line 269
  goto ldv_51557;
  default: ;
#line 271
  return (-22);
  }
  ldv_51557: 
#line 273
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, data);
#line 274
  return (0);
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_core_ops  const  gpiomux_core_ops  = 
#line 277
     {& gpiomux_log_status, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0};
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_tuner_ops  const  gpiomux_tuner_ops  = 
#line 281
     {& gpiomux_s_radio, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_audio_ops  const  gpiomux_audio_ops  =    {0, 0, & gpiomux_s_audio_routing, 0};
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_video_ops  const  gpiomux_video_ops  = 
#line 289
     {0, 0, 0, & gpiomux_s_std, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_ops  const  gpiomux_ops  = 
#line 293
     {& gpiomux_core_ops, & gpiomux_tuner_ops, & gpiomux_audio_ops, & gpiomux_video_ops,
    0, 0, 0, 0};
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int resetctrl_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 305
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 305
  cx = (struct cx18 *)tmp;
#line 307
  mutex_lock_nested(& cx->gpio_lock, 0U);
#line 308
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& sd->name),
         cx->gpio_dir, cx->gpio_val);
#line 310
  mutex_unlock(& cx->gpio_lock);
#line 311
  return (0);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static int resetctrl_reset(struct v4l2_subdev *sd , u32 val ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_gpio_i2c_slave_reset  const  *p ;

  {
#line 316
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 316
  cx = (struct cx18 *)tmp;
#line 319
  p = & (cx->card)->gpio_i2c_slave_reset;
#line 320
  switch (val) {
  case 0U: 
#line 322
  gpio_reset_seq(cx, p->active_lo_mask, p->active_hi_mask, (unsigned int )p->msecs_asserted,
                 (unsigned int )p->msecs_recovery);
#line 324
  goto ldv_51577;
  case 1U: 
#line 340
  gpio_reset_seq(cx, p->ir_reset_mask, 0U, (unsigned int )p->msecs_asserted, (unsigned int )p->msecs_recovery);
#line 342
  goto ldv_51577;
  case 2U: ;
#line 344
  if ((int )(cx->card)->tuners[0].tuner == 71) {
#line 345
    gpio_reset_seq(cx, (u32 )(1 << (int )(cx->card)->xceive_pin), 0U, 1U, 1U);
  } else {

  }
#line 347
  goto ldv_51577;
  }
  ldv_51577: ;
#line 349
  return (0);
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_core_ops  const  resetctrl_core_ops  = 
#line 352
     {& resetctrl_log_status, 0, 0, 0, & resetctrl_reset, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0};
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static struct v4l2_subdev_ops  const  resetctrl_ops  = 
#line 357
     {& resetctrl_core_ops, 0, 0, 0, 0, 0, 0, 0};
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void cx18_gpio_init(struct cx18 *cx ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 366
  mutex_lock_nested(& cx->gpio_lock, 0U);
#line 367
  cx->gpio_dir = (cx->card)->gpio_init.direction;
#line 368
  cx->gpio_val = (cx->card)->gpio_init.initial_value;
#line 370
  if ((int )(cx->card)->tuners[0].tuner == 71) {
#line 371
    cx->gpio_dir = cx->gpio_dir | (u32 )(1 << (int )(cx->card)->xceive_pin);
#line 372
    cx->gpio_val = cx->gpio_val | (u32 )(1 << (int )(cx->card)->xceive_pin);
  } else {

  }
#line 375
  if (cx->gpio_dir == 0U) {
#line 376
    mutex_unlock(& cx->gpio_lock);
#line 377
    return;
  } else {

  }
#line 380
  if ((cx18_debug & 2) != 0) {
#line 380
    tmp = cx18_read_reg(cx, 13074692U);
#line 380
    tmp___0 = cx18_read_reg(cx, 13074688U);
#line 380
    tmp___1 = cx18_read_reg(cx, 13074700U);
#line 380
    tmp___2 = cx18_read_reg(cx, 13074696U);
#line 380
    printk("\016%s:  info: GPIO initial dir: %08x/%08x out: %08x/%08x\n", (char *)(& cx->v4l2_dev.name),
           tmp___2, tmp___1, tmp___0, tmp);
  } else {

  }
#line 386
  gpio_write(cx);
#line 387
  mutex_unlock(& cx->gpio_lock);
#line 388
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int cx18_gpio_register(struct cx18 *cx , u32 hw ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev_ops  const  *ops ;
  char *str ;
  int tmp ;

  {
#line 396
  switch (hw) {
  case 32U: 
#line 398
  sd = & cx->sd_gpiomux;
#line 399
  ops = & gpiomux_ops;
#line 400
  str = (char *)"gpio-mux";
#line 401
  goto ldv_51593;
  case 64U: 
#line 403
  sd = & cx->sd_resetctrl;
#line 404
  ops = & resetctrl_ops;
#line 405
  str = (char *)"gpio-reset-ctrl";
#line 406
  goto ldv_51593;
  default: ;
#line 408
  return (-22);
  }
  ldv_51593: 
#line 411
  v4l2_subdev_init(sd, ops);
#line 412
  v4l2_set_subdevdata(sd, (void *)cx);
#line 413
  snprintf((char *)(& sd->name), 32UL, "%s %s", (char *)(& cx->v4l2_dev.name), str);
#line 414
  sd->grp_id = hw;
#line 415
  tmp = v4l2_device_register_subdev(& cx->v4l2_dev, sd);
#line 415
  return (tmp);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void cx18_reset_ir_gpio(void *data ) 
{ 
  struct cx18 *cx ;
  struct cx18 *tmp ;

  {
#line 420
  tmp = to_cx18((struct v4l2_device *)data);
#line 420
  cx = tmp;
#line 422
  if ((unsigned int )(cx->card)->gpio_i2c_slave_reset.ir_reset_mask == 0U) {
#line 423
    return;
  } else {

  }
#line 425
  if ((cx18_debug & 2) != 0) {
#line 425
    printk("\016%s:  info: Resetting IR microcontroller\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 427
  if ((unsigned long )(& cx->sd_resetctrl) != (unsigned long )((struct v4l2_subdev *)0)) {
#line 427
    if ((unsigned long )(cx->sd_resetctrl.ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((cx->sd_resetctrl.ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 u32  ))0)) {
#line 427
      (*(((cx->sd_resetctrl.ops)->core)->reset))(& cx->sd_resetctrl, 1U);
    } else {

    }
  } else {

  }
#line 428
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
static char const   __kstrtab_cx18_reset_ir_gpio[19U]  = 
#line 430
  {      'c',      'x',      '1',      '8', 
        '_',      'r',      'e',      's', 
        'e',      't',      '_',      'i', 
        'r',      '_',      'g',      'p', 
        'i',      'o',      '\000'};
#line 430
struct kernel_symbol  const  __ksymtab_cx18_reset_ir_gpio ;
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_reset_ir_gpio  =    {(unsigned long )(& cx18_reset_ir_gpio), (char const   *)(& __kstrtab_cx18_reset_ir_gpio)};
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int cx18_reset_tuner_gpio(void *dev , int component , int cmd , int value ) 
{ 
  struct i2c_algo_bit_data *algo ;
  struct cx18_i2c_algo_callback_data *cb_data ;
  struct cx18 *cx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 436
  algo = (struct i2c_algo_bit_data *)dev;
#line 437
  cb_data = (struct cx18_i2c_algo_callback_data *)algo->data;
#line 438
  cx = cb_data->cx;
#line 440
  if (cmd != 0 || (int )(cx->card)->tuners[0].tuner != 71) {
#line 442
    return (0);
  } else {

  }
#line 444
  if ((cx18_debug & 2) != 0) {
#line 444
    printk("\016%s:  info: Resetting XCeive tuner\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 445
  if ((unsigned long )(& cx->sd_resetctrl) != (unsigned long )((struct v4l2_subdev *)0)) {
#line 445
    if ((unsigned long )(cx->sd_resetctrl.ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((cx->sd_resetctrl.ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 u32  ))0)) {
#line 445
      tmp = (*(((cx->sd_resetctrl.ops)->core)->reset))(& cx->sd_resetctrl, 2U);
#line 445
      tmp___0 = tmp;
    } else {
#line 445
      tmp___0 = -515;
    }
#line 445
    tmp___1 = tmp___0;
  } else {
#line 445
    tmp___1 = -19;
  }
#line 445
  return (tmp___1);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_initialize_v4l2_subdev_core_ops_15(void) 
{ 
  void *tmp ;

  {
#line 451
  tmp = ldv_zalloc(304UL);
#line 451
  resetctrl_core_ops_group0 = (struct v4l2_subdev *)tmp;
#line 452
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  struct v4l2_subdev *ldvarg13 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 455
  tmp = ldv_zalloc(304UL);
#line 455
  ldvarg13 = (struct v4l2_subdev *)tmp;
#line 457
  tmp___0 = __VERIFIER_nondet_int();
#line 457
  switch (tmp___0) {
  case 0: ;
#line 460
  if (ldv_state_variable_18 == 1) {
#line 462
    gpiomux_s_radio(ldvarg13);
#line 464
    ldv_state_variable_18 = 1;
  } else {

  }
#line 467
  goto ldv_51624;
  default: 
#line 468
  ldv_stop();
  }
  ldv_51624: ;
#line 472
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  struct v4l2_subdev *ldvarg112 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 475
  tmp = ldv_zalloc(304UL);
#line 475
  ldvarg112 = (struct v4l2_subdev *)tmp;
#line 477
  tmp___0 = __VERIFIER_nondet_int();
#line 477
  switch (tmp___0) {
  case 0: ;
#line 480
  if (ldv_state_variable_19 == 1) {
#line 482
    gpiomux_log_status(ldvarg112);
#line 484
    ldv_state_variable_19 = 1;
  } else {

  }
#line 487
  goto ldv_51631;
  default: 
#line 488
  ldv_stop();
  }
  ldv_51631: ;
#line 492
  return;
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  v4l2_std_id ldvarg15 ;
  struct v4l2_subdev *ldvarg14 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 496
  tmp = ldv_zalloc(304UL);
#line 496
  ldvarg14 = (struct v4l2_subdev *)tmp;
#line 495
  memset((void *)(& ldvarg15), 0, 8UL);
#line 498
  tmp___0 = __VERIFIER_nondet_int();
#line 498
  switch (tmp___0) {
  case 0: ;
#line 501
  if (ldv_state_variable_16 == 1) {
#line 503
    gpiomux_s_std(ldvarg14, ldvarg15);
#line 505
    ldv_state_variable_16 = 1;
  } else {

  }
#line 508
  goto ldv_51639;
  default: 
#line 509
  ldv_stop();
  }
  ldv_51639: ;
#line 513
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  u32 ldvarg9 ;
  u32 tmp ;
  u32 ldvarg12 ;
  u32 tmp___0 ;
  struct v4l2_subdev *ldvarg10 ;
  void *tmp___1 ;
  u32 ldvarg11 ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 516
  tmp = __VERIFIER_nondet_u32();
#line 516
  ldvarg9 = tmp;
#line 517
  tmp___0 = __VERIFIER_nondet_u32();
#line 517
  ldvarg12 = tmp___0;
#line 518
  tmp___1 = ldv_zalloc(304UL);
#line 518
  ldvarg10 = (struct v4l2_subdev *)tmp___1;
#line 519
  tmp___2 = __VERIFIER_nondet_u32();
#line 519
  ldvarg11 = tmp___2;
#line 521
  tmp___3 = __VERIFIER_nondet_int();
#line 521
  switch (tmp___3) {
  case 0: ;
#line 524
  if (ldv_state_variable_17 == 1) {
#line 526
    gpiomux_s_audio_routing(ldvarg10, ldvarg12, ldvarg11, ldvarg9);
#line 528
    ldv_state_variable_17 = 1;
  } else {

  }
#line 531
  goto ldv_51649;
  default: 
#line 532
  ldv_stop();
  }
  ldv_51649: ;
#line 536
  return;
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  u32 ldvarg107 ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 539
  tmp = __VERIFIER_nondet_u32();
#line 539
  ldvarg107 = tmp;
#line 541
  tmp___0 = __VERIFIER_nondet_int();
#line 541
  switch (tmp___0) {
  case 0: ;
#line 544
  if (ldv_state_variable_15 == 1) {
#line 546
    resetctrl_log_status(resetctrl_core_ops_group0);
#line 548
    ldv_state_variable_15 = 1;
  } else {

  }
#line 551
  goto ldv_51656;
  case 1: ;
#line 554
  if (ldv_state_variable_15 == 1) {
#line 556
    resetctrl_reset(resetctrl_core_ops_group0, ldvarg107);
#line 558
    ldv_state_variable_15 = 1;
  } else {

  }
#line 561
  goto ldv_51656;
  default: 
#line 562
  ldv_stop();
  }
  ldv_51656: ;
#line 566
  return;
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void *ldv_kmem_cache_alloc_190(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 697
  ldv_check_alloc_flags(flags);
#line 699
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 700
  return ((void *)0);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int ldv_pskb_expand_head_196(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 741
  ldv_check_alloc_flags(flags);
#line 743
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 743
  return (tmp);
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv_skb_clone_198(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 757
  ldv_check_alloc_flags(flags);
#line 759
  tmp = skb_clone(ldv_func_arg1, flags);
#line 759
  return (tmp);
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv_skb_copy_200(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 773
  ldv_check_alloc_flags(flags);
#line 775
  tmp = skb_copy(ldv_func_arg1, flags);
#line 775
  return (tmp);
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_201(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 781
  ldv_check_alloc_flags(flags);
#line 783
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 783
  return (tmp);
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_202(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 789
  ldv_check_alloc_flags(flags);
#line 791
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 791
  return (tmp);
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_203(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 797
  ldv_check_alloc_flags(flags);
#line 799
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 799
  return (tmp);
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int ldv_pskb_expand_head_204(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 805
  ldv_check_alloc_flags(flags);
#line 807
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 807
  return (tmp);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int ldv_pskb_expand_head_205(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 813
  ldv_check_alloc_flags(flags);
#line 815
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 815
  return (tmp);
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
struct sk_buff *ldv_skb_clone_206(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 821
  ldv_check_alloc_flags(flags);
#line 823
  tmp = skb_clone(ldv_func_arg1, flags);
#line 823
  return (tmp);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 235 "include/uapi/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 


  {
#line 240
  *p = __swab32p((__u32 const   *)p);
#line 241
  return;
}
}
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 164 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 167
  __list_del_entry(list);
#line 168
  list_add_tail(list, head);
#line 169
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 228 "include/linux/list.h"
__inline static int list_is_singular(struct list_head  const  *head ) 
{ 
  int tmp ;

  {
#line 230
  tmp = list_empty(head);
#line 230
  return (tmp == 0 && (unsigned long )head->next == (unsigned long )head->prev);
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 301 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 315 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_232(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445 "include/linux/slab.h"
__inline static void *ldv_kmalloc_228(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 462
  tmp___2 = __kmalloc(size, flags);
#line 462
  return (tmp___2);
}
}
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 69 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 71
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 59
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_29001: ;
#line 19
    goto ldv_29001;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_29010: ;
#line 36
    goto ldv_29010;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 97 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 101
  tmp = get_dma_ops(dev);
#line 101
  ops = tmp;
#line 103
  tmp___0 = valid_dma_direction((int )dir);
#line 103
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 103
  if (tmp___1 != 0L) {
#line 103
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (103), "i" (12UL));
    ldv_29060: ;
#line 103
    goto ldv_29060;
  } else {

  }
#line 104
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 107
  return;
}
}
#line 109 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 113
  tmp = get_dma_ops(dev);
#line 113
  ops = tmp;
#line 115
  tmp___0 = valid_dma_direction((int )dir);
#line 115
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 115
  if (tmp___1 != 0L) {
#line 115
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (115), "i" (12UL));
    ldv_29068: ;
#line 115
    goto ldv_29068;
  } else {

  }
#line 116
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 117
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 118
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 119
  return;
}
}
#line 30 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 32
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 32
  return (tmp);
}
}
#line 36 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
#line 39
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 40
  return;
}
}
#line 71 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ 


  {
#line 74
  dma_sync_single_for_cpu((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                          dma_handle, size, (enum dma_data_direction )direction);
#line 75
  return;
}
}
#line 78 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ 


  {
#line 81
  dma_sync_single_for_device((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             dma_handle, size, (enum dma_data_direction )direction);
#line 82
  return;
}
}
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_240(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_248(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_242(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_238(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_246(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_247(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_243(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_244(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_245(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_buf_sync_for_cpu(struct cx18_stream *s , struct cx18_buffer *buf ) 
{ 


  {
#line 32
  pci_dma_sync_single_for_cpu((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size,
                              s->dma);
#line 34
  return;
}
}
#line 43
void _cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) ;
#line 56
void cx18_buf_swap(struct cx18_buffer *buf ) ;
#line 57
void _cx18_mdl_swap(struct cx18_mdl *mdl ) ;
#line 69
struct cx18_queue *_cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl , struct cx18_queue *q ,
                                 int to_front ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static struct cx18_queue *cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                                struct cx18_queue *q ) 
{ 
  struct cx18_queue *tmp ;

  {
#line 76
  tmp = _cx18_enqueue(s, mdl, q, 0);
#line 76
  return (tmp);
}
}
#line 80 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static struct cx18_queue *cx18_push(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                             struct cx18_queue *q ) 
{ 
  struct cx18_queue *tmp ;

  {
#line 83
  tmp = _cx18_enqueue(s, mdl, q, 1);
#line 83
  return (tmp);
}
}
#line 86
void cx18_queue_init(struct cx18_queue *q ) ;
#line 87
struct cx18_mdl *cx18_dequeue(struct cx18_stream *s , struct cx18_queue *q ) ;
#line 88
struct cx18_mdl *cx18_queue_get_mdl(struct cx18_stream *s , u32 id , u32 bytesused ) ;
#line 90
void cx18_flush_queues(struct cx18_stream *s ) ;
#line 93
void cx18_unload_queues(struct cx18_stream *s ) ;
#line 94
void cx18_load_queues(struct cx18_stream *s ) ;
#line 97
int cx18_stream_alloc(struct cx18_stream *s ) ;
#line 98
void cx18_stream_free(struct cx18_stream *s ) ;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___1(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_51521;
  ldv_51520: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_51519;
  } else {

  }
#line 74
  i = i + 1;
  ldv_51521: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_51520;
  } else {

  }
  ldv_51519: ;
#line 81
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_buf_swap(struct cx18_buffer *buf ) 
{ 
  int i ;

  {
#line 131
  i = 0;
#line 131
  goto ldv_51635;
  ldv_51634: 
#line 132
  __swab32s((__u32 *)buf->buf + (unsigned long )i);
#line 131
  i = i + 4;
  ldv_51635: ;
#line 131
  if ((u32 )i < buf->bytesused) {
#line 133
    goto ldv_51634;
  } else {

  }

#line 138
  return;
}
}
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void _cx18_mdl_swap(struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 139
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 139
  buf = (struct cx18_buffer *)__mptr;
#line 139
  goto ldv_51647;
  ldv_51646: ;
#line 140
  if (buf->bytesused == 0U) {
#line 141
    goto ldv_51645;
  } else {

  }
#line 142
  cx18_buf_swap(buf);
#line 139
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 139
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_51647: ;
#line 139
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 141
    goto ldv_51646;
  } else {

  }
  ldv_51645: ;
#line 146
  return;
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_queue_init(struct cx18_queue *q ) 
{ 


  {
#line 148
  INIT_LIST_HEAD(& q->list);
#line 149
  atomic_set(& q->depth, 0);
#line 150
  q->bytesused = 0U;
#line 151
  return;
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct cx18_queue *_cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl , struct cx18_queue *q ,
                                 int to_front ) 
{ 
  int tmp ;

  {
#line 157
  if ((unsigned long )(& s->q_full) != (unsigned long )q) {
#line 158
    mdl->bytesused = 0U;
#line 159
    mdl->readpos = 0U;
#line 160
    mdl->m_flags = 0UL;
#line 161
    mdl->skipped = 0U;
#line 162
    mdl->curr_buf = (struct cx18_buffer *)0;
  } else {

  }
#line 166
  if ((unsigned long )(& s->q_busy) == (unsigned long )q) {
#line 166
    tmp = atomic_read((atomic_t const   *)(& q->depth));
#line 166
    if (tmp > 62) {
#line 168
      q = & s->q_free;
    } else {

    }
  } else {

  }
#line 170
  spin_lock(& q->lock);
#line 172
  if (to_front != 0) {
#line 173
    list_add(& mdl->list, & q->list);
  } else {
#line 175
    list_add_tail(& mdl->list, & q->list);
  }
#line 176
  q->bytesused = q->bytesused + (mdl->bytesused - mdl->readpos);
#line 177
  atomic_inc(& q->depth);
#line 179
  spin_unlock(& q->lock);
#line 180
  return (q);
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct cx18_mdl *cx18_dequeue(struct cx18_stream *s , struct cx18_queue *q ) 
{ 
  struct cx18_mdl *mdl ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 185
  mdl = (struct cx18_mdl *)0;
#line 187
  spin_lock(& q->lock);
#line 188
  tmp = list_empty((struct list_head  const  *)(& q->list));
#line 188
  if (tmp == 0) {
#line 189
    __mptr = (struct list_head  const  *)q->list.next;
#line 189
    mdl = (struct cx18_mdl *)__mptr;
#line 190
    list_del_init(& mdl->list);
#line 191
    q->bytesused = q->bytesused + (mdl->readpos - mdl->bytesused);
#line 192
    mdl->skipped = 0U;
#line 193
    atomic_dec(& q->depth);
  } else {

  }
#line 195
  spin_unlock(& q->lock);
#line 196
  return (mdl);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
static void _cx18_mdl_update_bufs_for_cpu(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  u32 buf_size ;
  u32 bytesused ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 203
  buf_size = s->buf_size;
#line 204
  bytesused = mdl->bytesused;
#line 206
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 206
  buf = (struct cx18_buffer *)__mptr;
#line 206
  goto ldv_51676;
  ldv_51675: 
#line 207
  buf->readpos = 0U;
#line 208
  if (bytesused >= buf_size) {
#line 209
    buf->bytesused = buf_size;
#line 210
    bytesused = bytesused - buf_size;
  } else {
#line 212
    buf->bytesused = bytesused;
#line 213
    bytesused = 0U;
  }
#line 215
  cx18_buf_sync_for_cpu(s, buf);
#line 206
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 206
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_51676: ;
#line 206
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 208
    goto ldv_51675;
  } else {

  }

#line 213
  return;
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
__inline static void cx18_mdl_update_bufs_for_cpu(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 224
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 224
  if (tmp != 0) {
#line 225
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 225
    buf = (struct cx18_buffer *)__mptr;
#line 227
    buf->bytesused = mdl->bytesused;
#line 228
    buf->readpos = 0U;
#line 229
    cx18_buf_sync_for_cpu(s, buf);
  } else {
#line 231
    _cx18_mdl_update_bufs_for_cpu(s, mdl);
  }
#line 232
  return;
}
}
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct cx18_mdl *cx18_queue_get_mdl(struct cx18_stream *s , u32 id , u32 bytesused ) 
{ 
  struct cx18 *cx ;
  struct cx18_mdl *mdl ;
  struct cx18_mdl *tmp ;
  struct cx18_mdl *ret ;
  struct list_head sweep_up ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 238
  cx = s->cx;
#line 241
  ret = (struct cx18_mdl *)0;
#line 242
  sweep_up.next = & sweep_up;
#line 242
  sweep_up.prev = & sweep_up;
#line 250
  spin_lock(& s->q_busy.lock);
#line 251
  __mptr = (struct list_head  const  *)s->q_busy.list.next;
#line 251
  mdl = (struct cx18_mdl *)__mptr;
#line 251
  __mptr___0 = (struct list_head  const  *)mdl->list.next;
#line 251
  tmp = (struct cx18_mdl *)__mptr___0;
#line 251
  goto ldv_51704;
  ldv_51703: ;
#line 259
  if (mdl->id != id) {
#line 260
    mdl->skipped = mdl->skipped + 1U;
#line 261
    tmp___0 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 261
    if (mdl->skipped >= (unsigned int )(tmp___0 + -1)) {
#line 263
      printk("\f%s: Skipped %s, MDL %d, %d times - it must have dropped out of rotation\n",
             (char *)(& cx->v4l2_dev.name), s->name, mdl->id, mdl->skipped);
#line 268
      list_move_tail(& mdl->list, & sweep_up);
#line 269
      atomic_dec(& s->q_busy.depth);
    } else {

    }
#line 271
    goto ldv_51701;
  } else {

  }
#line 277
  list_del_init(& mdl->list);
#line 278
  atomic_dec(& s->q_busy.depth);
#line 279
  ret = mdl;
#line 280
  goto ldv_51702;
  ldv_51701: 
#line 251
  mdl = tmp;
#line 251
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 251
  tmp = (struct cx18_mdl *)__mptr___1;
  ldv_51704: ;
#line 251
  if ((unsigned long )(& mdl->list) != (unsigned long )(& s->q_busy.list)) {
#line 253
    goto ldv_51703;
  } else {

  }
  ldv_51702: 
#line 282
  spin_unlock(& s->q_busy.lock);
#line 288
  if ((unsigned long )ret != (unsigned long )((struct cx18_mdl *)0)) {
#line 289
    ret->bytesused = bytesused;
#line 290
    ret->skipped = 0U;
#line 292
    cx18_mdl_update_bufs_for_cpu(s, ret);
#line 293
    if (s->type != 1) {
#line 294
      set_bit(0L, (unsigned long volatile   *)(& ret->m_flags));
    } else {

    }
  } else {

  }
#line 298
  __mptr___2 = (struct list_head  const  *)sweep_up.next;
#line 298
  mdl = (struct cx18_mdl *)__mptr___2;
#line 298
  __mptr___3 = (struct list_head  const  *)mdl->list.next;
#line 298
  tmp = (struct cx18_mdl *)__mptr___3;
#line 298
  goto ldv_51712;
  ldv_51711: 
#line 299
  list_del_init(& mdl->list);
#line 300
  cx18_enqueue(s, mdl, & s->q_free);
#line 298
  mdl = tmp;
#line 298
  __mptr___4 = (struct list_head  const  *)tmp->list.next;
#line 298
  tmp = (struct cx18_mdl *)__mptr___4;
  ldv_51712: ;
#line 298
  if ((unsigned long )(& mdl->list) != (unsigned long )(& sweep_up)) {
#line 300
    goto ldv_51711;
  } else {

  }

#line 302
  return (ret);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
static void cx18_queue_flush(struct cx18_stream *s , struct cx18_queue *q_src , struct cx18_queue *q_dst ) 
{ 
  struct cx18_mdl *mdl ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 312
  if (((unsigned long )q_src == (unsigned long )q_dst || (unsigned long )(& s->q_full) == (unsigned long )q_dst) || (unsigned long )(& s->q_busy) == (unsigned long )q_dst) {
#line 313
    return;
  } else {

  }
#line 315
  spin_lock(& q_src->lock);
#line 316
  spin_lock(& q_dst->lock);
#line 317
  goto ldv_51723;
  ldv_51722: 
#line 318
  __mptr = (struct list_head  const  *)q_src->list.next;
#line 318
  mdl = (struct cx18_mdl *)__mptr;
#line 319
  list_move_tail(& mdl->list, & q_dst->list);
#line 320
  mdl->bytesused = 0U;
#line 321
  mdl->readpos = 0U;
#line 322
  mdl->m_flags = 0UL;
#line 323
  mdl->skipped = 0U;
#line 324
  mdl->curr_buf = (struct cx18_buffer *)0;
#line 325
  atomic_inc(& q_dst->depth);
  ldv_51723: 
#line 317
  tmp = list_empty((struct list_head  const  *)(& q_src->list));
#line 317
  if (tmp == 0) {
#line 319
    goto ldv_51722;
  } else {

  }
#line 327
  cx18_queue_init(q_src);
#line 328
  spin_unlock(& q_src->lock);
#line 329
  spin_unlock(& q_dst->lock);
#line 330
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_flush_queues(struct cx18_stream *s ) 
{ 


  {
#line 334
  cx18_queue_flush(s, & s->q_busy, & s->q_free);
#line 335
  cx18_queue_flush(s, & s->q_full, & s->q_free);
#line 336
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_unload_queues(struct cx18_stream *s ) 
{ 
  struct cx18_queue *q_idle ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct list_head  const  *__mptr___1 ;

  {
#line 344
  q_idle = & s->q_idle;
#line 349
  cx18_queue_flush(s, & s->q_busy, q_idle);
#line 350
  cx18_queue_flush(s, & s->q_full, q_idle);
#line 351
  cx18_queue_flush(s, & s->q_free, q_idle);
#line 354
  spin_lock(& q_idle->lock);
#line 355
  __mptr = (struct list_head  const  *)q_idle->list.next;
#line 355
  mdl = (struct cx18_mdl *)__mptr;
#line 355
  goto ldv_51744;
  ldv_51743: ;
#line 356
  goto ldv_51741;
  ldv_51740: 
#line 357
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 357
  buf = (struct cx18_buffer *)__mptr___0;
#line 359
  list_move_tail(& buf->list, & s->buf_pool);
#line 360
  buf->bytesused = 0U;
#line 361
  buf->readpos = 0U;
  ldv_51741: 
#line 356
  tmp = list_empty((struct list_head  const  *)(& mdl->buf_list));
#line 356
  if (tmp == 0) {
#line 358
    goto ldv_51740;
  } else {

  }
#line 363
  mdl->id = s->mdl_base_idx;
#line 355
  __mptr___1 = (struct list_head  const  *)mdl->list.next;
#line 355
  mdl = (struct cx18_mdl *)__mptr___1;
  ldv_51744: ;
#line 355
  if ((unsigned long )mdl != (unsigned long )q_idle) {
#line 357
    goto ldv_51743;
  } else {

  }
#line 366
  spin_unlock(& q_idle->lock);
#line 367
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_load_queues(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  int mdl_id ;
  int i ;
  u32 partial_buf_size ;
  int tmp ;
  struct list_head  const  *__mptr ;

  {
#line 375
  cx = s->cx;
#line 387
  mdl_id = (int )s->mdl_base_idx;
#line 388
  mdl = cx18_dequeue(s, & s->q_idle);
#line 388
  i = (int )s->bufs_per_mdl;
#line 388
  goto ldv_51761;
  ldv_51760: 
#line 392
  mdl->id = (u32 )mdl_id;
#line 394
  i = 0;
#line 394
  goto ldv_51759;
  ldv_51758: 
#line 395
  tmp = list_empty((struct list_head  const  *)(& s->buf_pool));
#line 395
  if (tmp != 0) {
#line 396
    goto ldv_51755;
  } else {

  }
#line 398
  __mptr = (struct list_head  const  *)s->buf_pool.next;
#line 398
  buf = (struct cx18_buffer *)__mptr;
#line 400
  list_move_tail(& buf->list, & mdl->buf_list);
#line 403
  cx18_writel___1(cx, (u32 )buf->dma_handle, (void *)(& (cx->scb)->cpu_mdl[mdl_id + i].paddr));
#line 405
  cx18_writel___1(cx, s->buf_size, (void *)(& (cx->scb)->cpu_mdl[mdl_id + i].length));
#line 394
  i = i + 1;
  ldv_51759: ;
#line 394
  if ((u32 )i < s->bufs_per_mdl) {
#line 396
    goto ldv_51758;
  } else {

  }
  ldv_51755: ;
#line 409
  if ((u32 )i == s->bufs_per_mdl) {
#line 417
    partial_buf_size = s->mdl_size % s->buf_size;
#line 418
    if (partial_buf_size != 0U) {
#line 419
      cx18_writel___1(cx, partial_buf_size, (void *)(& (cx->scb)->cpu_mdl[(mdl_id + i) + -1].length));
    } else {

    }
#line 422
    cx18_enqueue(s, mdl, & s->q_free);
  } else {
#line 425
    cx18_push(s, mdl, & s->q_idle);
  }
#line 427
  mdl_id = mdl_id + i;
#line 390
  mdl = cx18_dequeue(s, & s->q_idle);
  ldv_51761: ;
#line 388
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0) && (u32 )i == s->bufs_per_mdl) {
#line 391
    goto ldv_51760;
  } else {

  }

#line 396
  return;
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void _cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  int dma ;
  u32 buf_size ;
  struct pci_dev *pci_dev ;
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 433
  dma = s->dma;
#line 434
  buf_size = s->buf_size;
#line 435
  pci_dev = (s->cx)->pci_dev;
#line 438
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 438
  buf = (struct cx18_buffer *)__mptr;
#line 438
  goto ldv_51776;
  ldv_51775: 
#line 439
  pci_dma_sync_single_for_device(pci_dev, buf->dma_handle, (size_t )buf_size, dma);
#line 438
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 438
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_51776: ;
#line 438
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 440
    goto ldv_51775;
  } else {

  }

#line 445
  return;
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
int cx18_stream_alloc(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  int i ;
  unsigned int bufsz ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 445
  cx = s->cx;
#line 448
  if (s->buffers == 0U) {
#line 449
    return (0);
  } else {

  }
#line 451
  if ((cx18_debug & 2) != 0) {
#line 451
    printk("\016%s:  info: Allocate %s stream: %d x %d buffers (%d.%02d kB total)\n",
           (char *)(& cx->v4l2_dev.name), s->name, s->buffers, s->buf_size, (s->buffers * s->buf_size) / 1024U,
           (((s->buffers * s->buf_size) * 100U) / 1024U) % 100U);
  } else {

  }
#line 457
  if ((long )(cx->free_mdl_idx + s->buffers) + 3248L > 65536L) {
#line 459
    bufsz = 62288U;
#line 462
    printk("\v%s: Too many buffers, cannot fit in SCB area\n", (char *)(& cx->v4l2_dev.name));
#line 463
    printk("\v%s: Max buffers = %zd\n", (char *)(& cx->v4l2_dev.name), (unsigned long )(bufsz / 8U));
#line 465
    return (-12);
  } else {

  }
#line 468
  s->mdl_base_idx = cx->free_mdl_idx;
#line 471
  i = 0;
#line 471
  goto ldv_51788;
  ldv_51787: 
#line 476
  tmp = kzalloc(64UL, 720U);
#line 476
  mdl = (struct cx18_mdl *)tmp;
#line 477
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 478
    goto ldv_51786;
  } else {

  }
#line 480
  tmp___0 = kzalloc(40UL, 720U);
#line 480
  buf = (struct cx18_buffer *)tmp___0;
#line 482
  if ((unsigned long )buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 483
    kfree((void const   *)mdl);
#line 484
    goto ldv_51786;
  } else {

  }
#line 487
  tmp___1 = kmalloc((size_t )s->buf_size, 720U);
#line 487
  buf->buf = (char *)tmp___1;
#line 488
  if ((unsigned long )buf->buf == (unsigned long )((char *)0)) {
#line 489
    kfree((void const   *)mdl);
#line 490
    kfree((void const   *)buf);
#line 491
    goto ldv_51786;
  } else {

  }
#line 494
  INIT_LIST_HEAD(& mdl->list);
#line 495
  INIT_LIST_HEAD(& mdl->buf_list);
#line 496
  mdl->id = s->mdl_base_idx;
#line 497
  cx18_enqueue(s, mdl, & s->q_idle);
#line 499
  INIT_LIST_HEAD(& buf->list);
#line 500
  buf->dma_handle = pci_map_single((s->cx)->pci_dev, (void *)buf->buf, (size_t )s->buf_size,
                                   s->dma);
#line 502
  cx18_buf_sync_for_cpu(s, buf);
#line 503
  list_add_tail(& buf->list, & s->buf_pool);
#line 471
  i = i + 1;
  ldv_51788: ;
#line 471
  if ((u32 )i < s->buffers) {
#line 473
    goto ldv_51787;
  } else {

  }
  ldv_51786: ;
#line 505
  if ((u32 )i == s->buffers) {
#line 506
    cx->free_mdl_idx = cx->free_mdl_idx + s->buffers;
#line 507
    return (0);
  } else {

  }
#line 509
  printk("\v%s: Couldn\'t allocate buffers for %s stream\n", (char *)(& cx->v4l2_dev.name),
         s->name);
#line 510
  cx18_stream_free(s);
#line 511
  return (-12);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void cx18_stream_free(struct cx18_stream *s ) 
{ 
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  struct cx18 *cx ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 518
  cx = s->cx;
#line 520
  if ((cx18_debug & 2) != 0) {
#line 520
    printk("\016%s:  info: Deallocating buffers for %s stream\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 523
  cx18_unload_queues(s);
#line 526
  goto ldv_51796;
  ldv_51795: 
#line 527
  kfree((void const   *)mdl);
  ldv_51796: 
#line 526
  mdl = cx18_dequeue(s, & s->q_idle);
#line 526
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 528
    goto ldv_51795;
  } else {

  }

#line 530
  goto ldv_51801;
  ldv_51800: 
#line 531
  __mptr = (struct list_head  const  *)s->buf_pool.next;
#line 531
  buf = (struct cx18_buffer *)__mptr;
#line 532
  list_del_init(& buf->list);
#line 534
  pci_unmap_single((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size, s->dma);
#line 536
  kfree((void const   *)buf->buf);
#line 537
  kfree((void const   *)buf);
  ldv_51801: 
#line 530
  tmp = list_empty((struct list_head  const  *)(& s->buf_pool));
#line 530
  if (tmp == 0) {
#line 532
    goto ldv_51800;
  } else {

  }

#line 537
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 641
  ldv_check_alloc_flags(flags);
#line 643
  ldv_kmalloc_228(size, flags);
#line 644
  return ((void *)0);
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void *ldv_kmem_cache_alloc_232(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 671
  ldv_check_alloc_flags(flags);
#line 673
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 674
  return ((void *)0);
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
int ldv_pskb_expand_head_238(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 715
  ldv_check_alloc_flags(flags);
#line 717
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 717
  return (tmp);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv_skb_clone_240(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 731
  ldv_check_alloc_flags(flags);
#line 733
  tmp = skb_clone(ldv_func_arg1, flags);
#line 733
  return (tmp);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv_skb_copy_242(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 747
  ldv_check_alloc_flags(flags);
#line 749
  tmp = skb_copy(ldv_func_arg1, flags);
#line 749
  return (tmp);
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_243(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 755
  ldv_check_alloc_flags(flags);
#line 757
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 757
  return (tmp);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_244(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 763
  ldv_check_alloc_flags(flags);
#line 765
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 765
  return (tmp);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_245(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 771
  ldv_check_alloc_flags(flags);
#line 773
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 773
  return (tmp);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
int ldv_pskb_expand_head_246(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 779
  ldv_check_alloc_flags(flags);
#line 781
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 781
  return (tmp);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
int ldv_pskb_expand_head_247(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 787
  ldv_check_alloc_flags(flags);
#line 789
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 789
  return (tmp);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
struct sk_buff *ldv_skb_clone_248(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 795
  ldv_check_alloc_flags(flags);
#line 797
  tmp = skb_clone(ldv_func_arg1, flags);
#line 797
  return (tmp);
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6347.rlock);
}
}
#line 144 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_274(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 19 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern size_t __VERIFIER_nondet_size_t(void) ;
#line 25
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) ;
#line 78
int reg_timer_2(struct timer_list *timer ) ;
#line 80
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 90
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 806 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 809
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 810
    return ((char const   *)dev->init_name);
  } else {

  }
#line 812
  tmp = kobject_name(& dev->kobj);
#line 812
  return (tmp);
}
}
#line 151 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 166 "include/media/v4l2-dev.h"
__inline static int video_register_device_no_warn(struct video_device *vdev , int type ,
                                                  int nr ) 
{ 
  int tmp ;

  {
#line 169
  tmp = __video_register_device(vdev, type, nr, 0, (vdev->fops)->owner);
#line 169
  return (tmp);
}
}
#line 174
extern void video_unregister_device(struct video_device * ) ;
#line 178
extern struct video_device *video_device_alloc(void) ;
#line 181
extern void video_device_release(struct video_device * ) ;
#line 214 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 216
  dev_set_drvdata(& vdev->dev, data);
#line 217
  return;
}
}
#line 228 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 230
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 230
  return (tmp);
}
}
#line 328 "include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_api(struct cx18 *cx , u32 cmd , int args , u32 *data ) ;
#line 606 "include/media/v4l2-ctrls.h"
extern s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl * ) ;
#line 196 "include/media/cx2341x.h"
extern int cx2341x_handler_setup(struct cx2341x_handler * ) ;
#line 197
extern void cx2341x_handler_set_busy(struct cx2341x_handler * , int  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_282(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_290(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_284(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_288(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_289(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_285(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_286(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_287(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 177 "include/media/videobuf-core.h"
extern int videobuf_waiton(struct videobuf_queue * , struct videobuf_buffer * , int  ,
                           int  ) ;
#line 179
extern int videobuf_iolock(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
#line 232
extern int videobuf_mmap_free(struct videobuf_queue * ) ;
#line 32 "include/media/videobuf-vmalloc.h"
extern void videobuf_queue_vmalloc_init(struct videobuf_queue * , struct videobuf_queue_ops  const  * ,
                                        struct device * , spinlock_t * , enum v4l2_buf_type  ,
                                        enum v4l2_field  , unsigned int  , void * ,
                                        struct mutex * ) ;
#line 44
extern void videobuf_vmalloc_free(struct videobuf_buffer * ) ;
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___0  =    1444U;
#line 494 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_60Hz  =    272U;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_50Hz  =    284U;
#line 700 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static int cx18_raw_vbi(struct cx18  const  *cx ) 
{ 


  {
#line 702
  return ((unsigned int )cx->vbi.in.type == 4U);
}
}
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-fileops.h"
int cx18_v4l2_open(struct file *filp ) ;
#line 26
ssize_t cx18_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) ;
#line 30
int cx18_v4l2_close(struct file *filp ) ;
#line 31
unsigned int cx18_v4l2_enc_poll(struct file *filp , poll_table *wait ) ;
#line 36
int cx18_v4l2_mmap(struct file *file , struct vm_area_struct *vma ) ;
#line 37
void cx18_vb_timeout(unsigned long data ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_buf_sync_for_device(struct cx18_stream *s , struct cx18_buffer *buf ) 
{ 


  {
#line 39
  pci_dma_sync_single_for_device((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size,
                                 s->dma);
#line 41
  return;
}
}
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 48
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 48
  if (tmp != 0) {
#line 49
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 49
    cx18_buf_sync_for_device(s, (struct cx18_buffer *)__mptr);
  } else {
#line 53
    _cx18_mdl_sync_for_device(s, mdl);
  }
#line 54
  return;
}
}
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
void cx18_set_funcs(struct video_device *vdev ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
u32 cx18_find_handle(struct cx18 *cx ) ;
#line 26
struct cx18_stream *cx18_handle_to_stream(struct cx18 *cx , u32 handle ) ;
#line 32
void cx18_stream_rotate_idx_mdls(struct cx18 *cx ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static bool cx18_stream_enabled(struct cx18_stream *s ) 
{ 


  {
#line 36
  return ((bool )(((unsigned long )s->video_dev != (unsigned long )((struct video_device *)0) || ((unsigned long )s->dvb != (unsigned long )((struct cx18_dvb *)0) && (s->dvb)->enabled != 0)) || (s->type == 5 && (s->cx)->stream_buffers[5] != 0)));
}
}
#line 56
void cx18_out_work_handler(struct work_struct *work ) ;
#line 59
int cx18_start_v4l2_encode_stream(struct cx18_stream *s ) ;
#line 60
int cx18_stop_v4l2_encode_stream(struct cx18_stream *s , int gop_end ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-dvb.h"
int cx18_dvb_register(struct cx18_stream *stream ) ;
#line 25
void cx18_dvb_unregister(struct cx18_stream *stream ) ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static struct v4l2_file_operations cx18_v4l2_enc_fops  = 
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
     {& __this_module, & cx18_v4l2_read, 0, & cx18_v4l2_enc_poll, 0, & video_ioctl2,
    0, 0, & cx18_v4l2_mmap, & cx18_v4l2_open, & cx18_v4l2_close};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static struct __anonstruct_cx18_stream_info_319 cx18_stream_info[7U]  = {      {"encoder MPEG", 0, 0, 2}, 
        {"TS", 0, -1, 2}, 
        {"encoder YUV", 0, 32, 2}, 
        {"encoder VBI", 1, 0, 2}, 
        {"encoder PCM audio", 0, 24, 2}, 
        {"encoder IDX", 0, -1, 2}, 
        {"encoder radio", 2, 0, 3}};
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void cx18_dma_free(struct videobuf_queue *q , struct cx18_stream *s , struct cx18_videobuf_buffer *buf ) 
{ 


  {
#line 199
  videobuf_waiton(q, & buf->vb, 0, 0);
#line 200
  videobuf_vmalloc_free(& buf->vb);
#line 201
  buf->vb.state = 0;
#line 202
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static int cx18_prepare_buffer(struct videobuf_queue *q , struct cx18_stream *s ,
                               struct cx18_videobuf_buffer *buf , u32 pixelformat ,
                               unsigned int width , unsigned int height , enum v4l2_field field ) 
{ 
  struct cx18 *cx ;
  int rc ;

  {
#line 211
  cx = s->cx;
#line 212
  rc = 0;
#line 215
  buf->bytes_used = 0U;
#line 217
  if (width <= 47U || height <= 31U) {
#line 218
    return (-22);
  } else {

  }
#line 220
  buf->vb.size = (unsigned long )((width * height) * 2U);
#line 221
  if (buf->vb.baddr != 0UL && buf->vb.bsize < buf->vb.size) {
#line 222
    return (-22);
  } else {

  }
#line 225
  if ((((buf->vb.width != width || buf->vb.height != height) || (unsigned int )buf->vb.field != (unsigned int )field) || s->pixelformat != pixelformat) || buf->tvnorm != cx->std) {
#line 229
    buf->vb.width = width;
#line 230
    buf->vb.height = height;
#line 231
    buf->vb.field = field;
#line 232
    buf->tvnorm = cx->std;
#line 233
    s->pixelformat = pixelformat;
#line 237
    if (s->pixelformat == 842091848U) {
#line 238
      s->vb_bytes_per_frame = (height * 2160U) / 2U;
    } else {
#line 240
      s->vb_bytes_per_frame = height * 1440U;
    }
#line 241
    cx18_dma_free(q, s, buf);
  } else {

  }
#line 244
  if (buf->vb.baddr != 0UL && buf->vb.bsize < buf->vb.size) {
#line 245
    return (-22);
  } else {

  }
#line 247
  if ((unsigned int )buf->vb.field == 0U) {
#line 248
    buf->vb.field = 4;
  } else {

  }
#line 250
  if ((unsigned int )buf->vb.state == 0U) {
#line 251
    buf->vb.width = width;
#line 252
    buf->vb.height = height;
#line 253
    buf->vb.field = field;
#line 254
    buf->tvnorm = cx->std;
#line 255
    s->pixelformat = pixelformat;
#line 259
    if (s->pixelformat == 842091848U) {
#line 260
      s->vb_bytes_per_frame = (height * 2160U) / 2U;
    } else {
#line 262
      s->vb_bytes_per_frame = height * 1440U;
    }
#line 263
    rc = videobuf_iolock(q, & buf->vb, (struct v4l2_framebuffer *)0);
#line 264
    if (rc != 0) {
#line 265
      goto fail;
    } else {

    }
  } else {

  }
#line 267
  buf->vb.state = 1;
#line 268
  return (0);
  fail: 
#line 271
  cx18_dma_free(q, s, buf);
#line 272
  return (rc);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static int buffer_setup(struct videobuf_queue *q , unsigned int *count , unsigned int *size ) 
{ 
  struct cx18_stream *s ;
  struct cx18 *cx ;

  {
#line 285
  s = (struct cx18_stream *)q->priv_data;
#line 286
  cx = s->cx;
#line 288
  *size = (unsigned int )(((int )cx->cxhdl.width * 2) * (int )cx->cxhdl.height);
#line 289
  if (*count == 0U) {
#line 290
    *count = 32U;
  } else {

  }
#line 292
  goto ldv_51800;
  ldv_51799: 
#line 293
  *count = *count - 1U;
  ldv_51800: ;
#line 292
  if (*size * *count > 132710400U) {
#line 294
    goto ldv_51799;
  } else {

  }
#line 295
  q->field = 4;
#line 296
  q->last = 4;
#line 298
  return (0);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static int buffer_prepare(struct videobuf_queue *q , struct videobuf_buffer *vb ,
                          enum v4l2_field field ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;
  struct cx18 *cx ;
  int tmp ;

  {
#line 306
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 306
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 307
  s = (struct cx18_stream *)q->priv_data;
#line 308
  cx = s->cx;
#line 310
  tmp = cx18_prepare_buffer(q, s, buf, s->pixelformat, (unsigned int )cx->cxhdl.width,
                            (unsigned int )cx->cxhdl.height, field);
#line 310
  return (tmp);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void buffer_release(struct videobuf_queue *q , struct videobuf_buffer *vb ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;

  {
#line 318
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 318
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 319
  s = (struct cx18_stream *)q->priv_data;
#line 321
  cx18_dma_free(q, s, buf);
#line 322
  return;
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void buffer_queue(struct videobuf_queue *q , struct videobuf_buffer *vb ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;

  {
#line 327
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 327
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 328
  s = (struct cx18_stream *)q->priv_data;
#line 330
  buf->vb.state = 2;
#line 332
  list_add_tail(& buf->vb.queue, & s->vb_capture);
#line 333
  return;
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static struct videobuf_queue_ops cx18_videobuf_qops  =    {& buffer_setup, & buffer_prepare, & buffer_queue, & buffer_release};
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void cx18_stream_init(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  struct video_device *video_dev ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;

  {
#line 344
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 345
  video_dev = s->video_dev;
#line 348
  memset((void *)s, 0, 1568UL);
#line 349
  s->video_dev = video_dev;
#line 352
  s->dvb = (struct cx18_dvb *)0;
#line 353
  s->cx = cx;
#line 354
  s->type = type;
#line 355
  s->name = cx18_stream_info[type].name;
#line 356
  s->handle = 4294967295U;
#line 358
  s->dma = cx18_stream_info[type].dma;
#line 359
  s->buffers = (u32 )cx->stream_buffers[type];
#line 360
  s->buf_size = (u32 )cx->stream_buf_size[type];
#line 361
  INIT_LIST_HEAD(& s->buf_pool);
#line 362
  s->bufs_per_mdl = 1U;
#line 363
  s->mdl_size = s->buf_size * s->bufs_per_mdl;
#line 365
  __init_waitqueue_head(& s->waitq, "&s->waitq", & __key);
#line 366
  s->id = 4294967295U;
#line 367
  spinlock_check(& s->q_free.lock);
#line 367
  __raw_spin_lock_init(& s->q_free.lock.ldv_6347.rlock, "&(&s->q_free.lock)->rlock",
                       & __key___0);
#line 368
  cx18_queue_init(& s->q_free);
#line 369
  spinlock_check(& s->q_busy.lock);
#line 369
  __raw_spin_lock_init(& s->q_busy.lock.ldv_6347.rlock, "&(&s->q_busy.lock)->rlock",
                       & __key___1);
#line 370
  cx18_queue_init(& s->q_busy);
#line 371
  spinlock_check(& s->q_full.lock);
#line 371
  __raw_spin_lock_init(& s->q_full.lock.ldv_6347.rlock, "&(&s->q_full.lock)->rlock",
                       & __key___2);
#line 372
  cx18_queue_init(& s->q_full);
#line 373
  spinlock_check(& s->q_idle.lock);
#line 373
  __raw_spin_lock_init(& s->q_idle.lock.ldv_6347.rlock, "&(&s->q_idle.lock)->rlock",
                       & __key___3);
#line 374
  cx18_queue_init(& s->q_idle);
#line 376
  __init_work(& s->out_work_order, 0);
#line 376
  __constr_expr_0.counter = 137438953408L;
#line 376
  s->out_work_order.data = __constr_expr_0;
#line 376
  lockdep_init_map(& s->out_work_order.lockdep_map, "(&s->out_work_order)", & __key___4,
                   0);
#line 376
  INIT_LIST_HEAD(& s->out_work_order.entry);
#line 376
  s->out_work_order.func = & cx18_out_work_handler;
#line 378
  INIT_LIST_HEAD(& s->vb_capture);
#line 379
  s->vb_timeout.function = & cx18_vb_timeout;
#line 380
  s->vb_timeout.data = (unsigned long )s;
#line 381
  reg_timer_2(& s->vb_timeout);
#line 382
  spinlock_check(& s->vb_lock);
#line 382
  __raw_spin_lock_init(& s->vb_lock.ldv_6347.rlock, "&(&s->vb_lock)->rlock", & __key___5);
#line 383
  if (type == 2) {
#line 384
    spinlock_check(& s->vbuf_q_lock);
#line 384
    __raw_spin_lock_init(& s->vbuf_q_lock.ldv_6347.rlock, "&(&s->vbuf_q_lock)->rlock",
                         & __key___6);
#line 386
    s->vb_type = 1;
#line 387
    videobuf_queue_vmalloc_init(& s->vbuf_q, (struct videobuf_queue_ops  const  *)(& cx18_videobuf_qops),
                                & (cx->pci_dev)->dev, & s->vbuf_q_lock, 1, 4, 256U,
                                (void *)s, & cx->serialize_lock);
#line 395
    s->pixelformat = 842091848U;
#line 396
    s->vb_bytes_per_frame = (u32 )(((int )cx->cxhdl.height * 2160) / 2);
  } else {

  }
#line 398
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static int cx18_prep_dev(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  u32 cap ;
  int num_offset ;
  int num ;
  void *tmp ;

  {
#line 402
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 403
  cap = cx->v4l2_cap;
#line 404
  num_offset = cx18_stream_info[type].num_offset;
#line 405
  num = (cx->instance + cx18_first_minor) + num_offset;
#line 414
  s->video_dev = (struct video_device *)0;
#line 415
  s->dvb = (struct cx18_dvb *)0;
#line 416
  s->cx = cx;
#line 417
  s->type = type;
#line 418
  s->name = cx18_stream_info[type].name;
#line 421
  if (type == 6 && (cap & 262144U) == 0U) {
#line 422
    return (0);
  } else {

  }
#line 425
  if (type == 3 && (cap & 80U) == 0U) {
#line 427
    return (0);
  } else {

  }
#line 431
  if (cx18_stream_info[type].dma != 3 && cx->stream_buffers[type] == 0) {
#line 433
    printk("\016%s: Disabled %s device\n", (char *)(& cx->v4l2_dev.name), cx18_stream_info[type].name);
#line 434
    return (0);
  } else {

  }
#line 437
  cx18_stream_init(cx, type);
#line 440
  if (type == 1) {
#line 441
    if (((unsigned int )(cx->card)->hw_all & 8U) != 0U) {
#line 442
      tmp = kzalloc(2264UL, 208U);
#line 442
      s->dvb = (struct cx18_dvb *)tmp;
#line 443
      if ((unsigned long )s->dvb == (unsigned long )((struct cx18_dvb *)0)) {
#line 444
        printk("\v%s: Couldn\'t allocate cx18_dvb structure for %s\n", (char *)(& cx->v4l2_dev.name),
               s->name);
#line 446
        return (-12);
      } else {

      }
    } else {
#line 450
      s->buffers = 0U;
    }
  } else {

  }
#line 454
  if (num_offset == -1) {
#line 455
    return (0);
  } else {

  }
#line 458
  s->video_dev = video_device_alloc();
#line 459
  if ((unsigned long )s->video_dev == (unsigned long )((struct video_device *)0)) {
#line 460
    printk("\v%s: Couldn\'t allocate v4l2 video_device for %s\n", (char *)(& cx->v4l2_dev.name),
           s->name);
#line 462
    return (-12);
  } else {

  }
#line 465
  snprintf((char *)(& (s->video_dev)->name), 32UL, "%s %s", (char *)(& cx->v4l2_dev.name),
           s->name);
#line 468
  (s->video_dev)->num = (u16 )num;
#line 469
  (s->video_dev)->v4l2_dev = & cx->v4l2_dev;
#line 470
  (s->video_dev)->fops = (struct v4l2_file_operations  const  *)(& cx18_v4l2_enc_fops);
#line 471
  (s->video_dev)->release = & video_device_release;
#line 472
  (s->video_dev)->tvnorms = 16777215ULL;
#line 473
  (s->video_dev)->lock = & cx->serialize_lock;
#line 474
  set_bit(2L, (unsigned long volatile   *)(& (s->video_dev)->flags));
#line 475
  cx18_set_funcs(s->video_dev);
#line 476
  return (0);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int cx18_streams_setup(struct cx18 *cx ) 
{ 
  int type ;
  int ret ;

  {
#line 485
  type = 0;
#line 485
  goto ldv_51859;
  ldv_51858: 
#line 487
  ret = cx18_prep_dev(cx, type);
#line 488
  if (ret < 0) {
#line 489
    goto ldv_51857;
  } else {

  }
#line 492
  ret = cx18_stream_alloc((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
#line 493
  if (ret < 0) {
#line 494
    goto ldv_51857;
  } else {

  }
#line 485
  type = type + 1;
  ldv_51859: ;
#line 485
  if (type <= 6) {
#line 487
    goto ldv_51858;
  } else {

  }
  ldv_51857: ;
#line 496
  if (type == 7) {
#line 497
    return (0);
  } else {

  }
#line 500
  cx18_streams_cleanup(cx, 0);
#line 501
  return (ret);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static int cx18_reg_dev(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  int vfl_type ;
  char const   *name ;
  int num ;
  int ret ;
  struct cx18_stream *s_mpg ;

  {
#line 506
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 507
  vfl_type = cx18_stream_info[type].vfl_type;
#line 511
  if (type == 1 && (unsigned long )s->dvb != (unsigned long )((struct cx18_dvb *)0)) {
#line 512
    ret = cx18_dvb_register(s);
#line 513
    if (ret < 0) {
#line 514
      printk("\v%s: DVB failed to register\n", (char *)(& cx->v4l2_dev.name));
#line 515
      return (ret);
    } else {

    }
  } else {

  }
#line 519
  if ((unsigned long )s->video_dev == (unsigned long )((struct video_device *)0)) {
#line 520
    return (0);
  } else {

  }
#line 522
  num = (int )(s->video_dev)->num;
#line 524
  if (type != 0) {
#line 525
    s_mpg = (struct cx18_stream *)(& cx->streams);
#line 527
    if ((unsigned long )s_mpg->video_dev != (unsigned long )((struct video_device *)0)) {
#line 528
      num = (int )(s_mpg->video_dev)->num + cx18_stream_info[type].num_offset;
    } else {

    }
  } else {

  }
#line 531
  video_set_drvdata(s->video_dev, (void *)s);
#line 534
  ret = video_register_device_no_warn(s->video_dev, vfl_type, num);
#line 535
  if (ret < 0) {
#line 536
    printk("\v%s: Couldn\'t register v4l2 device for %s (device node number %d)\n",
           (char *)(& cx->v4l2_dev.name), s->name, num);
#line 538
    video_device_release(s->video_dev);
#line 539
    s->video_dev = (struct video_device *)0;
#line 540
    return (ret);
  } else {

  }
#line 543
  name = video_device_node_name(s->video_dev);
#line 545
  switch (vfl_type) {
  case 0: 
#line 547
  printk("\016%s: Registered device %s for %s (%d x %d.%02d kB)\n", (char *)(& cx->v4l2_dev.name),
         name, s->name, cx->stream_buffers[type], cx->stream_buf_size[type] / 1024,
         ((cx->stream_buf_size[type] * 100) / 1024) % 100);
#line 551
  goto ldv_51871;
  case 2: 
#line 554
  printk("\016%s: Registered device %s for %s\n", (char *)(& cx->v4l2_dev.name), name,
         s->name);
#line 555
  goto ldv_51871;
  case 1: ;
#line 558
  if (cx->stream_buffers[type] != 0) {
#line 559
    printk("\016%s: Registered device %s for %s (%d x %d bytes)\n", (char *)(& cx->v4l2_dev.name),
           name, s->name, cx->stream_buffers[type], cx->stream_buf_size[type]);
  } else {
#line 564
    printk("\016%s: Registered device %s for %s\n", (char *)(& cx->v4l2_dev.name),
           name, s->name);
  }
#line 566
  goto ldv_51871;
  }
  ldv_51871: ;
#line 569
  return (0);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int cx18_streams_register(struct cx18 *cx ) 
{ 
  int type ;
  int err ;
  int ret ;

  {
#line 577
  ret = 0;
#line 580
  type = 0;
#line 580
  goto ldv_51881;
  ldv_51880: 
#line 581
  err = cx18_reg_dev(cx, type);
#line 582
  if (err != 0 && ret == 0) {
#line 583
    ret = err;
  } else {

  }
#line 580
  type = type + 1;
  ldv_51881: ;
#line 580
  if (type <= 6) {
#line 582
    goto ldv_51880;
  } else {

  }

#line 586
  if (ret == 0) {
#line 587
    return (0);
  } else {

  }
#line 590
  cx18_streams_cleanup(cx, 1);
#line 591
  return (ret);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void cx18_streams_cleanup(struct cx18 *cx , int unregister ) 
{ 
  struct video_device *vdev ;
  int type ;

  {
#line 601
  type = 0;
#line 601
  goto ldv_51891;
  ldv_51890: ;
#line 604
  if (type == 1) {
#line 605
    if ((unsigned long )cx->streams[type].dvb != (unsigned long )((struct cx18_dvb *)0)) {
#line 606
      if (unregister != 0) {
#line 607
        cx18_dvb_unregister((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
      } else {

      }
#line 608
      kfree((void const   *)cx->streams[type].dvb);
#line 609
      cx->streams[type].dvb = (struct cx18_dvb *)0;
#line 610
      cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
    } else {

    }
#line 612
    goto ldv_51889;
  } else {

  }
#line 616
  if (type == 5) {
#line 618
    if (cx->stream_buffers[type] != 0) {
#line 619
      cx->stream_buffers[type] = 0;
#line 626
      if (cx->streams[type].buffers != 0U) {
#line 627
        cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
      } else {

      }
    } else {

    }
#line 629
    goto ldv_51889;
  } else {

  }
#line 633
  vdev = cx->streams[type].video_dev;
#line 635
  cx->streams[type].video_dev = (struct video_device *)0;
#line 636
  if ((unsigned long )vdev == (unsigned long )((struct video_device *)0)) {
#line 637
    goto ldv_51889;
  } else {

  }
#line 639
  if (type == 2) {
#line 640
    videobuf_mmap_free(& cx->streams[type].vbuf_q);
  } else {

  }
#line 642
  cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
#line 645
  if (unregister != 0) {
#line 646
    video_unregister_device(vdev);
  } else {
#line 648
    video_device_release(vdev);
  }
  ldv_51889: 
#line 601
  type = type + 1;
  ldv_51891: ;
#line 601
  if (type <= 6) {
#line 603
    goto ldv_51890;
  } else {

  }

#line 608
  return;
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void cx18_vbi_setup(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  int raw ;
  int tmp ;
  u32 data[16U] ;
  int lines ;

  {
#line 654
  cx = s->cx;
#line 655
  tmp = cx18_raw_vbi((struct cx18  const  *)cx);
#line 655
  raw = tmp;
#line 659
  if ((unsigned int )cx->is_60hz != 0U) {
#line 660
    cx->vbi.count = 12U;
#line 661
    cx->vbi.start[0] = 10U;
#line 662
    cx->vbi.start[1] = 273U;
  } else {
#line 664
    cx->vbi.count = 18U;
#line 665
    cx->vbi.start[0] = 6U;
#line 666
    cx->vbi.start[1] = 318U;
  }
#line 670
  if (raw != 0) {
#line 671
    if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 671
      if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct v4l2_vbi_format * ))0)) {
#line 671
        (*((((cx->sd_av)->ops)->vbi)->s_raw_fmt))(cx->sd_av, & cx->vbi.in.fmt.vbi);
      } else {

      }
    } else {

    }
  } else
#line 673
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 673
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             struct v4l2_sliced_vbi_format * ))0)) {
#line 673
      (*((((cx->sd_av)->ops)->vbi)->s_sliced_fmt))(cx->sd_av, & cx->vbi.in.fmt.sliced);
    } else {

    }
  } else {

  }
#line 683
  if (raw != 0) {
#line 684
    lines = (int )(cx->vbi.count * 2U);
  } else {
#line 700
    lines = (unsigned int )cx->is_60hz != 0U ? 36 : 44;
  }
#line 703
  data[0] = s->handle;
#line 705
  data[1] = (u32 )(lines / 2 | (lines / 2 << 16));
#line 707
  data[2] = raw == 0 ? ((unsigned int )cx->is_60hz != 0U ? vbi_hblank_samples_60Hz : vbi_hblank_samples_50Hz) : vbi_active_samples___0;
#line 712
  data[3] = 1U;
#line 717
  if (raw != 0) {
#line 723
    data[4] = 543170656U;
#line 731
    data[5] = 812683472U;
  } else {
#line 747
    data[4] = 2968563952U;
#line 753
    data[5] = 2699075808U;
  }
#line 756
  if ((cx18_debug & 2) != 0) {
#line 756
    printk("\016%s:  info: Setup VBI h: %d lines %x bpl %d fr %d %x %x\n", (char *)(& cx->v4l2_dev.name),
           data[0], data[1], data[2], data[3], data[4], data[5]);
  } else {

  }
#line 759
  cx18_api(cx, 537002006U, 6, (u32 *)(& data));
#line 760
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void cx18_stream_rotate_idx_mdls(struct cx18 *cx ) 
{ 
  struct cx18_stream *s ;
  struct cx18_mdl *mdl ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 764
  s = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 767
  tmp = cx18_stream_enabled(s);
#line 767
  if (tmp) {
#line 767
    tmp___0 = 0;
  } else {
#line 767
    tmp___0 = 1;
  }
#line 767
  if (tmp___0) {
#line 768
    return;
  } else {

  }
#line 771
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_free.depth));
#line 771
  tmp___2 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 771
  if (tmp___1 + tmp___2 > 2) {
#line 773
    return;
  } else {

  }
#line 776
  tmp___3 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 776
  if (tmp___3 <= 1) {
#line 777
    return;
  } else {

  }
#line 783
  mdl = cx18_dequeue(s, & s->q_full);
#line 784
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 785
    cx18_enqueue(s, mdl, & s->q_free);
  } else {

  }
#line 786
  return;
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static struct cx18_queue *_cx18_stream_put_mdl_fw(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18 *cx ;
  struct cx18_queue *q ;
  struct cx18_queue *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 792
  cx = s->cx;
#line 796
  if (s->handle == 4294967295U) {
#line 799
    tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 799
    return (tmp);
  } else {
#line 796
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& s->s_flags));
#line 796
    if (tmp___0 != 0) {
#line 799
      tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 799
      return (tmp);
    } else {
#line 796
      tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 796
      if (tmp___1 == 0) {
#line 799
        tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 799
        return (tmp);
      } else {

      }
    }
  }
#line 801
  q = cx18_enqueue(s, mdl, & s->q_busy);
#line 802
  if ((unsigned long )(& s->q_busy) != (unsigned long )q) {
#line 803
    return (q);
  } else {

  }
#line 805
  cx18_mdl_sync_for_device(s, mdl);
#line 806
  cx18_vapi(cx, 537133061U, 5, s->handle, (long )((void *)(& (cx->scb)->cpu_mdl) + (unsigned long )mdl->id) - (long )cx->enc_mem,
            s->bufs_per_mdl, mdl->id, s->mdl_size);
#line 809
  return (q);
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void _cx18_stream_load_fw_queue(struct cx18_stream *s ) 
{ 
  struct cx18_queue *q ;
  struct cx18_mdl *mdl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 818
  tmp = atomic_read((atomic_t const   *)(& s->q_free.depth));
#line 818
  if (tmp == 0) {
#line 820
    return;
  } else {
#line 818
    tmp___0 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 818
    if (tmp___0 > 62) {
#line 820
      return;
    } else {

    }
  }
  ldv_51917: 
#line 824
  mdl = cx18_dequeue(s, & s->q_free);
#line 825
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 826
    goto ldv_51916;
  } else {

  }
#line 827
  q = _cx18_stream_put_mdl_fw(s, mdl);
#line 829
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 829
  if (tmp___1 <= 62 && (unsigned long )(& s->q_busy) == (unsigned long )q) {
#line 831
    goto ldv_51917;
  } else {

  }
  ldv_51916: ;
#line 836
  return;
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void cx18_out_work_handler(struct work_struct *work ) 
{ 
  struct cx18_stream *s ;
  struct work_struct  const  *__mptr ;

  {
#line 835
  __mptr = (struct work_struct  const  *)work;
#line 835
  s = (struct cx18_stream *)__mptr + 0xfffffffffffffdc8UL;
#line 837
  _cx18_stream_load_fw_queue(s);
#line 838
  return;
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static void cx18_stream_configure_mdls(struct cx18_stream *s ) 
{ 
  int tmp ;

  {
#line 842
  cx18_unload_queues(s);
#line 844
  switch (s->type) {
  case 2: ;
#line 851
  if (s->pixelformat == 842091848U) {
#line 852
    s->mdl_size = (u32 )(((int )(s->cx)->cxhdl.height * 2160) / 2);
  } else {
#line 854
    s->mdl_size = (u32 )((int )(s->cx)->cxhdl.height * 1440);
  }
#line 855
  s->bufs_per_mdl = s->mdl_size / s->buf_size;
#line 856
  if (s->mdl_size % s->buf_size != 0U) {
#line 857
    s->bufs_per_mdl = s->bufs_per_mdl + 1U;
  } else {

  }
#line 858
  goto ldv_51928;
  case 3: 
#line 860
  s->bufs_per_mdl = 1U;
#line 861
  tmp = cx18_raw_vbi((struct cx18  const  *)s->cx);
#line 861
  if (tmp != 0) {
#line 862
    s->mdl_size = ((unsigned int )(s->cx)->is_60hz != 0U ? 24U : 36U) * (unsigned int )vbi_active_samples___0;
  } else {
#line 870
    s->mdl_size = (unsigned int )(s->cx)->is_60hz != 0U ? (unsigned int )vbi_hblank_samples_60Hz * 36U : (unsigned int )vbi_hblank_samples_50Hz * 44U;
  }
#line 874
  goto ldv_51928;
  default: 
#line 876
  s->bufs_per_mdl = 1U;
#line 877
  s->mdl_size = s->buf_size * s->bufs_per_mdl;
#line 878
  goto ldv_51928;
  }
  ldv_51928: 
#line 881
  cx18_load_queues(s);
#line 882
  return;
}
}
#line 884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int cx18_start_v4l2_encode_stream(struct cx18_stream *s ) 
{ 
  u32 data[6U] ;
  struct cx18 *cx ;
  int captype ;
  struct cx18_stream *s_idx ;
  bool tmp ;
  int tmp___0 ;
  u64 tmp___1 ;
  s32 tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  s32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 887
  cx = s->cx;
#line 888
  captype = 0;
#line 891
  tmp = cx18_stream_enabled(s);
#line 891
  if (tmp) {
#line 891
    tmp___0 = 0;
  } else {
#line 891
    tmp___0 = 1;
  }
#line 891
  if (tmp___0) {
#line 892
    return (-22);
  } else {

  }
#line 894
  if ((cx18_debug & 2) != 0) {
#line 894
    printk("\016%s:  info: Start encoder stream %s\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 896
  switch (s->type) {
  case 0: 
#line 898
  captype = 1;
#line 899
  tmp___1 = 0ULL;
#line 899
  cx->vbi_data_inserted = tmp___1;
#line 899
  cx->mpg_data_received = tmp___1;
#line 900
  cx->dualwatch_jiffies = jiffies;
#line 901
  tmp___2 = v4l2_ctrl_g_ctrl(cx->cxhdl.ldv_36957.audio_mode);
#line 901
  cx->dualwatch_stereo_mode = (u32 )tmp___2;
#line 902
  cx->search_pack_header = 0;
#line 903
  goto ldv_51939;
  case 5: 
#line 906
  captype = 2;
#line 907
  goto ldv_51939;
  case 1: 
#line 909
  captype = 7;
#line 910
  goto ldv_51939;
  case 2: 
#line 912
  captype = 3;
#line 913
  goto ldv_51939;
  case 4: 
#line 915
  captype = 4;
#line 916
  goto ldv_51939;
  case 3: 
#line 926
  captype = 5;
#line 928
  cx->vbi.frame = 0U;
#line 929
  cx->vbi.inserted_frame = 0U;
#line 930
  memset((void *)(& cx->vbi.sliced_mpeg_size), 0, 128UL);
#line 932
  goto ldv_51939;
  default: ;
#line 934
  return (-22);
  }
  ldv_51939: 
#line 938
  clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 940
  cx18_vapi_result(cx, (u32 *)(& data), 1073741825U, 1, 537001984);
#line 941
  s->handle = data[0];
#line 942
  cx18_vapi(cx, 537001985U, 2, s->handle, captype);
#line 955
  if (captype != 7) {
#line 956
    cx18_vapi(cx, 537002011U, 2, s->handle, 0);
#line 957
    cx18_vapi(cx, 537002005U, 3, s->handle, 3, 1);
#line 958
    cx18_vapi(cx, 537002005U, 3, s->handle, 8, 0);
#line 959
    cx18_vapi(cx, 537002005U, 3, s->handle, 4, 1);
#line 965
    tmp___3 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 965
    if (tmp___3 == 0) {
#line 966
      cx18_vapi(cx, 537002005U, 2, s->handle, 12);
    } else {

    }
#line 975
    cx18_vapi(cx, 537002007U, 3, s->handle, 312, 313);
#line 978
    if ((cx->v4l2_cap & 16U) != 0U) {
#line 979
      cx18_vbi_setup(s);
    } else {

    }
#line 986
    s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 987
    tmp___4 = cx18_stream_enabled(s_idx);
#line 987
    cx18_vapi_result(cx, (u32 *)(& data), 537002000U, 2, s->handle, (int )tmp___4 ? 7 : 0);
#line 991
    cx->cxhdl.priv = (void *)s;
#line 992
    cx2341x_handler_setup(& cx->cxhdl);
#line 998
    if ((unsigned long )cx->cxhdl.ldv_36972.video_mute == (unsigned long )((struct v4l2_ctrl *)0)) {
#line 998
      tmp___6 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 998
      if (tmp___6 != 0) {
#line 1000
        tmp___5 = v4l2_ctrl_g_ctrl(cx->cxhdl.ldv_36972.video_mute_yuv);
#line 1000
        cx18_vapi(cx, 537002003U, 2, s->handle, (tmp___5 << 8) | 1);
      } else {

      }
    } else {

    }
#line 1006
    if (captype == 3) {
#line 1007
      if (s->pixelformat == 1498831189U) {
#line 1008
        cx18_vapi(cx, 537002019U, 2, s->handle, 1);
      } else {
#line 1012
        cx18_vapi(cx, 537002019U, 2, s->handle, 0);
      }
    } else {

    }
  } else {

  }
#line 1017
  tmp___7 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1017
  if (tmp___7 == 0) {
#line 1018
    cx2341x_handler_set_busy(& cx->cxhdl, 1);
#line 1019
    clear_bit(4L, (unsigned long volatile   *)(& cx->i_flags));
#line 1020
    cx18_write_reg(cx, 7U, 13631564U);
  } else {

  }
#line 1023
  cx18_vapi(cx, 537133058U, 3, s->handle, (long )((void *)(& (cx->scb)->cpu_mdl_ack) + (unsigned long )s->type) - (long )cx->enc_mem,
            (long )((void *)(& (cx->scb)->cpu_mdl_ack) + ((unsigned long )s->type + 1UL)) - (long )cx->enc_mem);
#line 1028
  cx18_stream_configure_mdls(s);
#line 1029
  _cx18_stream_load_fw_queue(s);
#line 1032
  tmp___9 = cx18_vapi(cx, 537001986U, 1, s->handle);
#line 1032
  if (tmp___9 != 0) {
#line 1033
    if (cx18_debug & 1) {
#line 1033
      printk("\016%s:  warning: Error starting capture!\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 1035
    set_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 1036
    if (s->type == 0) {
#line 1037
      cx18_vapi(cx, 537001987U, 2, s->handle, 1);
    } else {
#line 1039
      cx18_vapi(cx, 537001987U, 1, s->handle);
    }
#line 1040
    clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 1042
    cx18_vapi(cx, 537133062U, 1, s->handle);
#line 1043
    cx18_vapi(cx, 1073741826U, 1, s->handle);
#line 1044
    s->handle = 4294967295U;
#line 1045
    clear_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 1046
    tmp___8 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1046
    if (tmp___8 == 0) {
#line 1047
      set_bit(4L, (unsigned long volatile   *)(& cx->i_flags));
#line 1048
      cx18_write_reg(cx, 5U, 13631564U);
    } else {

    }
#line 1050
    return (-22);
  } else {

  }
#line 1054
  if (captype != 7) {
#line 1055
    atomic_inc(& cx->ana_capturing);
  } else {

  }
#line 1056
  atomic_inc(& cx->tot_capturing);
#line 1057
  return (0);
}
}
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static char const   __kstrtab_cx18_start_v4l2_encode_stream[30U]  = 
#line 1059
  {      'c',      'x',      '1',      '8', 
        '_',      's',      't',      'a', 
        'r',      't',      '_',      'v', 
        '4',      'l',      '2',      '_', 
        'e',      'n',      'c',      'o', 
        'd',      'e',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 1059
struct kernel_symbol  const  __ksymtab_cx18_start_v4l2_encode_stream ;
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_start_v4l2_encode_stream  =    {(unsigned long )(& cx18_start_v4l2_encode_stream), (char const   *)(& __kstrtab_cx18_start_v4l2_encode_stream)};
#line 1061 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void cx18_stop_all_captures(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_stream *s ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1065
  i = 6;
#line 1065
  goto ldv_51960;
  ldv_51959: 
#line 1066
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1068
  tmp = cx18_stream_enabled(s);
#line 1068
  if (tmp) {
#line 1068
    tmp___0 = 0;
  } else {
#line 1068
    tmp___0 = 1;
  }
#line 1068
  if (tmp___0) {
#line 1069
    goto ldv_51958;
  } else {

  }
#line 1070
  tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 1070
  if (tmp___1 != 0) {
#line 1071
    cx18_stop_v4l2_encode_stream(s, 0);
  } else {

  }
  ldv_51958: 
#line 1065
  i = i - 1;
  ldv_51960: ;
#line 1065
  if (i >= 0) {
#line 1067
    goto ldv_51959;
  } else {

  }

#line 1072
  return;
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int cx18_stop_v4l2_encode_stream(struct cx18_stream *s , int gop_end ) 
{ 
  struct cx18 *cx ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1077
  cx = s->cx;
#line 1079
  tmp = cx18_stream_enabled(s);
#line 1079
  if (tmp) {
#line 1079
    tmp___0 = 0;
  } else {
#line 1079
    tmp___0 = 1;
  }
#line 1079
  if (tmp___0) {
#line 1080
    return (-22);
  } else {

  }
#line 1085
  if ((cx18_debug & 2) != 0) {
#line 1085
    printk("\016%s:  info: Stop Capture\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1087
  tmp___1 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1087
  if (tmp___1 == 0) {
#line 1088
    return (0);
  } else {

  }
#line 1090
  set_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 1091
  if (s->type == 0) {
#line 1092
    cx18_vapi(cx, 537001987U, 2, s->handle, gop_end == 0);
  } else {
#line 1094
    cx18_vapi(cx, 537001987U, 1, s->handle);
  }
#line 1096
  if (s->type == 0 && gop_end != 0) {
#line 1097
    printk("\016%s: ignoring gop_end: not (yet?) supported by the firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1100
  if (s->type != 1) {
#line 1101
    atomic_dec(& cx->ana_capturing);
  } else {

  }
#line 1102
  atomic_dec(& cx->tot_capturing);
#line 1105
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 1108
  cx18_vapi(cx, 537133062U, 1, s->handle);
#line 1110
  cx18_vapi(cx, 1073741826U, 1, s->handle);
#line 1111
  s->handle = 4294967295U;
#line 1112
  clear_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 1114
  tmp___2 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1114
  if (tmp___2 > 0) {
#line 1115
    return (0);
  } else {

  }
#line 1117
  cx2341x_handler_set_busy(& cx->cxhdl, 0);
#line 1118
  cx18_write_reg(cx, 5U, 13631564U);
#line 1119
  __wake_up(& s->waitq, 3U, 1, (void *)0);
#line 1121
  return (0);
}
}
#line 1123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
static char const   __kstrtab_cx18_stop_v4l2_encode_stream[29U]  = 
#line 1123
  {      'c',      'x',      '1',      '8', 
        '_',      's',      't',      'o', 
        'p',      '_',      'v',      '4', 
        'l',      '2',      '_',      'e', 
        'n',      'c',      'o',      'd', 
        'e',      '_',      's',      't', 
        'r',      'e',      'a',      'm', 
        '\000'};
#line 1123
struct kernel_symbol  const  __ksymtab_cx18_stop_v4l2_encode_stream ;
#line 1123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_stop_v4l2_encode_stream  =    {(unsigned long )(& cx18_stop_v4l2_encode_stream), (char const   *)(& __kstrtab_cx18_stop_v4l2_encode_stream)};
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
u32 cx18_find_handle(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_stream *s ;

  {
#line 1130
  i = 0;
#line 1130
  goto ldv_51981;
  ldv_51980: 
#line 1131
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1133
  if ((unsigned long )s->video_dev != (unsigned long )((struct video_device *)0) && s->handle != 4294967295U) {
#line 1134
    return (s->handle);
  } else {

  }
#line 1130
  i = i + 1;
  ldv_51981: ;
#line 1130
  if (i <= 6) {
#line 1132
    goto ldv_51980;
  } else {

  }

#line 1136
  return (4294967295U);
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct cx18_stream *cx18_handle_to_stream(struct cx18 *cx , u32 handle ) 
{ 
  int i ;
  struct cx18_stream *s ;
  bool tmp ;

  {
#line 1144
  if (handle == 4294967295U) {
#line 1145
    return ((struct cx18_stream *)0);
  } else {

  }
#line 1147
  i = 0;
#line 1147
  goto ldv_51991;
  ldv_51990: 
#line 1148
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1149
  if (s->handle != handle) {
#line 1150
    goto ldv_51989;
  } else {

  }
#line 1151
  tmp = cx18_stream_enabled(s);
#line 1151
  if ((int )tmp) {
#line 1152
    return (s);
  } else {

  }
  ldv_51989: 
#line 1147
  i = i + 1;
  ldv_51991: ;
#line 1147
  if (i <= 6) {
#line 1149
    goto ldv_51990;
  } else {

  }

#line 1154
  return ((struct cx18_stream *)0);
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_retval_3  ;
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_retval_2  ;
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_initialize_v4l2_file_operations_14(void) 
{ 
  void *tmp ;

  {
#line 1162
  tmp = ldv_zalloc(512UL);
#line 1162
  cx18_v4l2_enc_fops_group0 = (struct file *)tmp;
#line 1163
  return;
}
}
#line 1165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 1166
  LDV_IN_INTERRUPT = 2;
#line 1167
  (*(timer->function))(timer->data);
#line 1168
  LDV_IN_INTERRUPT = 1;
#line 1169
  ldv_timer_state_2 = 2;
#line 1170
  return;
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 1174
  ldv_timer_list_2 = timer;
#line 1175
  ldv_timer_state_2 = 1;
#line 1176
  return (0);
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1179
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 1180
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 1181
      ldv_timer_list_2 = timer;
#line 1182
      ldv_timer_list_2->data = data;
#line 1183
      ldv_timer_state_2 = 1;
    } else {

    }
#line 1185
    return;
  } else {

  }
#line 1187
  reg_timer_2(timer);
#line 1188
  ldv_timer_list_2->data = data;
#line 1189
  return;
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_videobuf_queue_ops_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1193
  tmp = ldv_zalloc(616UL);
#line 1193
  cx18_videobuf_qops_group1 = (struct videobuf_queue *)tmp;
#line 1194
  tmp___0 = ldv_zalloc(240UL);
#line 1194
  cx18_videobuf_qops_group2 = (struct videobuf_buffer *)tmp___0;
#line 1195
  return;
}
}
#line 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 1199
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 1200
    ldv_timer_state_2 = 0;
#line 1201
    return;
  } else {

  }
#line 1203
  return;
}
}
#line 1206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  enum v4l2_field ldvarg16 ;
  unsigned int *ldvarg17 ;
  void *tmp ;
  unsigned int *ldvarg18 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1208
  tmp = ldv_zalloc(4UL);
#line 1208
  ldvarg17 = (unsigned int *)tmp;
#line 1209
  tmp___0 = ldv_zalloc(4UL);
#line 1209
  ldvarg18 = (unsigned int *)tmp___0;
#line 1207
  memset((void *)(& ldvarg16), 0, 4UL);
#line 1211
  tmp___1 = __VERIFIER_nondet_int();
#line 1211
  switch (tmp___1) {
  case 0: ;
#line 1214
  if (ldv_state_variable_13 == 1) {
#line 1216
    buffer_setup(cx18_videobuf_qops_group1, ldvarg18, ldvarg17);
#line 1218
    ldv_state_variable_13 = 1;
  } else {

  }
#line 1221
  if (ldv_state_variable_13 == 2) {
#line 1223
    buffer_setup(cx18_videobuf_qops_group1, ldvarg18, ldvarg17);
#line 1225
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1228
  goto ldv_52022;
  case 1: ;
#line 1231
  if (ldv_state_variable_13 == 2) {
#line 1233
    buffer_release(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 1235
    ldv_state_variable_13 = 1;
#line 1236
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1239
  goto ldv_52022;
  case 2: ;
#line 1242
  if (ldv_state_variable_13 == 1) {
#line 1244
    buffer_queue(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 1246
    ldv_state_variable_13 = 1;
  } else {

  }
#line 1249
  if (ldv_state_variable_13 == 2) {
#line 1251
    buffer_queue(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 1253
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1256
  goto ldv_52022;
  case 3: ;
#line 1259
  if (ldv_state_variable_13 == 1) {
#line 1261
    ldv_retval_2 = buffer_prepare(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2,
                                  ldvarg16);
#line 1263
    if (ldv_retval_2 == 0) {
#line 1264
      ldv_state_variable_13 = 2;
#line 1265
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1269
  goto ldv_52022;
  default: 
#line 1270
  ldv_stop();
  }
  ldv_52022: ;
#line 1274
  return;
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  loff_t *ldvarg103 ;
  void *tmp ;
  unsigned long ldvarg100 ;
  unsigned long tmp___0 ;
  char *ldvarg105 ;
  void *tmp___1 ;
  unsigned int ldvarg101 ;
  unsigned int tmp___2 ;
  struct vm_area_struct *ldvarg106 ;
  void *tmp___3 ;
  struct poll_table_struct *ldvarg102 ;
  void *tmp___4 ;
  size_t ldvarg104 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1278
  tmp = ldv_zalloc(8UL);
#line 1278
  ldvarg103 = (loff_t *)tmp;
#line 1279
  tmp___0 = __VERIFIER_nondet_ulong();
#line 1279
  ldvarg100 = tmp___0;
#line 1280
  tmp___1 = ldv_zalloc(1UL);
#line 1280
  ldvarg105 = (char *)tmp___1;
#line 1281
  tmp___2 = __VERIFIER_nondet_uint();
#line 1281
  ldvarg101 = tmp___2;
#line 1282
  tmp___3 = ldv_zalloc(184UL);
#line 1282
  ldvarg106 = (struct vm_area_struct *)tmp___3;
#line 1283
  tmp___4 = ldv_zalloc(16UL);
#line 1283
  ldvarg102 = (struct poll_table_struct *)tmp___4;
#line 1284
  tmp___5 = __VERIFIER_nondet_size_t();
#line 1284
  ldvarg104 = tmp___5;
#line 1286
  tmp___6 = __VERIFIER_nondet_int();
#line 1286
  switch (tmp___6) {
  case 0: ;
#line 1289
  if (ldv_state_variable_14 == 1) {
#line 1291
    cx18_v4l2_mmap(cx18_v4l2_enc_fops_group0, ldvarg106);
#line 1293
    ldv_state_variable_14 = 1;
  } else {

  }
#line 1296
  if (ldv_state_variable_14 == 2) {
#line 1298
    cx18_v4l2_mmap(cx18_v4l2_enc_fops_group0, ldvarg106);
#line 1300
    ldv_state_variable_14 = 2;
  } else {

  }
#line 1303
  goto ldv_52038;
  case 1: ;
#line 1306
  if (ldv_state_variable_14 == 2) {
#line 1308
    cx18_v4l2_close(cx18_v4l2_enc_fops_group0);
#line 1310
    ldv_state_variable_14 = 1;
#line 1311
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1314
  goto ldv_52038;
  case 2: ;
#line 1317
  if (ldv_state_variable_14 == 2) {
#line 1319
    cx18_v4l2_read(cx18_v4l2_enc_fops_group0, ldvarg105, ldvarg104, ldvarg103);
#line 1321
    ldv_state_variable_14 = 2;
  } else {

  }
#line 1324
  goto ldv_52038;
  case 3: ;
#line 1327
  if (ldv_state_variable_14 == 1) {
#line 1329
    cx18_v4l2_enc_poll(cx18_v4l2_enc_fops_group0, ldvarg102);
#line 1331
    ldv_state_variable_14 = 1;
  } else {

  }
#line 1334
  if (ldv_state_variable_14 == 2) {
#line 1336
    cx18_v4l2_enc_poll(cx18_v4l2_enc_fops_group0, ldvarg102);
#line 1338
    ldv_state_variable_14 = 2;
  } else {

  }
#line 1341
  goto ldv_52038;
  case 4: ;
#line 1344
  if (ldv_state_variable_14 == 1) {
#line 1346
    ldv_retval_3 = cx18_v4l2_open(cx18_v4l2_enc_fops_group0);
#line 1348
    if (ldv_retval_3 == 0) {
#line 1349
      ldv_state_variable_14 = 2;
#line 1350
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1354
  goto ldv_52038;
  case 5: ;
#line 1357
  if (ldv_state_variable_14 == 1) {
#line 1359
    video_ioctl2(cx18_v4l2_enc_fops_group0, ldvarg101, ldvarg100);
#line 1361
    ldv_state_variable_14 = 1;
  } else {

  }
#line 1364
  if (ldv_state_variable_14 == 2) {
#line 1366
    video_ioctl2(cx18_v4l2_enc_fops_group0, ldvarg101, ldvarg100);
#line 1368
    ldv_state_variable_14 = 2;
  } else {

  }
#line 1371
  goto ldv_52038;
  default: 
#line 1372
  ldv_stop();
  }
  ldv_52038: ;
#line 1376
  return;
}
}
#line 1504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void *ldv_kmem_cache_alloc_274(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1507
  ldv_check_alloc_flags(flags);
#line 1509
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1510
  return ((void *)0);
}
}
#line 1548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1551
  ldv_check_alloc_flags(flags);
#line 1553
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1553
  return (tmp);
}
}
#line 1564 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv_skb_clone_282(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1567
  ldv_check_alloc_flags(flags);
#line 1569
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1569
  return (tmp);
}
}
#line 1580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv_skb_copy_284(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1583
  ldv_check_alloc_flags(flags);
#line 1585
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1585
  return (tmp);
}
}
#line 1588 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_285(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1591
  ldv_check_alloc_flags(flags);
#line 1593
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1593
  return (tmp);
}
}
#line 1596 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_286(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1599
  ldv_check_alloc_flags(flags);
#line 1601
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1601
  return (tmp);
}
}
#line 1604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_287(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1607
  ldv_check_alloc_flags(flags);
#line 1609
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1609
  return (tmp);
}
}
#line 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_pskb_expand_head_288(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1615
  ldv_check_alloc_flags(flags);
#line 1617
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1617
  return (tmp);
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_pskb_expand_head_289(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1623
  ldv_check_alloc_flags(flags);
#line 1625
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1625
  return (tmp);
}
}
#line 1628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
struct sk_buff *ldv_skb_clone_290(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1631
  ldv_check_alloc_flags(flags);
#line 1633
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1633
  return (tmp);
}
}
#line 1 "<compiler builtins>"
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 230 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 112 "include/linux/list.h"
extern void list_del(struct list_head * ) ;
#line 114 "include/linux/string.h"
extern void *memchr(void const   * , int  , __kernel_size_t  ) ;
#line 43 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 372 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_308(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 374
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
#line 375
  return;
}
}
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 821 "include/linux/wait.h"
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 824
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 826
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_316(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 381 "include/linux/sched.h"
extern void schedule(void) ;
#line 647 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 723 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 725
  tmp = __builtin_object_size(from, 0);
#line 725
  sz = (int )tmp;
#line 727
  might_fault();
#line 730
  tmp___0 = ldv__builtin_expect(sz < 0, 1L);
#line 730
  if (tmp___0 != 0L) {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 730
    tmp___1 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 730
    if (tmp___1 != 0L) {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
    } else {
#line 735
      __copy_to_user_overflow();
    }
  }
#line 737
  return (n);
}
}
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 209 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 211
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 211
  return (tmp);
}
}
#line 219
extern struct video_device *video_devdata(struct file * ) ;
#line 60 "include/media/v4l2-fh.h"
extern void v4l2_fh_init(struct v4l2_fh * , struct video_device * ) ;
#line 65
extern void v4l2_fh_add(struct v4l2_fh * ) ;
#line 78
extern void v4l2_fh_del(struct v4l2_fh * ) ;
#line 85
extern void v4l2_fh_exit(struct v4l2_fh * ) ;
#line 97
extern int v4l2_fh_is_singular(struct v4l2_fh * ) ;
#line 102 "include/media/v4l2-fh.h"
__inline static int v4l2_fh_is_singular_file(struct file *filp ) 
{ 
  int tmp ;

  {
#line 104
  tmp = v4l2_fh_is_singular((struct v4l2_fh *)filp->private_data);
#line 104
  return (tmp);
}
}
#line 618 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_s_ctrl(struct v4l2_ctrl * , s32  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_324(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_332(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_326(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 216 "include/media/videobuf-core.h"
extern ssize_t videobuf_read_stream(struct videobuf_queue * , char * , size_t  , loff_t * ,
                                    int  , int  ) ;
#line 222
extern unsigned int videobuf_poll_stream(struct file * , struct videobuf_queue * ,
                                         poll_table * ) ;
#line 233
extern int videobuf_mmap_mapper(struct videobuf_queue * , struct vm_area_struct * ) ;
#line 434 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18_open_id *fh2id(struct v4l2_fh *fh ) 
{ 
  struct v4l2_fh  const  *__mptr ;

  {
#line 436
  __mptr = (struct v4l2_fh  const  *)fh;
#line 436
  return ((struct cx18_open_id *)__mptr);
}
}
#line 439 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18_open_id *file2id(struct file *file ) 
{ 
  struct cx18_open_id *tmp ;

  {
#line 441
  tmp = fh2id((struct v4l2_fh *)file->private_data);
#line 441
  return (tmp);
}
}
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-fileops.h"
int cx18_start_capture(struct cx18_open_id *id ) ;
#line 33
void cx18_stop_capture(struct cx18_open_id *id , int gop_end ) ;
#line 34
void cx18_mute(struct cx18 *cx ) ;
#line 35
void cx18_unmute(struct cx18 *cx ) ;
#line 40
int cx18_claim_stream(struct cx18_open_id *id , int type ) ;
#line 41
void cx18_release_stream(struct cx18_stream *s ) ;
#line 59 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_mdl_swap(struct cx18_mdl *mdl ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 61
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 61
  if (tmp != 0) {
#line 62
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 62
    cx18_buf_swap((struct cx18_buffer *)__mptr);
  } else {
#line 65
    _cx18_mdl_swap(mdl);
  }
#line 66
  return;
}
}
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-vbi.h"
void cx18_process_vbi_data(struct cx18 *cx , struct cx18_mdl *mdl , int streamtype ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-audio.h"
int cx18_audio_set_io(struct cx18 *cx ) ;
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_load_fw_queue(struct cx18_stream *s ) 
{ 


  {
#line 45
  schedule_work(& s->out_work_order);
#line 46
  return;
}
}
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_put_mdl_fw(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 


  {
#line 52
  cx18_enqueue(s, mdl, & s->q_free);
#line 53
  cx18_stream_load_fw_queue(s);
#line 54
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int cx18_claim_stream(struct cx18_open_id *id , int type ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_assoc ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 141
  cx = id->cx;
#line 142
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 146
  if (type == 5) {
#line 147
    printk("\f%s: MPEG Index stream cannot be claimed directly, but something tried.\n",
           (char *)(& cx->v4l2_dev.name));
#line 149
    return (-22);
  } else {

  }
#line 152
  tmp = test_and_set_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 152
  if (tmp != 0) {
#line 154
    if (s->id == id->open_id) {
#line 156
      return (0);
    } else {

    }
#line 158
    if (s->id == 4294967295U && type == 3) {
#line 162
      s->id = id->open_id;
#line 163
      if ((cx18_debug & 2) != 0) {
#line 163
        printk("\016%s:  info: Start Read VBI\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 164
      return (0);
    } else {

    }
#line 167
    if ((cx18_debug & 2) != 0) {
#line 167
      printk("\016%s:  info: Stream %d is busy\n", (char *)(& cx->v4l2_dev.name),
             type);
    } else {

    }
#line 168
    return (-16);
  } else {

  }
#line 170
  s->id = id->open_id;
#line 180
  if (type != 0) {
#line 181
    return (0);
  } else {

  }
#line 183
  s_assoc = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 184
  if (cx->vbi.insert_mpeg != 0) {
#line 184
    tmp___2 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 184
    if (tmp___2 == 0) {
#line 185
      s_assoc = (struct cx18_stream *)(& cx->streams) + 3UL;
    } else {
#line 184
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 186
    tmp___0 = cx18_stream_enabled(s_assoc);
#line 186
    if (tmp___0) {
#line 186
      tmp___1 = 0;
    } else {
#line 186
      tmp___1 = 1;
    }
#line 186
    if (tmp___1) {
#line 187
      return (0);
    } else {

    }
  }
#line 189
  set_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 192
  set_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 193
  return (0);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static char const   __kstrtab_cx18_claim_stream[18U]  = 
#line 195
  {      'c',      'x',      '1',      '8', 
        '_',      'c',      'l',      'a', 
        'i',      'm',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 195
struct kernel_symbol  const  __ksymtab_cx18_claim_stream ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_claim_stream  =    {(unsigned long )(& cx18_claim_stream), (char const   *)(& __kstrtab_cx18_claim_stream)};
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void cx18_release_stream(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s_assoc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 201
  cx = s->cx;
#line 204
  s->id = 4294967295U;
#line 205
  if (s->type == 5) {
#line 210
    return;
  } else {

  }
#line 213
  if (s->type == 3) {
#line 213
    tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 213
    if (tmp != 0) {
#line 216
      return;
    } else {

    }
  } else {

  }
#line 218
  tmp___0 = test_and_clear_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 218
  if (tmp___0 == 0) {
#line 219
    if (cx18_debug & 1) {
#line 219
      printk("\016%s:  warning: Release stream %s not in use!\n", (char *)(& cx->v4l2_dev.name),
             s->name);
    } else {

    }
#line 220
    return;
  } else {

  }
#line 223
  cx18_flush_queues(s);
#line 231
  if (s->type != 0) {
#line 232
    return;
  } else {

  }
#line 235
  s_assoc = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 236
  tmp___1 = test_and_clear_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 236
  if (tmp___1 != 0) {
#line 237
    clear_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 238
    cx18_flush_queues(s_assoc);
  } else {

  }
#line 242
  s_assoc = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 243
  tmp___2 = test_and_clear_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 243
  if (tmp___2 != 0) {
#line 244
    if (s_assoc->id == 4294967295U) {
#line 249
      clear_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 250
      cx18_flush_queues(s_assoc);
    } else {

    }
  } else {

  }
#line 252
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static char const   __kstrtab_cx18_release_stream[20U]  = 
#line 254
  {      'c',      'x',      '1',      '8', 
        '_',      'r',      'e',      'l', 
        'e',      'a',      's',      'e', 
        '_',      's',      't',      'r', 
        'e',      'a',      'm',      '\000'};
#line 254
struct kernel_symbol  const  __ksymtab_cx18_release_stream ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct kernel_symbol  const  __ksymtab_cx18_release_stream  =    {(unsigned long )(& cx18_release_stream), (char const   *)(& __kstrtab_cx18_release_stream)};
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static void cx18_dualwatch(struct cx18 *cx ) 
{ 
  struct v4l2_tuner vt ;
  u32 new_stereo_mode ;
  u32 dual ;
  s32 tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 260
  dual = 512U;
#line 262
  tmp = v4l2_ctrl_g_ctrl(cx->cxhdl.ldv_36957.audio_mode);
#line 262
  new_stereo_mode = (u32 )tmp;
#line 263
  memset((void *)(& vt), 0, 84UL);
#line 264
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 264
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 264
  goto ldv_51670;
  ldv_51669: ;
#line 264
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 264
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, & vt);
  } else {

  }
#line 264
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 264
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51670: ;
#line 264
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 266
    goto ldv_51669;
  } else {

  }

#line 265
  if (vt.audmode == 4U && (vt.rxsubchans & 4U) != 0U) {
#line 267
    new_stereo_mode = dual;
  } else {

  }
#line 269
  if (cx->dualwatch_stereo_mode == new_stereo_mode) {
#line 270
    return;
  } else {

  }
#line 272
  if ((cx18_debug & 2) != 0) {
#line 272
    printk("\016%s:  info: dualwatch: change stereo flag from 0x%x to 0x%x.\n", (char *)(& cx->v4l2_dev.name),
           cx->dualwatch_stereo_mode, new_stereo_mode);
  } else {

  }
#line 274
  tmp___0 = v4l2_ctrl_s_ctrl(cx->cxhdl.ldv_36957.audio_mode, (s32 )new_stereo_mode);
#line 274
  if (tmp___0 != 0) {
#line 275
    if ((cx18_debug & 2) != 0) {
#line 275
      printk("\016%s:  info: dualwatch: changing stereo flag failed\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 276
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static struct cx18_mdl *cx18_get_mdl(struct cx18_stream *s , int non_block , int *err ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s_vbi ;
  struct cx18_mdl *mdl ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;

  {
#line 282
  cx = s->cx;
#line 283
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 285
  tmp = get_current();
#line 285
  wait.flags = 0U;
#line 285
  wait.private = (void *)tmp;
#line 285
  wait.func = & autoremove_wake_function;
#line 285
  wait.task_list.next = & wait.task_list;
#line 285
  wait.task_list.prev = & wait.task_list;
#line 287
  *err = 0;
  ldv_51690: ;
#line 289
  if (s->type == 0) {
#line 291
    tmp___0 = msecs_to_jiffies(1000U);
#line 291
    if ((long )((cx->dualwatch_jiffies + tmp___0) - (unsigned long )jiffies) < 0L) {
#line 292
      cx->dualwatch_jiffies = jiffies;
#line 293
      cx18_dualwatch(cx);
    } else {

    }
#line 295
    tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 295
    if (tmp___1 != 0) {
#line 295
      tmp___2 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 295
      if (tmp___2 == 0) {
#line 297
        goto ldv_51688;
        ldv_51687: 
#line 300
        cx18_process_vbi_data(cx, mdl, s_vbi->type);
#line 302
        cx18_stream_put_mdl_fw(s_vbi, mdl);
        ldv_51688: 
#line 297
        mdl = cx18_dequeue(s_vbi, & s_vbi->q_full);
#line 297
        if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 299
          goto ldv_51687;
        } else {

        }

      } else {

      }
    } else {

    }
#line 305
    mdl = & cx->vbi.sliced_mpeg_mdl;
#line 306
    if (mdl->readpos != mdl->bytesused) {
#line 307
      return (mdl);
    } else {

    }
  } else {

  }
#line 311
  mdl = cx18_dequeue(s, & s->q_full);
#line 312
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 313
    tmp___3 = test_and_clear_bit(0L, (unsigned long volatile   *)(& mdl->m_flags));
#line 313
    if (tmp___3 == 0) {
#line 315
      return (mdl);
    } else {

    }
#line 316
    if (s->type == 0) {
#line 318
      cx18_mdl_swap(mdl);
    } else {
#line 321
      cx18_process_vbi_data(cx, mdl, s->type);
    }
#line 323
    return (mdl);
  } else {

  }
#line 327
  tmp___4 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 327
  if (tmp___4 == 0) {
#line 328
    if ((cx18_debug & 2) != 0) {
#line 328
      printk("\016%s:  info: EOS %s\n", (char *)(& cx->v4l2_dev.name), s->name);
    } else {

    }
#line 329
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 333
  if (non_block != 0) {
#line 334
    *err = -11;
#line 335
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 339
  prepare_to_wait(& s->waitq, & wait, 1);
#line 342
  tmp___5 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 342
  if (tmp___5 == 0) {
#line 343
    schedule();
  } else {

  }
#line 344
  finish_wait(& s->waitq, & wait);
#line 345
  tmp___6 = get_current();
#line 345
  tmp___7 = signal_pending(tmp___6);
#line 345
  if (tmp___7 != 0) {
#line 347
    if ((cx18_debug & 2) != 0) {
#line 347
      printk("\016%s:  info: User stopped %s\n", (char *)(& cx->v4l2_dev.name), s->name);
    } else {

    }
#line 348
    *err = -4;
#line 349
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 351
  goto ldv_51690;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static void cx18_setup_sliced_vbi_mdl(struct cx18 *cx ) 
{ 
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  int idx ;

  {
#line 356
  mdl = & cx->vbi.sliced_mpeg_mdl;
#line 357
  buf = & cx->vbi.sliced_mpeg_buf;
#line 358
  idx = (int )cx->vbi.inserted_frame & 31;
#line 360
  buf->buf = (char *)cx->vbi.sliced_mpeg_data[idx];
#line 361
  buf->bytesused = cx->vbi.sliced_mpeg_size[idx];
#line 362
  buf->readpos = 0U;
#line 364
  mdl->curr_buf = (struct cx18_buffer *)0;
#line 365
  mdl->bytesused = cx->vbi.sliced_mpeg_size[idx];
#line 366
  mdl->readpos = 0U;
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static size_t cx18_copy_buf_to_user(struct cx18_stream *s , struct cx18_buffer *buf ,
                                    char *ubuf , size_t ucount , bool *stop ) 
{ 
  struct cx18 *cx ;
  size_t len ;
  char const   *start ;
  char const   *p ;
  u8 const   *q ;
  u8 ch ;
  int stuffing ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 372
  cx = s->cx;
#line 373
  len = (size_t )(buf->bytesused - buf->readpos);
#line 375
  *stop = 0;
#line 376
  if (len > ucount) {
#line 377
    len = ucount;
  } else {

  }
#line 378
  if (cx->vbi.insert_mpeg != 0 && s->type == 0) {
#line 378
    tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 378
    if (tmp___0 == 0) {
#line 378
      if ((unsigned long )(& cx->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 399
        start = (char const   *)buf->buf + (unsigned long )buf->readpos;
#line 400
        p = start + 1UL;
#line 402
        ch = cx->search_pack_header != 0 ? 186U : 224U;
#line 405
        goto ldv_51713;
        ldv_51717: 
#line 407
        tmp = memchr((void const   *)p, 0, (__kernel_size_t )((long )(start + len) - (long )p));
#line 407
        q = (u8 const   *)tmp;
#line 408
        if ((unsigned long )q == (unsigned long )((u8 const   *)0U)) {
#line 409
          goto ldv_51712;
        } else {

        }
#line 410
        p = (char const   *)q + 1U;
#line 416
        if ((((unsigned long )((char *)q + 15UL) >= (unsigned long )(buf->buf + (unsigned long )buf->bytesused) || (unsigned int )((unsigned char )*(q + 1UL)) != 0U) || (unsigned int )((unsigned char )*(q + 2UL)) != 1U) || (int )((unsigned char )*(q + 3UL)) != (int )ch) {
#line 418
          goto ldv_51713;
        } else {

        }
#line 421
        if (cx->search_pack_header == 0) {
#line 423
          if (((int )*(q + 6UL) & 192) != 128) {
#line 424
            goto ldv_51713;
          } else {

          }
#line 426
          if ((((int )*(q + 7UL) & 192) == 128 && ((int )*(q + 9UL) & 240) == 32) || (((int )*(q + 7UL) & 192) == 192 && ((int )*(q + 9UL) & 240) == 48)) {
#line 431
            ch = 186U;
#line 432
            cx->search_pack_header = 1;
#line 433
            p = (char const   *)q + 9U;
          } else {

          }
#line 435
          goto ldv_51713;
        } else {

        }
#line 441
        stuffing = (int )*(q + 13UL) & 7;
#line 443
        i = 0;
#line 443
        goto ldv_51716;
        ldv_51715: ;
#line 444
        if ((unsigned int )((unsigned char )*(q + (unsigned long )(i + 14))) != 255U) {
#line 445
          goto ldv_51714;
        } else {

        }
#line 443
        i = i + 1;
        ldv_51716: ;
#line 443
        if (i < stuffing) {
#line 445
          goto ldv_51715;
        } else {

        }
        ldv_51714: ;
#line 446
        if (((((i == stuffing && ((int )*(q + 4UL) & 196) == 68) && ((int )*(q + 12UL) & 3) == 3) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 14))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 15))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 16))) == 1U) {
#line 453
          cx->search_pack_header = 0;
#line 454
          len = (size_t )((long )q - (long )start);
#line 455
          cx18_setup_sliced_vbi_mdl(cx);
#line 456
          *stop = 1;
#line 457
          goto ldv_51712;
        } else {

        }
        ldv_51713: ;
#line 405
        if ((unsigned long )(start + len) > (unsigned long )p) {
#line 407
          goto ldv_51717;
        } else {

        }
        ldv_51712: ;
      } else {

      }
    } else {

    }
  } else {

  }
#line 461
  tmp___1 = copy_to_user((void *)ubuf, (void const   *)buf->buf + (unsigned long )buf->readpos,
                         len);
#line 461
  if (tmp___1 != 0UL) {
#line 462
    if (cx18_debug & 1) {
#line 462
      printk("\016%s:  warning: copy %zd bytes to user failed for %s\n", (char *)(& cx->v4l2_dev.name),
             len, s->name);
    } else {

    }
#line 464
    return (0xfffffffffffffff2UL);
  } else {

  }
#line 466
  buf->readpos = buf->readpos + (u32 )len;
#line 467
  if (s->type == 0 && (unsigned long )(& cx->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 469
    cx->mpg_data_received = cx->mpg_data_received + (unsigned long long )len;
  } else {

  }
#line 470
  return (len);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static size_t cx18_copy_mdl_to_user(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                    char *ubuf , size_t ucount ) 
{ 
  size_t tot_written ;
  int rc ;
  bool stop ;
  struct list_head  const  *__mptr ;
  size_t tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 476
  tot_written = 0UL;
#line 478
  stop = 0;
#line 480
  if ((unsigned long )mdl->curr_buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 481
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 481
    mdl->curr_buf = (struct cx18_buffer *)__mptr;
  } else {

  }
#line 484
  if ((unsigned long )(& (mdl->curr_buf)->list) == (unsigned long )(& mdl->buf_list)) {
#line 490
    mdl->readpos = mdl->bytesused;
#line 491
    return (0UL);
  } else {

  }
#line 494
  goto ldv_51734;
  ldv_51733: ;
#line 496
  if ((mdl->curr_buf)->readpos >= (mdl->curr_buf)->bytesused) {
#line 497
    goto ldv_51731;
  } else {

  }
#line 499
  tmp = cx18_copy_buf_to_user(s, mdl->curr_buf, ubuf + tot_written, ucount - tot_written,
                              & stop);
#line 499
  rc = (int )tmp;
#line 501
  if (rc < 0) {
#line 502
    return ((size_t )rc);
  } else {

  }
#line 503
  mdl->readpos = mdl->readpos + (u32 )rc;
#line 504
  tot_written = (size_t )rc + tot_written;
#line 506
  if ((((int )stop || tot_written >= ucount) || (mdl->curr_buf)->readpos < (mdl->curr_buf)->bytesused) || mdl->readpos >= mdl->bytesused) {
#line 510
    goto ldv_51732;
  } else {

  }
  ldv_51731: 
#line 494
  __mptr___0 = (struct list_head  const  *)(mdl->curr_buf)->list.next;
#line 494
  mdl->curr_buf = (struct cx18_buffer *)__mptr___0;
  ldv_51734: ;
#line 494
  if ((unsigned long )(& (mdl->curr_buf)->list) != (unsigned long )(& mdl->buf_list)) {
#line 496
    goto ldv_51733;
  } else {

  }
  ldv_51732: ;
#line 512
  return (tot_written);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static ssize_t cx18_read(struct cx18_stream *s , char *ubuf , size_t tot_count , int non_block ) 
{ 
  struct cx18 *cx ;
  size_t tot_written ;
  int single_frame ;
  int tmp ;
  int tmp___0 ;
  struct cx18_mdl *mdl ;
  int rc ;
  size_t tmp___1 ;
  int idx ;

  {
#line 518
  cx = s->cx;
#line 519
  tot_written = 0UL;
#line 520
  single_frame = 0;
#line 522
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 522
  if (tmp == 0 && s->id == 4294967295U) {
#line 524
    if (cx18_debug & 1) {
#line 524
      printk("\016%s:  warning: Stream %s not initialized before read\n", (char *)(& cx->v4l2_dev.name),
             s->name);
    } else {

    }
#line 526
    return (-5L);
  } else {

  }
#line 532
  if (s->type == 3) {
#line 532
    tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 532
    if (tmp___0 == 0) {
#line 533
      single_frame = 1;
    } else {

    }
  } else {

  }
  ldv_51748: 
#line 539
  mdl = cx18_get_mdl(s, non_block, & rc);
#line 541
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 543
    if (tot_written != 0UL) {
#line 544
      goto ldv_51746;
    } else {

    }
#line 546
    if (rc == 0) {
#line 547
      clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 548
      clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 549
      cx18_release_stream(s);
    } else {

    }
#line 552
    return ((ssize_t )rc);
  } else {

  }
#line 555
  tmp___1 = cx18_copy_mdl_to_user(s, mdl, ubuf + tot_written, tot_count - tot_written);
#line 555
  rc = (int )tmp___1;
#line 558
  if ((unsigned long )(& cx->vbi.sliced_mpeg_mdl) != (unsigned long )mdl) {
#line 559
    if (mdl->readpos == mdl->bytesused) {
#line 560
      cx18_stream_put_mdl_fw(s, mdl);
    } else {
#line 562
      cx18_push(s, mdl, & s->q_full);
    }
  } else
#line 563
  if (mdl->readpos == mdl->bytesused) {
#line 564
    idx = (int )cx->vbi.inserted_frame & 31;
#line 566
    cx->vbi.sliced_mpeg_size[idx] = 0U;
#line 567
    cx->vbi.inserted_frame = cx->vbi.inserted_frame + 1U;
#line 568
    cx->vbi_data_inserted = cx->vbi_data_inserted + (u64 )mdl->bytesused;
  } else {

  }
#line 570
  if (rc < 0) {
#line 571
    return ((ssize_t )rc);
  } else {

  }
#line 572
  tot_written = (size_t )rc + tot_written;
#line 574
  if (tot_written == tot_count || single_frame != 0) {
#line 575
    goto ldv_51746;
  } else {

  }
#line 576
  goto ldv_51748;
  ldv_51746: ;
#line 577
  return ((ssize_t )tot_written);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static ssize_t cx18_read_pos(struct cx18_stream *s , char *ubuf , size_t count , loff_t *pos ,
                             int non_block ) 
{ 
  ssize_t rc ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  struct cx18 *cx ;

  {
#line 583
  if (count != 0UL) {
#line 583
    tmp = cx18_read(s, ubuf, count, non_block);
#line 583
    tmp___0 = tmp;
  } else {
#line 583
    tmp___0 = 0L;
  }
#line 583
  rc = tmp___0;
#line 584
  cx = s->cx;
#line 586
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 586
    printk("\016%s:  file: read %zd from %s, got %zd\n", (char *)(& cx->v4l2_dev.name),
           count, s->name, rc);
  } else {

  }
#line 587
  if (rc > 0L) {
#line 588
    pos = pos + (unsigned long )rc;
  } else {

  }
#line 589
  return (rc);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int cx18_start_capture(struct cx18_open_id *id ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_vbi ;
  struct cx18_stream *s_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 594
  cx = id->cx;
#line 595
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 599
  if (s->type == 6) {
#line 601
    return (-1);
  } else {

  }
#line 605
  tmp = cx18_claim_stream(id, s->type);
#line 605
  if (tmp != 0) {
#line 606
    return (-16);
  } else {

  }
#line 610
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 610
  if (tmp___0 != 0) {
#line 612
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 613
    return (0);
  } else {
#line 610
    tmp___1 = test_and_set_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 610
    if (tmp___1 != 0) {
#line 612
      set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 613
      return (0);
    } else {

    }
  }
#line 617
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 618
  s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 619
  if (s->type == 0) {
#line 625
    tmp___3 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 625
    if (tmp___3 != 0) {
#line 625
      tmp___4 = test_and_set_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
#line 625
      if (tmp___4 == 0) {
#line 627
        tmp___2 = cx18_start_v4l2_encode_stream(s_idx);
#line 627
        if (tmp___2 != 0) {
#line 628
          if (cx18_debug & 1) {
#line 628
            printk("\016%s:  warning: IDX capture start failed\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 629
          clear_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
#line 630
          goto start_failed;
        } else {

        }
#line 632
        if ((cx18_debug & 2) != 0) {
#line 632
          printk("\016%s:  info: IDX capture started\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
#line 634
    tmp___6 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 634
    if (tmp___6 != 0) {
#line 634
      tmp___7 = test_and_set_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 634
      if (tmp___7 == 0) {
#line 636
        tmp___5 = cx18_start_v4l2_encode_stream(s_vbi);
#line 636
        if (tmp___5 != 0) {
#line 637
          if (cx18_debug & 1) {
#line 637
            printk("\016%s:  warning: VBI capture start failed\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 638
          clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 639
          goto start_failed;
        } else {

        }
#line 641
        if ((cx18_debug & 2) != 0) {
#line 641
          printk("\016%s:  info: VBI insertion started\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 646
  tmp___9 = cx18_start_v4l2_encode_stream(s);
#line 646
  if (tmp___9 == 0) {
#line 648
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 650
    tmp___8 = test_and_clear_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 650
    if (tmp___8 != 0) {
#line 651
      cx18_vapi(cx, 537001991U, 1, s->handle);
    } else {

    }
#line 652
    return (0);
  } else {

  }
  start_failed: ;
#line 656
  if (cx18_debug & 1) {
#line 656
    printk("\016%s:  warning: Failed to start capturing for stream %s\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 663
  if (s->type == 0) {
#line 665
    tmp___10 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 665
    if (tmp___10 != 0) {
#line 666
      cx18_stop_v4l2_encode_stream(s_idx, 0);
#line 667
      clear_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
    } else {

    }
#line 670
    tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 670
    if (tmp___11 != 0) {
#line 670
      tmp___12 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 670
      if (tmp___12 == 0) {
#line 672
        cx18_stop_v4l2_encode_stream(s_vbi, 0);
#line 673
        clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
      } else {

      }
    } else {

    }
  } else {

  }
#line 676
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 677
  cx18_release_stream(s);
#line 678
  return (-5);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
ssize_t cx18_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int rc ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 684
  tmp = file2id(filp);
#line 684
  id = tmp;
#line 685
  cx = id->cx;
#line 686
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 689
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 689
    printk("\016%s:  file: read %zd bytes from %s\n", (char *)(& cx->v4l2_dev.name),
           count, s->name);
  } else {

  }
#line 691
  mutex_lock_nested(& cx->serialize_lock, 0U);
#line 692
  rc = cx18_start_capture(id);
#line 693
  mutex_unlock(& cx->serialize_lock);
#line 694
  if (rc != 0) {
#line 695
    return ((ssize_t )rc);
  } else {

  }
#line 697
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 699
    tmp___0 = videobuf_read_stream(& s->vbuf_q, buf, count, pos, 0, (int )filp->f_flags & 2048);
#line 699
    return (tmp___0);
  } else {

  }
#line 703
  tmp___1 = cx18_read_pos(s, buf, count, pos, (int )filp->f_flags & 2048);
#line 703
  return (tmp___1);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
unsigned int cx18_v4l2_enc_poll(struct file *filp , poll_table *wait ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int eof ;
  int tmp___0 ;
  int rc ;
  int tmp___1 ;
  int videobuf_poll ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 708
  tmp = file2id(filp);
#line 708
  id = tmp;
#line 709
  cx = id->cx;
#line 710
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 711
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 711
  eof = tmp___0;
#line 714
  if (eof == 0) {
#line 714
    tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 714
    if (tmp___1 == 0) {
#line 717
      mutex_lock_nested(& cx->serialize_lock, 0U);
#line 718
      rc = cx18_start_capture(id);
#line 719
      mutex_unlock(& cx->serialize_lock);
#line 720
      if (rc != 0) {
#line 721
        if ((cx18_debug & 2) != 0) {
#line 721
          printk("\016%s:  info: Could not start capture for %s (%d)\n", (char *)(& cx->v4l2_dev.name),
                 s->name, rc);
        } else {

        }
#line 723
        return (8U);
      } else {

      }
#line 725
      if ((cx18_debug & 32) != 0) {
#line 725
        printk("\016%s:  file: Encoder poll started capture\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
    } else {

    }
  } else {

  }
#line 728
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 730
    tmp___2 = videobuf_poll_stream(filp, & s->vbuf_q, wait);
#line 730
    videobuf_poll = (int )tmp___2;
#line 731
    if (eof != 0 && videobuf_poll == 8) {
#line 732
      return (16U);
    } else {
#line 734
      return ((unsigned int )videobuf_poll);
    }
  } else {

  }
#line 738
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 738
    printk("\016%s:  file: Encoder poll\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 739
  poll_wait(filp, & s->waitq, wait);
#line 741
  tmp___3 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 741
  if (tmp___3 != 0) {
#line 742
    return (65U);
  } else {

  }
#line 743
  if (eof != 0) {
#line 744
    return (16U);
  } else {

  }
#line 745
  return (0U);
}
}
#line 748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int cx18_v4l2_mmap(struct file *file , struct vm_area_struct *vma ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int eof ;
  int tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 750
  id = (struct cx18_open_id *)file->private_data;
#line 751
  cx = id->cx;
#line 752
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 753
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 753
  eof = tmp;
#line 755
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 759
    if (eof == 0) {
#line 759
      tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 759
      if (tmp___0 == 0) {
#line 762
        mutex_lock_nested(& cx->serialize_lock, 0U);
#line 763
        rc = cx18_start_capture(id);
#line 764
        mutex_unlock(& cx->serialize_lock);
#line 765
        if (rc != 0) {
#line 766
          if ((cx18_debug & 2) != 0) {
#line 766
            printk("\016%s:  info: Could not start capture for %s (%d)\n", (char *)(& cx->v4l2_dev.name),
                   s->name, rc);
          } else {

          }
#line 769
          return (-22);
        } else {

        }
#line 771
        if ((cx18_debug & 32) != 0) {
#line 771
          printk("\016%s:  file: Encoder mmap started capture\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
#line 774
    tmp___1 = videobuf_mmap_mapper(& s->vbuf_q, vma);
#line 774
    return (tmp___1);
  } else {

  }
#line 777
  return (-22);
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void cx18_vb_timeout(unsigned long data ) 
{ 
  struct cx18_stream *s ;
  struct cx18_videobuf_buffer *buf ;
  unsigned long flags ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 782
  s = (struct cx18_stream *)data;
#line 789
  ldv_spin_lock();
#line 790
  goto ldv_51804;
  ldv_51803: 
#line 791
  __mptr = (struct list_head  const  *)s->vb_capture.next;
#line 791
  buf = (struct cx18_videobuf_buffer *)__mptr + 0xffffffffffffffc8UL;
#line 793
  list_del(& buf->vb.queue);
#line 794
  buf->vb.state = 5;
#line 795
  __wake_up(& buf->vb.done, 3U, 1, (void *)0);
  ldv_51804: 
#line 790
  tmp = list_empty((struct list_head  const  *)(& s->vb_capture));
#line 790
  if (tmp == 0) {
#line 792
    goto ldv_51803;
  } else {

  }
#line 797
  spin_unlock_irqrestore(& s->vb_lock, flags);
#line 798
  return;
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void cx18_stop_capture(struct cx18_open_id *id , int gop_end ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_vbi ;
  struct cx18_stream *s_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 802
  cx = id->cx;
#line 803
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 804
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 805
  s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 807
  if ((cx18_debug & 16) != 0) {
#line 807
    printk("\016%s:  ioctl: close() of %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 812
  tmp___3 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 812
  if (tmp___3 != 0) {
#line 813
    if ((cx18_debug & 2) != 0) {
#line 813
      printk("\016%s:  info: close stopping capture\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 814
    if (id->type == 0) {
#line 816
      tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 816
      if (tmp != 0) {
#line 816
        tmp___0 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 816
        if (tmp___0 == 0) {
#line 818
          if ((cx18_debug & 2) != 0) {
#line 818
            printk("\016%s:  info: close stopping embedded VBI capture\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 820
          cx18_stop_v4l2_encode_stream(s_vbi, 0);
        } else {

        }
      } else {

      }
#line 822
      tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 822
      if (tmp___1 != 0) {
#line 823
        if ((cx18_debug & 2) != 0) {
#line 823
          printk("\016%s:  info: close stopping IDX capture\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
#line 824
        cx18_stop_v4l2_encode_stream(s_idx, 0);
      } else {

      }
    } else {

    }
#line 827
    if (id->type == 3) {
#line 827
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 827
      if (tmp___2 != 0) {
#line 830
        s->id = 4294967295U;
      } else {
#line 832
        cx18_stop_v4l2_encode_stream(s, gop_end);
      }
    } else {
#line 832
      cx18_stop_v4l2_encode_stream(s, gop_end);
    }
  } else {

  }
#line 834
  if (gop_end == 0) {
#line 835
    clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 836
    clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 837
    cx18_release_stream(s);
  } else {

  }
#line 839
  return;
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int cx18_v4l2_close(struct file *filp ) 
{ 
  struct v4l2_fh *fh ;
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 843
  fh = (struct v4l2_fh *)filp->private_data;
#line 844
  tmp = fh2id(fh);
#line 844
  id = tmp;
#line 845
  cx = id->cx;
#line 846
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 848
  if ((cx18_debug & 16) != 0) {
#line 848
    printk("\016%s:  ioctl: close() of %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 850
  mutex_lock_nested(& cx->serialize_lock, 0U);
#line 852
  if (id->type == 6) {
#line 852
    tmp___3 = v4l2_fh_is_singular_file(filp);
#line 852
    if (tmp___3 != 0) {
#line 855
      cx18_mute(cx);
#line 857
      clear_bit(5L, (unsigned long volatile   *)(& cx->i_flags));
#line 859
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 859
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 859
      goto ldv_51827;
      ldv_51826: ;
#line 859
      if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                v4l2_std_id  ))0)) {
#line 859
        (*(((__sd->ops)->video)->s_std))(__sd, cx->std);
      } else {

      }
#line 859
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 859
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
      ldv_51827: ;
#line 859
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 861
        goto ldv_51826;
      } else {

      }
#line 861
      cx18_audio_set_io(cx);
#line 862
      tmp___2 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 862
      if (tmp___2 > 0) {
#line 864
        tmp___0 = v4l2_ctrl_g_ctrl(cx->cxhdl.ldv_36972.video_mute);
#line 864
        tmp___1 = v4l2_ctrl_g_ctrl(cx->cxhdl.ldv_36972.video_mute_yuv);
#line 864
        cx18_vapi(cx, 537002003U, 2, s->handle, tmp___0 | (tmp___1 << 8));
      } else {

      }
#line 869
      cx18_unmute(cx);
    } else {

    }
  } else {

  }
#line 872
  v4l2_fh_del(fh);
#line 873
  v4l2_fh_exit(fh);
#line 876
  if (s->id == id->open_id) {
#line 877
    cx18_stop_capture(id, 0);
  } else {

  }
#line 878
  kfree((void const   *)id);
#line 879
  mutex_unlock(& cx->serialize_lock);
#line 880
  return (0);
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
static int cx18_serialized_open(struct cx18_stream *s , struct file *filp ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *item ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___3 ;

  {
#line 885
  cx = s->cx;
#line 888
  if ((cx18_debug & 32) != 0) {
#line 888
    printk("\016%s:  file: open %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 891
  tmp = kzalloc(192UL, 208U);
#line 891
  item = (struct cx18_open_id *)tmp;
#line 892
  if ((unsigned long )item == (unsigned long )((struct cx18_open_id *)0)) {
#line 893
    if (cx18_debug & 1) {
#line 893
      printk("\016%s:  warning: nomem on v4l2 open\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 894
    return (-12);
  } else {

  }
#line 896
  v4l2_fh_init(& item->fh, s->video_dev);
#line 898
  item->cx = cx;
#line 899
  item->type = s->type;
#line 901
  tmp___0 = cx->open_id;
#line 901
  cx->open_id = cx->open_id + 1;
#line 901
  item->open_id = (u32 )tmp___0;
#line 902
  filp->private_data = (void *)(& item->fh);
#line 903
  v4l2_fh_add(& item->fh);
#line 905
  if (item->type == 6) {
#line 905
    tmp___3 = v4l2_fh_is_singular_file(filp);
#line 905
    if (tmp___3 != 0) {
#line 907
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 907
      if (tmp___2 == 0) {
#line 908
        tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 908
        if (tmp___1 > 0) {
#line 911
          v4l2_fh_del(& item->fh);
#line 912
          v4l2_fh_exit(& item->fh);
#line 913
          kfree((void const   *)item);
#line 914
          return (-16);
        } else {

        }
      } else {

      }
#line 919
      set_bit(5L, (unsigned long volatile   *)(& cx->i_flags));
#line 921
      cx18_mute(cx);
#line 923
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 923
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 923
      goto ldv_51841;
      ldv_51840: ;
#line 923
      if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_radio != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 923
        (*(((__sd->ops)->tuner)->s_radio))(__sd);
      } else {

      }
#line 923
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 923
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
      ldv_51841: ;
#line 923
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 925
        goto ldv_51840;
      } else {

      }
#line 925
      cx18_audio_set_io(cx);
#line 927
      cx18_unmute(cx);
    } else {

    }
  } else {

  }
#line 929
  return (0);
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int cx18_v4l2_open(struct file *filp ) 
{ 
  int res ;
  struct video_device *video_dev ;
  struct video_device *tmp ;
  struct cx18_stream *s ;
  void *tmp___0 ;
  struct cx18 *cx ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 935
  tmp = video_devdata(filp);
#line 935
  video_dev = tmp;
#line 936
  tmp___0 = video_get_drvdata(video_dev);
#line 936
  s = (struct cx18_stream *)tmp___0;
#line 937
  cx = s->cx;
#line 939
  mutex_lock_nested(& cx->serialize_lock, 0U);
#line 940
  tmp___2 = cx18_init_on_first_open(cx);
#line 940
  if (tmp___2 != 0) {
#line 941
    tmp___1 = video_device_node_name(video_dev);
#line 941
    printk("\v%s: Failed to initialize on %s\n", (char *)(& cx->v4l2_dev.name), tmp___1);
#line 943
    mutex_unlock(& cx->serialize_lock);
#line 944
    return (-6);
  } else {

  }
#line 946
  res = cx18_serialized_open(s, filp);
#line 947
  mutex_unlock(& cx->serialize_lock);
#line 948
  return (res);
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void cx18_mute(struct cx18 *cx ) 
{ 
  u32 h ;
  int tmp ;

  {
#line 954
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 954
  if (tmp != 0) {
#line 955
    h = cx18_find_handle(cx);
#line 956
    if (h != 4294967295U) {
#line 957
      cx18_vapi(cx, 537002004U, 2, h, 1);
    } else {
#line 959
      printk("\v%s: Can\'t find valid task handle for mute\n", (char *)(& cx->v4l2_dev.name));
    }
  } else {

  }
#line 961
  if ((cx18_debug & 2) != 0) {
#line 961
    printk("\016%s:  info: Mute\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 962
  return;
}
}
#line 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void cx18_unmute(struct cx18 *cx ) 
{ 
  u32 h ;
  int tmp ;

  {
#line 967
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 967
  if (tmp != 0) {
#line 968
    h = cx18_find_handle(cx);
#line 969
    if (h != 4294967295U) {
#line 970
      cx18_msleep_timeout(100U, 0);
#line 971
      cx18_vapi(cx, 537002005U, 2, h, 12);
#line 972
      cx18_vapi(cx, 537002004U, 2, h, 0);
    } else {
#line 974
      printk("\v%s: Can\'t find valid task handle for unmute\n", (char *)(& cx->v4l2_dev.name));
    }
  } else {

  }
#line 976
  if ((cx18_debug & 2) != 0) {
#line 976
    printk("\016%s:  info: Unmute\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 977
  return;
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 1041
  ldv_spin_unlock();
#line 1043
  ldv_spin_unlock_irqrestore_308(lock, flags);
#line 1044
  return;
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void *ldv_kmem_cache_alloc_316(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1109
  ldv_check_alloc_flags(flags);
#line 1111
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1112
  return ((void *)0);
}
}
#line 1150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int ldv_pskb_expand_head_322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1153
  ldv_check_alloc_flags(flags);
#line 1155
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1155
  return (tmp);
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv_skb_clone_324(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1169
  ldv_check_alloc_flags(flags);
#line 1171
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1171
  return (tmp);
}
}
#line 1182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv_skb_copy_326(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1185
  ldv_check_alloc_flags(flags);
#line 1187
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1187
  return (tmp);
}
}
#line 1190 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1193
  ldv_check_alloc_flags(flags);
#line 1195
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1195
  return (tmp);
}
}
#line 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1201
  ldv_check_alloc_flags(flags);
#line 1203
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1203
  return (tmp);
}
}
#line 1206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1209
  ldv_check_alloc_flags(flags);
#line 1211
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1211
  return (tmp);
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int ldv_pskb_expand_head_330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1217
  ldv_check_alloc_flags(flags);
#line 1219
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1219
  return (tmp);
}
}
#line 1222 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int ldv_pskb_expand_head_331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1225
  ldv_check_alloc_flags(flags);
#line 1227
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1227
  return (tmp);
}
}
#line 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
struct sk_buff *ldv_skb_clone_332(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1233
  ldv_check_alloc_flags(flags);
#line 1235
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1235
  return (tmp);
}
}
#line 1 "<compiler builtins>"
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 176 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 179
int ldv_mod_timer_375(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_358(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 1439 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1441
  tmp = dev_name(& pdev->dev);
#line 1441
  return (tmp);
}
}
#line 331 "include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler * , char const   * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_366(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_374(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_368(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_364(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_372(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_373(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_369(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_370(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 202 "include/media/videobuf-core.h"
extern int videobuf_reqbufs(struct videobuf_queue * , struct v4l2_requestbuffers * ) ;
#line 204
extern int videobuf_querybuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 205
extern int videobuf_qbuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 207
extern int videobuf_dqbuf(struct videobuf_queue * , struct v4l2_buffer * , int  ) ;
#line 209
extern int videobuf_streamon(struct videobuf_queue * ) ;
#line 210
extern int videobuf_streamoff(struct videobuf_queue * ) ;
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___1  =    1444U;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___3(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_51300;
  ldv_51299: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_51298;
  } else {

  }
#line 74
  i = i + 1;
  ldv_51300: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_51299;
  } else {

  }
  ldv_51298: ;
#line 81
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_enc(struct cx18 *cx , u32 val , u32 addr ) 
{ 


  {
#line 176
  cx18_writel___3(cx, val, cx->enc_mem + (unsigned long )addr);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_read_enc(struct cx18 *cx , u32 addr ) 
{ 
  u32 tmp ;

  {
#line 181
  tmp = cx18_readl(cx, (void const   *)cx->enc_mem + (unsigned long )addr);
#line 181
  return (tmp);
}
}
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-video.h"
void cx18_video_set_io(struct cx18 *cx ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
u16 cx18_service2vbi(int type ) ;
#line 26
void cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) ;
#line 27
u16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt ) ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
u16 cx18_service2vbi(int type ) 
{ 


  {
#line 141
  switch (type) {
  case 1: ;
#line 143
  return (1U);
  case 4096: ;
#line 145
  return (4U);
  case 16384: ;
#line 147
  return (5U);
  case 1024: ;
#line 149
  return (7U);
  default: ;
#line 151
  return (0U);
  }
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int valid_service_line(int field , int line , int is_pal ) 
{ 


  {
#line 158
  return (((is_pal != 0 && line > 5) && ((field == 0 && line <= 23) || (field == 1 && line <= 22))) || ((is_pal == 0 && line > 9) && line <= 21));
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static u16 select_service_from_set(int field , int line , u16 set , int is_pal ) 
{ 
  u16 valid_set ;
  int i ;
  int tmp ;

  {
#line 172
  valid_set = is_pal != 0 ? 17409U : 4096U;
#line 175
  set = (u16 )((int )set & (int )valid_set);
#line 176
  if ((unsigned int )set == 0U) {
#line 177
    return (0U);
  } else {
#line 176
    tmp = valid_service_line(field, line, is_pal);
#line 176
    if (tmp == 0) {
#line 177
      return (0U);
    } else {

    }
  }
#line 178
  if (is_pal == 0) {
#line 179
    if (line == 21 && ((int )set & 4096) != 0) {
#line 180
      return (4096U);
    } else {

    }
  } else {
#line 182
    if ((line == 16 && field == 0) && ((int )set & 1024) != 0) {
#line 183
      return (1024U);
    } else {

    }
#line 184
    if ((line == 23 && field == 0) && ((int )set & 16384) != 0) {
#line 185
      return (16384U);
    } else {

    }
#line 186
    if (line == 23) {
#line 187
      return (0U);
    } else {

    }
  }
#line 189
  i = 0;
#line 189
  goto ldv_51718;
  ldv_51717: ;
#line 190
  if (((int )set >> i) & 1) {
#line 191
    return ((u16 )(1 << i));
  } else {

  }
#line 189
  i = i + 1;
  ldv_51718: ;
#line 189
  if (i <= 31) {
#line 191
    goto ldv_51717;
  } else {

  }

#line 193
  return (0U);
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  u16 set ;
  int f ;
  int l ;

  {
#line 202
  set = fmt->service_set;
#line 205
  fmt->service_set = 0U;
#line 206
  f = 0;
#line 206
  goto ldv_51731;
  ldv_51730: 
#line 207
  l = 0;
#line 207
  goto ldv_51728;
  ldv_51727: 
#line 208
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )set, is_pal);
#line 207
  l = l + 1;
  ldv_51728: ;
#line 207
  if (l <= 23) {
#line 209
    goto ldv_51727;
  } else {

  }
#line 206
  f = f + 1;
  ldv_51731: ;
#line 206
  if (f <= 1) {
#line 208
    goto ldv_51730;
  } else {

  }

#line 213
  return;
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int check_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  int f ;
  int l ;
  u16 set ;

  {
#line 219
  set = 0U;
#line 221
  f = 0;
#line 221
  goto ldv_51744;
  ldv_51743: 
#line 222
  l = 0;
#line 222
  goto ldv_51741;
  ldv_51740: 
#line 223
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )fmt->service_lines[f][l],
                                                     is_pal);
#line 224
  set = (u16 )((int )fmt->service_lines[f][l] | (int )set);
#line 222
  l = l + 1;
  ldv_51741: ;
#line 222
  if (l <= 23) {
#line 224
    goto ldv_51740;
  } else {

  }
#line 221
  f = f + 1;
  ldv_51744: ;
#line 221
  if (f <= 1) {
#line 223
    goto ldv_51743;
  } else {

  }

#line 227
  return ((unsigned int )set != 0U);
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
u16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt ) 
{ 
  int f ;
  int l ;
  u16 set ;

  {
#line 234
  set = 0U;
#line 236
  f = 0;
#line 236
  goto ldv_51756;
  ldv_51755: 
#line 237
  l = 0;
#line 237
  goto ldv_51753;
  ldv_51752: 
#line 238
  set = (u16 )((int )fmt->service_lines[f][l] | (int )set);
#line 237
  l = l + 1;
  ldv_51753: ;
#line 237
  if (l <= 23) {
#line 239
    goto ldv_51752;
  } else {

  }
#line 236
  f = f + 1;
  ldv_51756: ;
#line 236
  if (f <= 1) {
#line 238
    goto ldv_51755;
  } else {

  }

#line 240
  return (set);
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct v4l2_pix_format *pixfmt ;

  {
#line 246
  tmp = fh2id((struct v4l2_fh *)fh);
#line 246
  id = tmp;
#line 247
  cx = id->cx;
#line 248
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 249
  pixfmt = & fmt->fmt.pix;
#line 251
  pixfmt->width = (__u32 )cx->cxhdl.width;
#line 252
  pixfmt->height = (__u32 )cx->cxhdl.height;
#line 253
  pixfmt->colorspace = 1U;
#line 254
  pixfmt->field = 4U;
#line 255
  pixfmt->priv = 0U;
#line 256
  if (id->type == 2) {
#line 257
    pixfmt->pixelformat = s->pixelformat;
#line 258
    pixfmt->sizeimage = s->vb_bytes_per_frame;
#line 259
    pixfmt->bytesperline = 720U;
  } else {
#line 261
    pixfmt->pixelformat = 1195724877U;
#line 262
    pixfmt->sizeimage = 131072U;
#line 263
    pixfmt->bytesperline = 0U;
  }
#line 265
  return (0);
}
}
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_vbi_format *vbifmt ;
  __u32 tmp___0 ;

  {
#line 271
  tmp = fh2id((struct v4l2_fh *)fh);
#line 271
  cx = tmp->cx;
#line 272
  vbifmt = & fmt->fmt.vbi;
#line 274
  vbifmt->sampling_rate = 27000000U;
#line 275
  vbifmt->offset = 248U;
#line 276
  vbifmt->samples_per_line = (unsigned int )vbi_active_samples___1 - 4U;
#line 277
  vbifmt->sample_format = 1497715271U;
#line 278
  vbifmt->start[0] = (__s32 )cx->vbi.start[0];
#line 279
  vbifmt->start[1] = (__s32 )cx->vbi.start[1];
#line 280
  tmp___0 = cx->vbi.count;
#line 280
  vbifmt->count[1] = tmp___0;
#line 280
  vbifmt->count[0] = tmp___0;
#line 281
  vbifmt->flags = 0U;
#line 282
  vbifmt->reserved[0] = 0U;
#line 283
  vbifmt->reserved[1] = 0U;
#line 284
  return (0);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;

  {
#line 290
  tmp = fh2id((struct v4l2_fh *)fh);
#line 290
  cx = tmp->cx;
#line 291
  vbifmt = & fmt->fmt.sliced;
#line 294
  vbifmt->reserved[0] = 0U;
#line 295
  vbifmt->reserved[1] = 0U;
#line 296
  vbifmt->io_size = 2304U;
#line 297
  memset((void *)(& vbifmt->service_lines), 0, 96UL);
#line 298
  vbifmt->service_set = 0U;
#line 305
  if ((unsigned long )cx->sd_av == (unsigned long )((struct v4l2_subdev *)0)) {
#line 306
    return (-22);
  } else
#line 305
  if ((unsigned long )((cx->sd_av)->ops)->vbi == (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) || (unsigned long )(((cx->sd_av)->ops)->vbi)->g_sliced_fmt == (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_sliced_vbi_format * ))0)) {
#line 306
    return (-22);
  } else {
#line 305
    tmp___0 = (*((((cx->sd_av)->ops)->vbi)->g_sliced_fmt))(cx->sd_av, & fmt->fmt.sliced);
#line 305
    if (tmp___0 != 0) {
#line 306
      return (-22);
    } else {

    }
  }
#line 308
  vbifmt->service_set = cx18_get_service_set(vbifmt);
#line 309
  return (0);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_try_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int w ;
  int h ;
  int min_h ;
  int _min1 ;
  int _min2 ;
  int _max1 ;
  int _max2 ;
  int _min1___0 ;
  int _min2___0 ;
  int _max1___0 ;
  int _max2___0 ;

  {
#line 315
  tmp = fh2id((struct v4l2_fh *)fh);
#line 315
  id = tmp;
#line 316
  cx = id->cx;
#line 317
  w = (int )fmt->fmt.pix.width;
#line 318
  h = (int )fmt->fmt.pix.height;
#line 319
  min_h = 2;
#line 321
  _min1 = w;
#line 321
  _min2 = 720;
#line 321
  w = _min1 < _min2 ? _min1 : _min2;
#line 322
  _max1 = w;
#line 322
  _max2 = 2;
#line 322
  w = _max1 > _max2 ? _max1 : _max2;
#line 323
  if (id->type == 2) {
#line 325
    h = h & -32;
#line 326
    min_h = 32;
  } else {

  }
#line 328
  _min1___0 = h;
#line 328
  _min2___0 = (unsigned int )cx->is_50hz != 0U ? 576 : 480;
#line 328
  h = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 329
  _max1___0 = h;
#line 329
  _max2___0 = min_h;
#line 329
  h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 331
  fmt->fmt.pix.width = (__u32 )w;
#line 332
  fmt->fmt.pix.height = (__u32 )h;
#line 333
  return (0);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_try_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  int tmp ;

  {
#line 339
  tmp = cx18_g_fmt_vbi_cap(file, fh, fmt);
#line 339
  return (tmp);
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_try_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;

  {
#line 345
  tmp = fh2id((struct v4l2_fh *)fh);
#line 345
  cx = tmp->cx;
#line 346
  vbifmt = & fmt->fmt.sliced;
#line 348
  vbifmt->io_size = 2304U;
#line 349
  vbifmt->reserved[0] = 0U;
#line 350
  vbifmt->reserved[1] = 0U;
#line 353
  if ((unsigned int )vbifmt->service_set != 0U) {
#line 354
    cx18_expand_service_set(vbifmt, (int )cx->is_50hz);
  } else {

  }
#line 356
  tmp___0 = check_service_set(vbifmt, (int )cx->is_50hz);
#line 356
  if (tmp___0 != 0) {
#line 357
    vbifmt->service_set = cx18_get_service_set(vbifmt);
  } else {

  }
#line 358
  return (0);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_mbus_framefmt mbus_fmt ;
  struct cx18_stream *s ;
  int ret ;
  int w ;
  int h ;
  int tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  int tmp___3 ;

  {
#line 364
  tmp = fh2id((struct v4l2_fh *)fh);
#line 364
  id = tmp;
#line 365
  cx = id->cx;
#line 367
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 371
  ret = cx18_try_fmt_vid_cap(file, fh, fmt);
#line 372
  if (ret != 0) {
#line 373
    return (ret);
  } else {

  }
#line 374
  w = (int )fmt->fmt.pix.width;
#line 375
  h = (int )fmt->fmt.pix.height;
#line 377
  if (((int )cx->cxhdl.width == w && (int )cx->cxhdl.height == h) && s->pixelformat == fmt->fmt.pix.pixelformat) {
#line 379
    return (0);
  } else {

  }
#line 381
  tmp___0 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 381
  if (tmp___0 > 0) {
#line 382
    return (-16);
  } else {

  }
#line 384
  s->pixelformat = fmt->fmt.pix.pixelformat;
#line 387
  if (s->pixelformat == 842091848U) {
#line 388
    s->vb_bytes_per_frame = (u32 )((h * 2160) / 2);
  } else {
#line 390
    s->vb_bytes_per_frame = (u32 )(h * 1440);
  }
#line 392
  tmp___1 = (u16 )w;
#line 392
  cx->cxhdl.width = tmp___1;
#line 392
  mbus_fmt.width = (__u32 )tmp___1;
#line 393
  tmp___2 = (u16 )h;
#line 393
  cx->cxhdl.height = tmp___2;
#line 393
  mbus_fmt.height = (__u32 )tmp___2;
#line 394
  mbus_fmt.code = 1U;
#line 395
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 395
    if ((unsigned long )((cx->sd_av)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->video)->s_mbus_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 struct v4l2_mbus_framefmt * ))0)) {
#line 395
      (*((((cx->sd_av)->ops)->video)->s_mbus_fmt))(cx->sd_av, & mbus_fmt);
    } else {

    }
  } else {

  }
#line 396
  tmp___3 = cx18_g_fmt_vid_cap(file, fh, fmt);
#line 396
  return (tmp___3);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 402
  tmp = fh2id((struct v4l2_fh *)fh);
#line 402
  id = tmp;
#line 403
  cx = id->cx;
#line 410
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 410
  if (tmp___0 == 0) {
#line 410
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 410
    if (tmp___1 > 0) {
#line 411
      return (-16);
    } else {

    }
  } else {

  }
#line 418
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 418
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                          struct v4l2_vbi_format * ))0)) {
#line 418
      tmp___2 = (*((((cx->sd_av)->ops)->vbi)->s_raw_fmt))(cx->sd_av, & fmt->fmt.vbi);
#line 418
      tmp___3 = tmp___2;
    } else {
#line 418
      tmp___3 = -515;
    }
#line 418
    ret = tmp___3;
  } else {
#line 418
    ret = -19;
  }
#line 419
  if (ret != 0) {
#line 420
    return (ret);
  } else {

  }
#line 423
  (cx->vbi.sliced_in)->service_set = 0U;
#line 424
  cx->vbi.in.type = 4U;
#line 426
  tmp___4 = cx18_g_fmt_vbi_cap(file, fh, fmt);
#line 426
  return (tmp___4);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int ret ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;

  {
#line 432
  tmp = fh2id((struct v4l2_fh *)fh);
#line 432
  id = tmp;
#line 433
  cx = id->cx;
#line 435
  vbifmt = & fmt->fmt.sliced;
#line 437
  cx18_try_fmt_sliced_vbi_cap(file, fh, fmt);
#line 443
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 443
  if (tmp___0 != 0) {
#line 443
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 443
    if (tmp___1 > 0) {
#line 444
      return (-16);
    } else {

    }
  } else {

  }
#line 451
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 451
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             struct v4l2_sliced_vbi_format * ))0)) {
#line 451
      tmp___2 = (*((((cx->sd_av)->ops)->vbi)->s_sliced_fmt))(cx->sd_av, & fmt->fmt.sliced);
#line 451
      tmp___3 = tmp___2;
    } else {
#line 451
      tmp___3 = -515;
    }
#line 451
    ret = tmp___3;
  } else {
#line 451
    ret = -19;
  }
#line 452
  if (ret != 0) {
#line 453
    return (ret);
  } else {

  }
#line 455
  cx->vbi.in.type = 6U;
#line 456
  __len = 112UL;
#line 456
  if (__len > 63UL) {
#line 456
    __ret = __memcpy((void *)cx->vbi.sliced_in, (void const   *)vbifmt, __len);
  } else {
#line 456
    __ret = __builtin_memcpy((void *)cx->vbi.sliced_in, (void const   *)vbifmt, __len);
  }
#line 457
  return (0);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_register(struct file *file , void *fh , struct v4l2_dbg_register *reg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  u32 tmp___0 ;

  {
#line 464
  tmp = fh2id((struct v4l2_fh *)fh);
#line 464
  cx = tmp->cx;
#line 466
  if ((reg->reg & 3ULL) != 0ULL) {
#line 467
    return (-22);
  } else {

  }
#line 468
  if (reg->reg > 67108863ULL) {
#line 469
    return (-22);
  } else {

  }
#line 470
  reg->size = 4U;
#line 471
  tmp___0 = cx18_read_enc(cx, (u32 )reg->reg);
#line 471
  reg->val = (__u64 )tmp___0;
#line 472
  return (0);
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_register(struct file *file , void *fh , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 478
  tmp = fh2id((struct v4l2_fh *)fh);
#line 478
  cx = tmp->cx;
#line 480
  if (((unsigned long long )reg->reg & 3ULL) != 0ULL) {
#line 481
    return (-22);
  } else {

  }
#line 482
  if ((unsigned long long )reg->reg > 67108863ULL) {
#line 483
    return (-22);
  } else {

  }
#line 484
  cx18_write_enc(cx, (u32 )reg->val, (u32 )reg->reg);
#line 485
  return (0);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_querycap(struct file *file , void *fh , struct v4l2_capability *vcap ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  char const   *tmp___0 ;

  {
#line 492
  tmp = fh2id((struct v4l2_fh *)fh);
#line 492
  id = tmp;
#line 493
  cx = id->cx;
#line 495
  strlcpy((char *)(& vcap->driver), "cx18", 16UL);
#line 496
  strlcpy((char *)(& vcap->card), cx->card_name, 32UL);
#line 497
  tmp___0 = pci_name((struct pci_dev  const  *)cx->pci_dev);
#line 497
  snprintf((char *)(& vcap->bus_info), 32UL, "PCI:%s", tmp___0);
#line 499
  vcap->capabilities = cx->v4l2_cap;
#line 500
  if (id->type == 2) {
#line 501
    vcap->capabilities = vcap->capabilities | 67108864U;
  } else {

  }
#line 502
  return (0);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_enumaudio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 507
  tmp = fh2id((struct v4l2_fh *)fh);
#line 507
  cx = tmp->cx;
#line 509
  tmp___0 = cx18_get_audio_input(cx, (int )((u16 )vin->index), vin);
#line 509
  return (tmp___0);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_audio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 514
  tmp = fh2id((struct v4l2_fh *)fh);
#line 514
  cx = tmp->cx;
#line 516
  vin->index = cx->audio_input;
#line 517
  tmp___0 = cx18_get_audio_input(cx, (int )((u16 )vin->index), vin);
#line 517
  return (tmp___0);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_audio(struct file *file , void *fh , struct v4l2_audio  const  *vout ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 522
  tmp = fh2id((struct v4l2_fh *)fh);
#line 522
  cx = tmp->cx;
#line 524
  if ((unsigned int )vout->index >= (unsigned int )cx->nof_audio_inputs) {
#line 525
    return (-22);
  } else {

  }
#line 526
  cx->audio_input = vout->index;
#line 527
  cx18_audio_set_io(cx);
#line 528
  return (0);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_enum_input(struct file *file , void *fh , struct v4l2_input *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 533
  tmp = fh2id((struct v4l2_fh *)fh);
#line 533
  cx = tmp->cx;
#line 536
  tmp___0 = cx18_get_input(cx, (int )((u16 )vin->index), vin);
#line 536
  return (tmp___0);
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_cropcap(struct file *file , void *fh , struct v4l2_cropcap *cropcap ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  __s32 tmp___0 ;

  {
#line 542
  tmp = fh2id((struct v4l2_fh *)fh);
#line 542
  cx = tmp->cx;
#line 544
  if (cropcap->type != 1U) {
#line 545
    return (-22);
  } else {

  }
#line 546
  tmp___0 = 0;
#line 546
  cropcap->bounds.left = tmp___0;
#line 546
  cropcap->bounds.top = tmp___0;
#line 547
  cropcap->bounds.width = 720U;
#line 548
  cropcap->bounds.height = (unsigned int )cx->is_50hz != 0U ? 576U : 480U;
#line 549
  cropcap->pixelaspect.numerator = (unsigned int )cx->is_50hz != 0U ? 59U : 10U;
#line 550
  cropcap->pixelaspect.denominator = (unsigned int )cx->is_50hz != 0U ? 54U : 11U;
#line 551
  cropcap->defrect = cropcap->bounds;
#line 552
  return (0);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_crop(struct file *file , void *fh , struct v4l2_crop  const  *crop ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;

  {
#line 557
  tmp = fh2id((struct v4l2_fh *)fh);
#line 557
  id = tmp;
#line 558
  cx = id->cx;
#line 560
  if ((unsigned int )crop->type != 1U) {
#line 561
    return (-22);
  } else {

  }
#line 562
  if (cx18_debug & 1) {
#line 562
    printk("\016%s:  warning: VIDIOC_S_CROP not implemented\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 563
  return (-22);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_crop(struct file *file , void *fh , struct v4l2_crop *crop ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 568
  tmp = fh2id((struct v4l2_fh *)fh);
#line 568
  cx = tmp->cx;
#line 570
  if (crop->type != 1U) {
#line 571
    return (-22);
  } else {

  }
#line 572
  if (cx18_debug & 1) {
#line 572
    printk("\016%s:  warning: VIDIOC_G_CROP not implemented\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 573
  return (-22);
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_enum_fmt_vid_cap(struct file *file , void *fh , struct v4l2_fmtdesc *fmt ) 
{ 
  struct v4l2_fmtdesc formats[3U] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 579
  formats[0].index = 0U;
#line 579
  formats[0].type = 1U;
#line 579
  formats[0].flags = 0U;
#line 579
  formats[0].description[0] = 'H';
#line 579
  formats[0].description[1] = 'M';
#line 579
  formats[0].description[2] = '1';
#line 579
  formats[0].description[3] = '2';
#line 579
  formats[0].description[4] = ' ';
#line 579
  formats[0].description[5] = '(';
#line 579
  formats[0].description[6] = 'Y';
#line 579
  formats[0].description[7] = 'U';
#line 579
  formats[0].description[8] = 'V';
#line 579
  formats[0].description[9] = ' ';
#line 579
  formats[0].description[10] = '4';
#line 579
  formats[0].description[11] = ':';
#line 579
  formats[0].description[12] = '1';
#line 579
  formats[0].description[13] = ':';
#line 579
  formats[0].description[14] = '1';
#line 579
  formats[0].description[15] = ')';
#line 579
  formats[0].description[16] = '\000';
#line 579
  tmp = 17U;
#line 579
  while (1) {
#line 579
    if (tmp >= 32U) {
#line 579
      break;
    } else {

    }
#line 579
    formats[0].description[tmp] = (unsigned char)0;
#line 579
    tmp = tmp + 1U;
  }
#line 579
  formats[0].pixelformat = 842091848U;
#line 579
  formats[0].reserved[0] = 0U;
#line 579
  formats[0].reserved[1] = 0U;
#line 579
  formats[0].reserved[2] = 0U;
#line 579
  formats[0].reserved[3] = 0U;
#line 579
  formats[1].index = 1U;
#line 579
  formats[1].type = 1U;
#line 579
  formats[1].flags = 1U;
#line 579
  formats[1].description[0] = 'M';
#line 579
  formats[1].description[1] = 'P';
#line 579
  formats[1].description[2] = 'E';
#line 579
  formats[1].description[3] = 'G';
#line 579
  formats[1].description[4] = '\000';
#line 579
  tmp___0 = 5U;
#line 579
  while (1) {
#line 579
    if (tmp___0 >= 32U) {
#line 579
      break;
    } else {

    }
#line 579
    formats[1].description[tmp___0] = (unsigned char)0;
#line 579
    tmp___0 = tmp___0 + 1U;
  }
#line 579
  formats[1].pixelformat = 1195724877U;
#line 579
  formats[1].reserved[0] = 0U;
#line 579
  formats[1].reserved[1] = 0U;
#line 579
  formats[1].reserved[2] = 0U;
#line 579
  formats[1].reserved[3] = 0U;
#line 579
  formats[2].index = 2U;
#line 579
  formats[2].type = 1U;
#line 579
  formats[2].flags = 0U;
#line 579
  formats[2].description[0] = 'U';
#line 579
  formats[2].description[1] = 'Y';
#line 579
  formats[2].description[2] = 'V';
#line 579
  formats[2].description[3] = 'Y';
#line 579
  formats[2].description[4] = ' ';
#line 579
  formats[2].description[5] = '4';
#line 579
  formats[2].description[6] = ':';
#line 579
  formats[2].description[7] = '2';
#line 579
  formats[2].description[8] = ':';
#line 579
  formats[2].description[9] = '2';
#line 579
  formats[2].description[10] = '\000';
#line 579
  tmp___1 = 11U;
#line 579
  while (1) {
#line 579
    if (tmp___1 >= 32U) {
#line 579
      break;
    } else {

    }
#line 579
    formats[2].description[tmp___1] = (unsigned char)0;
#line 579
    tmp___1 = tmp___1 + 1U;
  }
#line 579
  formats[2].pixelformat = 1498831189U;
#line 579
  formats[2].reserved[0] = 0U;
#line 579
  formats[2].reserved[1] = 0U;
#line 579
  formats[2].reserved[2] = 0U;
#line 579
  formats[2].reserved[3] = 0U;
#line 591
  if (fmt->index > 2U) {
#line 592
    return (-22);
  } else {

  }
#line 593
  *fmt = formats[fmt->index];
#line 594
  return (0);
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_input(struct file *file , void *fh , unsigned int *i ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 599
  tmp = fh2id((struct v4l2_fh *)fh);
#line 599
  cx = tmp->cx;
#line 601
  *i = cx->active_input;
#line 602
  return (0);
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int cx18_s_input(struct file *file , void *fh , unsigned int inp ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;

  {
#line 607
  tmp = fh2id((struct v4l2_fh *)fh);
#line 607
  id = tmp;
#line 608
  cx = id->cx;
#line 610
  if ((unsigned int )cx->nof_inputs <= inp) {
#line 611
    return (-22);
  } else {

  }
#line 613
  if (cx->active_input == inp) {
#line 614
    if ((cx18_debug & 2) != 0) {
#line 614
      printk("\016%s:  info: Input unchanged\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 615
    return (0);
  } else {

  }
#line 618
  if ((cx18_debug & 2) != 0) {
#line 618
    printk("\016%s:  info: Changing input from %d to %d\n", (char *)(& cx->v4l2_dev.name),
           cx->active_input, inp);
  } else {

  }
#line 621
  cx->active_input = inp;
#line 623
  cx->audio_input = (u32 )(cx->card)->video_inputs[inp].audio_index;
#line 627
  cx18_mute(cx);
#line 628
  cx18_video_set_io(cx);
#line 629
  cx18_audio_set_io(cx);
#line 630
  cx18_unmute(cx);
#line 631
  return (0);
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_frequency(struct file *file , void *fh , struct v4l2_frequency *vf ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 637
  tmp = fh2id((struct v4l2_fh *)fh);
#line 637
  cx = tmp->cx;
#line 639
  if (vf->tuner != 0U) {
#line 640
    return (-22);
  } else {

  }
#line 642
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 642
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 642
  goto ldv_51942;
  ldv_51941: ;
#line 642
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency * ))0)) {
#line 642
    (*(((__sd->ops)->tuner)->g_frequency))(__sd, vf);
  } else {

  }
#line 642
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 642
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51942: ;
#line 642
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 644
    goto ldv_51941;
  } else {

  }

#line 643
  return (0);
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int cx18_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 648
  tmp = fh2id((struct v4l2_fh *)fh);
#line 648
  id = tmp;
#line 649
  cx = id->cx;
#line 651
  if ((unsigned int )vf->tuner != 0U) {
#line 652
    return (-22);
  } else {

  }
#line 654
  cx18_mute(cx);
#line 655
  if ((cx18_debug & 2) != 0) {
#line 655
    printk("\016%s:  info: v4l2 ioctl: set frequency %d\n", (char *)(& cx->v4l2_dev.name),
           vf->frequency);
  } else {

  }
#line 656
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 656
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 656
  goto ldv_51957;
  ldv_51956: ;
#line 656
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency  const  * ))0)) {
#line 656
    (*(((__sd->ops)->tuner)->s_frequency))(__sd, vf);
  } else {

  }
#line 656
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 656
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51957: ;
#line 656
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 658
    goto ldv_51956;
  } else {

  }
#line 657
  cx18_unmute(cx);
#line 658
  return (0);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_std(struct file *file , void *fh , v4l2_std_id *std ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 663
  tmp = fh2id((struct v4l2_fh *)fh);
#line 663
  cx = tmp->cx;
#line 665
  *std = cx->std;
#line 666
  return (0);
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int cx18_s_std(struct file *file , void *fh , v4l2_std_id std ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int tmp___0 ;
  int tmp___1 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 671
  tmp = fh2id((struct v4l2_fh *)fh);
#line 671
  id = tmp;
#line 672
  cx = id->cx;
#line 674
  if ((std & 16777215ULL) == 0ULL) {
#line 675
    return (-22);
  } else {

  }
#line 677
  if (cx->std == std) {
#line 678
    return (0);
  } else {

  }
#line 680
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 680
  if (tmp___0 != 0) {
#line 685
    return (-16);
  } else {
#line 680
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 680
    if (tmp___1 > 0) {
#line 685
      return (-16);
    } else {

    }
  }
#line 688
  cx->std = std;
#line 689
  cx->is_60hz = (std & 63744ULL) != 0ULL;
#line 690
  cx->is_50hz = (unsigned int )cx->is_60hz == 0U;
#line 691
  cx2341x_handler_set_50hz(& cx->cxhdl, (int )cx->is_50hz);
#line 692
  cx->cxhdl.width = 720U;
#line 693
  cx->cxhdl.height = (unsigned int )cx->is_50hz != 0U ? 576U : 480U;
#line 694
  cx->vbi.count = (unsigned int )cx->is_50hz != 0U ? 18U : 12U;
#line 695
  cx->vbi.start[0] = (unsigned int )cx->is_50hz != 0U ? 6U : 10U;
#line 696
  cx->vbi.start[1] = (unsigned int )cx->is_50hz != 0U ? 318U : 273U;
#line 697
  if ((cx18_debug & 2) != 0) {
#line 697
    printk("\016%s:  info: Switching standard to %llx.\n", (char *)(& cx->v4l2_dev.name),
           cx->std);
  } else {

  }
#line 701
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 701
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 701
  goto ldv_51978;
  ldv_51977: ;
#line 701
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                            v4l2_std_id  ))0)) {
#line 701
    (*(((__sd->ops)->video)->s_std))(__sd, cx->std);
  } else {

  }
#line 701
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 701
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51978: ;
#line 701
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 703
    goto ldv_51977;
  } else {

  }

#line 702
  return (0);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_s_tuner(struct file *file , void *fh , struct v4l2_tuner  const  *vt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 707
  tmp = fh2id((struct v4l2_fh *)fh);
#line 707
  id = tmp;
#line 708
  cx = id->cx;
#line 710
  if ((unsigned int )vt->index != 0U) {
#line 711
    return (-22);
  } else {

  }
#line 713
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 713
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 713
  goto ldv_51993;
  ldv_51992: ;
#line 713
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner  const  * ))0)) {
#line 713
    (*(((__sd->ops)->tuner)->s_tuner))(__sd, vt);
  } else {

  }
#line 713
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 713
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51993: ;
#line 713
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 715
    goto ldv_51992;
  } else {

  }

#line 714
  return (0);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_tuner(struct file *file , void *fh , struct v4l2_tuner *vt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 719
  tmp = fh2id((struct v4l2_fh *)fh);
#line 719
  cx = tmp->cx;
#line 721
  if (vt->index != 0U) {
#line 722
    return (-22);
  } else {

  }
#line 724
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 724
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 724
  goto ldv_52007;
  ldv_52006: ;
#line 724
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 724
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, vt);
  } else {

  }
#line 724
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 724
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_52007: ;
#line 724
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 726
    goto ldv_52006;
  } else {

  }

#line 726
  if (vt->type == 1U) {
#line 727
    strlcpy((char *)(& vt->name), "cx18 Radio Tuner", 32UL);
  } else {
#line 729
    strlcpy((char *)(& vt->name), "cx18 TV Tuner", 32UL);
  }
#line 730
  return (0);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_sliced_vbi_cap *cap ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int set ;
  int f ;
  int l ;
  int tmp___0 ;

  {
#line 736
  tmp = fh2id((struct v4l2_fh *)fh);
#line 736
  cx = tmp->cx;
#line 737
  set = (unsigned int )cx->is_50hz != 0U ? 17409 : 4096;
#line 740
  if (cap->type != 6U) {
#line 741
    return (-22);
  } else {

  }
#line 743
  cap->service_set = 0U;
#line 744
  f = 0;
#line 744
  goto ldv_52022;
  ldv_52021: 
#line 745
  l = 0;
#line 745
  goto ldv_52019;
  ldv_52018: 
#line 746
  tmp___0 = valid_service_line(f, l, (int )cx->is_50hz);
#line 746
  if (tmp___0 != 0) {
#line 751
    cap->service_lines[f][l] = (__u16 )set;
#line 752
    cap->service_set = (__u16 )((int )((short )cap->service_set) | (int )((short )set));
  } else {
#line 754
    cap->service_lines[f][l] = 0U;
  }
#line 745
  l = l + 1;
  ldv_52019: ;
#line 745
  if (l <= 23) {
#line 747
    goto ldv_52018;
  } else {

  }
#line 744
  f = f + 1;
  ldv_52022: ;
#line 744
  if (f <= 1) {
#line 746
    goto ldv_52021;
  } else {

  }
#line 757
  f = 0;
#line 757
  goto ldv_52025;
  ldv_52024: 
#line 758
  cap->reserved[f] = 0U;
#line 757
  f = f + 1;
  ldv_52025: ;
#line 757
  if (f <= 2) {
#line 759
    goto ldv_52024;
  } else {

  }

#line 759
  return (0);
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int _cx18_process_idx_data(struct cx18_buffer *buf , struct v4l2_enc_idx *idx ) 
{ 
  int consumed ;
  int remaining ;
  struct v4l2_enc_idx_entry *e_idx ;
  struct cx18_enc_idx_entry *e_buf ;
  int mapping[8U] ;

  {
#line 770
  mapping[0] = -1;
#line 770
  mapping[1] = 0;
#line 770
  mapping[2] = 1;
#line 770
  mapping[3] = -1;
#line 770
  mapping[4] = 2;
#line 770
  mapping[5] = -1;
#line 770
  mapping[6] = -1;
#line 770
  mapping[7] = -1;
#line 780
  remaining = (int )(buf->bytesused - buf->readpos);
#line 781
  consumed = 0;
#line 782
  e_idx = (struct v4l2_enc_idx_entry *)(& idx->entry) + (unsigned long )idx->entries;
#line 783
  e_buf = (struct cx18_enc_idx_entry *)buf->buf + (unsigned long )buf->readpos;
#line 785
  goto ldv_52037;
  ldv_52036: 
#line 788
  e_idx->offset = ((unsigned long long )e_buf->offset_high << 32) | (unsigned long long )e_buf->offset_low;
#line 791
  e_idx->pts = (((unsigned long long )e_buf->pts_high & 1ULL) << 32) | (unsigned long long )e_buf->pts_low;
#line 794
  e_idx->length = e_buf->length;
#line 796
  e_idx->flags = (__u32 )mapping[e_buf->flags & 7U];
#line 798
  e_idx->reserved[0] = 0U;
#line 799
  e_idx->reserved[1] = 0U;
#line 801
  idx->entries = idx->entries + 1U;
#line 802
  e_idx = (struct v4l2_enc_idx_entry *)(& idx->entry) + (unsigned long )idx->entries;
#line 803
  e_buf = e_buf + 1;
#line 805
  remaining = (int )((unsigned int )remaining - 24U);
#line 806
  consumed = (int )((unsigned int )consumed + 24U);
  ldv_52037: ;
#line 785
  if ((unsigned int )remaining > 23U && idx->entries <= 63U) {
#line 788
    goto ldv_52036;
  } else {

  }

#line 810
  if (remaining > 0 && (unsigned int )remaining <= 23U) {
#line 811
    consumed = consumed + remaining;
  } else {

  }
#line 813
  buf->readpos = buf->readpos + (u32 )consumed;
#line 814
  return (consumed);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_process_idx_data(struct cx18_stream *s , struct cx18_mdl *mdl , struct v4l2_enc_idx *idx ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 820
  if (s->type != 5) {
#line 821
    return (-22);
  } else {

  }
#line 823
  if ((unsigned long )mdl->curr_buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 824
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 824
    mdl->curr_buf = (struct cx18_buffer *)__mptr;
  } else {

  }
#line 827
  if ((unsigned long )(& (mdl->curr_buf)->list) == (unsigned long )(& mdl->buf_list)) {
#line 833
    mdl->readpos = mdl->bytesused;
#line 834
    return (0);
  } else {

  }
#line 837
  goto ldv_52051;
  ldv_52050: ;
#line 840
  if ((mdl->curr_buf)->readpos >= (mdl->curr_buf)->bytesused) {
#line 841
    goto ldv_52048;
  } else {

  }
#line 843
  tmp = _cx18_process_idx_data(mdl->curr_buf, idx);
#line 843
  mdl->readpos = mdl->readpos + (u32 )tmp;
#line 846
  if ((idx->entries > 63U || (mdl->curr_buf)->readpos < (mdl->curr_buf)->bytesused) || mdl->readpos >= mdl->bytesused) {
#line 849
    goto ldv_52049;
  } else {

  }
  ldv_52048: 
#line 837
  __mptr___0 = (struct list_head  const  *)(mdl->curr_buf)->list.next;
#line 837
  mdl->curr_buf = (struct cx18_buffer *)__mptr___0;
  ldv_52051: ;
#line 837
  if ((unsigned long )(& (mdl->curr_buf)->list) != (unsigned long )(& mdl->buf_list)) {
#line 839
    goto ldv_52050;
  } else {

  }
  ldv_52049: ;
#line 851
  return (0);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_g_enc_index(struct file *file , void *fh , struct v4l2_enc_idx *idx ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct cx18_stream *s ;
  s32 tmp___0 ;
  struct cx18_mdl *mdl ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 857
  tmp = fh2id((struct v4l2_fh *)fh);
#line 857
  cx = tmp->cx;
#line 858
  s = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 862
  tmp___1 = cx18_stream_enabled(s);
#line 862
  if (tmp___1) {
#line 862
    tmp___2 = 0;
  } else {
#line 862
    tmp___2 = 1;
  }
#line 862
  if (tmp___2) {
#line 863
    return (-22);
  } else {

  }
#line 866
  tmp___0 = (s32 )(s->buffers - s->bufs_per_mdl * 3U);
#line 868
  if (tmp___0 <= 0) {
#line 869
    tmp___0 = 1;
  } else {

  }
#line 870
  tmp___0 = (s32 )((s->buf_size * (u32 )tmp___0) / 24U);
#line 873
  idx->entries = 0U;
#line 874
  idx->entries_cap = (__u32 )tmp___0;
#line 875
  memset((void *)(& idx->reserved), 0, 16UL);
  ldv_52062: 
#line 879
  mdl = cx18_dequeue(s, & s->q_full);
#line 880
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 881
    goto ldv_52061;
  } else {

  }
#line 884
  cx18_process_idx_data(s, mdl, idx);
#line 885
  if (mdl->readpos < mdl->bytesused) {
#line 887
    cx18_push(s, mdl, & s->q_full);
#line 888
    goto ldv_52061;
  } else {

  }
#line 892
  cx18_enqueue(s, mdl, & s->q_free);
#line 894
  if (idx->entries <= 63U) {
#line 896
    goto ldv_52062;
  } else {

  }
  ldv_52061: 
#line 897
  cx18_stream_load_fw_queue(s);
#line 898
  return (0);
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static struct videobuf_queue *cx18_vb_queue(struct cx18_open_id *id ) 
{ 
  struct videobuf_queue *q ;
  struct cx18 *cx ;
  struct cx18_stream *s ;

  {
#line 903
  q = (struct videobuf_queue *)0;
#line 904
  cx = id->cx;
#line 905
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 907
  switch ((unsigned int )s->vb_type) {
  case 1U: 
#line 909
  q = & s->vbuf_q;
#line 910
  goto ldv_52070;
  case 4U: ;
#line 912
  goto ldv_52070;
  default: ;
#line 914
  goto ldv_52070;
  }
  ldv_52070: ;
#line 916
  return (q);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_streamon(struct file *file , void *priv , enum v4l2_buf_type type ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  unsigned long tmp ;
  struct videobuf_queue *tmp___0 ;
  int tmp___1 ;

  {
#line 922
  id = (struct cx18_open_id *)file->private_data;
#line 923
  cx = id->cx;
#line 924
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 927
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 929
    return (-22);
  } else {

  }
#line 931
  if (id->type != 2) {
#line 932
    return (-22);
  } else {

  }
#line 935
  tmp = msecs_to_jiffies(2000U);
#line 935
  ldv_mod_timer_375(& s->vb_timeout, tmp + (unsigned long )jiffies);
#line 937
  tmp___0 = cx18_vb_queue(id);
#line 937
  tmp___1 = videobuf_streamon(tmp___0);
#line 937
  return (tmp___1);
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_streamoff(struct file *file , void *priv , enum v4l2_buf_type type ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 943
  id = (struct cx18_open_id *)file->private_data;
#line 944
  cx = id->cx;
#line 945
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 948
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 950
    return (-22);
  } else {

  }
#line 952
  if (id->type != 2) {
#line 953
    return (-22);
  } else {

  }
#line 955
  tmp = cx18_vb_queue(id);
#line 955
  tmp___0 = videobuf_streamoff(tmp);
#line 955
  return (tmp___0);
}
}
#line 958 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_reqbufs(struct file *file , void *priv , struct v4l2_requestbuffers *rb ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 961
  id = (struct cx18_open_id *)file->private_data;
#line 962
  cx = id->cx;
#line 963
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 965
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 967
    return (-22);
  } else {

  }
#line 969
  tmp = cx18_vb_queue(id);
#line 969
  tmp___0 = videobuf_reqbufs(tmp, rb);
#line 969
  return (tmp___0);
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_querybuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 975
  id = (struct cx18_open_id *)file->private_data;
#line 976
  cx = id->cx;
#line 977
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 979
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 981
    return (-22);
  } else {

  }
#line 983
  tmp = cx18_vb_queue(id);
#line 983
  tmp___0 = videobuf_querybuf(tmp, b);
#line 983
  return (tmp___0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_qbuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 988
  id = (struct cx18_open_id *)file->private_data;
#line 989
  cx = id->cx;
#line 990
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 992
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 994
    return (-22);
  } else {

  }
#line 996
  tmp = cx18_vb_queue(id);
#line 996
  tmp___0 = videobuf_qbuf(tmp, b);
#line 996
  return (tmp___0);
}
}
#line 999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_dqbuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 1001
  id = (struct cx18_open_id *)file->private_data;
#line 1002
  cx = id->cx;
#line 1003
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 1005
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 1007
    return (-22);
  } else {

  }
#line 1009
  tmp = cx18_vb_queue(id);
#line 1009
  tmp___0 = videobuf_dqbuf(tmp, b, (int )file->f_flags & 2048);
#line 1009
  return (tmp___0);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  u32 h ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1015
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1015
  id = tmp;
#line 1016
  cx = id->cx;
#line 1019
  switch (enc->cmd) {
  case 0U: ;
#line 1021
  if ((cx18_debug & 16) != 0) {
#line 1021
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1022
  enc->flags = 0U;
#line 1023
  tmp___0 = cx18_start_capture(id);
#line 1023
  return (tmp___0);
  case 1U: ;
#line 1026
  if ((cx18_debug & 16) != 0) {
#line 1026
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1027
  enc->flags = enc->flags & 1U;
#line 1028
  cx18_stop_capture(id, (int )enc->flags & 1);
#line 1030
  goto ldv_52131;
  case 2U: ;
#line 1033
  if ((cx18_debug & 16) != 0) {
#line 1033
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1034
  enc->flags = 0U;
#line 1035
  tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 1035
  if (tmp___1 == 0) {
#line 1036
    return (-1);
  } else {

  }
#line 1037
  tmp___2 = test_and_set_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 1037
  if (tmp___2 != 0) {
#line 1038
    return (0);
  } else {

  }
#line 1039
  h = cx18_find_handle(cx);
#line 1040
  if (h == 4294967295U) {
#line 1041
    printk("\v%s: Can\'t find valid task handle for V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
#line 1043
    return (-77);
  } else {

  }
#line 1045
  cx18_mute(cx);
#line 1046
  cx18_vapi(cx, 537001991U, 1, h);
#line 1047
  goto ldv_52131;
  case 3U: ;
#line 1050
  if ((cx18_debug & 16) != 0) {
#line 1050
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1051
  enc->flags = 0U;
#line 1052
  tmp___3 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 1052
  if (tmp___3 == 0) {
#line 1053
    return (-1);
  } else {

  }
#line 1054
  tmp___4 = test_and_clear_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 1054
  if (tmp___4 == 0) {
#line 1055
    return (0);
  } else {

  }
#line 1056
  h = cx18_find_handle(cx);
#line 1057
  if (h == 4294967295U) {
#line 1058
    printk("\v%s: Can\'t find valid task handle for V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
#line 1060
    return (-77);
  } else {

  }
#line 1062
  cx18_vapi(cx, 537001992U, 1, h);
#line 1063
  cx18_unmute(cx);
#line 1064
  goto ldv_52131;
  default: ;
#line 1067
  if ((cx18_debug & 16) != 0) {
#line 1067
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& cx->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 1068
  return (-22);
  }
  ldv_52131: ;
#line 1070
  return (0);
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_try_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 1076
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1076
  cx = tmp->cx;
#line 1078
  switch (enc->cmd) {
  case 0U: ;
#line 1080
  if ((cx18_debug & 16) != 0) {
#line 1080
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1081
  enc->flags = 0U;
#line 1082
  goto ldv_52142;
  case 1U: ;
#line 1085
  if ((cx18_debug & 16) != 0) {
#line 1085
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1086
  enc->flags = enc->flags & 1U;
#line 1087
  goto ldv_52142;
  case 2U: ;
#line 1090
  if ((cx18_debug & 16) != 0) {
#line 1090
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1091
  enc->flags = 0U;
#line 1092
  goto ldv_52142;
  case 3U: ;
#line 1095
  if ((cx18_debug & 16) != 0) {
#line 1095
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1096
  enc->flags = 0U;
#line 1097
  goto ldv_52142;
  default: ;
#line 1100
  if ((cx18_debug & 16) != 0) {
#line 1100
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& cx->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 1101
  return (-22);
  }
  ldv_52142: ;
#line 1103
  return (0);
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static int cx18_log_status(struct file *file , void *fh ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_input vidin ;
  struct v4l2_audio audin ;
  int i ;
  struct tveeprom tv ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct cx18_stream *s ;
  int tmp___1 ;

  {
#line 1108
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1108
  cx = tmp->cx;
#line 1113
  printk("\016%s: Version: %s  Card: %s\n", (char *)(& cx->v4l2_dev.name), (char *)"1.5.1",
         cx->card_name);
#line 1114
  if ((cx->hw_flags & 2U) != 0U) {
#line 1117
    cx18_read_eeprom(cx, & tv);
  } else {

  }
#line 1119
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1119
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 1119
  goto ldv_52162;
  ldv_52161: ;
#line 1119
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->log_status != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1119
    (*(((__sd->ops)->core)->log_status))(__sd);
  } else {

  }
#line 1119
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1119
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_52162: ;
#line 1119
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1121
    goto ldv_52161;
  } else {

  }
#line 1120
  cx18_get_input(cx, (int )((u16 )cx->active_input), & vidin);
#line 1121
  cx18_get_audio_input(cx, (int )((u16 )cx->audio_input), & audin);
#line 1122
  printk("\016%s: Video Input: %s\n", (char *)(& cx->v4l2_dev.name), (__u8 *)(& vidin.name));
#line 1123
  printk("\016%s: Audio Input: %s\n", (char *)(& cx->v4l2_dev.name), (__u8 *)(& audin.name));
#line 1124
  mutex_lock_nested(& cx->gpio_lock, 0U);
#line 1125
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& cx->v4l2_dev.name),
         cx->gpio_dir, cx->gpio_val);
#line 1127
  mutex_unlock(& cx->gpio_lock);
#line 1128
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 1128
  printk("\016%s: Tuner: %s\n", (char *)(& cx->v4l2_dev.name), tmp___0 != 0 ? (char *)"Radio" : (char *)"TV");
#line 1130
  v4l2_ctrl_handler_log_status(& cx->cxhdl.hdl, (char const   *)(& cx->v4l2_dev.name));
#line 1131
  printk("\016%s: Status flags: 0x%08lx\n", (char *)(& cx->v4l2_dev.name), cx->i_flags);
#line 1132
  i = 0;
#line 1132
  goto ldv_52167;
  ldv_52166: 
#line 1133
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1135
  if ((unsigned long )s->video_dev == (unsigned long )((struct video_device *)0) || s->buffers == 0U) {
#line 1136
    goto ldv_52165;
  } else {

  }
#line 1137
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 1137
  printk("\016%s: Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\n",
         (char *)(& cx->v4l2_dev.name), s->name, s->s_flags, (((u32 )tmp___1 * s->bufs_per_mdl) * 100U) / s->buffers,
         (s->buffers * s->buf_size) / 1024U, s->buffers);
  ldv_52165: 
#line 1132
  i = i + 1;
  ldv_52167: ;
#line 1132
  if (i <= 6) {
#line 1134
    goto ldv_52166;
  } else {

  }
#line 1143
  printk("\016%s: Read MPEG/VBI: %lld/%lld bytes\n", (char *)(& cx->v4l2_dev.name),
         (long long )cx->mpg_data_received, (long long )cx->vbi_data_inserted);
#line 1146
  return (0);
}
}
#line 1149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static long cx18_default(struct file *file , void *fh , bool valid_prio , unsigned int cmd ,
                         void *arg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  u32 val ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1152
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1152
  cx = tmp->cx;
#line 1154
  switch (cmd) {
  case 1074029670U: 
#line 1156
  val = *((u32 *)arg);
#line 1158
  if (val == 0U || (int )val & 1) {
#line 1159
    __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1159
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 1159
    goto ldv_52185;
    ldv_52184: ;
#line 1159
    if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                           u32  ))0)) {
#line 1159
      (*(((__sd->ops)->core)->reset))(__sd, 1U);
    } else {

    }
#line 1159
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1159
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
    ldv_52185: ;
#line 1159
    if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1161
      goto ldv_52184;
    } else {

    }

  } else {

  }
#line 1161
  goto ldv_52187;
  default: ;
#line 1165
  return (-25L);
  }
  ldv_52187: ;
#line 1167
  return (0L);
}
}
#line 1170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
static struct v4l2_ioctl_ops  const  cx18_ioctl_ops  = 
#line 1170
     {& cx18_querycap, 0, 0, & cx18_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & cx18_g_fmt_vid_cap,
    0, 0, 0, & cx18_g_fmt_vbi_cap, 0, & cx18_g_fmt_sliced_vbi_cap, 0, 0, 0, 0, & cx18_s_fmt_vid_cap,
    0, 0, 0, & cx18_s_fmt_vbi_cap, 0, & cx18_s_fmt_sliced_vbi_cap, 0, 0, 0, 0, & cx18_try_fmt_vid_cap,
    0, 0, 0, & cx18_try_fmt_vbi_cap, 0, & cx18_try_fmt_sliced_vbi_cap, 0, 0, 0, 0,
    & cx18_reqbufs, & cx18_querybuf, & cx18_qbuf, 0, & cx18_dqbuf, 0, 0, 0, 0, 0,
    & cx18_streamon, & cx18_streamoff, & cx18_g_std, & cx18_s_std, 0, & cx18_enum_input,
    & cx18_g_input, & cx18_s_input, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cx18_enumaudio,
    & cx18_g_audio, & cx18_s_audio, 0, 0, 0, 0, 0, & cx18_cropcap, & cx18_g_crop,
    & cx18_s_crop, 0, 0, 0, 0, & cx18_g_enc_index, & cx18_encoder_cmd, & cx18_try_encoder_cmd,
    0, 0, 0, 0, & cx18_g_tuner, & cx18_s_tuner, & cx18_g_frequency, & cx18_s_frequency,
    0, & cx18_g_sliced_vbi_cap, & cx18_log_status, 0, & cx18_g_register, & cx18_s_register,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cx18_default};
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void cx18_set_funcs(struct video_device *vdev ) 
{ 


  {
#line 1217
  vdev->ioctl_ops = & cx18_ioctl_ops;
#line 1218
  return;
}
}
#line 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1222
  tmp = ldv_zalloc(52UL);
#line 1222
  cx18_ioctl_ops_group3 = (struct v4l2_audio *)tmp;
#line 1223
  tmp___0 = ldv_zalloc(512UL);
#line 1223
  cx18_ioctl_ops_group1 = (struct file *)tmp___0;
#line 1224
  tmp___1 = ldv_zalloc(208UL);
#line 1224
  cx18_ioctl_ops_group0 = (struct v4l2_format *)tmp___1;
#line 1225
  tmp___2 = ldv_zalloc(40UL);
#line 1225
  cx18_ioctl_ops_group4 = (struct v4l2_encoder_cmd *)tmp___2;
#line 1226
  tmp___3 = ldv_zalloc(88UL);
#line 1226
  cx18_ioctl_ops_group2 = (struct v4l2_buffer *)tmp___3;
#line 1227
  return;
}
}
#line 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  void *ldvarg52 ;
  void *tmp ;
  void *ldvarg74 ;
  void *tmp___0 ;
  void *ldvarg61 ;
  void *tmp___1 ;
  struct v4l2_frequency *ldvarg78 ;
  void *tmp___2 ;
  struct v4l2_tuner *ldvarg88 ;
  void *tmp___3 ;
  struct v4l2_dbg_register *ldvarg73 ;
  void *tmp___4 ;
  void *ldvarg66 ;
  void *tmp___5 ;
  struct v4l2_enc_idx *ldvarg65 ;
  void *tmp___6 ;
  struct v4l2_tuner *ldvarg57 ;
  void *tmp___7 ;
  struct v4l2_dbg_register *ldvarg62 ;
  void *tmp___8 ;
  void *ldvarg87 ;
  void *tmp___9 ;
  void *ldvarg80 ;
  void *tmp___10 ;
  void *ldvarg39 ;
  void *tmp___11 ;
  unsigned int ldvarg34 ;
  unsigned int tmp___12 ;
  void *ldvarg89 ;
  void *tmp___13 ;
  void *ldvarg93 ;
  void *tmp___14 ;
  void *ldvarg48 ;
  void *tmp___15 ;
  struct v4l2_input *ldvarg38 ;
  void *tmp___16 ;
  void *ldvarg85 ;
  void *tmp___17 ;
  bool ldvarg35 ;
  enum v4l2_buf_type ldvarg29 ;
  void *ldvarg37 ;
  void *tmp___18 ;
  void *ldvarg72 ;
  void *tmp___19 ;
  void *ldvarg56 ;
  void *tmp___20 ;
  struct v4l2_crop *ldvarg71 ;
  void *tmp___21 ;
  void *ldvarg43 ;
  void *tmp___22 ;
  void *ldvarg91 ;
  void *tmp___23 ;
  struct v4l2_sliced_vbi_cap *ldvarg67 ;
  void *tmp___24 ;
  void *ldvarg77 ;
  void *tmp___25 ;
  void *ldvarg75 ;
  void *tmp___26 ;
  unsigned int *ldvarg76 ;
  void *tmp___27 ;
  struct v4l2_fmtdesc *ldvarg82 ;
  void *tmp___28 ;
  void *ldvarg92 ;
  void *tmp___29 ;
  void *ldvarg54 ;
  void *tmp___30 ;
  void *ldvarg30 ;
  void *tmp___31 ;
  void *ldvarg68 ;
  void *tmp___32 ;
  void *ldvarg90 ;
  void *tmp___33 ;
  void *ldvarg70 ;
  void *tmp___34 ;
  void *ldvarg63 ;
  void *tmp___35 ;
  void *ldvarg45 ;
  void *tmp___36 ;
  void *ldvarg81 ;
  void *tmp___37 ;
  v4l2_std_id *ldvarg40 ;
  void *tmp___38 ;
  v4l2_std_id ldvarg55 ;
  void *ldvarg36 ;
  void *tmp___39 ;
  void *ldvarg79 ;
  void *tmp___40 ;
  struct v4l2_cropcap *ldvarg49 ;
  void *tmp___41 ;
  enum v4l2_buf_type ldvarg86 ;
  struct v4l2_requestbuffers *ldvarg59 ;
  void *tmp___42 ;
  void *ldvarg60 ;
  void *tmp___43 ;
  void *ldvarg41 ;
  void *tmp___44 ;
  struct v4l2_audio *ldvarg31 ;
  void *tmp___45 ;
  void *ldvarg47 ;
  void *tmp___46 ;
  void *ldvarg33 ;
  void *tmp___47 ;
  unsigned int ldvarg69 ;
  unsigned int tmp___48 ;
  void *ldvarg83 ;
  void *tmp___49 ;
  struct v4l2_capability *ldvarg44 ;
  void *tmp___50 ;
  void *ldvarg64 ;
  void *tmp___51 ;
  void *ldvarg53 ;
  void *tmp___52 ;
  void *ldvarg58 ;
  void *tmp___53 ;
  void *ldvarg46 ;
  void *tmp___54 ;
  void *ldvarg50 ;
  void *tmp___55 ;
  struct v4l2_frequency *ldvarg42 ;
  void *tmp___56 ;
  void *ldvarg32 ;
  void *tmp___57 ;
  void *ldvarg51 ;
  void *tmp___58 ;
  struct v4l2_crop *ldvarg84 ;
  void *tmp___59 ;
  int tmp___60 ;

  {
#line 1230
  tmp = ldv_zalloc(1UL);
#line 1230
  ldvarg52 = tmp;
#line 1231
  tmp___0 = ldv_zalloc(1UL);
#line 1231
  ldvarg74 = tmp___0;
#line 1232
  tmp___1 = ldv_zalloc(1UL);
#line 1232
  ldvarg61 = tmp___1;
#line 1233
  tmp___2 = ldv_zalloc(44UL);
#line 1233
  ldvarg78 = (struct v4l2_frequency *)tmp___2;
#line 1234
  tmp___3 = ldv_zalloc(84UL);
#line 1234
  ldvarg88 = (struct v4l2_tuner *)tmp___3;
#line 1235
  tmp___4 = ldv_zalloc(56UL);
#line 1235
  ldvarg73 = (struct v4l2_dbg_register *)tmp___4;
#line 1236
  tmp___5 = ldv_zalloc(1UL);
#line 1236
  ldvarg66 = tmp___5;
#line 1237
  tmp___6 = ldv_zalloc(2072UL);
#line 1237
  ldvarg65 = (struct v4l2_enc_idx *)tmp___6;
#line 1238
  tmp___7 = ldv_zalloc(84UL);
#line 1238
  ldvarg57 = (struct v4l2_tuner *)tmp___7;
#line 1239
  tmp___8 = ldv_zalloc(56UL);
#line 1239
  ldvarg62 = (struct v4l2_dbg_register *)tmp___8;
#line 1240
  tmp___9 = ldv_zalloc(1UL);
#line 1240
  ldvarg87 = tmp___9;
#line 1241
  tmp___10 = ldv_zalloc(1UL);
#line 1241
  ldvarg80 = tmp___10;
#line 1242
  tmp___11 = ldv_zalloc(1UL);
#line 1242
  ldvarg39 = tmp___11;
#line 1243
  tmp___12 = __VERIFIER_nondet_uint();
#line 1243
  ldvarg34 = tmp___12;
#line 1244
  tmp___13 = ldv_zalloc(1UL);
#line 1244
  ldvarg89 = tmp___13;
#line 1245
  tmp___14 = ldv_zalloc(1UL);
#line 1245
  ldvarg93 = tmp___14;
#line 1246
  tmp___15 = ldv_zalloc(1UL);
#line 1246
  ldvarg48 = tmp___15;
#line 1247
  tmp___16 = ldv_zalloc(80UL);
#line 1247
  ldvarg38 = (struct v4l2_input *)tmp___16;
#line 1248
  tmp___17 = ldv_zalloc(1UL);
#line 1248
  ldvarg85 = tmp___17;
#line 1251
  tmp___18 = ldv_zalloc(1UL);
#line 1251
  ldvarg37 = tmp___18;
#line 1252
  tmp___19 = ldv_zalloc(1UL);
#line 1252
  ldvarg72 = tmp___19;
#line 1253
  tmp___20 = ldv_zalloc(1UL);
#line 1253
  ldvarg56 = tmp___20;
#line 1254
  tmp___21 = ldv_zalloc(20UL);
#line 1254
  ldvarg71 = (struct v4l2_crop *)tmp___21;
#line 1255
  tmp___22 = ldv_zalloc(1UL);
#line 1255
  ldvarg43 = tmp___22;
#line 1256
  tmp___23 = ldv_zalloc(1UL);
#line 1256
  ldvarg91 = tmp___23;
#line 1257
  tmp___24 = ldv_zalloc(116UL);
#line 1257
  ldvarg67 = (struct v4l2_sliced_vbi_cap *)tmp___24;
#line 1258
  tmp___25 = ldv_zalloc(1UL);
#line 1258
  ldvarg77 = tmp___25;
#line 1259
  tmp___26 = ldv_zalloc(1UL);
#line 1259
  ldvarg75 = tmp___26;
#line 1260
  tmp___27 = ldv_zalloc(4UL);
#line 1260
  ldvarg76 = (unsigned int *)tmp___27;
#line 1261
  tmp___28 = ldv_zalloc(64UL);
#line 1261
  ldvarg82 = (struct v4l2_fmtdesc *)tmp___28;
#line 1262
  tmp___29 = ldv_zalloc(1UL);
#line 1262
  ldvarg92 = tmp___29;
#line 1263
  tmp___30 = ldv_zalloc(1UL);
#line 1263
  ldvarg54 = tmp___30;
#line 1264
  tmp___31 = ldv_zalloc(1UL);
#line 1264
  ldvarg30 = tmp___31;
#line 1265
  tmp___32 = ldv_zalloc(1UL);
#line 1265
  ldvarg68 = tmp___32;
#line 1266
  tmp___33 = ldv_zalloc(1UL);
#line 1266
  ldvarg90 = tmp___33;
#line 1267
  tmp___34 = ldv_zalloc(1UL);
#line 1267
  ldvarg70 = tmp___34;
#line 1268
  tmp___35 = ldv_zalloc(1UL);
#line 1268
  ldvarg63 = tmp___35;
#line 1269
  tmp___36 = ldv_zalloc(1UL);
#line 1269
  ldvarg45 = tmp___36;
#line 1270
  tmp___37 = ldv_zalloc(1UL);
#line 1270
  ldvarg81 = tmp___37;
#line 1271
  tmp___38 = ldv_zalloc(8UL);
#line 1271
  ldvarg40 = (v4l2_std_id *)tmp___38;
#line 1273
  tmp___39 = ldv_zalloc(1UL);
#line 1273
  ldvarg36 = tmp___39;
#line 1274
  tmp___40 = ldv_zalloc(1UL);
#line 1274
  ldvarg79 = tmp___40;
#line 1275
  tmp___41 = ldv_zalloc(44UL);
#line 1275
  ldvarg49 = (struct v4l2_cropcap *)tmp___41;
#line 1277
  tmp___42 = ldv_zalloc(20UL);
#line 1277
  ldvarg59 = (struct v4l2_requestbuffers *)tmp___42;
#line 1278
  tmp___43 = ldv_zalloc(1UL);
#line 1278
  ldvarg60 = tmp___43;
#line 1279
  tmp___44 = ldv_zalloc(1UL);
#line 1279
  ldvarg41 = tmp___44;
#line 1280
  tmp___45 = ldv_zalloc(52UL);
#line 1280
  ldvarg31 = (struct v4l2_audio *)tmp___45;
#line 1281
  tmp___46 = ldv_zalloc(1UL);
#line 1281
  ldvarg47 = tmp___46;
#line 1282
  tmp___47 = ldv_zalloc(1UL);
#line 1282
  ldvarg33 = tmp___47;
#line 1283
  tmp___48 = __VERIFIER_nondet_uint();
#line 1283
  ldvarg69 = tmp___48;
#line 1284
  tmp___49 = ldv_zalloc(1UL);
#line 1284
  ldvarg83 = tmp___49;
#line 1285
  tmp___50 = ldv_zalloc(104UL);
#line 1285
  ldvarg44 = (struct v4l2_capability *)tmp___50;
#line 1286
  tmp___51 = ldv_zalloc(1UL);
#line 1286
  ldvarg64 = tmp___51;
#line 1287
  tmp___52 = ldv_zalloc(1UL);
#line 1287
  ldvarg53 = tmp___52;
#line 1288
  tmp___53 = ldv_zalloc(1UL);
#line 1288
  ldvarg58 = tmp___53;
#line 1289
  tmp___54 = ldv_zalloc(1UL);
#line 1289
  ldvarg46 = tmp___54;
#line 1290
  tmp___55 = ldv_zalloc(1UL);
#line 1290
  ldvarg50 = tmp___55;
#line 1291
  tmp___56 = ldv_zalloc(44UL);
#line 1291
  ldvarg42 = (struct v4l2_frequency *)tmp___56;
#line 1292
  tmp___57 = ldv_zalloc(1UL);
#line 1292
  ldvarg32 = tmp___57;
#line 1293
  tmp___58 = ldv_zalloc(1UL);
#line 1293
  ldvarg51 = tmp___58;
#line 1294
  tmp___59 = ldv_zalloc(20UL);
#line 1294
  ldvarg84 = (struct v4l2_crop *)tmp___59;
#line 1249
  memset((void *)(& ldvarg35), 0, 1UL);
#line 1250
  memset((void *)(& ldvarg29), 0, 4UL);
#line 1272
  memset((void *)(& ldvarg55), 0, 8UL);
#line 1276
  memset((void *)(& ldvarg86), 0, 4UL);
#line 1296
  tmp___60 = __VERIFIER_nondet_int();
#line 1296
  switch (tmp___60) {
  case 0: ;
#line 1299
  if (ldv_state_variable_12 == 1) {
#line 1301
    cx18_try_fmt_sliced_vbi_cap(cx18_ioctl_ops_group1, ldvarg93, cx18_ioctl_ops_group0);
#line 1303
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1306
  goto ldv_52265;
  case 1: ;
#line 1309
  if (ldv_state_variable_12 == 1) {
#line 1311
    cx18_s_fmt_vbi_cap(cx18_ioctl_ops_group1, ldvarg92, cx18_ioctl_ops_group0);
#line 1313
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1316
  goto ldv_52265;
  case 2: ;
#line 1319
  if (ldv_state_variable_12 == 1) {
#line 1321
    cx18_try_fmt_vid_cap(cx18_ioctl_ops_group1, ldvarg91, cx18_ioctl_ops_group0);
#line 1323
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1326
  goto ldv_52265;
  case 3: ;
#line 1329
  if (ldv_state_variable_12 == 1) {
#line 1331
    cx18_try_encoder_cmd(cx18_ioctl_ops_group1, ldvarg90, cx18_ioctl_ops_group4);
#line 1333
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1336
  goto ldv_52265;
  case 4: ;
#line 1339
  if (ldv_state_variable_12 == 1) {
#line 1341
    cx18_s_tuner(cx18_ioctl_ops_group1, ldvarg89, (struct v4l2_tuner  const  *)ldvarg88);
#line 1343
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1346
  goto ldv_52265;
  case 5: ;
#line 1349
  if (ldv_state_variable_12 == 1) {
#line 1351
    cx18_streamoff(cx18_ioctl_ops_group1, ldvarg87, ldvarg86);
#line 1353
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1356
  goto ldv_52265;
  case 6: ;
#line 1359
  if (ldv_state_variable_12 == 1) {
#line 1361
    cx18_g_crop(cx18_ioctl_ops_group1, ldvarg85, ldvarg84);
#line 1363
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1366
  goto ldv_52265;
  case 7: ;
#line 1369
  if (ldv_state_variable_12 == 1) {
#line 1371
    cx18_enum_fmt_vid_cap(cx18_ioctl_ops_group1, ldvarg83, ldvarg82);
#line 1373
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1376
  goto ldv_52265;
  case 8: ;
#line 1379
  if (ldv_state_variable_12 == 1) {
#line 1381
    cx18_encoder_cmd(cx18_ioctl_ops_group1, ldvarg81, cx18_ioctl_ops_group4);
#line 1383
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1386
  goto ldv_52265;
  case 9: ;
#line 1389
  if (ldv_state_variable_12 == 1) {
#line 1391
    cx18_s_fmt_vid_cap(cx18_ioctl_ops_group1, ldvarg80, cx18_ioctl_ops_group0);
#line 1393
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1396
  goto ldv_52265;
  case 10: ;
#line 1399
  if (ldv_state_variable_12 == 1) {
#line 1401
    cx18_g_frequency(cx18_ioctl_ops_group1, ldvarg79, ldvarg78);
#line 1403
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1406
  goto ldv_52265;
  case 11: ;
#line 1409
  if (ldv_state_variable_12 == 1) {
#line 1411
    cx18_g_input(cx18_ioctl_ops_group1, ldvarg77, ldvarg76);
#line 1413
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1416
  goto ldv_52265;
  case 12: ;
#line 1419
  if (ldv_state_variable_12 == 1) {
#line 1421
    cx18_qbuf(cx18_ioctl_ops_group1, ldvarg75, cx18_ioctl_ops_group2);
#line 1423
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1426
  goto ldv_52265;
  case 13: ;
#line 1429
  if (ldv_state_variable_12 == 1) {
#line 1431
    cx18_g_register(cx18_ioctl_ops_group1, ldvarg74, ldvarg73);
#line 1433
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1436
  goto ldv_52265;
  case 14: ;
#line 1439
  if (ldv_state_variable_12 == 1) {
#line 1441
    cx18_s_crop(cx18_ioctl_ops_group1, ldvarg72, (struct v4l2_crop  const  *)ldvarg71);
#line 1443
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1446
  goto ldv_52265;
  case 15: ;
#line 1449
  if (ldv_state_variable_12 == 1) {
#line 1451
    cx18_s_input(cx18_ioctl_ops_group1, ldvarg70, ldvarg69);
#line 1453
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1456
  goto ldv_52265;
  case 16: ;
#line 1459
  if (ldv_state_variable_12 == 1) {
#line 1461
    cx18_g_sliced_vbi_cap(cx18_ioctl_ops_group1, ldvarg68, ldvarg67);
#line 1463
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1466
  goto ldv_52265;
  case 17: ;
#line 1469
  if (ldv_state_variable_12 == 1) {
#line 1471
    cx18_g_enc_index(cx18_ioctl_ops_group1, ldvarg66, ldvarg65);
#line 1473
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1476
  goto ldv_52265;
  case 18: ;
#line 1479
  if (ldv_state_variable_12 == 1) {
#line 1481
    cx18_g_fmt_sliced_vbi_cap(cx18_ioctl_ops_group1, ldvarg64, cx18_ioctl_ops_group0);
#line 1483
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1486
  goto ldv_52265;
  case 19: ;
#line 1489
  if (ldv_state_variable_12 == 1) {
#line 1491
    cx18_s_register(cx18_ioctl_ops_group1, ldvarg63, (struct v4l2_dbg_register  const  *)ldvarg62);
#line 1493
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1496
  goto ldv_52265;
  case 20: ;
#line 1499
  if (ldv_state_variable_12 == 1) {
#line 1501
    cx18_enumaudio(cx18_ioctl_ops_group1, ldvarg61, cx18_ioctl_ops_group3);
#line 1503
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1506
  goto ldv_52265;
  case 21: ;
#line 1509
  if (ldv_state_variable_12 == 1) {
#line 1511
    cx18_reqbufs(cx18_ioctl_ops_group1, ldvarg60, ldvarg59);
#line 1513
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1516
  goto ldv_52265;
  case 22: ;
#line 1519
  if (ldv_state_variable_12 == 1) {
#line 1521
    cx18_g_tuner(cx18_ioctl_ops_group1, ldvarg58, ldvarg57);
#line 1523
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1526
  goto ldv_52265;
  case 23: ;
#line 1529
  if (ldv_state_variable_12 == 1) {
#line 1531
    cx18_s_std(cx18_ioctl_ops_group1, ldvarg56, ldvarg55);
#line 1533
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1536
  goto ldv_52265;
  case 24: ;
#line 1539
  if (ldv_state_variable_12 == 1) {
#line 1541
    cx18_try_fmt_vbi_cap(cx18_ioctl_ops_group1, ldvarg54, cx18_ioctl_ops_group0);
#line 1543
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1546
  goto ldv_52265;
  case 25: ;
#line 1549
  if (ldv_state_variable_12 == 1) {
#line 1551
    cx18_log_status(cx18_ioctl_ops_group1, ldvarg53);
#line 1553
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1556
  goto ldv_52265;
  case 26: ;
#line 1559
  if (ldv_state_variable_12 == 1) {
#line 1561
    cx18_dqbuf(cx18_ioctl_ops_group1, ldvarg52, cx18_ioctl_ops_group2);
#line 1563
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1566
  goto ldv_52265;
  case 27: ;
#line 1569
  if (ldv_state_variable_12 == 1) {
#line 1571
    cx18_querybuf(cx18_ioctl_ops_group1, ldvarg51, cx18_ioctl_ops_group2);
#line 1573
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1576
  goto ldv_52265;
  case 28: ;
#line 1579
  if (ldv_state_variable_12 == 1) {
#line 1581
    cx18_cropcap(cx18_ioctl_ops_group1, ldvarg50, ldvarg49);
#line 1583
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1586
  goto ldv_52265;
  case 29: ;
#line 1589
  if (ldv_state_variable_12 == 1) {
#line 1591
    cx18_g_fmt_vid_cap(cx18_ioctl_ops_group1, ldvarg48, cx18_ioctl_ops_group0);
#line 1593
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1596
  goto ldv_52265;
  case 30: ;
#line 1599
  if (ldv_state_variable_12 == 1) {
#line 1601
    cx18_s_fmt_sliced_vbi_cap(cx18_ioctl_ops_group1, ldvarg47, cx18_ioctl_ops_group0);
#line 1603
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1606
  goto ldv_52265;
  case 31: ;
#line 1609
  if (ldv_state_variable_12 == 1) {
#line 1611
    cx18_g_audio(cx18_ioctl_ops_group1, ldvarg46, cx18_ioctl_ops_group3);
#line 1613
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1616
  goto ldv_52265;
  case 32: ;
#line 1619
  if (ldv_state_variable_12 == 1) {
#line 1621
    cx18_querycap(cx18_ioctl_ops_group1, ldvarg45, ldvarg44);
#line 1623
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1626
  goto ldv_52265;
  case 33: ;
#line 1629
  if (ldv_state_variable_12 == 1) {
#line 1631
    cx18_s_frequency(cx18_ioctl_ops_group1, ldvarg43, (struct v4l2_frequency  const  *)ldvarg42);
#line 1633
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1636
  goto ldv_52265;
  case 34: ;
#line 1639
  if (ldv_state_variable_12 == 1) {
#line 1641
    cx18_g_std(cx18_ioctl_ops_group1, ldvarg41, ldvarg40);
#line 1643
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1646
  goto ldv_52265;
  case 35: ;
#line 1649
  if (ldv_state_variable_12 == 1) {
#line 1651
    cx18_enum_input(cx18_ioctl_ops_group1, ldvarg39, ldvarg38);
#line 1653
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1656
  goto ldv_52265;
  case 36: ;
#line 1659
  if (ldv_state_variable_12 == 1) {
#line 1661
    cx18_default(cx18_ioctl_ops_group1, ldvarg36, (int )ldvarg35, ldvarg34, ldvarg37);
#line 1663
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1666
  goto ldv_52265;
  case 37: ;
#line 1669
  if (ldv_state_variable_12 == 1) {
#line 1671
    cx18_g_fmt_vbi_cap(cx18_ioctl_ops_group1, ldvarg33, cx18_ioctl_ops_group0);
#line 1673
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1676
  goto ldv_52265;
  case 38: ;
#line 1679
  if (ldv_state_variable_12 == 1) {
#line 1681
    cx18_s_audio(cx18_ioctl_ops_group1, ldvarg32, (struct v4l2_audio  const  *)ldvarg31);
#line 1683
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1686
  goto ldv_52265;
  case 39: ;
#line 1689
  if (ldv_state_variable_12 == 1) {
#line 1691
    cx18_streamon(cx18_ioctl_ops_group1, ldvarg30, ldvarg29);
#line 1693
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1696
  goto ldv_52265;
  default: 
#line 1697
  ldv_stop();
  }
  ldv_52265: ;
#line 1701
  return;
}
}
#line 1829 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void *ldv_kmem_cache_alloc_358(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1832
  ldv_check_alloc_flags(flags);
#line 1834
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1835
  return ((void *)0);
}
}
#line 1873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_pskb_expand_head_364(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1876
  ldv_check_alloc_flags(flags);
#line 1878
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1878
  return (tmp);
}
}
#line 1889 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv_skb_clone_366(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1892
  ldv_check_alloc_flags(flags);
#line 1894
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1894
  return (tmp);
}
}
#line 1905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv_skb_copy_368(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1908
  ldv_check_alloc_flags(flags);
#line 1910
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1910
  return (tmp);
}
}
#line 1913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_369(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1916
  ldv_check_alloc_flags(flags);
#line 1918
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1918
  return (tmp);
}
}
#line 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_370(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1924
  ldv_check_alloc_flags(flags);
#line 1926
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1926
  return (tmp);
}
}
#line 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1932
  ldv_check_alloc_flags(flags);
#line 1934
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1934
  return (tmp);
}
}
#line 1937 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_pskb_expand_head_372(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1940
  ldv_check_alloc_flags(flags);
#line 1942
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1942
  return (tmp);
}
}
#line 1945 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_pskb_expand_head_373(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1948
  ldv_check_alloc_flags(flags);
#line 1950
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1950
  return (tmp);
}
}
#line 1953 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
struct sk_buff *ldv_skb_clone_374(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1956
  ldv_check_alloc_flags(flags);
#line 1958
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1958
  return (tmp);
}
}
#line 1961 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_mod_timer_375(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 1965
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1965
  ldv_func_res = tmp;
#line 1967
  activate_pending_timer_2(ldv_func_arg1, ldv_func_arg2, 1);
#line 1969
  return (ldv_func_res);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_402(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_410(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_418(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_412(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_408(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_416(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_417(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_413(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_414(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
static int cx18_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl , u32 fmt ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  int type ;
  int tmp ;
  int i ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
#line 131
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 131
  cx = (struct cx18 *)__mptr + 0xfffffffffffffa98UL;
#line 132
  type = (cxhdl->ldv_36968.stream_type)->ldv_36505.val;
#line 134
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 134
  if (tmp > 0) {
#line 135
    return (-16);
  } else {

  }
#line 137
  if (fmt != 1U || ((type != 0 && type != 3) && type != 5)) {
#line 142
    cx->vbi.insert_mpeg = 0;
#line 143
    if ((cx18_debug & 2) != 0) {
#line 143
      printk("\016%s:  info: disabled insertion of sliced VBI data into the MPEG stream\n",
             (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 145
    return (0);
  } else {

  }
#line 149
  if ((unsigned long )cx->vbi.sliced_mpeg_data[0] == (unsigned long )((u8 *)0U)) {
#line 152
    i = 0;
#line 152
    goto ldv_51363;
    ldv_51362: 
#line 153
    tmp___0 = kmalloc(1592UL, 208U);
#line 153
    cx->vbi.sliced_mpeg_data[i] = (u8 *)tmp___0;
#line 155
    if ((unsigned long )cx->vbi.sliced_mpeg_data[i] == (unsigned long )((u8 *)0U)) {
#line 156
      goto ldv_51360;
      ldv_51359: 
#line 157
      kfree((void const   *)cx->vbi.sliced_mpeg_data[i]);
#line 158
      cx->vbi.sliced_mpeg_data[i] = (u8 *)0U;
      ldv_51360: 
#line 156
      i = i - 1;
#line 156
      if (i >= 0) {
#line 158
        goto ldv_51359;
      } else {

      }
#line 160
      cx->vbi.insert_mpeg = 0;
#line 162
      printk("\f%s: Unable to allocate buffers for sliced VBI data insertion\n", (char *)(& cx->v4l2_dev.name));
#line 164
      return (-12);
    } else {

    }
#line 152
    i = i + 1;
    ldv_51363: ;
#line 152
    if (i <= 31) {
#line 154
      goto ldv_51362;
    } else {

    }

  } else {

  }
#line 169
  cx->vbi.insert_mpeg = (int )fmt;
#line 170
  if ((cx18_debug & 2) != 0) {
#line 170
    printk("\016%s:  info: enabled insertion of sliced VBI data into the MPEG PS,when sliced VBI is enabled\n",
           (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 177
  tmp___1 = cx18_get_service_set(cx->vbi.sliced_in);
#line 177
  if ((unsigned int )tmp___1 == 0U) {
#line 178
    if ((unsigned int )cx->is_60hz != 0U) {
#line 179
      (cx->vbi.sliced_in)->service_set = 4096U;
    } else {
#line 182
      (cx->vbi.sliced_in)->service_set = 16384U;
    }
#line 183
    cx18_expand_service_set(cx->vbi.sliced_in, (int )cx->is_50hz);
  } else {

  }
#line 185
  return (0);
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
static int cx18_s_video_encoding(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  int is_mpeg1 ;
  struct v4l2_mbus_framefmt fmt ;

  {
#line 190
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 190
  cx = (struct cx18 *)__mptr + 0xfffffffffffffa98UL;
#line 191
  is_mpeg1 = val == 0U;
#line 195
  fmt.width = (__u32 )((int )cxhdl->width / (is_mpeg1 != 0 ? 2 : 1));
#line 196
  fmt.height = (__u32 )cxhdl->height;
#line 197
  fmt.code = 1U;
#line 198
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 198
    if ((unsigned long )((cx->sd_av)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->video)->s_mbus_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 struct v4l2_mbus_framefmt * ))0)) {
#line 198
      (*((((cx->sd_av)->ops)->video)->s_mbus_fmt))(cx->sd_av, & fmt);
    } else {

    }
  } else {

  }
#line 199
  return (0);
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
static int cx18_s_audio_sampling_freq(struct cx2341x_handler *cxhdl , u32 idx ) 
{ 
  u32 freqs[3U] ;
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 204
  freqs[0] = 44100U;
#line 204
  freqs[1] = 48000U;
#line 204
  freqs[2] = 32000U;
#line 205
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 205
  cx = (struct cx18 *)__mptr + 0xfffffffffffffa98UL;
#line 209
  if (idx <= 2U) {
#line 210
    __mptr___0 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 210
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
#line 210
    goto ldv_51390;
    ldv_51389: ;
#line 210
    if ((unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->audio)->s_clock_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                     u32  ))0)) {
#line 210
      (*(((__sd->ops)->audio)->s_clock_freq))(__sd, freqs[idx]);
    } else {

    }
#line 210
    __mptr___1 = (struct list_head  const  *)__sd->list.next;
#line 210
    __sd = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff80UL;
    ldv_51390: ;
#line 210
    if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 212
      goto ldv_51389;
    } else {

    }

  } else {

  }
#line 211
  return (0);
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
static int cx18_s_audio_mode(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;

  {
#line 216
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 216
  cx = (struct cx18 *)__mptr + 0xfffffffffffffa98UL;
#line 218
  cx->dualwatch_stereo_mode = val;
#line 219
  return (0);
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct cx2341x_handler_ops cx18_cxhdl_ops  =    {& cx18_s_audio_sampling_freq, & cx18_s_audio_mode, & cx18_s_video_encoding, & cx18_s_stream_vbi_fmt};
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_initialize_cx2341x_handler_ops_11(void) 
{ 
  void *tmp ;

  {
#line 231
  tmp = ldv_zalloc(528UL);
#line 231
  cx18_cxhdl_ops_group0 = (struct cx2341x_handler *)tmp;
#line 232
  return;
}
}
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  u32 ldvarg2 ;
  u32 tmp ;
  u32 ldvarg0 ;
  u32 tmp___0 ;
  u32 ldvarg3 ;
  u32 tmp___1 ;
  u32 ldvarg1 ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 235
  tmp = __VERIFIER_nondet_u32();
#line 235
  ldvarg2 = tmp;
#line 236
  tmp___0 = __VERIFIER_nondet_u32();
#line 236
  ldvarg0 = tmp___0;
#line 237
  tmp___1 = __VERIFIER_nondet_u32();
#line 237
  ldvarg3 = tmp___1;
#line 238
  tmp___2 = __VERIFIER_nondet_u32();
#line 238
  ldvarg1 = tmp___2;
#line 240
  tmp___3 = __VERIFIER_nondet_int();
#line 240
  switch (tmp___3) {
  case 0: ;
#line 243
  if (ldv_state_variable_11 == 1) {
#line 245
    cx18_s_stream_vbi_fmt(cx18_cxhdl_ops_group0, ldvarg3);
#line 247
    ldv_state_variable_11 = 1;
  } else {

  }
#line 250
  goto ldv_51411;
  case 1: ;
#line 253
  if (ldv_state_variable_11 == 1) {
#line 255
    cx18_s_video_encoding(cx18_cxhdl_ops_group0, ldvarg2);
#line 257
    ldv_state_variable_11 = 1;
  } else {

  }
#line 260
  goto ldv_51411;
  case 2: ;
#line 263
  if (ldv_state_variable_11 == 1) {
#line 265
    cx18_s_audio_sampling_freq(cx18_cxhdl_ops_group0, ldvarg1);
#line 267
    ldv_state_variable_11 = 1;
  } else {

  }
#line 270
  goto ldv_51411;
  case 3: ;
#line 273
  if (ldv_state_variable_11 == 1) {
#line 275
    cx18_s_audio_mode(cx18_cxhdl_ops_group0, ldvarg0);
#line 277
    ldv_state_variable_11 = 1;
  } else {

  }
#line 280
  goto ldv_51411;
  default: 
#line 281
  ldv_stop();
  }
  ldv_51411: ;
#line 285
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void *ldv_kmem_cache_alloc_402(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 416
  ldv_check_alloc_flags(flags);
#line 418
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 419
  return ((void *)0);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
int ldv_pskb_expand_head_408(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 460
  ldv_check_alloc_flags(flags);
#line 462
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 462
  return (tmp);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv_skb_clone_410(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 476
  ldv_check_alloc_flags(flags);
#line 478
  tmp = skb_clone(ldv_func_arg1, flags);
#line 478
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv_skb_copy_412(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 492
  ldv_check_alloc_flags(flags);
#line 494
  tmp = skb_copy(ldv_func_arg1, flags);
#line 494
  return (tmp);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_413(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 500
  ldv_check_alloc_flags(flags);
#line 502
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 502
  return (tmp);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_414(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 508
  ldv_check_alloc_flags(flags);
#line 510
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 510
  return (tmp);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 516
  ldv_check_alloc_flags(flags);
#line 518
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 518
  return (tmp);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
int ldv_pskb_expand_head_416(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 524
  ldv_check_alloc_flags(flags);
#line 526
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 526
  return (tmp);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
int ldv_pskb_expand_head_417(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 532
  ldv_check_alloc_flags(flags);
#line 534
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 534
  return (tmp);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
struct sk_buff *ldv_skb_clone_418(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 540
  ldv_check_alloc_flags(flags);
#line 542
  tmp = skb_clone(ldv_func_arg1, flags);
#line 542
  return (tmp);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
void ldv__builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 53 "include/linux/string.h"
extern char *strchr(char const   * , int  ) ;
#line 301 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 254 "include/linux/time.h"
extern struct timeval ns_to_timeval(s64 const    ) ;
#line 823 "include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 295 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_461(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 210 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 212
  __len = count;
#line 212
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 214
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_444(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 327 "include/linux/hrtimer.h"
extern ktime_t ktime_get(void) ;
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
void cx18_api_epu_cmd_irq(struct cx18 *cx , int rpu ) ;
#line 145 "drivers/media/dvb-core/dvb_demux.h"
extern void dvb_dmx_swfilter(struct dvb_demux * , u8 const   * , size_t  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_454(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_459(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_455(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_456(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_457(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 42 "include/media/videobuf-vmalloc.h"
extern void *videobuf_to_vmalloc(struct videobuf_buffer * ) ;
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect___2(struct cx18 *cx , u32 val , void *addr ,
                                            u32 eval , u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_51313;
  ldv_51312: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_51310;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_51311;
  } else {

  }
  ldv_51310: 
#line 88
  i = i + 1;
  ldv_51313: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_51312;
  } else {

  }
  ldv_51311: ;
#line 95
  return;
}
}
#line 141 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_memcpy_fromio(struct cx18 *cx , void *to , void const   *from ,
                                        unsigned int len ) 
{ 


  {
#line 144
  memcpy_fromio(to, (void const volatile   *)from, (size_t )len);
#line 145
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect___2(struct cx18 *cx , u32 val , u32 reg ,
                                               u32 eval , u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect___2(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static char const   *rpu_str[4U]  = {      "APU",      "CPU",      "EPU",      "HPU"};
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static struct cx18_api_info  const  api_info[43U]  = 
#line 144
  {      {537001985U, 0U, 1U, "CX18_CPU_SET_CHANNEL_TYPE"}, 
        {33554435U, 0U, 1U, "CX18_EPU_DEBUG"}, 
        {1073741825U, 0U, 1U, "CX18_CREATE_TASK"}, 
        {1073741826U, 0U, 1U, "CX18_DESTROY_TASK"}, 
        {537001986U, 8U, 1U, "CX18_CPU_CAPTURE_START"}, 
        {537001987U, 8U, 1U, "CX18_CPU_CAPTURE_STOP"}, 
        {537001991U, 0U, 1U, "CX18_CPU_CAPTURE_PAUSE"}, 
        {537001992U, 0U, 1U, "CX18_CPU_CAPTURE_RESUME"}, 
        {537001985U, 0U, 1U, "CX18_CPU_SET_CHANNEL_TYPE"}, 
        {537002002U, 0U, 1U, "CX18_CPU_SET_STREAM_OUTPUT_TYPE"}, 
        {537001988U, 0U, 1U, "CX18_CPU_SET_VIDEO_IN"}, 
        {537001989U, 0U, 1U, "CX18_CPU_SET_VIDEO_RATE"}, 
        {537001990U, 0U, 1U, "CX18_CPU_SET_VIDEO_RESOLUTION"}, 
        {537001993U, 0U, 1U, "CX18_CPU_SET_FILTER_PARAM"}, 
        {537001996U, 0U, 1U, "CX18_CPU_SET_SPATIAL_FILTER_TYPE"}, 
        {537001998U, 0U, 1U, "CX18_CPU_SET_MEDIAN_CORING"}, 
        {537002000U, 0U, 1U, "CX18_CPU_SET_INDEXTABLE"}, 
        {537002001U, 0U, 1U, "CX18_CPU_SET_AUDIO_PARAMETERS"}, 
        {537002003U, 0U, 1U, "CX18_CPU_SET_VIDEO_MUTE"}, 
        {537002004U, 0U, 1U, "CX18_CPU_SET_AUDIO_MUTE"}, 
        {537002005U, 0U, 1U, "CX18_CPU_SET_MISC_PARAMETERS"}, 
        {537002006U, 8U, 1U, "CX18_CPU_SET_RAW_VBI_PARAM"}, 
        {537002007U, 0U, 1U, "CX18_CPU_SET_CAPTURE_LINE_NO"}, 
        {537002008U, 0U, 1U, "CX18_CPU_SET_COPYRIGHT"}, 
        {537002009U, 0U, 1U, "CX18_CPU_SET_AUDIO_PID"}, 
        {537002010U, 0U, 1U, "CX18_CPU_SET_VIDEO_PID"}, 
        {537002011U, 0U, 1U, "CX18_CPU_SET_VER_CROP_LINE"}, 
        {537002012U, 0U, 1U, "CX18_CPU_SET_GOP_STRUCTURE"}, 
        {537002013U, 0U, 1U, "CX18_CPU_SET_SCENE_CHANGE_DETECTION"}, 
        {537002014U, 0U, 1U, "CX18_CPU_SET_ASPECT_RATIO"}, 
        {537002015U, 0U, 1U, "CX18_CPU_SET_SKIP_INPUT_FRAME"}, 
        {537002016U, 0U, 1U, "CX18_CPU_SET_SLICED_VBI_PARAM"}, 
        {537002017U, 0U, 1U, "CX18_CPU_SET_USERDATA_PLACE_HOLDER"}, 
        {537002018U, 0U, 1U, "CX18_CPU_GET_ENC_PTS"}, 
        {537002019U, 0U, 1U, "CX18_CPU_SET_VFC_PARAM"}, 
        {537133058U, 0U, 1U, "CX18_CPU_DE_SET_MDL_ACK"}, 
        {537133061U, 4U, 1U, "CX18_CPU_DE_SET_MDL"}, 
        {537133062U, 8U, 1U, "CX18_CPU_DE_RELEASE_MDL"}, 
        {268435457U, 0U, 0U, "CX18_APU_START"}, 
        {268435458U, 0U, 0U, "CX18_APU_STOP"}, 
        {268435461U, 0U, 0U, "CX18_APU_RESETAI"}, 
        {536870915U, 0U, 1U, "CX18_CPU_DEBUG_PEEK32"}, 
        {0U, 0U, 0U, "0"}};
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static struct cx18_api_info  const  *find_api_info(u32 cmd ) 
{ 
  int i ;

  {
#line 195
  i = 0;
#line 195
  goto ldv_51657;
  ldv_51656: ;
#line 196
  if ((unsigned int )api_info[i].cmd == cmd) {
#line 197
    return ((struct cx18_api_info  const  *)(& api_info) + (unsigned long )i);
  } else {

  }
#line 195
  i = i + 1;
  ldv_51657: ;
#line 195
  if ((unsigned int )api_info[i].cmd != 0U) {
#line 197
    goto ldv_51656;
  } else {

  }

#line 198
  return ((struct cx18_api_info  const  *)0);
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static char *u32arr2hex(u32 *data , int n , char *buf ) 
{ 
  char *p ;
  int i ;

  {
#line 207
  i = 0;
#line 207
  p = buf;
#line 207
  goto ldv_51667;
  ldv_51666: 
#line 209
  snprintf(p, 12UL, " %#010x", *(data + (unsigned long )i));
#line 207
  i = i + 1;
#line 207
  p = p + 11UL;
  ldv_51667: ;
#line 207
  if (i < n) {
#line 209
    goto ldv_51666;
  } else {

  }
#line 211
  *p = 0;
#line 212
  return (buf);
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void dump_mb(struct cx18 *cx , struct cx18_mailbox *mb , char *name ) 
{ 
  char argstr[67U] ;
  char *tmp ;

  {
#line 219
  if ((cx18_debug & 4) == 0) {
#line 220
    return;
  } else {

  }
#line 222
  if ((cx18_debug & 4) != 0) {
#line 222
    tmp = u32arr2hex((u32 *)(& mb->args), 6, (char *)(& argstr));
#line 222
    printk("\016%s:  api: %s: req %#010x ack %#010x cmd %#010x err %#010x args%s\n",
           (char *)(& cx->v4l2_dev.name), name, mb->request, mb->ack, mb->cmd, mb->error,
           tmp);
  } else {

  }
#line 223
  return;
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void cx18_mdl_send_to_dvb(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 236
  if (((unsigned long )s->dvb == (unsigned long )((struct cx18_dvb *)0) || (s->dvb)->enabled == 0) || mdl->bytesused == 0U) {
#line 237
    return;
  } else {

  }
#line 242
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 242
  if (tmp != 0) {
#line 243
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 243
    buf = (struct cx18_buffer *)__mptr;
#line 245
    if (buf->bytesused != 0U) {
#line 246
      dvb_dmx_swfilter(& (s->dvb)->demux, (u8 const   *)buf->buf, (size_t )buf->bytesused);
    } else {

    }
#line 248
    return;
  } else {

  }
#line 251
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 251
  buf = (struct cx18_buffer *)__mptr___0;
#line 251
  goto ldv_51688;
  ldv_51687: ;
#line 252
  if (buf->bytesused == 0U) {
#line 253
    goto ldv_51686;
  } else {

  }
#line 254
  dvb_dmx_swfilter(& (s->dvb)->demux, (u8 const   *)buf->buf, (size_t )buf->bytesused);
#line 251
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 251
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_51688: ;
#line 251
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 253
    goto ldv_51687;
  } else {

  }
  ldv_51686: ;
#line 258
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void cx18_mdl_send_to_videobuf(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_videobuf_buffer *vb_buf ;
  struct cx18_buffer *buf ;
  u8 *p ;
  u32 offset ;
  int dispatch ;
  int tmp ;
  struct list_head  const  *__mptr ;
  void *tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  size_t __len ;
  void *__ret ;
  struct list_head  const  *__mptr___1 ;
  ktime_t tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 264
  offset = 0U;
#line 265
  dispatch = 0;
#line 267
  if (mdl->bytesused == 0U) {
#line 268
    return;
  } else {

  }
#line 271
  spin_lock(& s->vb_lock);
#line 272
  tmp = list_empty((struct list_head  const  *)(& s->vb_capture));
#line 272
  if (tmp != 0) {
#line 273
    goto out;
  } else {

  }
#line 275
  __mptr = (struct list_head  const  *)s->vb_capture.next;
#line 275
  vb_buf = (struct cx18_videobuf_buffer *)__mptr + 0xffffffffffffffc8UL;
#line 278
  tmp___0 = videobuf_to_vmalloc(& vb_buf->vb);
#line 278
  p = (u8 *)tmp___0;
#line 279
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
#line 280
    goto out;
  } else {

  }
#line 282
  offset = vb_buf->bytes_used;
#line 283
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 283
  buf = (struct cx18_buffer *)__mptr___0;
#line 283
  goto ldv_51710;
  ldv_51709: ;
#line 284
  if (buf->bytesused == 0U) {
#line 285
    goto ldv_51705;
  } else {

  }
#line 287
  if ((size_t )(buf->bytesused + offset) <= vb_buf->vb.bsize) {
#line 288
    __len = (size_t )buf->bytesused;
#line 288
    __ret = __builtin_memcpy((void *)p + (unsigned long )offset, (void const   *)buf->buf,
                             __len);
#line 289
    offset = buf->bytesused + offset;
#line 290
    vb_buf->bytes_used = vb_buf->bytes_used + buf->bytesused;
  } else {

  }
#line 283
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 283
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_51710: ;
#line 283
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 285
    goto ldv_51709;
  } else {

  }
  ldv_51705: ;
#line 295
  if (vb_buf->bytes_used >= s->vb_bytes_per_frame) {
#line 296
    dispatch = 1;
#line 297
    vb_buf->bytes_used = 0U;
  } else {

  }
#line 300
  if (dispatch != 0) {
#line 301
    tmp___1 = ktime_get();
#line 301
    vb_buf->vb.ts = ns_to_timeval(tmp___1.tv64);
#line 302
    list_del(& vb_buf->vb.queue);
#line 303
    vb_buf->vb.state = 4;
#line 304
    __wake_up(& vb_buf->vb.done, 3U, 1, (void *)0);
  } else {

  }
#line 307
  tmp___2 = msecs_to_jiffies(2000U);
#line 307
  ldv_mod_timer_461(& s->vb_timeout, tmp___2 + (unsigned long )jiffies);
  out: 
#line 310
  spin_unlock(& s->vb_lock);
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void cx18_mdl_send_to_alsa(struct cx18 *cx , struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 318
  if (mdl->bytesused == 0U) {
#line 319
    return;
  } else {

  }
#line 324
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 324
  if (tmp != 0) {
#line 325
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 325
    buf = (struct cx18_buffer *)__mptr;
#line 327
    if (buf->bytesused != 0U) {
#line 328
      (*(cx->pcm_announce_callback))(cx->alsa, (u8 *)buf->buf, (size_t )buf->bytesused);
    } else {

    }
#line 330
    return;
  } else {

  }
#line 333
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 333
  buf = (struct cx18_buffer *)__mptr___0;
#line 333
  goto ldv_51725;
  ldv_51724: ;
#line 334
  if (buf->bytesused == 0U) {
#line 335
    goto ldv_51723;
  } else {

  }
#line 336
  (*(cx->pcm_announce_callback))(cx->alsa, (u8 *)buf->buf, (size_t )buf->bytesused);
#line 333
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 333
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_51725: ;
#line 333
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 335
    goto ldv_51724;
  } else {

  }
  ldv_51723: ;
#line 340
  return;
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void epu_dma_done(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 handle ;
  u32 mdl_ack_count ;
  u32 id ;
  struct cx18_mailbox *mb ;
  struct cx18_mdl_ack *mdl_ack ;
  struct cx18_stream *s ;
  struct cx18_mdl *mdl ;
  int i ;

  {
#line 349
  mb = & order->mb;
#line 350
  handle = mb->args[0];
#line 351
  s = cx18_handle_to_stream(cx, handle);
#line 353
  if ((unsigned long )s == (unsigned long )((struct cx18_stream *)0)) {
#line 354
    printk("\f%s: Got DMA done notification for unknown/inactive handle %d, %s mailbox seq no %d\n",
           (char *)(& cx->v4l2_dev.name), handle, (int )order->flags & 1 ? (char *)"stale" : (char *)"good",
           mb->request);
#line 358
    return;
  } else {

  }
#line 361
  mdl_ack_count = mb->args[2];
#line 362
  mdl_ack = (struct cx18_mdl_ack *)(& order->mdl_ack);
#line 363
  i = 0;
#line 363
  goto ldv_51741;
  ldv_51740: 
#line 364
  id = mdl_ack->id;
#line 386
  if ((int )order->flags & 1 && (s->mdl_base_idx > id || s->mdl_base_idx + s->buffers <= id)) {
#line 389
    printk("\f%s: Fell behind! Ignoring stale mailbox with  inconsistent data. Lost MDL for mailbox seq no %d\n",
           (char *)(& cx->v4l2_dev.name), mb->request);
#line 392
    goto ldv_51738;
  } else {

  }
#line 394
  mdl = cx18_queue_get_mdl(s, id, mdl_ack->data_used);
#line 396
  if ((cx18_debug & 8) != 0 && (cx18_debug & 256) != 0) {
#line 396
    printk("\016%s:  dma: DMA DONE for %s (MDL %d)\n", (char *)(& cx->v4l2_dev.name),
           s->name, id);
  } else {

  }
#line 397
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 398
    printk("\f%s: Could not find MDL %d for stream %s\n", (char *)(& cx->v4l2_dev.name),
           id, s->name);
#line 400
    goto ldv_51739;
  } else {

  }
#line 403
  if ((cx18_debug & 8) != 0 && (cx18_debug & 256) != 0) {
#line 403
    printk("\016%s:  dma: %s recv bytesused = %d\n", (char *)(& cx->v4l2_dev.name),
           s->name, mdl->bytesused);
  } else {

  }
#line 406
  if (s->type == 1) {
#line 407
    cx18_mdl_send_to_dvb(s, mdl);
#line 408
    cx18_enqueue(s, mdl, & s->q_free);
  } else
#line 409
  if (s->type == 4) {
#line 411
    if ((unsigned long )cx->pcm_announce_callback != (unsigned long )((void (*)(struct snd_cx18_card * ,
                                                                                u8 * ,
                                                                                size_t  ))0)) {
#line 412
      cx18_mdl_send_to_alsa(cx, s, mdl);
#line 413
      cx18_enqueue(s, mdl, & s->q_free);
    } else {
#line 415
      cx18_enqueue(s, mdl, & s->q_full);
    }
  } else
#line 417
  if (s->type == 2) {
#line 418
    cx18_mdl_send_to_videobuf(s, mdl);
#line 419
    cx18_enqueue(s, mdl, & s->q_free);
  } else {
#line 421
    cx18_enqueue(s, mdl, & s->q_full);
#line 422
    if (s->type == 5) {
#line 423
      cx18_stream_rotate_idx_mdls(cx);
    } else {

    }
  }
  ldv_51739: 
#line 363
  i = i + 1;
#line 363
  mdl_ack = mdl_ack + 1;
  ldv_51741: ;
#line 363
  if ((u32 )i < mdl_ack_count) {
#line 365
    goto ldv_51740;
  } else {

  }
  ldv_51738: 
#line 427
  cx18_stream_load_fw_queue(s);
#line 429
  __wake_up(& cx->dma_waitq, 3U, 1, (void *)0);
#line 430
  if (s->id != 4294967295U) {
#line 431
    __wake_up(& s->waitq, 3U, 1, (void *)0);
  } else {

  }
#line 432
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void epu_debug(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  char *p ;
  char *str ;
  int tmp ;

  {
#line 437
  str = order->str;
#line 439
  if ((cx18_debug & 2) != 0) {
#line 439
    printk("\016%s:  info: %x %s\n", (char *)(& cx->v4l2_dev.name), order->mb.args[0],
           str);
  } else {

  }
#line 440
  p = strchr((char const   *)str, 46);
#line 441
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 441
  if ((tmp == 0 && (unsigned long )p != (unsigned long )((char *)0)) && (unsigned long )p > (unsigned long )str) {
#line 442
    printk("\016%s: FW version: %s\n", (char *)(& cx->v4l2_dev.name), p + 0xffffffffffffffffUL);
  } else {

  }
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void epu_cmd(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 


  {
#line 447
  switch (order->rpu) {
  case 1: ;
#line 450
  switch (order->mb.cmd) {
  case 33816577U: 
#line 452
  epu_dma_done(cx, order);
#line 453
  goto ldv_51754;
  case 33554435U: 
#line 455
  epu_debug(cx, order);
#line 456
  goto ldv_51754;
  default: 
#line 458
  printk("\f%s: Unknown CPU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 460
  goto ldv_51754;
  }
  ldv_51754: ;
#line 462
  goto ldv_51757;
  case 0: 
#line 465
  printk("\f%s: Unknown APU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 467
  goto ldv_51757;
  default: ;
#line 469
  goto ldv_51757;
  }
  ldv_51757: ;
#line 472
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void free_in_work_order(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 


  {
#line 476
  atomic_set(& order->pending, 0);
#line 477
  return;
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void cx18_in_work_handler(struct work_struct *work ) 
{ 
  struct cx18_in_work_order *order ;
  struct work_struct  const  *__mptr ;
  struct cx18 *cx ;

  {
#line 482
  __mptr = (struct work_struct  const  *)work;
#line 482
  order = (struct cx18_in_work_order *)__mptr;
#line 483
  cx = order->cx;
#line 484
  epu_cmd(cx, order);
#line 485
  free_in_work_order(cx, order);
#line 486
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static void mb_ack_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  struct cx18_mailbox *ack_mb ;
  u32 ack_irq ;
  u32 req ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 498
  switch (order->rpu) {
  case 0: 
#line 500
  ack_irq = 131072U;
#line 501
  ack_mb = & (cx->scb)->apu2epu_mb;
#line 502
  goto ldv_51779;
  case 1: 
#line 504
  ack_irq = 65536U;
#line 505
  ack_mb = & (cx->scb)->cpu2epu_mb;
#line 506
  goto ldv_51779;
  default: 
#line 508
  printk("\f%s: Unhandled RPU (%d) for command %x ack\n", (char *)(& cx->v4l2_dev.name),
         order->rpu, order->mb.cmd);
#line 510
  return;
  }
  ldv_51779: 
#line 513
  req = order->mb.request;
#line 515
  tmp = cx18_readl(cx, (void const   *)(& ack_mb->request));
#line 515
  if (tmp != req) {
#line 515
    goto _L;
  } else {
#line 515
    tmp___0 = cx18_readl(cx, (void const   *)(& ack_mb->ack));
#line 515
    if (tmp___0 == req) {
      _L: /* CIL Label */ 
#line 517
      if (cx18_debug & 1) {
#line 517
        printk("\016%s:  warning: Possibly falling behind: %s self-ack\'ed our incoming %s to EPU mailbox (sequence no. %u) while processing\n",
               (char *)(& cx->v4l2_dev.name), rpu_str[order->rpu], rpu_str[order->rpu],
               req);
      } else {

      }
#line 521
      order->flags = order->flags | 2UL;
#line 522
      return;
    } else {

    }
  }
#line 524
  cx18_writel___3(cx, req, (void *)(& ack_mb->ack));
#line 525
  cx18_write_reg_expect___2(cx, ack_irq, 13054272U, ack_irq, ack_irq);
#line 526
  return;
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static int epu_dma_done_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 handle ;
  u32 mdl_ack_offset ;
  u32 mdl_ack_count ;
  struct cx18_mailbox *mb ;
  int i ;

  {
#line 535
  mb = & order->mb;
#line 536
  handle = mb->args[0];
#line 537
  mdl_ack_offset = mb->args[1];
#line 538
  mdl_ack_count = mb->args[2];
#line 540
  if ((handle == 4294967295U || mdl_ack_count == 0U) || mdl_ack_count > 2U) {
#line 542
    if ((order->flags & 3UL) == 0UL) {
#line 543
      mb_ack_irq(cx, order);
    } else {

    }
#line 544
    return (-1);
  } else {

  }
#line 547
  i = 0;
#line 547
  goto ldv_51792;
  ldv_51791: 
#line 548
  *((u32 *)(& order->mdl_ack) + (unsigned long )i / 4UL) = cx18_readl(cx, (void const   *)(cx->enc_mem + ((unsigned long )mdl_ack_offset + (unsigned long )i)));
#line 547
  i = (int )((unsigned int )i + 4U);
  ldv_51792: ;
#line 547
  if ((unsigned long )i < (unsigned long )mdl_ack_count * 8UL) {
#line 549
    goto ldv_51791;
  } else {

  }

#line 551
  if ((order->flags & 3UL) == 0UL) {
#line 552
    mb_ack_irq(cx, order);
  } else {

  }
#line 553
  return (1);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static int epu_debug_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 str_offset ;
  char *str ;

  {
#line 560
  str = order->str;
#line 562
  *str = 0;
#line 563
  str_offset = order->mb.args[1];
#line 564
  if (str_offset != 0U) {
#line 565
    cx18_setup_page(cx, str_offset);
#line 566
    cx18_memcpy_fromio(cx, (void *)str, (void const   *)cx->enc_mem + (unsigned long )str_offset,
                       252U);
#line 567
    *(str + 252UL) = 0;
#line 568
    cx18_setup_page(cx, 14417920U);
  } else {

  }
#line 571
  if ((order->flags & 3UL) == 0UL) {
#line 572
    mb_ack_irq(cx, order);
  } else {

  }
#line 574
  return (str_offset != 0U);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
__inline static int epu_cmd_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  int ret ;

  {
#line 580
  ret = -1;
#line 582
  switch (order->rpu) {
  case 1: ;
#line 585
  switch (order->mb.cmd) {
  case 33816577U: 
#line 587
  ret = epu_dma_done_irq(cx, order);
#line 588
  goto ldv_51807;
  case 33554435U: 
#line 590
  ret = epu_debug_irq(cx, order);
#line 591
  goto ldv_51807;
  default: 
#line 593
  printk("\f%s: Unknown CPU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 595
  goto ldv_51807;
  }
  ldv_51807: ;
#line 597
  goto ldv_51810;
  case 0: 
#line 600
  printk("\f%s: Unknown APU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 602
  goto ldv_51810;
  default: ;
#line 604
  goto ldv_51810;
  }
  ldv_51810: ;
#line 606
  return (ret);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
__inline static struct cx18_in_work_order *alloc_in_work_order_irq(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_in_work_order *order ;
  int tmp ;

  {
#line 613
  order = (struct cx18_in_work_order *)0;
#line 615
  i = 0;
#line 615
  goto ldv_51820;
  ldv_51819: 
#line 624
  tmp = atomic_read((atomic_t const   *)(& cx->in_work_order[i].pending));
#line 624
  if (tmp == 0) {
#line 625
    order = (struct cx18_in_work_order *)(& cx->in_work_order) + (unsigned long )i;
#line 626
    atomic_set(& order->pending, 1);
#line 627
    goto ldv_51818;
  } else {

  }
#line 615
  i = i + 1;
  ldv_51820: ;
#line 615
  if (i <= 69) {
#line 617
    goto ldv_51819;
  } else {

  }
  ldv_51818: ;
#line 630
  return (order);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void cx18_api_epu_cmd_irq(struct cx18 *cx , int rpu ) 
{ 
  struct cx18_mailbox *mb ;
  struct cx18_mailbox *order_mb ;
  struct cx18_in_work_order *order ;
  int submit ;
  int i ;

  {
#line 641
  switch (rpu) {
  case 1: 
#line 643
  mb = & (cx->scb)->cpu2epu_mb;
#line 644
  goto ldv_51831;
  case 0: 
#line 646
  mb = & (cx->scb)->apu2epu_mb;
#line 647
  goto ldv_51831;
  default: ;
#line 649
  return;
  }
  ldv_51831: 
#line 652
  order = alloc_in_work_order_irq(cx);
#line 653
  if ((unsigned long )order == (unsigned long )((struct cx18_in_work_order *)0)) {
#line 654
    printk("\f%s: Unable to find blank work order form to schedule incoming mailbox command processing\n",
           (char *)(& cx->v4l2_dev.name));
#line 656
    return;
  } else {

  }
#line 659
  order->flags = 0UL;
#line 660
  order->rpu = rpu;
#line 661
  order_mb = & order->mb;
#line 664
  i = 0;
#line 664
  goto ldv_51835;
  ldv_51834: 
#line 665
  *(& order_mb->cmd + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->cmd) + (unsigned long )i);
#line 664
  i = i + 1;
  ldv_51835: ;
#line 664
  if (i <= 3) {
#line 666
    goto ldv_51834;
  } else {

  }
#line 668
  i = 0;
#line 668
  goto ldv_51838;
  ldv_51837: 
#line 669
  *(& order_mb->request + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->request) + (unsigned long )i);
#line 668
  i = i + 1;
  ldv_51838: ;
#line 668
  if (i <= 1) {
#line 670
    goto ldv_51837;
  } else {

  }

#line 671
  if (order_mb->request == order_mb->ack) {
#line 672
    if (cx18_debug & 1) {
#line 672
      printk("\016%s:  warning: Possibly falling behind: %s self-ack\'ed our incoming %s to EPU mailbox (sequence no. %u)\n",
             (char *)(& cx->v4l2_dev.name), rpu_str[rpu], rpu_str[rpu], order_mb->request);
    } else {

    }
#line 676
    if (cx18_debug & 1) {
#line 677
      dump_mb(cx, order_mb, (char *)"incoming");
    } else {

    }
#line 678
    order->flags = 1UL;
  } else {

  }
#line 685
  submit = epu_cmd_irq(cx, order);
#line 686
  if (submit > 0) {
#line 687
    queue_work(cx->in_work_queue, & order->work);
  } else {

  }
#line 688
  return;
}
}
#line 696 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static int cx18_api_call(struct cx18 *cx , u32 cmd , int args , u32 *data ) 
{ 
  struct cx18_api_info  const  *info ;
  struct cx18_api_info  const  *tmp ;
  u32 irq ;
  u32 req ;
  u32 ack ;
  u32 err ;
  struct cx18_mailbox *mb ;
  wait_queue_head_t *waitq ;
  struct mutex *mb_lock ;
  unsigned long t0 ;
  unsigned long timeout ;
  unsigned long ret ;
  int i ;
  char argstr[67U] ;
  wait_queue_t w ;
  struct task_struct *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  bool __cond ;
  bool __cond___0 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 698
  tmp = find_api_info(cmd);
#line 698
  info = tmp;
#line 706
  tmp___0 = get_current();
#line 706
  w.flags = 0U;
#line 706
  w.private = (void *)tmp___0;
#line 706
  w.func = & autoremove_wake_function;
#line 706
  w.task_list.next = & w.task_list;
#line 706
  w.task_list.prev = & w.task_list;
#line 708
  if ((unsigned long )info == (unsigned long )((struct cx18_api_info  const  *)0)) {
#line 709
    printk("\f%s: unknown cmd %x\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 710
    return (-22);
  } else {

  }
#line 713
  if ((cx18_debug & 4) != 0) {
#line 714
    if (cmd == 537133061U) {
#line 715
      if ((cx18_debug & 256) != 0) {
#line 716
        if ((cx18_debug & 4) != 0 && (cx18_debug & 256) != 0) {
#line 716
          tmp___1 = u32arr2hex(data, args, (char *)(& argstr));
#line 716
          printk("\016%s:  api: %s\tcmd %#010x args%s\n", (char *)(& cx->v4l2_dev.name),
                 info->name, cmd, tmp___1);
        } else {

        }
      } else {

      }
    } else
#line 720
    if ((cx18_debug & 4) != 0) {
#line 720
      tmp___2 = u32arr2hex(data, args, (char *)(& argstr));
#line 720
      printk("\016%s:  api: %s\tcmd %#010x args%s\n", (char *)(& cx->v4l2_dev.name),
             info->name, cmd, tmp___2);
    } else {

    }
  } else {

  }
#line 725
  switch ((int )info->rpu) {
  case 0: 
#line 727
  waitq = & cx->mb_apu_waitq;
#line 728
  mb_lock = & cx->epu2apu_mb_lock;
#line 729
  irq = 128U;
#line 730
  mb = & (cx->scb)->epu2apu_mb;
#line 731
  goto ldv_51861;
  case 1: 
#line 733
  waitq = & cx->mb_cpu_waitq;
#line 734
  mb_lock = & cx->epu2cpu_mb_lock;
#line 735
  irq = 8U;
#line 736
  mb = & (cx->scb)->epu2cpu_mb;
#line 737
  goto ldv_51861;
  default: 
#line 739
  printk("\f%s: Unknown RPU (%d) for API call\n", (char *)(& cx->v4l2_dev.name), (int )info->rpu);
#line 740
  return (-22);
  }
  ldv_51861: 
#line 743
  mutex_lock_nested(mb_lock, 0U);
#line 754
  req = cx18_readl(cx, (void const   *)(& mb->request));
#line 755
  timeout = msecs_to_jiffies(10U);
#line 756
  __ret = (long )timeout;
#line 756
  ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 756
  __cond___0 = ack == req;
#line 756
  if ((int )__cond___0 && __ret == 0L) {
#line 756
    __ret = 1L;
  } else {

  }
#line 756
  if (((int )__cond___0 || __ret == 0L) == 0) {
#line 756
    __ret___0 = (long )timeout;
#line 756
    INIT_LIST_HEAD(& __wait.task_list);
#line 756
    __wait.flags = 0U;
    ldv_51874: 
#line 756
    tmp___3 = prepare_to_wait_event(waitq, & __wait, 2);
#line 756
    __int = tmp___3;
#line 756
    ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 756
    __cond = ack == req;
#line 756
    if ((int )__cond && __ret___0 == 0L) {
#line 756
      __ret___0 = 1L;
    } else {

    }
#line 756
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 756
      goto ldv_51873;
    } else {

    }
#line 756
    __ret___0 = schedule_timeout(__ret___0);
#line 756
    goto ldv_51874;
    ldv_51873: 
#line 756
    finish_wait(waitq, & __wait);
#line 756
    __ret = __ret___0;
  } else {

  }
#line 756
  ret = (unsigned long )__ret;
#line 759
  if (req != ack) {
#line 761
    cx18_writel___3(cx, req, (void *)(& mb->ack));
#line 762
    printk("\v%s: mbox was found stuck busy when setting up for %s; clearing busy and trying to proceed\n",
           (char *)(& cx->v4l2_dev.name), info->name);
  } else
#line 764
  if (ret != timeout) {
#line 765
    if ((cx18_debug & 4) != 0) {
#line 765
      tmp___4 = jiffies_to_msecs(timeout - ret);
#line 765
      printk("\016%s:  api: waited %u msecs for busy mbox to be acked\n", (char *)(& cx->v4l2_dev.name),
             tmp___4);
    } else {

    }
  } else {

  }
#line 769
  req = (req & 4294967294U) != 4294967294U ? req + 1U : 1U;
#line 771
  cx18_writel___3(cx, cmd, (void *)(& mb->cmd));
#line 772
  i = 0;
#line 772
  goto ldv_51878;
  ldv_51877: 
#line 773
  cx18_writel___3(cx, *(data + (unsigned long )i), (void *)(& mb->args) + (unsigned long )i);
#line 772
  i = i + 1;
  ldv_51878: ;
#line 772
  if (i < args) {
#line 774
    goto ldv_51877;
  } else {

  }
#line 774
  cx18_writel___3(cx, 0U, (void *)(& mb->error));
#line 775
  cx18_writel___3(cx, req, (void *)(& mb->request));
#line 776
  cx18_writel___3(cx, req - 1U, (void *)(& mb->ack));
#line 781
  timeout = msecs_to_jiffies(((int )info->flags & 4) != 0 ? 10U : 20U);
#line 783
  if ((cx18_debug & 128) != 0 && (cx18_debug & 256) != 0) {
#line 783
    printk("\016%s:  irq: sending interrupt SW1: %x to send %s\n", (char *)(& cx->v4l2_dev.name),
           irq, info->name);
  } else {

  }
#line 787
  prepare_to_wait(waitq, & w, 2);
#line 788
  cx18_write_reg_expect___2(cx, irq, 13054208U, irq, irq);
#line 790
  t0 = jiffies;
#line 791
  ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 792
  if (ack != req) {
#line 793
    schedule_timeout((long )timeout);
#line 794
    ret = (unsigned long )jiffies - t0;
#line 795
    ack = cx18_readl(cx, (void const   *)(& mb->ack));
  } else {
#line 797
    ret = (unsigned long )jiffies - t0;
  }
#line 800
  finish_wait(waitq, & w);
#line 802
  if (req != ack) {
#line 803
    mutex_unlock(mb_lock);
#line 804
    if (ret >= timeout) {
#line 806
      if (cx18_debug & 1) {
#line 806
        tmp___5 = jiffies_to_msecs(ret);
#line 806
        printk("\016%s:  warning: sending %s timed out waiting %d msecs for RPU acknowledgement\n",
               (char *)(& cx->v4l2_dev.name), info->name, tmp___5);
      } else {

      }
    } else
#line 810
    if (cx18_debug & 1) {
#line 810
      tmp___6 = jiffies_to_msecs(ret);
#line 810
      printk("\016%s:  warning: woken up before mailbox ack was ready after submitting %s to RPU.  only waited %d msecs on req %u but awakened with unmatched ack %u\n",
             (char *)(& cx->v4l2_dev.name), info->name, tmp___6, req, ack);
    } else {

    }
#line 818
    return (-22);
  } else {

  }
#line 821
  if (ret >= timeout) {
#line 822
    if (cx18_debug & 1) {
#line 822
      tmp___7 = jiffies_to_msecs(ret);
#line 822
      printk("\016%s:  warning: failed to be awakened upon RPU acknowledgment sending %s; timed out waiting %d msecs\n",
             (char *)(& cx->v4l2_dev.name), info->name, tmp___7);
    } else {

    }
  } else
#line 826
  if ((cx18_debug & 4) != 0 && (cx18_debug & 256) != 0) {
#line 826
    tmp___8 = jiffies_to_msecs(ret);
#line 826
    printk("\016%s:  api: waited %u msecs for %s to be acked\n", (char *)(& cx->v4l2_dev.name),
           tmp___8, info->name);
  } else {

  }
#line 830
  i = 0;
#line 830
  goto ldv_51881;
  ldv_51880: 
#line 831
  *(data + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->args) + (unsigned long )i);
#line 830
  i = i + 1;
  ldv_51881: ;
#line 830
  if (i <= 5) {
#line 832
    goto ldv_51880;
  } else {

  }
#line 832
  err = cx18_readl(cx, (void const   *)(& mb->error));
#line 833
  mutex_unlock(mb_lock);
#line 840
  if (((int )info->flags & 8) != 0) {
#line 841
    cx18_msleep_timeout(300U, 0);
  } else {

  }
#line 843
  if (err != 0U) {
#line 844
    if ((cx18_debug & 4) != 0) {
#line 844
      printk("\016%s:  api: mailbox error %08x for command %s\n", (char *)(& cx->v4l2_dev.name),
             err, info->name);
    } else {

    }
  } else {

  }
#line 846
  return (err != 0U ? -5 : 0);
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int cx18_api(struct cx18 *cx , u32 cmd , int args , u32 *data ) 
{ 
  int tmp ;

  {
#line 851
  tmp = cx18_api_call(cx, cmd, args, data);
#line 851
  return (tmp);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
static int cx18_set_filter_param(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  u32 mode ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 856
  cx = s->cx;
#line 860
  mode = (int )cx->filter_mode & 1 ? 2U : cx->spatial_strength != 0U;
#line 861
  ret = cx18_vapi(cx, 537001993U, 4, s->handle, 1, mode, cx->spatial_strength);
#line 863
  mode = (cx->filter_mode & 2U) == 0U ? cx->temporal_strength != 0U : 2U;
#line 864
  if (ret == 0) {
#line 864
    tmp = cx18_vapi(cx, 537001993U, 4, s->handle, 0, mode, cx->temporal_strength);
#line 864
    ret = tmp;
  } else {
#line 864
    ret = ret;
  }
#line 866
  if (ret == 0) {
#line 866
    tmp___0 = cx18_vapi(cx, 537001993U, 4, s->handle, 2, cx->filter_mode >> 2, 0);
#line 866
    ret = tmp___0;
  } else {
#line 866
    ret = ret;
  }
#line 868
  return (ret);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int cx18_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) 
{ 
  struct cx18_stream *s ;
  struct cx18 *cx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 874
  s = (struct cx18_stream *)priv;
#line 875
  cx = s->cx;
#line 877
  switch (cmd) {
  case 187U: ;
#line 879
  return (0);
  case 143U: 
#line 881
  tmp = cx18_vapi(cx, 537001988U, 6, s->handle, 0, 0, 0, 0, *data);
#line 881
  return (tmp);
  case 145U: 
#line 884
  tmp___0 = cx18_vapi(cx, 537001990U, 3, s->handle, *(data + 1UL), *data);
#line 884
  return (tmp___0);
  case 185U: 
#line 887
  tmp___1 = cx18_vapi(cx, 537002002U, 2, s->handle, *data);
#line 887
  return (tmp___1);
  case 153U: 
#line 890
  tmp___2 = cx18_vapi(cx, 537002014U, 2, s->handle, *data);
#line 890
  return (tmp___2);
  case 151U: 
#line 894
  tmp___3 = cx18_vapi(cx, 537002012U, 3, s->handle, *data, *(data + 1UL));
#line 894
  return (tmp___3);
  case 197U: ;
#line 897
  return (0);
  case 189U: 
#line 899
  tmp___4 = cx18_vapi(cx, 537002001U, 2, s->handle, *data);
#line 899
  return (tmp___4);
  case 218U: 
#line 902
  tmp___5 = cx18_vapi(cx, 537002004U, 2, s->handle, *data);
#line 902
  return (tmp___5);
  case 149U: 
#line 905
  tmp___6 = cx18_vapi(cx, 537001989U, 5, s->handle, *data, *(data + 1UL), *(data + 2UL),
                      *(data + 3UL));
#line 905
  return (tmp___6);
  case 217U: 
#line 908
  tmp___7 = cx18_vapi(cx, 537002003U, 2, s->handle, *data);
#line 908
  return (tmp___7);
  case 208U: 
#line 911
  tmp___8 = cx18_vapi(cx, 537002015U, 2, s->handle, *data);
#line 911
  return (tmp___8);
  case 220U: 
#line 914
  tmp___9 = cx18_vapi(cx, 537002005U, 4, s->handle, *data, *(data + 1UL), *(data + 2UL));
#line 914
  return (tmp___9);
  case 155U: 
#line 917
  cx->filter_mode = (*data & 3U) | (*(data + 1UL) << 2);
#line 918
  tmp___10 = cx18_set_filter_param(s);
#line 918
  return (tmp___10);
  case 157U: 
#line 920
  cx->spatial_strength = *data;
#line 921
  cx->temporal_strength = *(data + 1UL);
#line 922
  tmp___11 = cx18_set_filter_param(s);
#line 922
  return (tmp___11);
  case 161U: 
#line 924
  tmp___12 = cx18_vapi(cx, 537001996U, 3, s->handle, *data, *(data + 1UL));
#line 924
  return (tmp___12);
  case 159U: 
#line 927
  tmp___13 = cx18_vapi(cx, 537001998U, 5, s->handle, *data, *(data + 1UL), *(data + 2UL),
                       *(data + 3UL));
#line 927
  return (tmp___13);
  }
#line 930
  printk("\f%s: Unknown cmd %x\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 931
  return (0);
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int cx18_vapi_result(struct cx18 *cx , u32 *data , u32 cmd , int args  , ...) 
{ 
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 940
  ldv__builtin_va_start((__va_list_tag *)(& ap));
#line 941
  i = 0;
#line 941
  goto ldv_51930;
  ldv_51929: 
#line 942
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 942
  *(data + (unsigned long )i) = tmp;
#line 941
  i = i + 1;
  ldv_51930: ;
#line 941
  if (i < args) {
#line 943
    goto ldv_51929;
  } else {

  }
#line 943
  ldv__builtin_va_end((__va_list_tag *)(& ap));
#line 944
  tmp___0 = cx18_api(cx, cmd, args, data);
#line 944
  return (tmp___0);
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int cx18_vapi(struct cx18 *cx , u32 cmd , int args  , ...) 
{ 
  u32 data[6U] ;
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 953
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 954
    printk("\v%s: cx == NULL (cmd=%x)\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 955
    return (0);
  } else {

  }
#line 957
  if (args > 6) {
#line 958
    printk("\v%s: args too big (cmd=%x)\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 959
    args = 6;
  } else {

  }
#line 961
  ldv__builtin_va_start((__va_list_tag *)(& ap));
#line 962
  i = 0;
#line 962
  goto ldv_51941;
  ldv_51940: 
#line 963
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 963
  data[i] = tmp;
#line 962
  i = i + 1;
  ldv_51941: ;
#line 962
  if (i < args) {
#line 964
    goto ldv_51940;
  } else {

  }
#line 964
  ldv__builtin_va_end((__va_list_tag *)(& ap));
#line 965
  tmp___0 = cx18_api(cx, cmd, args, (u32 *)(& data));
#line 965
  return (tmp___0);
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void *ldv_kmem_cache_alloc_444(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1098
  ldv_check_alloc_flags(flags);
#line 1100
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1101
  return ((void *)0);
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1142
  ldv_check_alloc_flags(flags);
#line 1144
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1144
  return (tmp);
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1158
  ldv_check_alloc_flags(flags);
#line 1160
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1160
  return (tmp);
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv_skb_copy_454(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1174
  ldv_check_alloc_flags(flags);
#line 1176
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1176
  return (tmp);
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_455(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1182
  ldv_check_alloc_flags(flags);
#line 1184
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1184
  return (tmp);
}
}
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_456(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1190
  ldv_check_alloc_flags(flags);
#line 1192
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1192
  return (tmp);
}
}
#line 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_457(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1198
  ldv_check_alloc_flags(flags);
#line 1200
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1200
  return (tmp);
}
}
#line 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1206
  ldv_check_alloc_flags(flags);
#line 1208
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1208
  return (tmp);
}
}
#line 1211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_pskb_expand_head_459(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1214
  ldv_check_alloc_flags(flags);
#line 1216
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1216
  return (tmp);
}
}
#line 1219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1222
  ldv_check_alloc_flags(flags);
#line 1224
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1224
  return (tmp);
}
}
#line 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_mod_timer_461(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 1231
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1231
  ldv_func_res = tmp;
#line 1233
  activate_pending_timer_2(ldv_func_arg1, ldv_func_arg2, 1);
#line 1235
  return (ldv_func_res);
}
}
#line 58 "./arch/x86/include/asm/string_64.h"
extern void *memmove(void * , void const   * , size_t  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_488(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_496(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_504(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_498(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_502(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_503(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_499(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_500(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_501(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___2  =    1444U;
#line 494 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_60Hz___0  =    272U;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_50Hz___0  =    284U;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static u8 const   raw_vbi_sav_rp[2U]  = {      32U,      96U};
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static u8 const   sliced_vbi_eav_rp[2U]  = {      176U,      240U};
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static void copy_vbi_data(struct cx18 *cx , int lines , u32 pts_stamp ) 
{ 
  int line ;
  int i ;
  u32 linemask[2U] ;
  unsigned short size ;
  u8 mpeg_hdr_data[32U] ;
  int sd ;
  int idx ;
  u8 *dst ;
  struct v4l2_sliced_vbi_data *sdata ;
  int f ;
  int l ;
  u16 tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;

  {
#line 137
  line = 0;
#line 139
  linemask[0] = 0U;
#line 139
  linemask[1] = 0U;
#line 141
  mpeg_hdr_data[0] = 0U;
#line 141
  mpeg_hdr_data[1] = 0U;
#line 141
  mpeg_hdr_data[2] = 1U;
#line 141
  mpeg_hdr_data[3] = 186U;
#line 141
  mpeg_hdr_data[4] = 68U;
#line 141
  mpeg_hdr_data[5] = 0U;
#line 141
  mpeg_hdr_data[6] = 12U;
#line 141
  mpeg_hdr_data[7] = 102U;
#line 141
  mpeg_hdr_data[8] = 36U;
#line 141
  mpeg_hdr_data[9] = 1U;
#line 141
  mpeg_hdr_data[10] = 1U;
#line 141
  mpeg_hdr_data[11] = 209U;
#line 141
  mpeg_hdr_data[12] = 211U;
#line 141
  mpeg_hdr_data[13] = 250U;
#line 141
  mpeg_hdr_data[14] = 255U;
#line 141
  mpeg_hdr_data[15] = 255U;
#line 141
  mpeg_hdr_data[16] = 0U;
#line 141
  mpeg_hdr_data[17] = 0U;
#line 141
  mpeg_hdr_data[18] = 1U;
#line 141
  mpeg_hdr_data[19] = 189U;
#line 141
  mpeg_hdr_data[20] = 0U;
#line 141
  mpeg_hdr_data[21] = 26U;
#line 141
  mpeg_hdr_data[22] = 132U;
#line 141
  mpeg_hdr_data[23] = 128U;
#line 141
  mpeg_hdr_data[24] = 7U;
#line 141
  mpeg_hdr_data[25] = 33U;
#line 141
  mpeg_hdr_data[26] = 0U;
#line 141
  mpeg_hdr_data[27] = 93U;
#line 141
  mpeg_hdr_data[28] = 99U;
#line 141
  mpeg_hdr_data[29] = 167U;
#line 141
  mpeg_hdr_data[30] = 255U;
#line 141
  mpeg_hdr_data[31] = 255U;
#line 154
  sd = 32;
#line 155
  idx = (int )cx->vbi.frame & 31;
#line 156
  dst = cx->vbi.sliced_mpeg_data[idx];
#line 158
  i = 0;
#line 158
  goto ldv_51371;
  ldv_51370: 
#line 159
  sdata = (struct v4l2_sliced_vbi_data *)(& cx->vbi.sliced_data) + (unsigned long )i;
#line 162
  if (sdata->id == 0U) {
#line 163
    goto ldv_51366;
  } else {

  }
#line 165
  l = (int )(sdata->line - 6U);
#line 166
  f = (int )sdata->field;
#line 167
  if (f != 0) {
#line 168
    l = l + 18;
  } else {

  }
#line 169
  if (l <= 31) {
#line 170
    linemask[0] = linemask[0] | (u32 )(1 << l);
  } else {
#line 172
    linemask[1] = linemask[1] | (u32 )(1 << (l + -32));
  }
#line 173
  tmp = cx18_service2vbi((int )sdata->id);
#line 173
  *(dst + (unsigned long )((sd + 12) + line * 43)) = (u8 )tmp;
#line 174
  __len = 42UL;
#line 174
  if (__len > 63UL) {
#line 174
    __ret = __memcpy((void *)(dst + (((unsigned long )sd + (unsigned long )(line * 43)) + 13UL)),
                     (void const   *)(& sdata->data), __len);
  } else {
#line 174
    __ret = __builtin_memcpy((void *)(dst + (((unsigned long )sd + (unsigned long )(line * 43)) + 13UL)),
                             (void const   *)(& sdata->data), __len);
  }
#line 175
  line = line + 1;
  ldv_51366: 
#line 158
  i = i + 1;
  ldv_51371: ;
#line 158
  if (i < lines) {
#line 160
    goto ldv_51370;
  } else {

  }
#line 177
  __len___0 = 32UL;
#line 177
  if (__len___0 > 63UL) {
#line 177
    __ret___0 = __memcpy((void *)dst, (void const   *)(& mpeg_hdr_data), __len___0);
  } else {
#line 177
    __ret___0 = __builtin_memcpy((void *)dst, (void const   *)(& mpeg_hdr_data), __len___0);
  }
#line 178
  if (line == 36) {
#line 182
    __len___1 = 4UL;
#line 182
    if (__len___1 > 63UL) {
#line 182
      __ret___1 = __memcpy((void *)dst + (unsigned long )sd, (void const   *)"ITV0",
                           __len___1);
    } else {
#line 182
      __ret___1 = __builtin_memcpy((void *)dst + (unsigned long )sd, (void const   *)"ITV0",
                                   __len___1);
    }
#line 183
    memmove((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(dst + ((unsigned long )sd + 12UL)),
            (size_t )(line * 43));
#line 184
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 4U;
  } else {
#line 186
    __len___2 = 4UL;
#line 186
    if (__len___2 > 63UL) {
#line 186
      __ret___2 = __memcpy((void *)dst + (unsigned long )sd, (void const   *)"itv0",
                           __len___2);
    } else {
#line 186
      __ret___2 = __builtin_memcpy((void *)dst + (unsigned long )sd, (void const   *)"itv0",
                                   __len___2);
    }
#line 189
    __len___3 = 8UL;
#line 189
    if (__len___3 > 63UL) {
#line 189
      __ret___3 = __memcpy((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(& linemask),
                           __len___3);
    } else {
#line 189
      __ret___3 = __builtin_memcpy((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(& linemask),
                                   __len___3);
    }
#line 190
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 12U;
  }
#line 192
  *(dst + 20UL) = (u8 )(((int )size + 10) >> 8);
#line 193
  *(dst + 21UL) = (u8 )((unsigned int )((unsigned char )size) + 10U);
#line 194
  *(dst + 25UL) = ((unsigned int )((u8 )(pts_stamp >> 29)) & 6U) | 33U;
#line 195
  *(dst + 26UL) = (u8 )(pts_stamp >> 22);
#line 196
  *(dst + 27UL) = (unsigned int )((u8 )(pts_stamp >> 14)) | 1U;
#line 197
  *(dst + 28UL) = (u8 )(pts_stamp >> 7);
#line 198
  *(dst + 29UL) = (unsigned int )((int )((u8 )pts_stamp) << 1U) | 1U;
#line 199
  cx->vbi.sliced_mpeg_size[idx] = (u32 )((int )size + sd);
#line 200
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static u32 compress_raw_buf(struct cx18 *cx , u8 *buf , u32 size , u32 hdr_size ) 
{ 
  u32 line_size ;
  u32 lines ;
  u8 *q ;
  u8 *p ;
  int i ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 207
  line_size = vbi_active_samples___2;
#line 208
  lines = cx->vbi.count * 2U;
#line 209
  q = buf;
#line 214
  buf = buf + (unsigned long )hdr_size;
#line 216
  i = 0;
#line 216
  goto ldv_51404;
  ldv_51403: 
#line 217
  p = buf + (unsigned long )((u32 )i * line_size);
#line 220
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || ((int )*(p + 3UL) != (int )((unsigned char )raw_vbi_sav_rp[0]) && (int )*(p + 3UL) != (int )((unsigned char )raw_vbi_sav_rp[1]))) {
#line 223
    goto ldv_51396;
  } else {

  }
#line 224
  if ((u32 )i == lines - 1U) {
#line 226
    __len = (size_t )((line_size - hdr_size) - 4U);
#line 226
    __ret = __builtin_memcpy((void *)q, (void const   *)p + 4U, __len);
#line 227
    q = q + (unsigned long )((line_size - hdr_size) - 4U);
#line 228
    p = p + (unsigned long )((line_size - hdr_size) - 1U);
#line 229
    memset((void *)q, (int )*p, (size_t )hdr_size);
  } else {
#line 231
    __len___0 = (size_t )(line_size - 4U);
#line 231
    __ret___0 = __builtin_memcpy((void *)q, (void const   *)p + 4U, __len___0);
#line 232
    q = q + (unsigned long )(line_size - 4U);
  }
#line 216
  i = i + 1;
  ldv_51404: ;
#line 216
  if ((u32 )i < lines) {
#line 218
    goto ldv_51403;
  } else {

  }
  ldv_51396: ;
#line 235
  return ((line_size - 4U) * lines);
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static u32 compress_sliced_buf(struct cx18 *cx , u8 *buf , u32 size , u32 const   hdr_size ) 
{ 
  struct v4l2_decode_vbi_line vbi ;
  int i ;
  u32 line ;
  u32 line_size ;
  u8 *p ;
  size_t __len ;
  void *__ret ;

  {
#line 243
  line = 0U;
#line 244
  line_size = (unsigned int )cx->is_60hz != 0U ? vbi_hblank_samples_60Hz___0 : vbi_hblank_samples_50Hz___0;
#line 248
  i = (int )hdr_size;
#line 248
  buf = buf + (unsigned long )hdr_size;
#line 248
  goto ldv_51417;
  ldv_51416: ;
#line 249
  if ((((unsigned int )*buf == 255U && (unsigned int )*(buf + 1UL) == 0U) && (unsigned int )*(buf + 2UL) == 0U) && ((int )*(buf + 3UL) == (int )((unsigned char )sliced_vbi_eav_rp[0]) || (int )*(buf + 3UL) == (int )((unsigned char )sliced_vbi_eav_rp[1]))) {
#line 252
    goto ldv_51415;
  } else {

  }
#line 248
  i = i + 1;
#line 248
  buf = buf + 1;
  ldv_51417: ;
#line 248
  if ((u32 )i < size) {
#line 250
    goto ldv_51416;
  } else {

  }
  ldv_51415: 
#line 260
  size = ((unsigned int )hdr_size - (unsigned int )i) + size;
#line 261
  if (size < line_size) {
#line 262
    return (line);
  } else {

  }
#line 264
  i = 0;
#line 264
  goto ldv_51424;
  ldv_51423: 
#line 265
  p = buf + (unsigned long )((u32 )i * line_size);
#line 268
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || ((int )*(p + 3UL) != (int )((unsigned char )sliced_vbi_eav_rp[0]) && (int )*(p + 3UL) != (int )((unsigned char )sliced_vbi_eav_rp[1]))) {
#line 271
    goto ldv_51419;
  } else {

  }
#line 272
  vbi.p = p + 4UL;
#line 273
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 273
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->decode_vbi_line != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                struct v4l2_decode_vbi_line * ))0)) {
#line 273
      (*((((cx->sd_av)->ops)->vbi)->decode_vbi_line))(cx->sd_av, & vbi);
    } else {

    }
  } else {

  }
#line 274
  if (vbi.type != 0U) {
#line 275
    cx->vbi.sliced_data[line].id = vbi.type;
#line 276
    cx->vbi.sliced_data[line].field = vbi.is_second_field;
#line 277
    cx->vbi.sliced_data[line].line = vbi.line;
#line 278
    __len = 42UL;
#line 278
    if (__len > 63UL) {
#line 278
      __ret = __memcpy((void *)(& cx->vbi.sliced_data[line].data), (void const   *)vbi.p,
                       __len);
    } else {
#line 278
      __ret = __builtin_memcpy((void *)(& cx->vbi.sliced_data[line].data), (void const   *)vbi.p,
                               __len);
    }
#line 279
    line = line + 1U;
  } else {

  }
  ldv_51419: 
#line 264
  i = i + 1;
  ldv_51424: ;
#line 264
  if ((u32 )i < size / line_size) {
#line 266
    goto ldv_51423;
  } else {

  }

#line 282
  return (line);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
static void _cx18_process_vbi_data(struct cx18 *cx , struct cx18_buffer *buf ) 
{ 
  struct vbi_data_hdr *hdr ;
  u8 *p ;
  u32 size ;
  u32 pts ;
  int lines ;
  u32 tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  u32 tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 295
  hdr = (struct vbi_data_hdr *)buf->buf;
#line 297
  p = (u8 *)buf->buf;
#line 298
  size = buf->bytesused;
#line 307
  cx18_buf_swap(buf);
#line 310
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 310
  if (tmp___0 != 0) {
#line 312
    tmp = compress_raw_buf(cx, p, size, 12U);
#line 312
    buf->bytesused = tmp;
#line 312
    size = tmp;
#line 319
    p = p + (unsigned long )(size - 4U);
#line 320
    __len = 4UL;
#line 320
    if (__len > 63UL) {
#line 320
      __ret = __memcpy((void *)p, (void const   *)(& cx->vbi.frame), __len);
    } else {
#line 320
      __ret = __builtin_memcpy((void *)p, (void const   *)(& cx->vbi.frame), __len);
    }
#line 321
    cx->vbi.frame = cx->vbi.frame + 1U;
#line 322
    return;
  } else {

  }
#line 327
  tmp___3 = __fswab32(hdr->magic);
#line 327
  if (tmp___3 == 1073741823U) {
#line 327
    tmp___2 = __fswab32(hdr->pts);
#line 327
    pts = tmp___2;
  } else {
#line 327
    pts = 0U;
  }
#line 330
  tmp___4 = compress_sliced_buf(cx, p, size, 12U);
#line 330
  lines = (int )tmp___4;
#line 333
  if (lines == 0) {
#line 334
    cx->vbi.sliced_data[0].id = 0U;
#line 335
    cx->vbi.sliced_data[0].line = 0U;
#line 336
    cx->vbi.sliced_data[0].field = 0U;
#line 337
    lines = 1;
  } else {

  }
#line 339
  size = (u32 )((unsigned long )lines) * 64U;
#line 339
  buf->bytesused = size;
#line 340
  __len___0 = (size_t )size;
#line 340
  __ret___0 = __builtin_memcpy((void *)p, (void const   *)(& cx->vbi.sliced_data),
                               __len___0);
#line 342
  if (cx->vbi.insert_mpeg != 0) {
#line 343
    copy_vbi_data(cx, lines, pts);
  } else {

  }
#line 344
  cx->vbi.frame = cx->vbi.frame + 1U;
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void cx18_process_vbi_data(struct cx18 *cx , struct cx18_mdl *mdl , int streamtype ) 
{ 
  struct cx18_buffer *buf ;
  u32 orig_used ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 353
  if (streamtype != 3) {
#line 354
    return;
  } else {

  }
#line 366
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 366
  buf = (struct cx18_buffer *)__mptr;
#line 366
  goto ldv_51458;
  ldv_51457: 
#line 367
  orig_used = buf->bytesused;
#line 368
  if (orig_used == 0U) {
#line 369
    goto ldv_51456;
  } else {

  }
#line 370
  _cx18_process_vbi_data(cx, buf);
#line 371
  mdl->bytesused = mdl->bytesused + (buf->bytesused - orig_used);
#line 366
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 366
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_51458: ;
#line 366
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 368
    goto ldv_51457;
  } else {

  }
  ldv_51456: ;
#line 373
  return;
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void *ldv_kmem_cache_alloc_488(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 505
  ldv_check_alloc_flags(flags);
#line 507
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 508
  return ((void *)0);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
int ldv_pskb_expand_head_494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 549
  ldv_check_alloc_flags(flags);
#line 551
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 551
  return (tmp);
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_496(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 565
  ldv_check_alloc_flags(flags);
#line 567
  tmp = skb_clone(ldv_func_arg1, flags);
#line 567
  return (tmp);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv_skb_copy_498(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 581
  ldv_check_alloc_flags(flags);
#line 583
  tmp = skb_copy(ldv_func_arg1, flags);
#line 583
  return (tmp);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_499(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 589
  ldv_check_alloc_flags(flags);
#line 591
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 591
  return (tmp);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_500(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 597
  ldv_check_alloc_flags(flags);
#line 599
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 599
  return (tmp);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_501(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 605
  ldv_check_alloc_flags(flags);
#line 607
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 607
  return (tmp);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
int ldv_pskb_expand_head_502(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 613
  ldv_check_alloc_flags(flags);
#line 615
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 615
  return (tmp);
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
int ldv_pskb_expand_head_503(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 621
  ldv_check_alloc_flags(flags);
#line 623
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 623
  return (tmp);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_504(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 629
  ldv_check_alloc_flags(flags);
#line 631
  tmp = skb_clone(ldv_func_arg1, flags);
#line 631
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_530(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_538(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_546(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_540(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_536(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_544(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_545(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_541(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_542(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_543(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
int cx18_audio_set_io(struct cx18 *cx ) 
{ 
  struct cx18_card_audio_input  const  *in ;
  u32 u ;
  u32 v ;
  int err ;
  int tmp ;
  struct v4l2_subdev *__sd ;
  long __err ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 140
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 140
  if (tmp != 0) {
#line 141
    in = & (cx->card)->radio_input;
  } else {
#line 143
    in = (struct cx18_card_audio_input  const  *)(& (cx->card)->audio_inputs) + (unsigned long )cx->audio_input;
  }
#line 146
  if ((unsigned long )cx->sd_extmux != (unsigned long )((struct v4l2_subdev *)0)) {
#line 146
    if ((unsigned long )((cx->sd_extmux)->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_extmux)->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ))0)) {
#line 146
      (*((((cx->sd_extmux)->ops)->audio)->s_routing))(cx->sd_extmux, (unsigned int )in->muxer_input,
                                                      0U, 0U);
    } else {

    }
  } else {

  }
#line 149
  __err = 0L;
#line 149
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 149
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 149
  goto ldv_51487;
  ldv_51486: ;
#line 149
  if ((((unsigned int )(cx->card)->hw_audio_ctrl == 0U || (__sd->grp_id & (u32 )(cx->card)->hw_audio_ctrl) != 0U) && (unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                                                                                u32  ))0)) {
#line 149
    tmp___0 = (*(((__sd->ops)->audio)->s_routing))(__sd, in->audio_input, 0U, 0U);
#line 149
    __err = (long )tmp___0;
  } else {

  }
#line 149
  if (__err != 0L && __err != -515L) {
#line 149
    goto ldv_51485;
  } else {

  }
#line 149
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 149
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51487: ;
#line 149
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 151
    goto ldv_51486;
  } else {

  }
  ldv_51485: 
#line 149
  err = (int )(__err != -515L ? __err : 0L);
#line 151
  if (err != 0) {
#line 152
    return (err);
  } else {

  }
#line 155
  u = cx18_read_reg(cx, 13049876U);
#line 156
  v = u & 4294967247U;
#line 157
  switch (in->audio_input) {
  case 0U: 
#line 159
  v = v;
#line 160
  goto ldv_51491;
  case 1U: 
#line 162
  v = v | 16U;
#line 163
  goto ldv_51491;
  default: 
#line 165
  v = v | 32U;
#line 166
  goto ldv_51491;
  }
  ldv_51491: ;
#line 168
  if (v == u) {
#line 170
    u = u & 4294967247U;
#line 171
    switch (in->audio_input) {
    case 0U: 
#line 173
    u = u | 32U;
#line 174
    goto ldv_51495;
    case 1U: 
#line 176
    u = u | 32U;
#line 177
    goto ldv_51495;
    default: 
#line 179
    u = u;
#line 180
    goto ldv_51495;
    }
    ldv_51495: 
#line 182
    cx18_write_reg_expect(cx, u | 2816U, 13049876U, u, 48U);
  } else {

  }
#line 185
  cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 187
  return (0);
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void *ldv_kmem_cache_alloc_530(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 320
  ldv_check_alloc_flags(flags);
#line 322
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 323
  return ((void *)0);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
int ldv_pskb_expand_head_536(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 364
  ldv_check_alloc_flags(flags);
#line 366
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 366
  return (tmp);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_538(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 380
  ldv_check_alloc_flags(flags);
#line 382
  tmp = skb_clone(ldv_func_arg1, flags);
#line 382
  return (tmp);
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv_skb_copy_540(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 396
  ldv_check_alloc_flags(flags);
#line 398
  tmp = skb_copy(ldv_func_arg1, flags);
#line 398
  return (tmp);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_541(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 404
  ldv_check_alloc_flags(flags);
#line 406
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 406
  return (tmp);
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_542(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 412
  ldv_check_alloc_flags(flags);
#line 414
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 414
  return (tmp);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_543(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 420
  ldv_check_alloc_flags(flags);
#line 422
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 422
  return (tmp);
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
int ldv_pskb_expand_head_544(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 428
  ldv_check_alloc_flags(flags);
#line 430
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 430
  return (tmp);
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
int ldv_pskb_expand_head_545(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 436
  ldv_check_alloc_flags(flags);
#line 438
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 438
  return (tmp);
}
}
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_546(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 446
  tmp = skb_clone(ldv_func_arg1, flags);
#line 446
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_572(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_580(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_588(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_582(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_578(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_586(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_587(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_583(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_584(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_585(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void cx18_video_set_io(struct cx18 *cx ) 
{ 
  int inp ;

  {
#line 124
  inp = (int )cx->active_input;
#line 126
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 126
    if ((unsigned long )((cx->sd_av)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                u32  ))0)) {
#line 126
      (*((((cx->sd_av)->ops)->video)->s_routing))(cx->sd_av, (cx->card)->video_inputs[inp].video_input,
                                                  0U, 0U);
    } else {

    }
  } else {

  }
#line 127
  return;
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void *ldv_kmem_cache_alloc_572(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 260
  ldv_check_alloc_flags(flags);
#line 262
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 263
  return ((void *)0);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
int ldv_pskb_expand_head_578(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 304
  ldv_check_alloc_flags(flags);
#line 306
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 306
  return (tmp);
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv_skb_clone_580(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 320
  ldv_check_alloc_flags(flags);
#line 322
  tmp = skb_clone(ldv_func_arg1, flags);
#line 322
  return (tmp);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv_skb_copy_582(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 336
  ldv_check_alloc_flags(flags);
#line 338
  tmp = skb_copy(ldv_func_arg1, flags);
#line 338
  return (tmp);
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_583(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 344
  ldv_check_alloc_flags(flags);
#line 346
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 346
  return (tmp);
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_584(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 352
  ldv_check_alloc_flags(flags);
#line 354
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 354
  return (tmp);
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_585(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 360
  ldv_check_alloc_flags(flags);
#line 362
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 362
  return (tmp);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
int ldv_pskb_expand_head_586(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 368
  ldv_check_alloc_flags(flags);
#line 370
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 370
  return (tmp);
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
int ldv_pskb_expand_head_587(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 376
  ldv_check_alloc_flags(flags);
#line 378
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 378
  return (tmp);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
struct sk_buff *ldv_skb_clone_588(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 384
  ldv_check_alloc_flags(flags);
#line 386
  tmp = skb_clone(ldv_func_arg1, flags);
#line 386
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_614(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_622(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_630(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_624(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_620(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_628(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_625(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_626(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_627(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
static void xpu_ack(struct cx18 *cx , u32 sw2 ) 
{ 


  {
#line 127
  if ((sw2 & 8U) != 0U) {
#line 128
    __wake_up(& cx->mb_cpu_waitq, 3U, 1, (void *)0);
  } else {

  }
#line 129
  if ((sw2 & 128U) != 0U) {
#line 130
    __wake_up(& cx->mb_apu_waitq, 3U, 1, (void *)0);
  } else {

  }
#line 131
  return;
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
static void epu_cmd___0(struct cx18 *cx , u32 sw1 ) 
{ 


  {
#line 135
  if ((sw1 & 65536U) != 0U) {
#line 136
    cx18_api_epu_cmd_irq(cx, 1);
  } else {

  }
#line 137
  if ((sw1 & 131072U) != 0U) {
#line 138
    cx18_api_epu_cmd_irq(cx, 0);
  } else {

  }
#line 139
  return;
}
}
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
irqreturn_t cx18_irq_handler(int irq , void *dev_id ) 
{ 
  struct cx18 *cx ;
  u32 sw1 ;
  u32 sw2 ;
  u32 hw2 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
#line 143
  cx = (struct cx18 *)dev_id;
#line 146
  tmp = cx18_read_reg(cx, 13054212U);
#line 146
  sw1 = tmp & cx->sw1_irq_mask;
#line 147
  tmp___0 = cx18_read_reg(cx, 13054276U);
#line 147
  sw2 = tmp___0 & cx->sw2_irq_mask;
#line 148
  tmp___1 = cx18_read_reg(cx, 13054148U);
#line 148
  hw2 = tmp___1 & cx->hw2_irq_mask;
#line 150
  if (sw1 != 0U) {
#line 151
    cx18_write_reg_expect(cx, sw1, 13054212U, ~ sw1, sw1);
  } else {

  }
#line 152
  if (sw2 != 0U) {
#line 153
    cx18_write_reg_expect(cx, sw2, 13054276U, ~ sw2, sw2);
  } else {

  }
#line 154
  if (hw2 != 0U) {
#line 155
    cx18_write_reg_expect(cx, hw2, 13054148U, ~ hw2, hw2);
  } else {

  }
#line 157
  if ((sw1 != 0U || sw2 != 0U) || hw2 != 0U) {
#line 158
    if ((cx18_debug & 128) != 0 && (cx18_debug & 256) != 0) {
#line 158
      printk("\016%s:  irq: received interrupts SW1: %x  SW2: %x  HW2: %x\n", (char *)(& cx->v4l2_dev.name),
             sw1, sw2, hw2);
    } else {

    }
  } else {

  }
#line 165
  if (sw1 != 0U) {
#line 166
    epu_cmd___0(cx, sw1);
  } else {

  }
#line 173
  if (sw2 != 0U) {
#line 174
    xpu_ack(cx, sw2);
  } else {

  }
#line 176
  return ((irqreturn_t )((sw1 != 0U || sw2 != 0U) || hw2 != 0U));
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void *ldv_kmem_cache_alloc_614(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 309
  ldv_check_alloc_flags(flags);
#line 311
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 312
  return ((void *)0);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
int ldv_pskb_expand_head_620(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 353
  ldv_check_alloc_flags(flags);
#line 355
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 355
  return (tmp);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv_skb_clone_622(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 369
  ldv_check_alloc_flags(flags);
#line 371
  tmp = skb_clone(ldv_func_arg1, flags);
#line 371
  return (tmp);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv_skb_copy_624(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 385
  ldv_check_alloc_flags(flags);
#line 387
  tmp = skb_copy(ldv_func_arg1, flags);
#line 387
  return (tmp);
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_625(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 393
  ldv_check_alloc_flags(flags);
#line 395
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 395
  return (tmp);
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_626(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 401
  ldv_check_alloc_flags(flags);
#line 403
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 403
  return (tmp);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_627(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 409
  ldv_check_alloc_flags(flags);
#line 411
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 411
  return (tmp);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
int ldv_pskb_expand_head_628(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 417
  ldv_check_alloc_flags(flags);
#line 419
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 419
  return (tmp);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 425
  ldv_check_alloc_flags(flags);
#line 427
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 427
  return (tmp);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
struct sk_buff *ldv_skb_clone_630(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 433
  ldv_check_alloc_flags(flags);
#line 435
  tmp = skb_clone(ldv_func_arg1, flags);
#line 435
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_656(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 281 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler * , unsigned int  ,
                                        struct lock_class_key * , char const   * ) ;
#line 318
extern int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler * ) ;
#line 363
extern struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                           u32  , s32  , s32  , u32  , s32  ) ;
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-av-core.h"
__inline static struct cx18_av_state *to_cx18_av_state(struct v4l2_subdev *sd ) 
{ 
  struct v4l2_subdev  const  *__mptr ;

  {
#line 348
  __mptr = (struct v4l2_subdev  const  *)sd;
#line 348
  return ((struct cx18_av_state *)__mptr);
}
}
#line 351 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-av-core.h"
__inline static struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_ctrl_handler  const  *__mptr ;

  {
#line 353
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 353
  return (& ((struct cx18_av_state *)__mptr + 0xfffffffffffffed0UL)->sd);
}
}
#line 358
int cx18_av_write(struct cx18 *cx , u16 addr , u8 value ) ;
#line 359
int cx18_av_write4(struct cx18 *cx , u16 addr , u32 value ) ;
#line 360
int cx18_av_write4_noretry(struct cx18 *cx , u16 addr , u32 value ) ;
#line 361
int cx18_av_write_expect(struct cx18 *cx , u16 addr , u8 value , u8 eval , u8 mask ) ;
#line 362
int cx18_av_write4_expect(struct cx18 *cx , u16 addr , u32 value , u32 eval , u32 mask ) ;
#line 364
u8 cx18_av_read(struct cx18 *cx , u16 addr ) ;
#line 365
u32 cx18_av_read4(struct cx18 *cx , u16 addr ) ;
#line 366
int cx18_av_and_or(struct cx18 *cx , u16 addr , unsigned int and_mask , u8 or_value ) ;
#line 367
int cx18_av_and_or4(struct cx18 *cx , u16 addr , u32 and_mask , u32 or_value ) ;
#line 368
void cx18_av_std_setup(struct cx18 *cx ) ;
#line 374
int cx18_av_loadfw(struct cx18 *cx ) ;
#line 378
int cx18_av_s_clock_freq(struct v4l2_subdev *sd , u32 freq ) ;
#line 379
void cx18_av_audio_set_path(struct cx18 *cx ) ;
#line 380
struct v4l2_ctrl_ops  const  cx18_av_audio_ctrl_ops ;
#line 384
int cx18_av_decode_vbi_line(struct v4l2_subdev *sd , struct v4l2_decode_vbi_line *vbi ) ;
#line 386
int cx18_av_s_raw_fmt(struct v4l2_subdev *sd , struct v4l2_vbi_format *fmt ) ;
#line 387
int cx18_av_g_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) ;
#line 388
int cx18_av_s_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_664(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_672(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_666(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_662(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_670(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_671(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_667(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_668(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_669(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_noretry(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 153
  cx18_writel_noretry(cx, val, cx->reg_mem + (unsigned long )reg);
#line 154
  return;
}
}
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_write(struct cx18 *cx , u16 addr , u8 value ) 
{ 
  u32 reg ;
  u32 mask ;
  int shift ;
  u32 x ;
  u32 tmp ;

  {
#line 127
  reg = (u32 )(((int )addr & -4) + 12845056);
#line 128
  mask = 255U;
#line 129
  shift = ((int )addr & 3) * 8;
#line 130
  tmp = cx18_read_reg(cx, reg);
#line 130
  x = tmp;
#line 132
  x = (~ (mask << shift) & x) | ((unsigned int )value << shift);
#line 133
  cx18_write_reg(cx, x, reg);
#line 134
  return (0);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_write_expect(struct cx18 *cx , u16 addr , u8 value , u8 eval , u8 mask ) 
{ 
  u32 reg ;
  int shift ;
  u32 x ;
  u32 tmp ;

  {
#line 139
  reg = (u32 )(((int )addr & -4) + 12845056);
#line 140
  shift = ((int )addr & 3) * 8;
#line 141
  tmp = cx18_read_reg(cx, reg);
#line 141
  x = tmp;
#line 143
  x = (~ (255U << shift) & x) | ((unsigned int )value << shift);
#line 144
  cx18_write_reg_expect(cx, x, reg, (unsigned int )eval << shift, (unsigned int )mask << shift);
#line 146
  return (0);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_write4(struct cx18 *cx , u16 addr , u32 value ) 
{ 


  {
#line 151
  cx18_write_reg(cx, value, (u32 )((int )addr + 12845056));
#line 152
  return (0);
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_write4_expect(struct cx18 *cx , u16 addr , u32 value , u32 eval , u32 mask ) 
{ 


  {
#line 158
  cx18_write_reg_expect(cx, value, (u32 )((int )addr + 12845056), eval, mask);
#line 159
  return (0);
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_write4_noretry(struct cx18 *cx , u16 addr , u32 value ) 
{ 


  {
#line 164
  cx18_write_reg_noretry(cx, value, (u32 )((int )addr + 12845056));
#line 165
  return (0);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
u8 cx18_av_read(struct cx18 *cx , u16 addr ) 
{ 
  u32 x ;
  u32 tmp ;
  int shift ;

  {
#line 170
  tmp = cx18_read_reg(cx, (u32 )(((int )addr & -4) + 12845056));
#line 170
  x = tmp;
#line 171
  shift = ((int )addr & 3) * 8;
#line 173
  return ((u8 )(x >> shift));
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
u32 cx18_av_read4(struct cx18 *cx , u16 addr ) 
{ 
  u32 tmp ;

  {
#line 178
  tmp = cx18_read_reg(cx, (u32 )((int )addr + 12845056));
#line 178
  return (tmp);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_and_or(struct cx18 *cx , u16 addr , unsigned int and_mask , u8 or_value ) 
{ 
  u8 tmp ;
  int tmp___0 ;

  {
#line 184
  tmp = cx18_av_read(cx, (int )addr);
#line 184
  tmp___0 = cx18_av_write(cx, (int )addr, ((int )tmp & (int )((u8 )and_mask)) | (int )or_value);
#line 184
  return (tmp___0);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_and_or4(struct cx18 *cx , u16 addr , u32 and_mask , u32 or_value ) 
{ 
  u32 tmp ;
  int tmp___0 ;

  {
#line 192
  tmp = cx18_av_read4(cx, (int )addr);
#line 192
  tmp___0 = cx18_av_write4(cx, (int )addr, (tmp & and_mask) | or_value);
#line 192
  return (tmp___0);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static void cx18_av_init(struct cx18 *cx ) 
{ 


  {
#line 209
  cx18_av_write4(cx, 264, 370017295U);
#line 213
  cx18_av_write4(cx, 268, 2876158U);
#line 217
  cx18_av_write4(cx, 272, 5384109U);
#line 220
  cx18_av_write(cx, 295, 86);
#line 221
  return;
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static void cx18_av_initialize(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int default_volume ;
  u32 v ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  s32 tmp___5 ;

  {
#line 225
  tmp = to_cx18_av_state(sd);
#line 225
  state = tmp;
#line 226
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 226
  cx = (struct cx18 *)tmp___0;
#line 230
  cx18_av_loadfw(cx);
#line 232
  cx18_av_write4_expect(cx, 2048, 50331648U, 50331648U, 318767104U);
#line 236
  v = cx18_av_read4(cx, 0);
#line 238
  cx18_av_write4_expect(cx, 0, v | 1U, v, 65534U);
#line 240
  cx18_av_write4_expect(cx, 0, v & 65534U, v & 65534U, 65535U);
#line 244
  tmp___1 = cx18_av_read4(cx, 344);
#line 244
  v = tmp___1 & 3791650559U;
#line 246
  cx18_av_write4(cx, 344, v);
#line 248
  cx18_av_write4(cx, 344, v | 268435712U);
#line 250
  tmp___2 = cx18_av_read4(cx, 348);
#line 250
  v = tmp___2 & 3791650559U;
#line 252
  cx18_av_write4(cx, 348, v);
#line 254
  cx18_av_write4(cx, 348, v | 100663552U);
#line 257
  cx18_av_write4(cx, 308, 661506U);
#line 259
  tmp___3 = cx18_av_read4(cx, 316);
#line 259
  v = tmp___3 | 1U;
#line 261
  cx18_av_write4_expect(cx, 316, v, v, 50372367U);
#line 263
  cx18_av_write4_expect(cx, 316, v & 4294967294U, v & 4294967294U, 50372367U);
#line 267
  cx18_av_and_or4(cx, 276, 4294967295U, 265216U);
#line 270
  cx18_av_and_or4(cx, 280, 4294967295U, 2U);
#line 273
  cx18_av_write4(cx, 1188, 32768U);
#line 274
  cx18_av_write4(cx, 1188, 0U);
#line 291
  cx18_av_and_or4(cx, 256, 4294705151U, 1179648U);
#line 294
  cx18_av_init(cx);
#line 299
  cx18_av_and_or4(cx, 1024, 4294436848U, 33818624U);
#line 303
  cx18_av_and_or4(cx, 1184, 4294967295U, 5242880U);
#line 306
  cx18_av_and_or4(cx, 1164, 4294902015U, 8192U);
#line 315
  cx18_av_write4(cx, 1028, 1074996526U);
#line 338
  cx18_av_and_or4(cx, 260, 4278190080U, 23808U);
#line 345
  cx18_av_write4(cx, 1144, 1713898015U);
#line 346
  tmp___4 = cx18_av_read(cx, 2260);
#line 346
  default_volume = (int )tmp___4;
#line 351
  if (default_volume > 228) {
#line 353
    default_volume = 228;
#line 354
    cx18_av_write(cx, 2260, 228);
  } else
#line 355
  if (default_volume <= 19) {
#line 357
    default_volume = 20;
#line 358
    cx18_av_write(cx, 2260, 20);
  } else {

  }
#line 360
  default_volume = (((228 - default_volume) >> 1) + 23) << 9;
#line 361
  tmp___5 = default_volume;
#line 361
  (state->volume)->default_value = tmp___5;
#line 361
  (state->volume)->cur.val = tmp___5;
#line 362
  v4l2_ctrl_handler_setup(& state->hdl);
#line 363
  return;
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_reset(struct v4l2_subdev *sd , u32 val ) 
{ 


  {
#line 367
  cx18_av_initialize(sd);
#line 368
  return (0);
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_load_fw(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;

  {
#line 373
  tmp = to_cx18_av_state(sd);
#line 373
  state = tmp;
#line 375
  if (state->is_initialized == 0) {
#line 377
    state->is_initialized = 1;
#line 378
    cx18_av_initialize(sd);
  } else {

  }
#line 380
  return (0);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void cx18_av_std_setup(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  v4l2_std_id std ;
  int src_decimation ;
  int hblank ;
  int hactive ;
  int burst ;
  int vblank ;
  int vactive ;
  int sc ;
  int vblank656 ;
  int luma_lpf ;
  int uv_lpf ;
  int comb ;
  u32 pll_int ;
  u32 pll_frac ;
  u32 pll_post ;
  u8 tmp ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  int fsc ;
  int pll ;
  u64 tmp___2 ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 385
  state = & cx->av_state;
#line 386
  sd = & state->sd;
#line 387
  std = state->std;
#line 393
  src_decimation = 543;
#line 401
  if ((std & 0xffffffffffff4fffULL) != 0ULL) {
#line 402
    cx18_av_write(cx, 1183, 17);
  } else {
#line 404
    cx18_av_write(cx, 1183, 20);
  }
#line 414
  if ((std & 16713471ULL) != 0ULL) {
#line 446
    vblank656 = 48;
#line 447
    vblank = 38;
#line 448
    vactive = 579;
#line 457
    hblank = 132;
#line 458
    hactive = 720;
#line 467
    burst = 93;
#line 468
    luma_lpf = 2;
#line 469
    if ((std & 255ULL) != 0ULL) {
#line 470
      uv_lpf = 1;
#line 471
      comb = 32;
#line 473
      sc = 688700;
    } else
#line 474
    if (std == 1024ULL) {
#line 475
      uv_lpf = 1;
#line 476
      comb = 32;
#line 478
      sc = 556422;
    } else {
#line 480
      uv_lpf = 0;
#line 481
      comb = 0;
#line 484
      sc = 672314;
    }
  } else {
#line 506
    vblank656 = 38;
#line 507
    vblank = 26;
#line 508
    vactive = 481;
#line 517
    hactive = 720;
#line 518
    hblank = 122;
#line 519
    luma_lpf = 1;
#line 520
    uv_lpf = 1;
#line 529
    if (std == 2048ULL) {
#line 530
      burst = 90;
#line 531
      luma_lpf = 2;
#line 532
      comb = 32;
#line 534
      sc = 688700;
    } else
#line 535
    if (std == 256ULL) {
#line 537
      burst = 97;
#line 538
      comb = 32;
#line 540
      sc = 555421;
    } else {
#line 542
      burst = 90;
#line 543
      comb = 102;
#line 545
      sc = 556032;
    }
  }
#line 550
  tmp = cx18_av_read(cx, 264);
#line 550
  pll_int = (u32 )tmp;
#line 551
  tmp___0 = cx18_av_read4(cx, 268);
#line 551
  pll_frac = tmp___0 & 33554431U;
#line 552
  tmp___1 = cx18_av_read(cx, 265);
#line 552
  pll_post = (u32 )tmp___1;
#line 553
  if ((cx18_debug & 2) != 0) {
#line 553
    printk("\016%s:  info: PLL regs = int: %u, frac: %u, post: %u\n", (char *)(& sd->name),
           pll_int, pll_frac, pll_post);
  } else {

  }
#line 556
  if (pll_post != 0U) {
#line 560
    pll = (int )((((unsigned long long )pll_int << 25) + (unsigned long long )pll_frac) * 28636360ULL >> 25);
#line 561
    pll = (int )((u32 )pll / pll_post);
#line 562
    if ((cx18_debug & 2) != 0) {
#line 562
      printk("\016%s:  info: Video PLL = %d.%06d MHz\n", (char *)(& sd->name), pll / 1000000,
             pll % 1000000);
    } else {

    }
#line 564
    if ((cx18_debug & 2) != 0) {
#line 564
      printk("\016%s:  info: Pixel rate = %d.%06d Mpixel/sec\n", (char *)(& sd->name),
             pll / 8000000, (pll / 8) % 1000000);
    } else {

    }
#line 567
    if ((cx18_debug & 2) != 0) {
#line 567
      printk("\016%s:  info: ADC XTAL/pixel clock decimation ratio = %d.%03d\n", (char *)(& sd->name),
             src_decimation / 256, ((src_decimation % 256) * 1000) / 256);
    } else {

    }
#line 571
    tmp___2 = (unsigned long long )sc * 28636360ULL;
#line 572
    __base = (uint32_t )src_decimation;
#line 572
    __rem = (uint32_t )(tmp___2 % (u64 )__base);
#line 572
    tmp___2 = tmp___2 / (u64 )__base;
#line 573
    fsc = (int )(tmp___2 >> 13);
#line 574
    if ((cx18_debug & 2) != 0) {
#line 574
      printk("\016%s:  info: Chroma sub-carrier initial freq = %d.%06d MHz\n", (char *)(& sd->name),
             fsc / 1000000, fsc % 1000000);
    } else {

    }
#line 578
    if ((cx18_debug & 2) != 0) {
#line 578
      printk("\016%s:  info: hblank %i, hactive %i, vblank %i, vactive %i, vblank656 %i, src_dec %i, burst 0x%02x, luma_lpf %i, uv_lpf %i, comb 0x%02x, sc 0x%06x\n",
             (char *)(& sd->name), hblank, hactive, vblank, vactive, vblank656, src_decimation,
             burst, luma_lpf, uv_lpf, comb, sc);
    } else {

    }
  } else {

  }
#line 588
  cx18_av_write(cx, 1136, (int )((u8 )hblank));
#line 589
  cx18_av_write(cx, 1137, (int )((u8 )(((int )((signed char )(hblank >> 8)) & 3) | (int )((signed char )(hactive << 4)))));
#line 591
  cx18_av_write(cx, 1138, (int )((u8 )(hactive >> 4)));
#line 594
  cx18_av_write(cx, 1139, (int )((u8 )burst));
#line 597
  cx18_av_write(cx, 1140, (int )((u8 )vblank));
#line 598
  cx18_av_write(cx, 1141, (int )((u8 )(((int )((signed char )(vblank >> 8)) & 3) | (int )((signed char )(vactive << 4)))));
#line 600
  cx18_av_write(cx, 1142, (int )((u8 )(vactive >> 4)));
#line 601
  cx18_av_write(cx, 1143, (int )((u8 )vblank656));
#line 604
  cx18_av_write(cx, 1144, (int )((u8 )src_decimation));
#line 605
  cx18_av_write(cx, 1145, (int )((u8 )(src_decimation >> 8)));
#line 608
  cx18_av_write(cx, 1146, (int )((u8 )((int )((signed char )(luma_lpf << 6)) | ((int )((signed char )(uv_lpf << 4)) & 48))));
#line 611
  cx18_av_write(cx, 1147, (int )((u8 )comb));
#line 614
  cx18_av_write(cx, 1148, (int )((u8 )sc));
#line 615
  cx18_av_write(cx, 1149, (int )((u8 )(sc >> 8)));
#line 616
  cx18_av_write(cx, 1150, (int )((u8 )(sc >> 16)));
#line 618
  if ((std & 16713471ULL) != 0ULL) {
#line 619
    state->slicer_line_delay = 1;
#line 620
    state->slicer_line_offset = state->slicer_line_delay + 4;
  } else {
#line 622
    state->slicer_line_delay = 0;
#line 623
    state->slicer_line_offset = state->slicer_line_delay + 8;
  }
#line 625
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 626
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static void input_change(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  v4l2_std_id std ;
  u8 v ;

  {
#line 630
  state = & cx->av_state;
#line 631
  std = state->std;
#line 635
  cx18_av_write(cx, 1183, (std & 45056ULL) != 0ULL ? 20 : 17);
#line 636
  cx18_av_and_or(cx, 1025, 4294967199U, 0);
#line 637
  cx18_av_and_or(cx, 1025, 4294967199U, 96);
#line 639
  if ((std & 63744ULL) != 0ULL) {
#line 640
    if (std == 8192ULL) {
#line 642
      cx18_av_write_expect(cx, 2056, 247, 247, 255);
#line 643
      cx18_av_write_expect(cx, 2059, 2, 2, 63);
    } else
#line 644
    if (std == 32768ULL) {
#line 646
      cx18_av_write_expect(cx, 2056, 248, 248, 255);
#line 647
      cx18_av_write_expect(cx, 2059, 3, 3, 63);
    } else {
#line 650
      cx18_av_write_expect(cx, 2056, 246, 246, 255);
#line 651
      cx18_av_write_expect(cx, 2059, 1, 1, 63);
    }
  } else
#line 653
  if ((std & 255ULL) != 0ULL) {
#line 655
    cx18_av_write_expect(cx, 2056, 255, 255, 255);
#line 656
    cx18_av_write_expect(cx, 2059, 3, 3, 63);
  } else
#line 657
  if ((std & 16711680ULL) != 0ULL) {
#line 659
    cx18_av_write_expect(cx, 2056, 255, 255, 255);
#line 660
    cx18_av_write_expect(cx, 2059, 3, 3, 63);
  } else {

  }
#line 663
  v = cx18_av_read(cx, 2051);
#line 664
  if (((int )v & 16) != 0) {
#line 666
    v = (unsigned int )v & 239U;
#line 667
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 668
    v = (u8 )((unsigned int )v | 16U);
#line 669
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 671
  return;
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_frequency(struct v4l2_subdev *sd , struct v4l2_frequency  const  *freq ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 676
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 676
  cx = (struct cx18 *)tmp;
#line 677
  input_change(cx);
#line 678
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int set_input(struct cx18 *cx , enum cx18_av_video_input vid_input , enum cx18_av_audio_input aud_input ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  enum analog_signal_type ch[3U] ;
  u8 afe_mux_cfg ;
  u8 adc2_cfg ;
  u8 input_mode ;
  u32 afe_cfg ;
  int i ;
  int luma ;
  int r_chroma ;
  int b_chroma ;
  int luma___0 ;
  int chroma ;

  {
#line 684
  state = & cx->av_state;
#line 685
  sd = & state->sd;
#line 689
  ch[0] = 0;
#line 689
  ch[1] = 0;
#line 689
  ch[2] = 0;
#line 697
  if ((cx18_debug & 2) != 0) {
#line 697
    printk("\016%s:  info: decoder set video input %d, audio input %d\n", (char *)(& sd->name),
           (unsigned int )vid_input, (unsigned int )aud_input);
  } else {

  }
#line 700
  if ((unsigned int )vid_input != 0U && (unsigned int )vid_input <= 8U) {
#line 702
    afe_mux_cfg = (unsigned int )((u8 )vid_input) + 239U;
#line 703
    ch[0] = 1;
#line 704
    input_mode = 0U;
  } else
#line 705
  if ((unsigned int )vid_input > 4095U) {
#line 706
    luma = (int )vid_input & 61440;
#line 707
    r_chroma = (int )vid_input & 983040;
#line 708
    b_chroma = (int )vid_input & 15728640;
#line 710
    if ((((((((unsigned int )vid_input & 4278194175U) != 0U || luma <= 4095) || luma > 32768) || r_chroma <= 262143) || r_chroma > 393216) || b_chroma <= 7340031) || b_chroma > 8388608) {
#line 717
      printk("\v%s: 0x%06x is not a valid video input!\n", (char *)(& sd->name), (unsigned int )vid_input);
#line 719
      return (-22);
    } else {

    }
#line 721
    afe_mux_cfg = (u8 )((luma + -4096) >> 12);
#line 722
    ch[0] = 2;
#line 723
    afe_mux_cfg = (u8 )((int )((signed char )((r_chroma + -262144) >> 12)) | (int )((signed char )afe_mux_cfg));
#line 724
    ch[1] = 6;
#line 725
    afe_mux_cfg = (u8 )((int )((signed char )((b_chroma + -7340032) >> 14)) | (int )((signed char )afe_mux_cfg));
#line 726
    ch[2] = 5;
#line 727
    input_mode = 6U;
  } else {
#line 729
    luma___0 = (int )vid_input & 240;
#line 730
    chroma = (int )vid_input & 3840;
#line 732
    if ((((((unsigned int )vid_input & 4294963215U) != 0U || luma___0 <= 15) || luma___0 > 128) || chroma <= 1023) || chroma > 2048) {
#line 737
      printk("\v%s: 0x%06x is not a valid video input!\n", (char *)(& sd->name), (unsigned int )vid_input);
#line 739
      return (-22);
    } else {

    }
#line 741
    afe_mux_cfg = (unsigned int )((u8 )((luma___0 + -16) >> 4)) + 240U;
#line 742
    ch[0] = 2;
#line 743
    if (chroma > 1791) {
#line 744
      afe_mux_cfg = (unsigned int )afe_mux_cfg & 63U;
#line 745
      afe_mux_cfg = (u8 )((int )((signed char )((chroma + -1792) >> 2)) | (int )((signed char )afe_mux_cfg));
#line 746
      ch[2] = 3;
    } else {
#line 748
      afe_mux_cfg = (unsigned int )afe_mux_cfg & 207U;
#line 749
      afe_mux_cfg = (u8 )((int )((signed char )((chroma + -1024) >> 4)) | (int )((signed char )afe_mux_cfg));
#line 750
      ch[1] = 3;
    }
#line 752
    input_mode = 2U;
  }
#line 755
  switch ((unsigned int )aud_input) {
  case 0U: ;
  case 1U: ;
#line 759
  goto ldv_51611;
  case 4U: 
#line 761
  afe_mux_cfg = (unsigned int )afe_mux_cfg & 207U;
#line 762
  ch[1] = 4;
#line 763
  goto ldv_51611;
  case 5U: 
#line 765
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & -49) | 16);
#line 766
  ch[1] = 4;
#line 767
  goto ldv_51611;
  case 6U: 
#line 769
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & -49) | 32);
#line 770
  ch[1] = 4;
#line 771
  goto ldv_51611;
  case 7U: 
#line 773
  afe_mux_cfg = (unsigned int )afe_mux_cfg & 63U;
#line 774
  ch[2] = 4;
#line 775
  goto ldv_51611;
  case 8U: 
#line 777
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & 63) | 64);
#line 778
  ch[2] = 4;
#line 779
  goto ldv_51611;
  default: 
#line 782
  printk("\v%s: 0x%04x is not a valid audio input!\n", (char *)(& sd->name), (unsigned int )aud_input);
#line 784
  return (-22);
  }
  ldv_51611: 
#line 788
  cx18_av_write_expect(cx, 259, (int )afe_mux_cfg, (int )afe_mux_cfg, 247);
#line 790
  cx18_av_and_or(cx, 1025, 4294967289U, (int )input_mode);
#line 793
  adc2_cfg = cx18_av_read(cx, 258);
#line 794
  if ((unsigned int )ch[2] == 0U) {
#line 795
    adc2_cfg = (unsigned int )adc2_cfg & 253U;
  } else {
#line 797
    adc2_cfg = (u8 )((unsigned int )adc2_cfg | 2U);
  }
#line 800
  if ((unsigned int )ch[1] != 0U && (unsigned int )ch[2] != 0U) {
#line 801
    adc2_cfg = (u8 )((unsigned int )adc2_cfg | 4U);
  } else {
#line 803
    adc2_cfg = (unsigned int )adc2_cfg & 251U;
  }
#line 804
  cx18_av_write_expect(cx, 258, (int )adc2_cfg, (int )adc2_cfg, 23);
#line 807
  afe_cfg = cx18_av_read4(cx, 260);
#line 808
  afe_cfg = afe_cfg & 4278190080U;
#line 809
  afe_cfg = afe_cfg | 20480U;
#line 810
  if ((unsigned int )ch[1] != 0U && (unsigned int )ch[2] != 0U) {
#line 811
    afe_cfg = afe_cfg | 48U;
  } else {

  }
#line 813
  i = 0;
#line 813
  goto ldv_51628;
  ldv_51627: ;
#line 814
  switch ((unsigned int )ch[i]) {
  default: ;
  case 0U: 
#line 818
  afe_cfg = (u32 )(512 << i) | afe_cfg;
#line 819
  goto ldv_51620;
  case 1U: ;
  case 2U: ;
#line 822
  if (i > 0) {
#line 823
    afe_cfg = afe_cfg | 8192U;
  } else {

  }
#line 824
  goto ldv_51620;
  case 3U: ;
  case 5U: ;
  case 6U: 
#line 829
  afe_cfg = (u32 )(512 << i) | afe_cfg;
#line 830
  if (i == 0 && (unsigned int )ch[i] == 3U) {
#line 831
    afe_cfg = afe_cfg & 4294963199U;
  } else {

  }
#line 832
  goto ldv_51620;
  case 4U: 
#line 838
  afe_cfg = (u32 )(576 << i) | afe_cfg;
#line 839
  if (i == 0) {
#line 840
    afe_cfg = afe_cfg & 4294950911U;
  } else {

  }
#line 841
  goto ldv_51620;
  }
  ldv_51620: 
#line 813
  i = i + 1;
  ldv_51628: ;
#line 813
  if (i <= 2) {
#line 815
    goto ldv_51627;
  } else {

  }
#line 845
  cx18_av_write4(cx, 260, afe_cfg);
#line 847
  state->vid_input = vid_input;
#line 848
  state->aud_input = aud_input;
#line 849
  cx18_av_audio_set_path(cx);
#line 850
  input_change(cx);
#line 851
  return (0);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_video_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 857
  tmp = to_cx18_av_state(sd);
#line 857
  state = tmp;
#line 858
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 858
  cx = (struct cx18 *)tmp___0;
#line 859
  tmp___1 = set_input(cx, (enum cx18_av_video_input )input, state->aud_input);
#line 859
  return (tmp___1);
}
}
#line 862 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_audio_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 865
  tmp = to_cx18_av_state(sd);
#line 865
  state = tmp;
#line 866
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 866
  cx = (struct cx18 *)tmp___0;
#line 867
  tmp___1 = set_input(cx, state->vid_input, (enum cx18_av_audio_input )input);
#line 867
  return (tmp___1);
}
}
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_g_tuner(struct v4l2_subdev *sd , struct v4l2_tuner *vt ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 vpres ;
  u8 mode ;
  int val ;
  u8 tmp___1 ;

  {
#line 872
  tmp = to_cx18_av_state(sd);
#line 872
  state = tmp;
#line 873
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 873
  cx = (struct cx18 *)tmp___0;
#line 876
  val = 0;
#line 878
  if (state->radio != 0) {
#line 879
    return (0);
  } else {

  }
#line 881
  tmp___1 = cx18_av_read(cx, 1038);
#line 881
  vpres = (unsigned int )tmp___1 & 32U;
#line 882
  vt->signal = (unsigned int )vpres != 0U ? 65535 : 0;
#line 884
  vt->capability = vt->capability | 112U;
#line 888
  mode = cx18_av_read(cx, 2052);
#line 891
  if (((int )mode & 15) == 1) {
#line 892
    val = val | 2;
  } else {
#line 894
    val = val | 1;
  }
#line 896
  if ((unsigned int )mode == 2U || (unsigned int )mode == 4U) {
#line 897
    val = 12;
  } else {

  }
#line 899
  if (((int )mode & 16) != 0) {
#line 900
    val = val | 4;
  } else {

  }
#line 902
  vt->rxsubchans = (__u32 )val;
#line 903
  vt->audmode = (__u32 )state->audmode;
#line 904
  return (0);
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_tuner(struct v4l2_subdev *sd , struct v4l2_tuner  const  *vt ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 v ;

  {
#line 909
  tmp = to_cx18_av_state(sd);
#line 909
  state = tmp;
#line 910
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 910
  cx = (struct cx18 *)tmp___0;
#line 913
  if (state->radio != 0) {
#line 914
    return (0);
  } else {

  }
#line 916
  v = cx18_av_read(cx, 2057);
#line 917
  v = (unsigned int )v & 240U;
#line 919
  switch (vt->audmode) {
  case 0U: ;
#line 924
  goto ldv_51663;
  case 1U: ;
  case 3U: 
#line 930
  v = (u8 )((unsigned int )v | 4U);
#line 931
  goto ldv_51663;
  case 4U: 
#line 936
  v = (u8 )((unsigned int )v | 7U);
#line 937
  goto ldv_51663;
  case 2U: 
#line 942
  v = (u8 )((unsigned int )v | 1U);
#line 943
  goto ldv_51663;
  default: ;
#line 945
  return (-22);
  }
  ldv_51663: 
#line 947
  cx18_av_write_expect(cx, 2057, (int )v, (int )v, 255);
#line 948
  state->audmode = (int )vt->audmode;
#line 949
  return (0);
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_std(struct v4l2_subdev *sd , v4l2_std_id norm ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 fmt ;
  u8 pal_m ;

  {
#line 954
  tmp = to_cx18_av_state(sd);
#line 954
  state = tmp;
#line 955
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 955
  cx = (struct cx18 *)tmp___0;
#line 957
  fmt = 0U;
#line 958
  pal_m = 0U;
#line 960
  if (state->radio == 0 && state->std == norm) {
#line 961
    return (0);
  } else {

  }
#line 963
  state->radio = 0;
#line 964
  state->std = norm;
#line 967
  if (state->std == 8192ULL) {
#line 968
    fmt = 2U;
  } else
#line 969
  if (state->std == 16384ULL) {
#line 970
    fmt = 3U;
  } else
#line 971
  if (state->std == 256ULL) {
#line 972
    pal_m = 1U;
#line 973
    fmt = 5U;
  } else
#line 974
  if (state->std == 512ULL) {
#line 975
    fmt = 6U;
  } else
#line 976
  if (state->std == 1024ULL) {
#line 977
    fmt = 7U;
  } else
#line 978
  if (state->std == 2048ULL) {
#line 979
    fmt = 8U;
  } else
#line 982
  if ((state->std & 45056ULL) != 0ULL) {
#line 983
    fmt = 1U;
  } else
#line 984
  if ((state->std & 255ULL) != 0ULL) {
#line 985
    fmt = 4U;
  } else
#line 986
  if ((state->std & 16711680ULL) != 0ULL) {
#line 987
    fmt = 12U;
  } else {

  }
#line 990
  if ((cx18_debug & 2) != 0) {
#line 990
    printk("\016%s:  info: changing video std to fmt %i\n", (char *)(& sd->name),
           (int )fmt);
  } else {

  }
#line 995
  if ((unsigned int )fmt > 3U && (unsigned int )fmt <= 7U) {
#line 997
    cx18_av_and_or(cx, 1024, 4294967280U, 1);
#line 999
    cx18_av_and_or(cx, 1147, 4294967289U, 0);
  } else {

  }
#line 1001
  cx18_av_and_or(cx, 1024, 4294967248U, (int )((unsigned int )fmt | 32U));
#line 1002
  cx18_av_and_or(cx, 1027, 4294967292U, (int )pal_m);
#line 1003
  cx18_av_std_setup(cx);
#line 1004
  input_change(cx);
#line 1005
  return (0);
}
}
#line 1008 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_radio(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;

  {
#line 1010
  tmp = to_cx18_av_state(sd);
#line 1010
  state = tmp;
#line 1011
  state->radio = 1;
#line 1012
  return (0);
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;

  {
#line 1017
  tmp = to_sd(ctrl);
#line 1017
  sd = tmp;
#line 1018
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1018
  cx = (struct cx18 *)tmp___0;
#line 1020
  switch (ctrl->id) {
  case 9963776U: 
#line 1022
  cx18_av_write(cx, 1044, (int )((unsigned int )((u8 )ctrl->ldv_36505.val) + 128U));
#line 1023
  goto ldv_51687;
  case 9963777U: 
#line 1026
  cx18_av_write(cx, 1045, (int )((u8 )ctrl->ldv_36505.val) << 1U);
#line 1027
  goto ldv_51687;
  case 9963778U: 
#line 1030
  cx18_av_write(cx, 1056, (int )((u8 )ctrl->ldv_36505.val) << 1U);
#line 1031
  cx18_av_write(cx, 1057, (int )((u8 )ctrl->ldv_36505.val) << 1U);
#line 1032
  goto ldv_51687;
  case 9963779U: 
#line 1035
  cx18_av_write(cx, 1058, (int )((u8 )ctrl->ldv_36505.val));
#line 1036
  goto ldv_51687;
  default: ;
#line 1039
  return (-22);
  }
  ldv_51687: ;
#line 1041
  return (0);
}
}
#line 1044 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_mbus_fmt(struct v4l2_subdev *sd , struct v4l2_mbus_framefmt *fmt ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int HSC ;
  int VSC ;
  int Vsrc ;
  int Hsrc ;
  int filter ;
  int Vlines ;
  int is_50Hz ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;

  {
#line 1046
  tmp = to_cx18_av_state(sd);
#line 1046
  state = tmp;
#line 1047
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1047
  cx = (struct cx18 *)tmp___0;
#line 1049
  is_50Hz = (state->std & 63744ULL) == 0ULL;
#line 1051
  if (fmt->code != 1U) {
#line 1052
    return (-22);
  } else {

  }
#line 1054
  fmt->field = 4U;
#line 1055
  fmt->colorspace = 1U;
#line 1057
  tmp___1 = cx18_av_read(cx, 1142);
#line 1057
  Vsrc = ((int )tmp___1 & 63) << 4;
#line 1058
  tmp___2 = cx18_av_read(cx, 1141);
#line 1058
  Vsrc = ((int )tmp___2 >> 4) | Vsrc;
#line 1060
  tmp___3 = cx18_av_read(cx, 1138);
#line 1060
  Hsrc = ((int )tmp___3 & 63) << 4;
#line 1061
  tmp___4 = cx18_av_read(cx, 1137);
#line 1061
  Hsrc = ((int )tmp___4 >> 4) | Hsrc;
#line 1070
  Vlines = (int )(fmt->height + (is_50Hz != 0 ? 3U : 1U));
#line 1079
  if (((fmt->width * 16U < (__u32 )Hsrc || (__u32 )Hsrc < fmt->width) || Vlines * 8 < Vsrc) || Vsrc < Vlines) {
#line 1081
    printk("\v%s: %dx%d is not a valid size!\n", (char *)(& sd->name), fmt->width,
           fmt->height);
#line 1083
    return (-34);
  } else {

  }
#line 1086
  HSC = (int )((__u32 )(Hsrc * 1048576) / fmt->width - 1048576U);
#line 1087
  VSC = 66048 - (Vsrc * 512) / Vlines;
#line 1088
  VSC = VSC & 8191;
#line 1090
  if (fmt->width > 384U) {
#line 1091
    filter = 0;
  } else
#line 1092
  if (fmt->width > 192U) {
#line 1093
    filter = 1;
  } else
#line 1094
  if (fmt->width > 96U) {
#line 1095
    filter = 2;
  } else {
#line 1097
    filter = 3;
  }
#line 1099
  if ((cx18_debug & 2) != 0) {
#line 1099
    printk("\016%s:  info: decoder set size %dx%d -> scale  %ux%u\n", (char *)(& sd->name),
           fmt->width, fmt->height, HSC, VSC);
  } else {

  }
#line 1104
  cx18_av_write(cx, 1048, (int )((u8 )HSC));
#line 1105
  cx18_av_write(cx, 1049, (int )((u8 )(HSC >> 8)));
#line 1106
  cx18_av_write(cx, 1050, (int )((u8 )(HSC >> 16)));
#line 1108
  cx18_av_write(cx, 1052, (int )((u8 )VSC));
#line 1109
  cx18_av_write(cx, 1053, (int )((u8 )(VSC >> 8)));
#line 1111
  cx18_av_write(cx, 1054, (int )((u8 )((int )((signed char )filter) | 8)));
#line 1112
  return (0);
}
}
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_stream(struct v4l2_subdev *sd , int enable ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1117
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1117
  cx = (struct cx18 *)tmp;
#line 1119
  if ((cx18_debug & 2) != 0) {
#line 1119
    printk("\016%s:  info: %s output\n", (char *)(& sd->name), enable != 0 ? (char *)"enable" : (char *)"disable");
  } else {

  }
#line 1120
  if (enable != 0) {
#line 1121
    cx18_av_write(cx, 277, 140);
#line 1122
    cx18_av_write(cx, 278, 7);
  } else {
#line 1124
    cx18_av_write(cx, 277, 0);
#line 1125
    cx18_av_write(cx, 278, 0);
  }
#line 1127
  return (0);
}
}
#line 1130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static void log_video_status(struct cx18 *cx ) 
{ 
  char const   *fmt_strs[16U] ;
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  u8 vidfmt_sel ;
  u8 tmp ;
  u8 gen_stat1 ;
  u8 tmp___0 ;
  u8 gen_stat2 ;
  u8 tmp___1 ;
  int vid_input ;

  {
#line 1132
  fmt_strs[0] = "0x0";
#line 1132
  fmt_strs[1] = "NTSC-M";
#line 1132
  fmt_strs[2] = "NTSC-J";
#line 1132
  fmt_strs[3] = "NTSC-4.43";
#line 1132
  fmt_strs[4] = "PAL-BDGHI";
#line 1132
  fmt_strs[5] = "PAL-M";
#line 1132
  fmt_strs[6] = "PAL-N";
#line 1132
  fmt_strs[7] = "PAL-Nc";
#line 1132
  fmt_strs[8] = "PAL-60";
#line 1132
  fmt_strs[9] = "0x9";
#line 1132
  fmt_strs[10] = "0xA";
#line 1132
  fmt_strs[11] = "0xB";
#line 1132
  fmt_strs[12] = "SECAM";
#line 1132
  fmt_strs[13] = "0xD";
#line 1132
  fmt_strs[14] = "0xE";
#line 1132
  fmt_strs[15] = "0xF";
#line 1141
  state = & cx->av_state;
#line 1142
  sd = & state->sd;
#line 1143
  tmp = cx18_av_read(cx, 1024);
#line 1143
  vidfmt_sel = (unsigned int )tmp & 15U;
#line 1144
  tmp___0 = cx18_av_read(cx, 1037);
#line 1144
  gen_stat1 = tmp___0;
#line 1145
  tmp___1 = cx18_av_read(cx, 1038);
#line 1145
  gen_stat2 = tmp___1;
#line 1146
  vid_input = (int )state->vid_input;
#line 1148
  printk("\016%s: Video signal:              %spresent\n", (char *)(& sd->name), ((int )gen_stat2 & 32) != 0 ? (char *)"" : (char *)"not ");
#line 1150
  printk("\016%s: Detected format:           %s\n", (char *)(& sd->name), fmt_strs[(int )gen_stat1 & 15]);
#line 1153
  printk("\016%s: Specified standard:        %s\n", (char *)(& sd->name), (unsigned int )vidfmt_sel != 0U ? fmt_strs[(int )vidfmt_sel] : (char const   */* const  */)"automatic detection");
#line 1157
  if (vid_input > 0 && vid_input <= 8) {
#line 1159
    printk("\016%s: Specified video input:     Composite %d\n", (char *)(& sd->name),
           vid_input);
  } else {
#line 1162
    printk("\016%s: Specified video input:     S-Video (Luma In%d, Chroma In%d)\n",
           (char *)(& sd->name), (vid_input & 240) >> 4, (vid_input & 3840) >> 8);
  }
#line 1168
  printk("\016%s: Specified audioclock freq: %d Hz\n", (char *)(& sd->name), state->audclk_freq);
#line 1169
  return;
}
}
#line 1172 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static void log_audio_status(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  u8 download_ctl ;
  u8 tmp ;
  u8 mod_det_stat0 ;
  u8 tmp___0 ;
  u8 mod_det_stat1 ;
  u8 tmp___1 ;
  u8 audio_config ;
  u8 tmp___2 ;
  u8 pref_mode ;
  u8 tmp___3 ;
  u8 afc0 ;
  u8 tmp___4 ;
  u8 mute_ctl ;
  u8 tmp___5 ;
  int aud_input ;
  char *p ;

  {
#line 1174
  state = & cx->av_state;
#line 1175
  sd = & state->sd;
#line 1176
  tmp = cx18_av_read(cx, 2051);
#line 1176
  download_ctl = tmp;
#line 1177
  tmp___0 = cx18_av_read(cx, 2052);
#line 1177
  mod_det_stat0 = tmp___0;
#line 1178
  tmp___1 = cx18_av_read(cx, 2053);
#line 1178
  mod_det_stat1 = tmp___1;
#line 1179
  tmp___2 = cx18_av_read(cx, 2056);
#line 1179
  audio_config = tmp___2;
#line 1180
  tmp___3 = cx18_av_read(cx, 2057);
#line 1180
  pref_mode = tmp___3;
#line 1181
  tmp___4 = cx18_av_read(cx, 2059);
#line 1181
  afc0 = tmp___4;
#line 1182
  tmp___5 = cx18_av_read(cx, 2259);
#line 1182
  mute_ctl = tmp___5;
#line 1183
  aud_input = (int )state->aud_input;
#line 1186
  switch ((int )mod_det_stat0) {
  case 0: 
#line 1187
  p = (char *)"mono";
#line 1187
  goto ldv_51735;
  case 1: 
#line 1188
  p = (char *)"stereo";
#line 1188
  goto ldv_51735;
  case 2: 
#line 1189
  p = (char *)"dual";
#line 1189
  goto ldv_51735;
  case 4: 
#line 1190
  p = (char *)"tri";
#line 1190
  goto ldv_51735;
  case 16: 
#line 1191
  p = (char *)"mono with SAP";
#line 1191
  goto ldv_51735;
  case 17: 
#line 1192
  p = (char *)"stereo with SAP";
#line 1192
  goto ldv_51735;
  case 18: 
#line 1193
  p = (char *)"dual with SAP";
#line 1193
  goto ldv_51735;
  case 20: 
#line 1194
  p = (char *)"tri with SAP";
#line 1194
  goto ldv_51735;
  case 254: 
#line 1195
  p = (char *)"forced mode";
#line 1195
  goto ldv_51735;
  default: 
#line 1196
  p = (char *)"not defined";
#line 1196
  goto ldv_51735;
  }
  ldv_51735: 
#line 1198
  printk("\016%s: Detected audio mode:       %s\n", (char *)(& sd->name), p);
#line 1200
  switch ((int )mod_det_stat1) {
  case 0: 
#line 1201
  p = (char *)"not defined";
#line 1201
  goto ldv_51746;
  case 1: 
#line 1202
  p = (char *)"EIAJ";
#line 1202
  goto ldv_51746;
  case 2: 
#line 1203
  p = (char *)"A2-M";
#line 1203
  goto ldv_51746;
  case 3: 
#line 1204
  p = (char *)"A2-BG";
#line 1204
  goto ldv_51746;
  case 4: 
#line 1205
  p = (char *)"A2-DK1";
#line 1205
  goto ldv_51746;
  case 5: 
#line 1206
  p = (char *)"A2-DK2";
#line 1206
  goto ldv_51746;
  case 6: 
#line 1207
  p = (char *)"A2-DK3";
#line 1207
  goto ldv_51746;
  case 7: 
#line 1208
  p = (char *)"A1 (6.0 MHz FM Mono)";
#line 1208
  goto ldv_51746;
  case 8: 
#line 1209
  p = (char *)"AM-L";
#line 1209
  goto ldv_51746;
  case 9: 
#line 1210
  p = (char *)"NICAM-BG";
#line 1210
  goto ldv_51746;
  case 10: 
#line 1211
  p = (char *)"NICAM-DK";
#line 1211
  goto ldv_51746;
  case 11: 
#line 1212
  p = (char *)"NICAM-I";
#line 1212
  goto ldv_51746;
  case 12: 
#line 1213
  p = (char *)"NICAM-L";
#line 1213
  goto ldv_51746;
  case 13: 
#line 1214
  p = (char *)"BTSC/EIAJ/A2-M Mono (4.5 MHz FMMono)";
#line 1214
  goto ldv_51746;
  case 14: 
#line 1215
  p = (char *)"IF FM Radio";
#line 1215
  goto ldv_51746;
  case 15: 
#line 1216
  p = (char *)"BTSC";
#line 1216
  goto ldv_51746;
  case 16: 
#line 1217
  p = (char *)"detected chrominance";
#line 1217
  goto ldv_51746;
  case 253: 
#line 1218
  p = (char *)"unknown audio standard";
#line 1218
  goto ldv_51746;
  case 254: 
#line 1219
  p = (char *)"forced audio standard";
#line 1219
  goto ldv_51746;
  case 255: 
#line 1220
  p = (char *)"no detected audio standard";
#line 1220
  goto ldv_51746;
  default: 
#line 1221
  p = (char *)"not defined";
#line 1221
  goto ldv_51746;
  }
  ldv_51746: 
#line 1223
  printk("\016%s: Detected audio standard:   %s\n", (char *)(& sd->name), p);
#line 1224
  printk("\016%s: Audio muted:               %s\n", (char *)(& sd->name), ((int )mute_ctl & 2) != 0 ? (char *)"yes" : (char *)"no");
#line 1226
  printk("\016%s: Audio microcontroller:     %s\n", (char *)(& sd->name), ((int )download_ctl & 16) != 0 ? (char *)"running" : (char *)"stopped");
#line 1229
  switch ((int )audio_config >> 4) {
  case 0: 
#line 1230
  p = (char *)"undefined";
#line 1230
  goto ldv_51768;
  case 1: 
#line 1231
  p = (char *)"BTSC";
#line 1231
  goto ldv_51768;
  case 2: 
#line 1232
  p = (char *)"EIAJ";
#line 1232
  goto ldv_51768;
  case 3: 
#line 1233
  p = (char *)"A2-M";
#line 1233
  goto ldv_51768;
  case 4: 
#line 1234
  p = (char *)"A2-BG";
#line 1234
  goto ldv_51768;
  case 5: 
#line 1235
  p = (char *)"A2-DK1";
#line 1235
  goto ldv_51768;
  case 6: 
#line 1236
  p = (char *)"A2-DK2";
#line 1236
  goto ldv_51768;
  case 7: 
#line 1237
  p = (char *)"A2-DK3";
#line 1237
  goto ldv_51768;
  case 8: 
#line 1238
  p = (char *)"A1 (6.0 MHz FM Mono)";
#line 1238
  goto ldv_51768;
  case 9: 
#line 1239
  p = (char *)"AM-L";
#line 1239
  goto ldv_51768;
  case 10: 
#line 1240
  p = (char *)"NICAM-BG";
#line 1240
  goto ldv_51768;
  case 11: 
#line 1241
  p = (char *)"NICAM-DK";
#line 1241
  goto ldv_51768;
  case 12: 
#line 1242
  p = (char *)"NICAM-I";
#line 1242
  goto ldv_51768;
  case 13: 
#line 1243
  p = (char *)"NICAM-L";
#line 1243
  goto ldv_51768;
  case 14: 
#line 1244
  p = (char *)"FM radio";
#line 1244
  goto ldv_51768;
  case 15: 
#line 1245
  p = (char *)"automatic detection";
#line 1245
  goto ldv_51768;
  default: 
#line 1246
  p = (char *)"undefined";
#line 1246
  goto ldv_51768;
  }
  ldv_51768: 
#line 1248
  printk("\016%s: Configured audio standard: %s\n", (char *)(& sd->name), p);
#line 1250
  if ((unsigned int )((int )audio_config >> 4) <= 14U) {
#line 1251
    switch ((int )audio_config & 15) {
    case 0: 
#line 1252
    p = (char *)"MONO1 (LANGUAGE A/Mono L+R channel for BTSC, EIAJ, A2)";
#line 1252
    goto ldv_51786;
    case 1: 
#line 1253
    p = (char *)"MONO2 (LANGUAGE B)";
#line 1253
    goto ldv_51786;
    case 2: 
#line 1254
    p = (char *)"MONO3 (STEREO forced MONO)";
#line 1254
    goto ldv_51786;
    case 3: 
#line 1255
    p = (char *)"MONO4 (NICAM ANALOG-Language C/Analog Fallback)";
#line 1255
    goto ldv_51786;
    case 4: 
#line 1256
    p = (char *)"STEREO";
#line 1256
    goto ldv_51786;
    case 5: 
#line 1257
    p = (char *)"DUAL1 (AC)";
#line 1257
    goto ldv_51786;
    case 6: 
#line 1258
    p = (char *)"DUAL2 (BC)";
#line 1258
    goto ldv_51786;
    case 7: 
#line 1259
    p = (char *)"DUAL3 (AB)";
#line 1259
    goto ldv_51786;
    default: 
#line 1260
    p = (char *)"undefined";
    }
    ldv_51786: 
#line 1262
    printk("\016%s: Configured audio mode:     %s\n", (char *)(& sd->name), p);
  } else {
#line 1264
    switch ((int )audio_config & 15) {
    case 0: 
#line 1265
    p = (char *)"BG";
#line 1265
    goto ldv_51796;
    case 1: 
#line 1266
    p = (char *)"DK1";
#line 1266
    goto ldv_51796;
    case 2: 
#line 1267
    p = (char *)"DK2";
#line 1267
    goto ldv_51796;
    case 3: 
#line 1268
    p = (char *)"DK3";
#line 1268
    goto ldv_51796;
    case 4: 
#line 1269
    p = (char *)"I";
#line 1269
    goto ldv_51796;
    case 5: 
#line 1270
    p = (char *)"L";
#line 1270
    goto ldv_51796;
    case 6: 
#line 1271
    p = (char *)"BTSC";
#line 1271
    goto ldv_51796;
    case 7: 
#line 1272
    p = (char *)"EIAJ";
#line 1272
    goto ldv_51796;
    case 8: 
#line 1273
    p = (char *)"A2-M";
#line 1273
    goto ldv_51796;
    case 9: 
#line 1274
    p = (char *)"FM Radio (4.5 MHz)";
#line 1274
    goto ldv_51796;
    case 10: 
#line 1275
    p = (char *)"FM Radio (5.5 MHz)";
#line 1275
    goto ldv_51796;
    case 11: 
#line 1276
    p = (char *)"S-Video";
#line 1276
    goto ldv_51796;
    case 15: 
#line 1277
    p = (char *)"automatic standard and mode detection";
#line 1277
    goto ldv_51796;
    default: 
#line 1278
    p = (char *)"undefined";
#line 1278
    goto ldv_51796;
    }
    ldv_51796: 
#line 1280
    printk("\016%s: Configured audio system:   %s\n", (char *)(& sd->name), p);
  }
#line 1283
  if (aud_input != 0) {
#line 1284
    printk("\016%s: Specified audio input:     Tuner (In%d)\n", (char *)(& sd->name),
           aud_input);
  } else {
#line 1287
    printk("\016%s: Specified audio input:     External\n", (char *)(& sd->name));
  }
#line 1289
  switch ((int )pref_mode & 15) {
  case 0: 
#line 1290
  p = (char *)"mono/language A";
#line 1290
  goto ldv_51811;
  case 1: 
#line 1291
  p = (char *)"language B";
#line 1291
  goto ldv_51811;
  case 2: 
#line 1292
  p = (char *)"language C";
#line 1292
  goto ldv_51811;
  case 3: 
#line 1293
  p = (char *)"analog fallback";
#line 1293
  goto ldv_51811;
  case 4: 
#line 1294
  p = (char *)"stereo";
#line 1294
  goto ldv_51811;
  case 5: 
#line 1295
  p = (char *)"language AC";
#line 1295
  goto ldv_51811;
  case 6: 
#line 1296
  p = (char *)"language BC";
#line 1296
  goto ldv_51811;
  case 7: 
#line 1297
  p = (char *)"language AB";
#line 1297
  goto ldv_51811;
  default: 
#line 1298
  p = (char *)"undefined";
#line 1298
  goto ldv_51811;
  }
  ldv_51811: 
#line 1300
  printk("\016%s: Preferred audio mode:      %s\n", (char *)(& sd->name), p);
#line 1302
  if (((int )audio_config & 15) == 15) {
#line 1303
    switch (((int )afc0 >> 3) & 1) {
    case 0: 
#line 1304
    p = (char *)"system DK";
#line 1304
    goto ldv_51821;
    case 1: 
#line 1305
    p = (char *)"system L";
#line 1305
    goto ldv_51821;
    }
    ldv_51821: 
#line 1307
    printk("\016%s: Selected 65 MHz format:    %s\n", (char *)(& sd->name), p);
#line 1309
    switch ((int )afc0 & 7) {
    case 0: 
#line 1310
    p = (char *)"Chroma";
#line 1310
    goto ldv_51824;
    case 1: 
#line 1311
    p = (char *)"BTSC";
#line 1311
    goto ldv_51824;
    case 2: 
#line 1312
    p = (char *)"EIAJ";
#line 1312
    goto ldv_51824;
    case 3: 
#line 1313
    p = (char *)"A2-M";
#line 1313
    goto ldv_51824;
    case 4: 
#line 1314
    p = (char *)"autodetect";
#line 1314
    goto ldv_51824;
    default: 
#line 1315
    p = (char *)"undefined";
#line 1315
    goto ldv_51824;
    }
    ldv_51824: 
#line 1317
    printk("\016%s: Selected 45 MHz format:    %s\n", (char *)(& sd->name), p);
  } else {

  }
#line 1319
  return;
}
}
#line 1321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1323
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1323
  cx = (struct cx18 *)tmp;
#line 1324
  log_video_status(cx);
#line 1325
  log_audio_status(cx);
#line 1326
  return (0);
}
}
#line 1330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_g_register(struct v4l2_subdev *sd , struct v4l2_dbg_register *reg ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 1333
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1333
  cx = (struct cx18 *)tmp;
#line 1335
  if ((reg->reg & 3ULL) != 0ULL) {
#line 1336
    return (-22);
  } else {

  }
#line 1337
  reg->size = 4U;
#line 1338
  tmp___0 = cx18_av_read4(cx, (int )((u16 )reg->reg) & 4092);
#line 1338
  reg->val = (__u64 )tmp___0;
#line 1339
  return (0);
}
}
#line 1342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static int cx18_av_s_register(struct v4l2_subdev *sd , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1345
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1345
  cx = (struct cx18 *)tmp;
#line 1347
  if (((unsigned long long )reg->reg & 3ULL) != 0ULL) {
#line 1348
    return (-22);
  } else {

  }
#line 1349
  cx18_av_write4(cx, (int )((u16 )reg->reg) & 4092, (u32 )reg->val);
#line 1350
  return (0);
}
}
#line 1354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_ctrl_ops  const  cx18_av_ctrl_ops  =    {0, 0, & cx18_av_s_ctrl};
#line 1358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_core_ops  const  cx18_av_general_ops  = 
#line 1358
     {& cx18_av_log_status, 0, 0, & cx18_av_load_fw, & cx18_av_reset, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & cx18_av_g_register, & cx18_av_s_register, 0, 0, 0, 0};
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_tuner_ops  const  cx18_av_tuner_ops  = 
#line 1368
     {& cx18_av_s_radio, & cx18_av_s_frequency, 0, 0, & cx18_av_g_tuner, & cx18_av_s_tuner,
    0, 0, 0, 0};
#line 1375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_audio_ops  const  cx18_av_audio_ops  =    {& cx18_av_s_clock_freq, 0, & cx18_av_s_audio_routing, 0};
#line 1380 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_video_ops  const  cx18_av_video_ops  = 
#line 1380
     {& cx18_av_s_video_routing, 0, 0, & cx18_av_s_std, 0, 0, 0, 0, 0, 0, & cx18_av_s_stream,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cx18_av_s_mbus_fmt, 0, 0, 0};
#line 1387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_vbi_ops  const  cx18_av_vbi_ops  =    {& cx18_av_decode_vbi_line, 0, 0, 0, & cx18_av_s_raw_fmt, & cx18_av_g_sliced_fmt,
    & cx18_av_s_sliced_fmt};
#line 1394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
static struct v4l2_subdev_ops  const  cx18_av_ops  = 
#line 1394
     {& cx18_av_general_ops, & cx18_av_tuner_ops, & cx18_av_audio_ops, & cx18_av_video_ops,
    & cx18_av_vbi_ops, 0, 0, 0};
#line 1402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int cx18_av_probe(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  int err ;
  u32 tmp ;
  struct lock_class_key _key ;
  int err___0 ;

  {
#line 1404
  state = & cx->av_state;
#line 1408
  tmp = cx18_av_read4(cx, 256);
#line 1408
  state->rev = tmp & 65535U;
#line 1410
  state->vid_input = 7;
#line 1411
  state->aud_input = 8;
#line 1412
  state->audclk_freq = 48000U;
#line 1413
  state->audmode = 3;
#line 1414
  state->slicer_line_delay = 0;
#line 1415
  state->slicer_line_offset = state->slicer_line_delay + 8;
#line 1417
  sd = & state->sd;
#line 1418
  v4l2_subdev_init(sd, & cx18_av_ops);
#line 1419
  v4l2_set_subdevdata(sd, (void *)cx);
#line 1420
  snprintf((char *)(& sd->name), 32UL, "%s %03x", (char *)(& cx->v4l2_dev.name), state->rev >> 4);
#line 1422
  sd->grp_id = 16U;
#line 1423
  v4l2_ctrl_handler_init_class(& state->hdl, 9U, & _key, "cx18_av_core:1423:(&state->hdl)->_lock");
#line 1424
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963776U, 0, 255, 1U, 128);
#line 1426
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963777U, 0, 127, 1U, 64);
#line 1428
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963778U, 0, 127, 1U, 64);
#line 1430
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963779U, -128, 127, 1U, 0);
#line 1433
  state->volume = v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963781U,
                                    0, 65535, 655U, 0);
#line 1436
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963785U, 0, 1, 1U, 0);
#line 1439
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963782U, 0, 65535, 655U,
                    32768);
#line 1442
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963783U, 0, 65535, 655U,
                    32768);
#line 1445
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963784U, 0, 65535, 655U,
                    32768);
#line 1448
  sd->ctrl_handler = & state->hdl;
#line 1449
  if (state->hdl.error != 0) {
#line 1450
    err___0 = state->hdl.error;
#line 1452
    v4l2_ctrl_handler_free(& state->hdl);
#line 1453
    return (err___0);
  } else {

  }
#line 1455
  err = v4l2_device_register_subdev(& cx->v4l2_dev, sd);
#line 1456
  if (err != 0) {
#line 1457
    v4l2_ctrl_handler_free(& state->hdl);
  } else {
#line 1459
    cx18_av_init(cx);
  }
#line 1460
  return (err);
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_video_ops_6(void) 
{ 
  void *tmp ;

  {
#line 1465
  tmp = ldv_zalloc(304UL);
#line 1465
  cx18_av_video_ops_group0 = (struct v4l2_subdev *)tmp;
#line 1466
  return;
}
}
#line 1468 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_audio_ops_7(void) 
{ 
  void *tmp ;

  {
#line 1469
  tmp = ldv_zalloc(304UL);
#line 1469
  cx18_av_audio_ops_group0 = (struct v4l2_subdev *)tmp;
#line 1470
  return;
}
}
#line 1472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_core_ops_9(void) 
{ 
  void *tmp ;

  {
#line 1473
  tmp = ldv_zalloc(304UL);
#line 1473
  cx18_av_general_ops_group0 = (struct v4l2_subdev *)tmp;
#line 1474
  return;
}
}
#line 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_tuner_ops_8(void) 
{ 
  void *tmp ;

  {
#line 1477
  tmp = ldv_zalloc(304UL);
#line 1477
  cx18_av_tuner_ops_group0 = (struct v4l2_subdev *)tmp;
#line 1478
  return;
}
}
#line 1480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_vbi_ops_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1481
  tmp = ldv_zalloc(112UL);
#line 1481
  cx18_av_vbi_ops_group0 = (struct v4l2_sliced_vbi_format *)tmp;
#line 1482
  tmp___0 = ldv_zalloc(304UL);
#line 1482
  cx18_av_vbi_ops_group1 = (struct v4l2_subdev *)tmp___0;
#line 1483
  return;
}
}
#line 1485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  struct v4l2_frequency *ldvarg109 ;
  void *tmp ;
  struct v4l2_tuner *ldvarg108 ;
  void *tmp___0 ;
  struct v4l2_tuner *ldvarg110 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1486
  tmp = ldv_zalloc(44UL);
#line 1486
  ldvarg109 = (struct v4l2_frequency *)tmp;
#line 1487
  tmp___0 = ldv_zalloc(84UL);
#line 1487
  ldvarg108 = (struct v4l2_tuner *)tmp___0;
#line 1488
  tmp___1 = ldv_zalloc(84UL);
#line 1488
  ldvarg110 = (struct v4l2_tuner *)tmp___1;
#line 1490
  tmp___2 = __VERIFIER_nondet_int();
#line 1490
  switch (tmp___2) {
  case 0: ;
#line 1493
  if (ldv_state_variable_8 == 1) {
#line 1495
    cx18_av_s_tuner(cx18_av_tuner_ops_group0, (struct v4l2_tuner  const  *)ldvarg110);
#line 1497
    ldv_state_variable_8 = 1;
  } else {

  }
#line 1500
  goto ldv_51882;
  case 1: ;
#line 1503
  if (ldv_state_variable_8 == 1) {
#line 1505
    cx18_av_s_radio(cx18_av_tuner_ops_group0);
#line 1507
    ldv_state_variable_8 = 1;
  } else {

  }
#line 1510
  goto ldv_51882;
  case 2: ;
#line 1513
  if (ldv_state_variable_8 == 1) {
#line 1515
    cx18_av_s_frequency(cx18_av_tuner_ops_group0, (struct v4l2_frequency  const  *)ldvarg109);
#line 1517
    ldv_state_variable_8 = 1;
  } else {

  }
#line 1520
  goto ldv_51882;
  case 3: ;
#line 1523
  if (ldv_state_variable_8 == 1) {
#line 1525
    cx18_av_g_tuner(cx18_av_tuner_ops_group0, ldvarg108);
#line 1527
    ldv_state_variable_8 = 1;
  } else {

  }
#line 1530
  goto ldv_51882;
  default: 
#line 1531
  ldv_stop();
  }
  ldv_51882: ;
#line 1535
  return;
}
}
#line 1537 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct v4l2_mbus_framefmt *ldvarg19 ;
  void *tmp ;
  u32 ldvarg22 ;
  u32 tmp___0 ;
  u32 ldvarg23 ;
  u32 tmp___1 ;
  v4l2_std_id ldvarg20 ;
  int ldvarg21 ;
  int tmp___2 ;
  u32 ldvarg24 ;
  u32 tmp___3 ;
  int tmp___4 ;

  {
#line 1538
  tmp = ldv_zalloc(48UL);
#line 1538
  ldvarg19 = (struct v4l2_mbus_framefmt *)tmp;
#line 1539
  tmp___0 = __VERIFIER_nondet_u32();
#line 1539
  ldvarg22 = tmp___0;
#line 1540
  tmp___1 = __VERIFIER_nondet_u32();
#line 1540
  ldvarg23 = tmp___1;
#line 1542
  tmp___2 = __VERIFIER_nondet_int();
#line 1542
  ldvarg21 = tmp___2;
#line 1543
  tmp___3 = __VERIFIER_nondet_u32();
#line 1543
  ldvarg24 = tmp___3;
#line 1541
  memset((void *)(& ldvarg20), 0, 8UL);
#line 1545
  tmp___4 = __VERIFIER_nondet_int();
#line 1545
  switch (tmp___4) {
  case 0: ;
#line 1548
  if (ldv_state_variable_6 == 1) {
#line 1550
    cx18_av_s_video_routing(cx18_av_video_ops_group0, ldvarg24, ldvarg23, ldvarg22);
#line 1552
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1555
  goto ldv_51897;
  case 1: ;
#line 1558
  if (ldv_state_variable_6 == 1) {
#line 1560
    cx18_av_s_stream(cx18_av_video_ops_group0, ldvarg21);
#line 1562
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1565
  goto ldv_51897;
  case 2: ;
#line 1568
  if (ldv_state_variable_6 == 1) {
#line 1570
    cx18_av_s_std(cx18_av_video_ops_group0, ldvarg20);
#line 1572
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1575
  goto ldv_51897;
  case 3: ;
#line 1578
  if (ldv_state_variable_6 == 1) {
#line 1580
    cx18_av_s_mbus_fmt(cx18_av_video_ops_group0, ldvarg19);
#line 1582
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1585
  goto ldv_51897;
  default: 
#line 1586
  ldv_stop();
  }
  ldv_51897: ;
#line 1590
  return;
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  u32 ldvarg6 ;
  u32 tmp ;
  u32 ldvarg5 ;
  u32 tmp___0 ;
  u32 ldvarg7 ;
  u32 tmp___1 ;
  u32 ldvarg8 ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 1593
  tmp = __VERIFIER_nondet_u32();
#line 1593
  ldvarg6 = tmp;
#line 1594
  tmp___0 = __VERIFIER_nondet_u32();
#line 1594
  ldvarg5 = tmp___0;
#line 1595
  tmp___1 = __VERIFIER_nondet_u32();
#line 1595
  ldvarg7 = tmp___1;
#line 1596
  tmp___2 = __VERIFIER_nondet_u32();
#line 1596
  ldvarg8 = tmp___2;
#line 1598
  tmp___3 = __VERIFIER_nondet_int();
#line 1598
  switch (tmp___3) {
  case 0: ;
#line 1601
  if (ldv_state_variable_7 == 1) {
#line 1603
    cx18_av_s_audio_routing(cx18_av_audio_ops_group0, ldvarg8, ldvarg7, ldvarg6);
#line 1605
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1608
  goto ldv_51910;
  case 1: ;
#line 1611
  if (ldv_state_variable_7 == 1) {
#line 1613
    cx18_av_s_clock_freq(cx18_av_audio_ops_group0, ldvarg5);
#line 1615
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1618
  goto ldv_51910;
  default: 
#line 1619
  ldv_stop();
  }
  ldv_51910: ;
#line 1623
  return;
}
}
#line 1625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  struct v4l2_ctrl *ldvarg113 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1626
  tmp = ldv_zalloc(144UL);
#line 1626
  ldvarg113 = (struct v4l2_ctrl *)tmp;
#line 1628
  tmp___0 = __VERIFIER_nondet_int();
#line 1628
  switch (tmp___0) {
  case 0: ;
#line 1631
  if (ldv_state_variable_10 == 1) {
#line 1633
    cx18_av_s_ctrl(ldvarg113);
#line 1635
    ldv_state_variable_10 = 1;
  } else {

  }
#line 1638
  goto ldv_51918;
  default: 
#line 1639
  ldv_stop();
  }
  ldv_51918: ;
#line 1643
  return;
}
}
#line 1645 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  struct v4l2_dbg_register *ldvarg28 ;
  void *tmp ;
  struct v4l2_dbg_register *ldvarg26 ;
  void *tmp___0 ;
  u32 ldvarg27 ;
  u32 tmp___1 ;
  int tmp___2 ;

  {
#line 1646
  tmp = ldv_zalloc(56UL);
#line 1646
  ldvarg28 = (struct v4l2_dbg_register *)tmp;
#line 1647
  tmp___0 = ldv_zalloc(56UL);
#line 1647
  ldvarg26 = (struct v4l2_dbg_register *)tmp___0;
#line 1648
  tmp___1 = __VERIFIER_nondet_u32();
#line 1648
  ldvarg27 = tmp___1;
#line 1650
  tmp___2 = __VERIFIER_nondet_int();
#line 1650
  switch (tmp___2) {
  case 0: ;
#line 1653
  if (ldv_state_variable_9 == 1) {
#line 1655
    cx18_av_load_fw(cx18_av_general_ops_group0);
#line 1657
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1660
  goto ldv_51927;
  case 1: ;
#line 1663
  if (ldv_state_variable_9 == 1) {
#line 1665
    cx18_av_s_register(cx18_av_general_ops_group0, (struct v4l2_dbg_register  const  *)ldvarg28);
#line 1667
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1670
  goto ldv_51927;
  case 2: ;
#line 1673
  if (ldv_state_variable_9 == 1) {
#line 1675
    cx18_av_reset(cx18_av_general_ops_group0, ldvarg27);
#line 1677
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1680
  goto ldv_51927;
  case 3: ;
#line 1683
  if (ldv_state_variable_9 == 1) {
#line 1685
    cx18_av_g_register(cx18_av_general_ops_group0, ldvarg26);
#line 1687
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1690
  goto ldv_51927;
  case 4: ;
#line 1693
  if (ldv_state_variable_9 == 1) {
#line 1695
    cx18_av_log_status(cx18_av_general_ops_group0);
#line 1697
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1700
  goto ldv_51927;
  default: 
#line 1701
  ldv_stop();
  }
  ldv_51927: ;
#line 1705
  return;
}
}
#line 1707 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  struct v4l2_vbi_format *ldvarg115 ;
  void *tmp ;
  struct v4l2_decode_vbi_line *ldvarg114 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1708
  tmp = ldv_zalloc(44UL);
#line 1708
  ldvarg115 = (struct v4l2_vbi_format *)tmp;
#line 1709
  tmp___0 = ldv_zalloc(24UL);
#line 1709
  ldvarg114 = (struct v4l2_decode_vbi_line *)tmp___0;
#line 1711
  tmp___1 = __VERIFIER_nondet_int();
#line 1711
  switch (tmp___1) {
  case 0: ;
#line 1714
  if (ldv_state_variable_5 == 1) {
#line 1716
    cx18_av_s_raw_fmt(cx18_av_vbi_ops_group1, ldvarg115);
#line 1718
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1721
  goto ldv_51939;
  case 1: ;
#line 1724
  if (ldv_state_variable_5 == 1) {
#line 1726
    cx18_av_g_sliced_fmt(cx18_av_vbi_ops_group1, cx18_av_vbi_ops_group0);
#line 1728
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1731
  goto ldv_51939;
  case 2: ;
#line 1734
  if (ldv_state_variable_5 == 1) {
#line 1736
    cx18_av_decode_vbi_line(cx18_av_vbi_ops_group1, ldvarg114);
#line 1738
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1741
  goto ldv_51939;
  case 3: ;
#line 1744
  if (ldv_state_variable_5 == 1) {
#line 1746
    cx18_av_s_sliced_fmt(cx18_av_vbi_ops_group1, cx18_av_vbi_ops_group0);
#line 1748
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1751
  goto ldv_51939;
  default: 
#line 1752
  ldv_stop();
  }
  ldv_51939: ;
#line 1756
  return;
}
}
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void *ldv_kmem_cache_alloc_656(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1887
  ldv_check_alloc_flags(flags);
#line 1889
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1890
  return ((void *)0);
}
}
#line 1928 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int ldv_pskb_expand_head_662(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1931
  ldv_check_alloc_flags(flags);
#line 1933
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1933
  return (tmp);
}
}
#line 1944 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_664(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1947
  ldv_check_alloc_flags(flags);
#line 1949
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1949
  return (tmp);
}
}
#line 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv_skb_copy_666(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1963
  ldv_check_alloc_flags(flags);
#line 1965
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1965
  return (tmp);
}
}
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_667(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1971
  ldv_check_alloc_flags(flags);
#line 1973
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1973
  return (tmp);
}
}
#line 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_668(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1979
  ldv_check_alloc_flags(flags);
#line 1981
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1981
  return (tmp);
}
}
#line 1984 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_669(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1987
  ldv_check_alloc_flags(flags);
#line 1989
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1989
  return (tmp);
}
}
#line 1992 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int ldv_pskb_expand_head_670(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1995
  ldv_check_alloc_flags(flags);
#line 1997
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1997
  return (tmp);
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int ldv_pskb_expand_head_671(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2003
  ldv_check_alloc_flags(flags);
#line 2005
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2005
  return (tmp);
}
}
#line 2008 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_672(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2011
  ldv_check_alloc_flags(flags);
#line 2013
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2013
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_698(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_706(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_714(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_708(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_704(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_712(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_713(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_710(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_711(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static int set_audclk_freq(struct cx18 *cx , u32 freq ) 
{ 
  struct cx18_av_state *state ;

  {
#line 125
  state = & cx->av_state;
#line 127
  if ((freq != 32000U && freq != 44100U) && freq != 48000U) {
#line 128
    return (-22);
  } else {

  }
#line 166
  if ((unsigned int )state->aud_input > 1U) {
#line 167
    switch (freq) {
    case 32000U: 
#line 173
    cx18_av_write4(cx, 264, 537723919U);
#line 177
    cx18_av_write4(cx, 268, 2876158U);
#line 181
    cx18_av_write4(cx, 272, 24540172U);
#line 185
    cx18_av_write4(cx, 2304, 134346623U);
#line 186
    cx18_av_write4(cx, 2308, 134346623U);
#line 187
    cx18_av_write4(cx, 2316, 134346623U);
#line 190
    cx18_av_write(cx, 295, 96);
#line 193
    cx18_av_write4(cx, 300, 287322111U);
#line 200
    cx18_av_write4(cx, 296, 2685218552U);
#line 201
    goto ldv_51265;
    case 44100U: 
#line 208
    cx18_av_write4(cx, 264, 403571727U);
#line 212
    cx18_av_write4(cx, 268, 2876158U);
#line 216
    cx18_av_write4(cx, 272, 6463986U);
#line 220
    cx18_av_write4(cx, 2304, 134311257U);
#line 221
    cx18_av_write4(cx, 2308, 134311257U);
#line 222
    cx18_av_write4(cx, 2316, 134311257U);
#line 225
    cx18_av_write(cx, 295, 88);
#line 228
    cx18_av_write4(cx, 300, 287347455U);
#line 235
    cx18_av_write4(cx, 296, 2686274552U);
#line 236
    goto ldv_51265;
    case 48000U: 
#line 243
    cx18_av_write4(cx, 264, 370017295U);
#line 247
    cx18_av_write4(cx, 268, 2876158U);
#line 251
    cx18_av_write4(cx, 272, 5384109U);
#line 255
    cx18_av_write4(cx, 2304, 134303658U);
#line 256
    cx18_av_write4(cx, 2308, 134303658U);
#line 257
    cx18_av_write4(cx, 2316, 134303658U);
#line 260
    cx18_av_write(cx, 295, 86);
#line 263
    cx18_av_write4(cx, 300, 287334399U);
#line 270
    cx18_av_write4(cx, 296, 2685506552U);
#line 271
    goto ldv_51265;
    }
    ldv_51265: ;
  } else {
#line 274
    switch (freq) {
    case 32000U: 
#line 280
    cx18_av_write4(cx, 264, 806159375U);
#line 284
    cx18_av_write4(cx, 268, 2876158U);
#line 288
    cx18_av_write4(cx, 272, 24540172U);
#line 292
    cx18_av_write4(cx, 2296, 134283264U);
#line 296
    cx18_av_write4(cx, 2304, 134348800U);
#line 297
    cx18_av_write4(cx, 2308, 134348800U);
#line 298
    cx18_av_write4(cx, 2316, 134348800U);
#line 301
    cx18_av_write(cx, 295, 112);
#line 304
    cx18_av_write4(cx, 300, 287318015U);
#line 311
    cx18_av_write4(cx, 296, 2685218552U);
#line 312
    goto ldv_51269;
    case 44100U: 
#line 319
    cx18_av_write4(cx, 264, 604898319U);
#line 323
    cx18_av_write4(cx, 268, 2876158U);
#line 327
    cx18_av_write4(cx, 272, 6463986U);
#line 331
    cx18_av_write4(cx, 2296, 134308045U);
#line 335
    cx18_av_write4(cx, 2304, 134312837U);
#line 336
    cx18_av_write4(cx, 2308, 134312837U);
#line 337
    cx18_av_write4(cx, 2316, 134312837U);
#line 340
    cx18_av_write(cx, 295, 100);
#line 343
    cx18_av_write4(cx, 300, 287334911U);
#line 350
    cx18_av_write4(cx, 296, 2686274552U);
#line 351
    goto ldv_51269;
    case 48000U: 
#line 358
    cx18_av_write4(cx, 264, 537723919U);
#line 362
    cx18_av_write4(cx, 268, 2876158U);
#line 366
    cx18_av_write4(cx, 272, 24540172U);
#line 370
    cx18_av_write4(cx, 2296, 134316032U);
#line 374
    cx18_av_write4(cx, 2304, 134305109U);
#line 375
    cx18_av_write4(cx, 2308, 134305109U);
#line 376
    cx18_av_write4(cx, 2316, 134305109U);
#line 379
    cx18_av_write(cx, 295, 96);
#line 382
    cx18_av_write4(cx, 300, 287326207U);
#line 389
    cx18_av_write4(cx, 296, 2685506552U);
#line 390
    goto ldv_51269;
    }
    ldv_51269: ;
  }
#line 394
  state->audclk_freq = freq;
#line 396
  return (0);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void cx18_av_audio_set_path(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  u8 v ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 401
  state = & cx->av_state;
#line 405
  tmp = cx18_av_read(cx, 2051);
#line 405
  v = (unsigned int )tmp & 239U;
#line 406
  cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 409
  tmp___0 = cx18_av_read(cx, 2064);
#line 409
  v = (u8 )((unsigned int )tmp___0 | 1U);
#line 410
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 413
  cx18_av_write(cx, 2259, 31);
#line 415
  if ((unsigned int )state->aud_input <= 1U) {
#line 417
    cx18_av_write4(cx, 2256, 16846866U);
  } else {
#line 424
    cx18_av_write4(cx, 2256, 520501360U);
  }
#line 427
  set_audclk_freq(cx, state->audclk_freq);
#line 430
  tmp___1 = cx18_av_read(cx, 2064);
#line 430
  v = (unsigned int )tmp___1 & 254U;
#line 431
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 433
  if ((unsigned int )state->aud_input > 1U) {
#line 436
    tmp___2 = cx18_av_read(cx, 2051);
#line 436
    v = (u8 )((unsigned int )tmp___2 | 16U);
#line 437
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 439
  return;
}
}
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static void set_volume(struct cx18 *cx , int volume ) 
{ 
  int vol ;

  {
#line 444
  vol = volume >> 9;
#line 448
  if (vol <= 23) {
#line 449
    vol = 0;
  } else {
#line 451
    vol = vol + -23;
  }
#line 454
  cx18_av_write(cx, 2260, (int )((unsigned int )((u8 )(114 - vol)) * 2U));
#line 455
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static void set_bass(struct cx18 *cx , int bass ) 
{ 


  {
#line 460
  cx18_av_and_or(cx, 2265, 4294967232U, (int )(48U - (unsigned int )((u8 )((bass * 48) / 65535))));
#line 461
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static void set_treble(struct cx18 *cx , int treble ) 
{ 


  {
#line 466
  cx18_av_and_or(cx, 2267, 4294967232U, (int )(48U - (unsigned int )((u8 )((treble * 48) / 65535))));
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static void set_balance(struct cx18 *cx , int balance ) 
{ 
  int bal ;

  {
#line 471
  bal = balance >> 8;
#line 472
  if (bal > 128) {
#line 474
    cx18_av_and_or(cx, 2261, 127U, 128);
#line 476
    cx18_av_and_or(cx, 2261, 4294967168U, (int )((u8 )bal) & 127);
  } else {
#line 479
    cx18_av_and_or(cx, 2261, 127U, 0);
#line 481
    cx18_av_and_or(cx, 2261, 4294967168U, (int )(128U - (unsigned int )((u8 )bal)));
  }
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static void set_mute(struct cx18 *cx , int mute ) 
{ 
  struct cx18_av_state *state ;
  u8 v ;

  {
#line 487
  state = & cx->av_state;
#line 490
  if ((unsigned int )state->aud_input > 1U) {
#line 495
    v = cx18_av_read(cx, 2051);
#line 496
    if (mute != 0) {
#line 498
      v = (unsigned int )v & 239U;
#line 499
      cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 500
      cx18_av_write(cx, 2259, 31);
    } else {
#line 503
      v = (u8 )((unsigned int )v | 16U);
#line 504
      cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
    }
  } else {
#line 508
    cx18_av_and_or(cx, 2259, 4294967293U, mute != 0 ? 2 : 0);
  }
#line 509
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
int cx18_av_s_clock_freq(struct v4l2_subdev *sd , u32 freq ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  int retval ;
  u8 v ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;

  {
#line 514
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 514
  cx = (struct cx18 *)tmp;
#line 515
  state = & cx->av_state;
#line 519
  if ((unsigned int )state->aud_input > 1U) {
#line 520
    tmp___0 = cx18_av_read(cx, 2051);
#line 520
    v = (unsigned int )tmp___0 & 239U;
#line 521
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 522
    cx18_av_write(cx, 2259, 31);
  } else {

  }
#line 524
  tmp___1 = cx18_av_read(cx, 2064);
#line 524
  v = (u8 )((unsigned int )tmp___1 | 1U);
#line 525
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 527
  retval = set_audclk_freq(cx, freq);
#line 529
  tmp___2 = cx18_av_read(cx, 2064);
#line 529
  v = (unsigned int )tmp___2 & 254U;
#line 530
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 531
  if ((unsigned int )state->aud_input > 1U) {
#line 532
    tmp___3 = cx18_av_read(cx, 2051);
#line 532
    v = (u8 )((unsigned int )tmp___3 | 16U);
#line 533
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 535
  return (retval);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
static int cx18_av_audio_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;

  {
#line 540
  tmp = to_sd(ctrl);
#line 540
  sd = tmp;
#line 541
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 541
  cx = (struct cx18 *)tmp___0;
#line 543
  switch (ctrl->id) {
  case 9963781U: 
#line 545
  set_volume(cx, ctrl->ldv_36505.val);
#line 546
  goto ldv_51315;
  case 9963783U: 
#line 548
  set_bass(cx, ctrl->ldv_36505.val);
#line 549
  goto ldv_51315;
  case 9963784U: 
#line 551
  set_treble(cx, ctrl->ldv_36505.val);
#line 552
  goto ldv_51315;
  case 9963782U: 
#line 554
  set_balance(cx, ctrl->ldv_36505.val);
#line 555
  goto ldv_51315;
  case 9963785U: 
#line 557
  set_mute(cx, ctrl->ldv_36505.val);
#line 558
  goto ldv_51315;
  default: ;
#line 560
  return (-22);
  }
  ldv_51315: ;
#line 562
  return (0);
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct v4l2_ctrl_ops  const  cx18_av_audio_ctrl_ops  =    {0, 0, & cx18_av_audio_s_ctrl};
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_main_exported_4(void) 
{ 
  struct v4l2_ctrl *ldvarg111 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 571
  tmp = ldv_zalloc(144UL);
#line 571
  ldvarg111 = (struct v4l2_ctrl *)tmp;
#line 573
  tmp___0 = __VERIFIER_nondet_int();
#line 573
  switch (tmp___0) {
  case 0: ;
#line 576
  if (ldv_state_variable_4 == 1) {
#line 578
    cx18_av_audio_s_ctrl(ldvarg111);
#line 580
    ldv_state_variable_4 = 1;
  } else {

  }
#line 583
  goto ldv_51327;
  default: 
#line 584
  ldv_stop();
  }
  ldv_51327: ;
#line 588
  return;
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void *ldv_kmem_cache_alloc_698(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 719
  ldv_check_alloc_flags(flags);
#line 721
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 722
  return ((void *)0);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
int ldv_pskb_expand_head_704(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 763
  ldv_check_alloc_flags(flags);
#line 765
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 765
  return (tmp);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_706(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 779
  ldv_check_alloc_flags(flags);
#line 781
  tmp = skb_clone(ldv_func_arg1, flags);
#line 781
  return (tmp);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv_skb_copy_708(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 795
  ldv_check_alloc_flags(flags);
#line 797
  tmp = skb_copy(ldv_func_arg1, flags);
#line 797
  return (tmp);
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 803
  ldv_check_alloc_flags(flags);
#line 805
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 805
  return (tmp);
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_710(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 811
  ldv_check_alloc_flags(flags);
#line 813
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 813
  return (tmp);
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_711(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 819
  ldv_check_alloc_flags(flags);
#line 821
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 821
  return (tmp);
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
int ldv_pskb_expand_head_712(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 827
  ldv_check_alloc_flags(flags);
#line 829
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 829
  return (tmp);
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
int ldv_pskb_expand_head_713(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 835
  ldv_check_alloc_flags(flags);
#line 837
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 837
  return (tmp);
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_714(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 843
  ldv_check_alloc_flags(flags);
#line 845
  tmp = skb_clone(ldv_func_arg1, flags);
#line 845
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_740(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_748(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_756(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_750(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_746(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_754(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_755(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_752(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_753(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
static int cx18_av_verifyfw(struct cx18 *cx , struct firmware  const  *fw ) 
{ 
  struct v4l2_subdev *sd ;
  int ret ;
  u8 const   *data ;
  u32 size ;
  int addr ;
  u32 expected ;
  u32 dl_control ;

  {
#line 134
  sd = & cx->av_state.sd;
#line 135
  ret = 0;
#line 142
  dl_control = cx18_av_read4(cx, 2048);
  ldv_51443: 
#line 144
  dl_control = dl_control & 16777215U;
#line 145
  dl_control = dl_control | 251658240U;
#line 146
  cx18_av_write4_noretry(cx, 2048, dl_control);
#line 147
  dl_control = cx18_av_read4(cx, 2048);
#line 148
  if ((dl_control & 4278190080U) != 251658240U) {
#line 150
    goto ldv_51443;
  } else {

  }

#line 151
  goto ldv_51446;
  ldv_51445: 
#line 152
  dl_control = cx18_av_read4(cx, 2048);
  ldv_51446: ;
#line 151
  if ((dl_control & 16383U) != 0U) {
#line 153
    goto ldv_51445;
  } else {

  }
#line 154
  data = fw->data;
#line 155
  size = (u32 )fw->size;
#line 156
  addr = 0;
#line 156
  goto ldv_51450;
  ldv_51449: 
#line 157
  dl_control = dl_control & 4294918143U;
#line 158
  expected = (((unsigned int )*(data + (unsigned long )addr) << 16) | (unsigned int )addr) | 251658240U;
#line 159
  if (expected != dl_control) {
#line 160
    printk("\v%s: verification of %s firmware load failed: expected %#010x got %#010x\n",
           (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw", expected, dl_control);
#line 163
    ret = -5;
#line 164
    goto ldv_51448;
  } else {

  }
#line 166
  dl_control = cx18_av_read4(cx, 2048);
#line 156
  addr = addr + 1;
  ldv_51450: ;
#line 156
  if ((u32 )addr < size) {
#line 158
    goto ldv_51449;
  } else {

  }
  ldv_51448: ;
#line 168
  if (ret == 0) {
#line 169
    printk("\016%s: verified load of %s firmware (%d bytes)\n", (char *)(& sd->name),
           (char *)"v4l-cx23418-dig.fw", size);
  } else {

  }
#line 171
  return (ret);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
int cx18_av_loadfw(struct cx18 *cx ) 
{ 
  struct v4l2_subdev *sd ;
  struct firmware  const  *fw ;
  u32 size ;
  u32 u ;
  u32 v ;
  u8 const   *ptr ;
  int i ;
  int retries1 ;
  int tmp ;
  u32 dl_control ;
  u32 value ;
  int retries2 ;
  int unrec_err ;
  int tmp___0 ;

  {
#line 176
  sd = & cx->av_state.sd;
#line 177
  fw = (struct firmware  const  *)0;
#line 182
  retries1 = 0;
#line 184
  tmp = request_firmware(& fw, "v4l-cx23418-dig.fw", & (cx->pci_dev)->dev);
#line 184
  if (tmp != 0) {
#line 185
    printk("\v%s: unable to open firmware %s\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw");
#line 186
    return (-22);
  } else {

  }
#line 191
  goto ldv_51474;
  ldv_51473: 
#line 192
  cx18_av_write4_expect(cx, 256, 65536U, 33840U, 4294967295U);
#line 194
  cx18_av_write_expect(cx, 2056, 246, 246, 255);
#line 197
  cx18_av_write4_expect(cx, 33024, 65536U, 33840U, 4294967295U);
#line 201
  cx18_av_write4_noretry(cx, 2048, 251658240U);
#line 203
  ptr = fw->data;
#line 204
  size = (u32 )fw->size;
#line 206
  i = 0;
#line 206
  goto ldv_51471;
  ldv_51470: 
#line 207
  dl_control = (((unsigned int )*(ptr + (unsigned long )i) << 16) | (unsigned int )i) | 251658240U;
#line 208
  value = 0U;
#line 210
  unrec_err = 0;
#line 212
  retries2 = 0;
#line 212
  goto ldv_51468;
  ldv_51467: 
#line 214
  cx18_av_write4_noretry(cx, 2048, dl_control);
#line 216
  __const_udelay(42950UL);
#line 217
  value = cx18_av_read4(cx, 2048);
#line 218
  if (value == dl_control) {
#line 219
    goto ldv_51466;
  } else {

  }
#line 223
  if (((value ^ dl_control) & 16128U) != 0U) {
#line 224
    unrec_err = 1;
#line 225
    goto ldv_51466;
  } else {

  }
#line 213
  retries2 = retries2 + 1;
  ldv_51468: ;
#line 212
  if (retries2 <= 9) {
#line 214
    goto ldv_51467;
  } else {

  }
  ldv_51466: ;
#line 228
  if (unrec_err != 0 || retries2 > 9) {
#line 229
    goto ldv_51469;
  } else {

  }
#line 206
  i = i + 1;
  ldv_51471: ;
#line 206
  if ((u32 )i < size) {
#line 208
    goto ldv_51470;
  } else {

  }
  ldv_51469: ;
#line 231
  if ((u32 )i == size) {
#line 232
    goto ldv_51472;
  } else {

  }
#line 233
  retries1 = retries1 + 1;
  ldv_51474: ;
#line 191
  if (retries1 <= 4) {
#line 193
    goto ldv_51473;
  } else {

  }
  ldv_51472: ;
#line 235
  if (retries1 > 4) {
#line 236
    printk("\v%s: unable to load firmware %s\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw");
#line 237
    release_firmware(fw);
#line 238
    return (-5);
  } else {

  }
#line 241
  cx18_av_write4_expect(cx, 2048, (u32 )fw->size | 50331648U, 50331648U, 318767104U);
#line 244
  printk("\016%s: loaded %s firmware (%d bytes)\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw",
         size);
#line 246
  tmp___0 = cx18_av_verifyfw(cx, fw);
#line 246
  if (tmp___0 == 0) {
#line 247
    cx18_av_write4_expect(cx, 2048, (u32 )fw->size | 318767104U, 318767104U, 318767104U);
  } else {

  }
#line 251
  cx18_av_and_or4(cx, 276, 4294967295U, 491520U);
#line 258
  cx18_av_write4(cx, 2324, 160U);
#line 267
  cx18_av_write4(cx, 2328, 416U);
#line 271
  cx18_av_write4(cx, 292, 1442887303U);
#line 273
  cx18_av_write4_expect(cx, 2056, 246U, 246U, 1057030143U);
#line 280
  cx18_av_write4(cx, 2508, 1U);
#line 282
  v = cx18_read_reg(cx, 13049876U);
#line 284
  if ((v & 2048U) != 0U) {
#line 285
    cx18_write_reg_expect(cx, v & 4294966271U, 13049876U, 0U, 1024U);
  } else {

  }
#line 289
  v = cx18_read_reg(cx, 13049876U);
#line 290
  u = v & 48U;
#line 291
  v = v & 4294967247U;
#line 292
  if (u == 32U || u == 48U) {
#line 294
    v = v;
#line 295
    cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 298
    v = (v & 4294967247U) | 32U;
  } else {
#line 301
    v = v | 32U;
#line 302
    cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 305
    v = (v & 4294967247U) | u;
  }
#line 307
  cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 311
  v = cx18_av_read4(cx, 2056);
#line 312
  v = v | 255U;
#line 313
  v = v | 1024U;
#line 314
  v = v | 335544320U;
#line 315
  cx18_av_write4_expect(cx, 2056, v, v, 1057030143U);
#line 317
  release_firmware(fw);
#line 318
  return (0);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void *ldv_kmem_cache_alloc_740(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 453
  ldv_check_alloc_flags(flags);
#line 455
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 456
  return ((void *)0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
int ldv_pskb_expand_head_746(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 497
  ldv_check_alloc_flags(flags);
#line 499
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 499
  return (tmp);
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv_skb_clone_748(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 513
  ldv_check_alloc_flags(flags);
#line 515
  tmp = skb_clone(ldv_func_arg1, flags);
#line 515
  return (tmp);
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv_skb_copy_750(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 529
  ldv_check_alloc_flags(flags);
#line 531
  tmp = skb_copy(ldv_func_arg1, flags);
#line 531
  return (tmp);
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 537
  ldv_check_alloc_flags(flags);
#line 539
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 539
  return (tmp);
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_752(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 545
  ldv_check_alloc_flags(flags);
#line 547
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 547
  return (tmp);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_753(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 553
  ldv_check_alloc_flags(flags);
#line 555
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 555
  return (tmp);
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
int ldv_pskb_expand_head_754(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 561
  ldv_check_alloc_flags(flags);
#line 563
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 563
  return (tmp);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
int ldv_pskb_expand_head_755(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 569
  ldv_check_alloc_flags(flags);
#line 571
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 571
  return (tmp);
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
struct sk_buff *ldv_skb_clone_756(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 577
  ldv_check_alloc_flags(flags);
#line 579
  tmp = skb_clone(ldv_func_arg1, flags);
#line 579
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_792(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
static u8 const   sliced_vbi_did[2U]  = {      145U,      85U};
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
static int odd_parity(u8 c ) 
{ 


  {
#line 171
  c = (u8 )(((int )c >> 4) ^ (int )c);
#line 172
  c = (u8 )(((int )c >> 2) ^ (int )c);
#line 173
  c = (u8 )(((int )c >> 1) ^ (int )c);
#line 175
  return ((int )c & 1);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
static int decode_vps(u8 *dst , u8 *p ) 
{ 
  u8 biphase_tbl[256U] ;
  u8 c ;
  u8 err ;
  int i ;

  {
#line 180
  biphase_tbl[0] = 240U;
#line 180
  biphase_tbl[1] = 120U;
#line 180
  biphase_tbl[2] = 112U;
#line 180
  biphase_tbl[3] = 240U;
#line 180
  biphase_tbl[4] = 180U;
#line 180
  biphase_tbl[5] = 60U;
#line 180
  biphase_tbl[6] = 52U;
#line 180
  biphase_tbl[7] = 180U;
#line 180
  biphase_tbl[8] = 176U;
#line 180
  biphase_tbl[9] = 56U;
#line 180
  biphase_tbl[10] = 48U;
#line 180
  biphase_tbl[11] = 176U;
#line 180
  biphase_tbl[12] = 240U;
#line 180
  biphase_tbl[13] = 120U;
#line 180
  biphase_tbl[14] = 112U;
#line 180
  biphase_tbl[15] = 240U;
#line 180
  biphase_tbl[16] = 210U;
#line 180
  biphase_tbl[17] = 90U;
#line 180
  biphase_tbl[18] = 82U;
#line 180
  biphase_tbl[19] = 210U;
#line 180
  biphase_tbl[20] = 150U;
#line 180
  biphase_tbl[21] = 30U;
#line 180
  biphase_tbl[22] = 22U;
#line 180
  biphase_tbl[23] = 150U;
#line 180
  biphase_tbl[24] = 146U;
#line 180
  biphase_tbl[25] = 26U;
#line 180
  biphase_tbl[26] = 18U;
#line 180
  biphase_tbl[27] = 146U;
#line 180
  biphase_tbl[28] = 210U;
#line 180
  biphase_tbl[29] = 90U;
#line 180
  biphase_tbl[30] = 82U;
#line 180
  biphase_tbl[31] = 210U;
#line 180
  biphase_tbl[32] = 208U;
#line 180
  biphase_tbl[33] = 88U;
#line 180
  biphase_tbl[34] = 80U;
#line 180
  biphase_tbl[35] = 208U;
#line 180
  biphase_tbl[36] = 148U;
#line 180
  biphase_tbl[37] = 28U;
#line 180
  biphase_tbl[38] = 20U;
#line 180
  biphase_tbl[39] = 148U;
#line 180
  biphase_tbl[40] = 144U;
#line 180
  biphase_tbl[41] = 24U;
#line 180
  biphase_tbl[42] = 16U;
#line 180
  biphase_tbl[43] = 144U;
#line 180
  biphase_tbl[44] = 208U;
#line 180
  biphase_tbl[45] = 88U;
#line 180
  biphase_tbl[46] = 80U;
#line 180
  biphase_tbl[47] = 208U;
#line 180
  biphase_tbl[48] = 240U;
#line 180
  biphase_tbl[49] = 120U;
#line 180
  biphase_tbl[50] = 112U;
#line 180
  biphase_tbl[51] = 240U;
#line 180
  biphase_tbl[52] = 180U;
#line 180
  biphase_tbl[53] = 60U;
#line 180
  biphase_tbl[54] = 52U;
#line 180
  biphase_tbl[55] = 180U;
#line 180
  biphase_tbl[56] = 176U;
#line 180
  biphase_tbl[57] = 56U;
#line 180
  biphase_tbl[58] = 48U;
#line 180
  biphase_tbl[59] = 176U;
#line 180
  biphase_tbl[60] = 240U;
#line 180
  biphase_tbl[61] = 120U;
#line 180
  biphase_tbl[62] = 112U;
#line 180
  biphase_tbl[63] = 240U;
#line 180
  biphase_tbl[64] = 225U;
#line 180
  biphase_tbl[65] = 105U;
#line 180
  biphase_tbl[66] = 97U;
#line 180
  biphase_tbl[67] = 225U;
#line 180
  biphase_tbl[68] = 165U;
#line 180
  biphase_tbl[69] = 45U;
#line 180
  biphase_tbl[70] = 37U;
#line 180
  biphase_tbl[71] = 165U;
#line 180
  biphase_tbl[72] = 161U;
#line 180
  biphase_tbl[73] = 41U;
#line 180
  biphase_tbl[74] = 33U;
#line 180
  biphase_tbl[75] = 161U;
#line 180
  biphase_tbl[76] = 225U;
#line 180
  biphase_tbl[77] = 105U;
#line 180
  biphase_tbl[78] = 97U;
#line 180
  biphase_tbl[79] = 225U;
#line 180
  biphase_tbl[80] = 195U;
#line 180
  biphase_tbl[81] = 75U;
#line 180
  biphase_tbl[82] = 67U;
#line 180
  biphase_tbl[83] = 195U;
#line 180
  biphase_tbl[84] = 135U;
#line 180
  biphase_tbl[85] = 15U;
#line 180
  biphase_tbl[86] = 7U;
#line 180
  biphase_tbl[87] = 135U;
#line 180
  biphase_tbl[88] = 131U;
#line 180
  biphase_tbl[89] = 11U;
#line 180
  biphase_tbl[90] = 3U;
#line 180
  biphase_tbl[91] = 131U;
#line 180
  biphase_tbl[92] = 195U;
#line 180
  biphase_tbl[93] = 75U;
#line 180
  biphase_tbl[94] = 67U;
#line 180
  biphase_tbl[95] = 195U;
#line 180
  biphase_tbl[96] = 193U;
#line 180
  biphase_tbl[97] = 73U;
#line 180
  biphase_tbl[98] = 65U;
#line 180
  biphase_tbl[99] = 193U;
#line 180
  biphase_tbl[100] = 133U;
#line 180
  biphase_tbl[101] = 13U;
#line 180
  biphase_tbl[102] = 5U;
#line 180
  biphase_tbl[103] = 133U;
#line 180
  biphase_tbl[104] = 129U;
#line 180
  biphase_tbl[105] = 9U;
#line 180
  biphase_tbl[106] = 1U;
#line 180
  biphase_tbl[107] = 129U;
#line 180
  biphase_tbl[108] = 193U;
#line 180
  biphase_tbl[109] = 73U;
#line 180
  biphase_tbl[110] = 65U;
#line 180
  biphase_tbl[111] = 193U;
#line 180
  biphase_tbl[112] = 225U;
#line 180
  biphase_tbl[113] = 105U;
#line 180
  biphase_tbl[114] = 97U;
#line 180
  biphase_tbl[115] = 225U;
#line 180
  biphase_tbl[116] = 165U;
#line 180
  biphase_tbl[117] = 45U;
#line 180
  biphase_tbl[118] = 37U;
#line 180
  biphase_tbl[119] = 165U;
#line 180
  biphase_tbl[120] = 161U;
#line 180
  biphase_tbl[121] = 41U;
#line 180
  biphase_tbl[122] = 33U;
#line 180
  biphase_tbl[123] = 161U;
#line 180
  biphase_tbl[124] = 225U;
#line 180
  biphase_tbl[125] = 105U;
#line 180
  biphase_tbl[126] = 97U;
#line 180
  biphase_tbl[127] = 225U;
#line 180
  biphase_tbl[128] = 224U;
#line 180
  biphase_tbl[129] = 104U;
#line 180
  biphase_tbl[130] = 96U;
#line 180
  biphase_tbl[131] = 224U;
#line 180
  biphase_tbl[132] = 164U;
#line 180
  biphase_tbl[133] = 44U;
#line 180
  biphase_tbl[134] = 36U;
#line 180
  biphase_tbl[135] = 164U;
#line 180
  biphase_tbl[136] = 160U;
#line 180
  biphase_tbl[137] = 40U;
#line 180
  biphase_tbl[138] = 32U;
#line 180
  biphase_tbl[139] = 160U;
#line 180
  biphase_tbl[140] = 224U;
#line 180
  biphase_tbl[141] = 104U;
#line 180
  biphase_tbl[142] = 96U;
#line 180
  biphase_tbl[143] = 224U;
#line 180
  biphase_tbl[144] = 194U;
#line 180
  biphase_tbl[145] = 74U;
#line 180
  biphase_tbl[146] = 66U;
#line 180
  biphase_tbl[147] = 194U;
#line 180
  biphase_tbl[148] = 134U;
#line 180
  biphase_tbl[149] = 14U;
#line 180
  biphase_tbl[150] = 6U;
#line 180
  biphase_tbl[151] = 134U;
#line 180
  biphase_tbl[152] = 130U;
#line 180
  biphase_tbl[153] = 10U;
#line 180
  biphase_tbl[154] = 2U;
#line 180
  biphase_tbl[155] = 130U;
#line 180
  biphase_tbl[156] = 194U;
#line 180
  biphase_tbl[157] = 74U;
#line 180
  biphase_tbl[158] = 66U;
#line 180
  biphase_tbl[159] = 194U;
#line 180
  biphase_tbl[160] = 192U;
#line 180
  biphase_tbl[161] = 72U;
#line 180
  biphase_tbl[162] = 64U;
#line 180
  biphase_tbl[163] = 192U;
#line 180
  biphase_tbl[164] = 132U;
#line 180
  biphase_tbl[165] = 12U;
#line 180
  biphase_tbl[166] = 4U;
#line 180
  biphase_tbl[167] = 132U;
#line 180
  biphase_tbl[168] = 128U;
#line 180
  biphase_tbl[169] = 8U;
#line 180
  biphase_tbl[170] = 0U;
#line 180
  biphase_tbl[171] = 128U;
#line 180
  biphase_tbl[172] = 192U;
#line 180
  biphase_tbl[173] = 72U;
#line 180
  biphase_tbl[174] = 64U;
#line 180
  biphase_tbl[175] = 192U;
#line 180
  biphase_tbl[176] = 224U;
#line 180
  biphase_tbl[177] = 104U;
#line 180
  biphase_tbl[178] = 96U;
#line 180
  biphase_tbl[179] = 224U;
#line 180
  biphase_tbl[180] = 164U;
#line 180
  biphase_tbl[181] = 44U;
#line 180
  biphase_tbl[182] = 36U;
#line 180
  biphase_tbl[183] = 164U;
#line 180
  biphase_tbl[184] = 160U;
#line 180
  biphase_tbl[185] = 40U;
#line 180
  biphase_tbl[186] = 32U;
#line 180
  biphase_tbl[187] = 160U;
#line 180
  biphase_tbl[188] = 224U;
#line 180
  biphase_tbl[189] = 104U;
#line 180
  biphase_tbl[190] = 96U;
#line 180
  biphase_tbl[191] = 224U;
#line 180
  biphase_tbl[192] = 240U;
#line 180
  biphase_tbl[193] = 120U;
#line 180
  biphase_tbl[194] = 112U;
#line 180
  biphase_tbl[195] = 240U;
#line 180
  biphase_tbl[196] = 180U;
#line 180
  biphase_tbl[197] = 60U;
#line 180
  biphase_tbl[198] = 52U;
#line 180
  biphase_tbl[199] = 180U;
#line 180
  biphase_tbl[200] = 176U;
#line 180
  biphase_tbl[201] = 56U;
#line 180
  biphase_tbl[202] = 48U;
#line 180
  biphase_tbl[203] = 176U;
#line 180
  biphase_tbl[204] = 240U;
#line 180
  biphase_tbl[205] = 120U;
#line 180
  biphase_tbl[206] = 112U;
#line 180
  biphase_tbl[207] = 240U;
#line 180
  biphase_tbl[208] = 210U;
#line 180
  biphase_tbl[209] = 90U;
#line 180
  biphase_tbl[210] = 82U;
#line 180
  biphase_tbl[211] = 210U;
#line 180
  biphase_tbl[212] = 150U;
#line 180
  biphase_tbl[213] = 30U;
#line 180
  biphase_tbl[214] = 22U;
#line 180
  biphase_tbl[215] = 150U;
#line 180
  biphase_tbl[216] = 146U;
#line 180
  biphase_tbl[217] = 26U;
#line 180
  biphase_tbl[218] = 18U;
#line 180
  biphase_tbl[219] = 146U;
#line 180
  biphase_tbl[220] = 210U;
#line 180
  biphase_tbl[221] = 90U;
#line 180
  biphase_tbl[222] = 82U;
#line 180
  biphase_tbl[223] = 210U;
#line 180
  biphase_tbl[224] = 208U;
#line 180
  biphase_tbl[225] = 88U;
#line 180
  biphase_tbl[226] = 80U;
#line 180
  biphase_tbl[227] = 208U;
#line 180
  biphase_tbl[228] = 148U;
#line 180
  biphase_tbl[229] = 28U;
#line 180
  biphase_tbl[230] = 20U;
#line 180
  biphase_tbl[231] = 148U;
#line 180
  biphase_tbl[232] = 144U;
#line 180
  biphase_tbl[233] = 24U;
#line 180
  biphase_tbl[234] = 16U;
#line 180
  biphase_tbl[235] = 144U;
#line 180
  biphase_tbl[236] = 208U;
#line 180
  biphase_tbl[237] = 88U;
#line 180
  biphase_tbl[238] = 80U;
#line 180
  biphase_tbl[239] = 208U;
#line 180
  biphase_tbl[240] = 240U;
#line 180
  biphase_tbl[241] = 120U;
#line 180
  biphase_tbl[242] = 112U;
#line 180
  biphase_tbl[243] = 240U;
#line 180
  biphase_tbl[244] = 180U;
#line 180
  biphase_tbl[245] = 60U;
#line 180
  biphase_tbl[246] = 52U;
#line 180
  biphase_tbl[247] = 180U;
#line 180
  biphase_tbl[248] = 176U;
#line 180
  biphase_tbl[249] = 56U;
#line 180
  biphase_tbl[250] = 48U;
#line 180
  biphase_tbl[251] = 176U;
#line 180
  biphase_tbl[252] = 240U;
#line 180
  biphase_tbl[253] = 120U;
#line 180
  biphase_tbl[254] = 112U;
#line 180
  biphase_tbl[255] = 240U;
#line 215
  err = 0U;
#line 218
  i = 0;
#line 218
  goto ldv_51279;
  ldv_51278: 
#line 219
  err = (u8 )(((int )biphase_tbl[(int )*(p + (unsigned long )i)] | (int )biphase_tbl[(int )*(p + ((unsigned long )i + 1UL))]) | (int )err);
#line 220
  c = (u8 )(((int )((signed char )biphase_tbl[(int )*(p + ((unsigned long )i + 1UL))]) & 15) | (int )((signed char )((int )biphase_tbl[(int )*(p + (unsigned long )i)] << 4)));
#line 222
  *(dst + (unsigned long )(i / 2)) = c;
#line 218
  i = i + 2;
  ldv_51279: ;
#line 218
  if (i <= 25) {
#line 220
    goto ldv_51278;
  } else {

  }

#line 225
  return ((int )err & 240);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int cx18_av_g_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  u16 lcr2vbi[16U] ;
  int is_pal ;
  int i ;
  u8 tmp___0 ;
  u8 v ;
  u8 tmp___1 ;
  u8 v___0 ;
  u8 tmp___2 ;

  {
#line 230
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 230
  cx = (struct cx18 *)tmp;
#line 231
  state = & cx->av_state;
#line 232
  lcr2vbi[0] = 0U;
#line 232
  lcr2vbi[1] = 1U;
#line 232
  lcr2vbi[2] = 0U;
#line 232
  lcr2vbi[3] = 0U;
#line 232
  lcr2vbi[4] = 16384U;
#line 232
  lcr2vbi[5] = 0U;
#line 232
  lcr2vbi[6] = 4096U;
#line 232
  lcr2vbi[7] = 0U;
#line 232
  lcr2vbi[8] = 0U;
#line 232
  lcr2vbi[9] = 1024U;
#line 232
  lcr2vbi[10] = 0U;
#line 232
  lcr2vbi[11] = 0U;
#line 232
  lcr2vbi[12] = 0U;
#line 232
  lcr2vbi[13] = 0U;
#line 232
  lcr2vbi[14] = 0U;
#line 232
  lcr2vbi[15] = 0U;
#line 239
  is_pal = (state->std & 63744ULL) == 0ULL;
#line 242
  memset((void *)(& svbi->service_lines), 0, 96UL);
#line 243
  svbi->service_set = 0U;
#line 246
  tmp___0 = cx18_av_read(cx, 1028);
#line 246
  if (((int )tmp___0 & 16) == 0) {
#line 247
    return (0);
  } else {

  }
#line 249
  if (is_pal != 0) {
#line 250
    i = 7;
#line 250
    goto ldv_51292;
    ldv_51291: 
#line 251
    tmp___1 = cx18_av_read(cx, (int )((unsigned int )((u16 )i) + 1053U));
#line 251
    v = tmp___1;
#line 253
    svbi->service_lines[0][i] = lcr2vbi[(int )v >> 4];
#line 254
    svbi->service_lines[1][i] = lcr2vbi[(int )v & 15];
#line 255
    svbi->service_set = (__u16 )((int )svbi->service_set | ((int )svbi->service_lines[0][i] | (int )svbi->service_lines[1][i]));
#line 250
    i = i + 1;
    ldv_51292: ;
#line 250
    if (i <= 23) {
#line 252
      goto ldv_51291;
    } else {

    }

  } else {
#line 259
    i = 10;
#line 259
    goto ldv_51296;
    ldv_51295: 
#line 260
    tmp___2 = cx18_av_read(cx, (int )((unsigned int )((u16 )i) + 1050U));
#line 260
    v___0 = tmp___2;
#line 262
    svbi->service_lines[0][i] = lcr2vbi[(int )v___0 >> 4];
#line 263
    svbi->service_lines[1][i] = lcr2vbi[(int )v___0 & 15];
#line 264
    svbi->service_set = (__u16 )((int )svbi->service_set | ((int )svbi->service_lines[0][i] | (int )svbi->service_lines[1][i]));
#line 259
    i = i + 1;
    ldv_51296: ;
#line 259
    if (i <= 21) {
#line 261
      goto ldv_51295;
    } else {

    }

  }
#line 268
  return (0);
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int cx18_av_s_raw_fmt(struct v4l2_subdev *sd , struct v4l2_vbi_format *fmt ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;

  {
#line 273
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 273
  cx = (struct cx18 *)tmp;
#line 274
  state = & cx->av_state;
#line 277
  cx18_av_std_setup(cx);
#line 280
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 281
  cx18_av_write(cx, 1028, 46);
#line 282
  return (0);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int cx18_av_s_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  int is_pal ;
  int i ;
  int x ;
  u8 lcr[24U] ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 287
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 287
  cx = (struct cx18 *)tmp;
#line 288
  state = & cx->av_state;
#line 289
  is_pal = (state->std & 63744ULL) == 0ULL;
#line 293
  x = 0;
#line 293
  goto ldv_51315;
  ldv_51314: 
#line 294
  lcr[x] = 0U;
#line 293
  x = x + 1;
  ldv_51315: ;
#line 293
  if (x <= 23) {
#line 295
    goto ldv_51314;
  } else {

  }
#line 297
  cx18_av_std_setup(cx);
#line 300
  cx18_av_write(cx, 1028, 50);
#line 301
  cx18_av_write(cx, 1030, 19);
#line 302
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 305
  if (is_pal != 0) {
#line 306
    i = 0;
#line 306
    goto ldv_51318;
    ldv_51317: 
#line 307
    tmp___0 = 0U;
#line 307
    svbi->service_lines[1][i] = tmp___0;
#line 307
    svbi->service_lines[0][i] = tmp___0;
#line 306
    i = i + 1;
    ldv_51318: ;
#line 306
    if (i <= 6) {
#line 308
      goto ldv_51317;
    } else {

    }

  } else {
#line 310
    i = 0;
#line 310
    goto ldv_51321;
    ldv_51320: 
#line 311
    tmp___1 = 0U;
#line 311
    svbi->service_lines[1][i] = tmp___1;
#line 311
    svbi->service_lines[0][i] = tmp___1;
#line 310
    i = i + 1;
    ldv_51321: ;
#line 310
    if (i <= 9) {
#line 312
      goto ldv_51320;
    } else {

    }
#line 314
    i = 22;
#line 314
    goto ldv_51324;
    ldv_51323: 
#line 315
    tmp___2 = 0U;
#line 315
    svbi->service_lines[1][i] = tmp___2;
#line 315
    svbi->service_lines[0][i] = tmp___2;
#line 314
    i = i + 1;
    ldv_51324: ;
#line 314
    if (i <= 23) {
#line 316
      goto ldv_51323;
    } else {

    }

  }
#line 320
  i = 7;
#line 320
  goto ldv_51335;
  ldv_51334: 
#line 321
  x = 0;
#line 321
  goto ldv_51332;
  ldv_51331: ;
#line 322
  switch ((int )svbi->service_lines[1 - x][i]) {
  case 1: 
#line 324
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(1 << x * 4)));
#line 325
  goto ldv_51327;
  case 16384: 
#line 327
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(4 << x * 4)));
#line 328
  goto ldv_51327;
  case 4096: 
#line 330
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(6 << x * 4)));
#line 331
  goto ldv_51327;
  case 1024: 
#line 333
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(9 << x * 4)));
#line 334
  goto ldv_51327;
  }
  ldv_51327: 
#line 321
  x = x + 1;
  ldv_51332: ;
#line 321
  if (x <= 1) {
#line 323
    goto ldv_51331;
  } else {

  }
#line 320
  i = i + 1;
  ldv_51335: ;
#line 320
  if (i <= 23) {
#line 322
    goto ldv_51334;
  } else {

  }

#line 339
  if (is_pal != 0) {
#line 340
    x = 1;
#line 340
    i = 1060;
#line 340
    goto ldv_51338;
    ldv_51337: 
#line 341
    cx18_av_write(cx, (int )((u16 )i), (int )lcr[x + 6]);
#line 340
    i = i + 1;
#line 340
    x = x + 1;
    ldv_51338: ;
#line 340
    if (i <= 1076) {
#line 342
      goto ldv_51337;
    } else {

    }

  } else {
#line 343
    x = 1;
#line 343
    i = 1060;
#line 343
    goto ldv_51341;
    ldv_51340: 
#line 344
    cx18_av_write(cx, (int )((u16 )i), (int )lcr[x + 9]);
#line 343
    i = i + 1;
#line 343
    x = x + 1;
    ldv_51341: ;
#line 343
    if (i <= 1072) {
#line 345
      goto ldv_51340;
    } else {

    }
#line 345
    i = 1073;
#line 345
    goto ldv_51344;
    ldv_51343: 
#line 346
    cx18_av_write(cx, (int )((u16 )i), 0);
#line 345
    i = i + 1;
    ldv_51344: ;
#line 345
    if (i <= 1076) {
#line 347
      goto ldv_51343;
    } else {

    }

  }
#line 349
  cx18_av_write(cx, 1084, 22);
#line 351
  cx18_av_write(cx, 1140, is_pal != 0 ? 38 : 26);
#line 352
  return (0);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int cx18_av_decode_vbi_line(struct v4l2_subdev *sd , struct v4l2_decode_vbi_line *vbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  struct vbi_anc_data *anc ;
  u8 *p ;
  int did ;
  int sdid ;
  int l ;
  int err ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 358
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 358
  cx = (struct cx18 *)tmp;
#line 359
  state = & cx->av_state;
#line 360
  anc = (struct vbi_anc_data *)vbi->p;
#line 362
  err = 0;
#line 367
  if ((((unsigned int )anc->preamble[0] != 0U || (unsigned int )anc->preamble[1] != 255U) || (unsigned int )anc->preamble[2] != 255U) || ((int )anc->did != (int )((unsigned char )sliced_vbi_did[0]) && (int )anc->did != (int )((unsigned char )sliced_vbi_did[1]))) {
#line 371
    tmp___0 = 0U;
#line 371
    vbi->type = tmp___0;
#line 371
    vbi->line = tmp___0;
#line 372
    return (0);
  } else {

  }
#line 375
  did = (int )anc->did;
#line 376
  sdid = (int )anc->sdid & 15;
#line 377
  l = (int )anc->idid[0] & 63;
#line 378
  l = state->slicer_line_offset + l;
#line 379
  p = (u8 *)(& anc->payload);
#line 382
  switch (sdid) {
  case 1: 
#line 384
  sdid = 1;
#line 385
  goto ldv_51359;
  case 4: 
#line 387
  sdid = 16384;
#line 388
  goto ldv_51359;
  case 6: 
#line 390
  sdid = 4096;
#line 391
  tmp___1 = odd_parity((int )*p);
#line 391
  if (tmp___1 == 0) {
#line 391
    tmp___3 = 1;
  } else {
#line 391
    tmp___2 = odd_parity((int )*(p + 1UL));
#line 391
    if (tmp___2 == 0) {
#line 391
      tmp___3 = 1;
    } else {
#line 391
      tmp___3 = 0;
    }
  }
#line 391
  err = tmp___3;
#line 392
  goto ldv_51359;
  case 9: 
#line 394
  sdid = 1024;
#line 395
  tmp___4 = decode_vps(p, p);
#line 395
  if (tmp___4 != 0) {
#line 396
    err = 1;
  } else {

  }
#line 397
  goto ldv_51359;
  default: 
#line 399
  sdid = 0;
#line 400
  err = 1;
#line 401
  goto ldv_51359;
  }
  ldv_51359: 
#line 404
  vbi->type = err == 0 ? (u32 )sdid : 0U;
#line 405
  vbi->line = err == 0 ? (u32 )l : 0U;
#line 406
  vbi->is_second_field = (u32 )(err == 0 && (int )sliced_vbi_did[1] == did);
#line 407
  vbi->p = p;
#line 408
  return (0);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 541
  ldv_check_alloc_flags(flags);
#line 543
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 544
  return ((void *)0);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 585
  ldv_check_alloc_flags(flags);
#line 587
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 587
  return (tmp);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 601
  ldv_check_alloc_flags(flags);
#line 603
  tmp = skb_clone(ldv_func_arg1, flags);
#line 603
  return (tmp);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv_skb_copy_792(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 617
  ldv_check_alloc_flags(flags);
#line 619
  tmp = skb_copy(ldv_func_arg1, flags);
#line 619
  return (tmp);
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 625
  ldv_check_alloc_flags(flags);
#line 627
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 627
  return (tmp);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 633
  ldv_check_alloc_flags(flags);
#line 635
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 635
  return (tmp);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 641
  ldv_check_alloc_flags(flags);
#line 643
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 643
  return (tmp);
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 649
  ldv_check_alloc_flags(flags);
#line 651
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 651
  return (tmp);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 657
  ldv_check_alloc_flags(flags);
#line 659
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 659
  return (tmp);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 665
  ldv_check_alloc_flags(flags);
#line 667
  tmp = skb_clone(ldv_func_arg1, flags);
#line 667
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_824(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_832(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_840(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_834(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_830(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_838(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_839(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_835(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_836(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_837(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
void cx18_memset_io(struct cx18 *cx , void *addr , int val , size_t count ) ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void cx18_init_scb(struct cx18 *cx ) 
{ 


  {
#line 125
  cx18_setup_page(cx, 14417920U);
#line 126
  cx18_memset_io(cx, (void *)cx->scb, 0, 65536UL);
#line 128
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->apu2cpu_irq));
#line 129
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->cpu2apu_irq_ack));
#line 130
  cx18_writel(cx, 2U, (void *)(& (cx->scb)->hpu2cpu_irq));
#line 131
  cx18_writel(cx, 2U, (void *)(& (cx->scb)->cpu2hpu_irq_ack));
#line 132
  cx18_writel(cx, 4U, (void *)(& (cx->scb)->ppu2cpu_irq));
#line 133
  cx18_writel(cx, 4U, (void *)(& (cx->scb)->cpu2ppu_irq_ack));
#line 134
  cx18_writel(cx, 8U, (void *)(& (cx->scb)->epu2cpu_irq));
#line 135
  cx18_writel(cx, 8U, (void *)(& (cx->scb)->cpu2epu_irq_ack));
#line 137
  cx18_writel(cx, 16U, (void *)(& (cx->scb)->cpu2apu_irq));
#line 138
  cx18_writel(cx, 16U, (void *)(& (cx->scb)->apu2cpu_irq_ack));
#line 139
  cx18_writel(cx, 32U, (void *)(& (cx->scb)->hpu2apu_irq));
#line 140
  cx18_writel(cx, 32U, (void *)(& (cx->scb)->apu2hpu_irq_ack));
#line 141
  cx18_writel(cx, 64U, (void *)(& (cx->scb)->ppu2apu_irq));
#line 142
  cx18_writel(cx, 64U, (void *)(& (cx->scb)->apu2ppu_irq_ack));
#line 143
  cx18_writel(cx, 128U, (void *)(& (cx->scb)->epu2apu_irq));
#line 144
  cx18_writel(cx, 128U, (void *)(& (cx->scb)->apu2epu_irq_ack));
#line 146
  cx18_writel(cx, 256U, (void *)(& (cx->scb)->cpu2hpu_irq));
#line 147
  cx18_writel(cx, 256U, (void *)(& (cx->scb)->hpu2cpu_irq_ack));
#line 148
  cx18_writel(cx, 512U, (void *)(& (cx->scb)->apu2hpu_irq));
#line 149
  cx18_writel(cx, 512U, (void *)(& (cx->scb)->hpu2apu_irq_ack));
#line 150
  cx18_writel(cx, 1024U, (void *)(& (cx->scb)->ppu2hpu_irq));
#line 151
  cx18_writel(cx, 1024U, (void *)(& (cx->scb)->hpu2ppu_irq_ack));
#line 152
  cx18_writel(cx, 2048U, (void *)(& (cx->scb)->epu2hpu_irq));
#line 153
  cx18_writel(cx, 2048U, (void *)(& (cx->scb)->hpu2epu_irq_ack));
#line 155
  cx18_writel(cx, 4096U, (void *)(& (cx->scb)->cpu2ppu_irq));
#line 156
  cx18_writel(cx, 4096U, (void *)(& (cx->scb)->ppu2cpu_irq_ack));
#line 157
  cx18_writel(cx, 8192U, (void *)(& (cx->scb)->apu2ppu_irq));
#line 158
  cx18_writel(cx, 8192U, (void *)(& (cx->scb)->ppu2apu_irq_ack));
#line 159
  cx18_writel(cx, 16384U, (void *)(& (cx->scb)->hpu2ppu_irq));
#line 160
  cx18_writel(cx, 16384U, (void *)(& (cx->scb)->ppu2hpu_irq_ack));
#line 161
  cx18_writel(cx, 32768U, (void *)(& (cx->scb)->epu2ppu_irq));
#line 162
  cx18_writel(cx, 32768U, (void *)(& (cx->scb)->ppu2epu_irq_ack));
#line 164
  cx18_writel(cx, 65536U, (void *)(& (cx->scb)->cpu2epu_irq));
#line 165
  cx18_writel(cx, 65536U, (void *)(& (cx->scb)->epu2cpu_irq_ack));
#line 166
  cx18_writel(cx, 131072U, (void *)(& (cx->scb)->apu2epu_irq));
#line 167
  cx18_writel(cx, 131072U, (void *)(& (cx->scb)->epu2apu_irq_ack));
#line 168
  cx18_writel(cx, 262144U, (void *)(& (cx->scb)->hpu2epu_irq));
#line 169
  cx18_writel(cx, 262144U, (void *)(& (cx->scb)->epu2hpu_irq_ack));
#line 170
  cx18_writel(cx, 524288U, (void *)(& (cx->scb)->ppu2epu_irq));
#line 171
  cx18_writel(cx, 524288U, (void *)(& (cx->scb)->epu2ppu_irq_ack));
#line 173
  cx18_writel(cx, 14419776U, (void *)(& (cx->scb)->apu2cpu_mb_offset));
#line 175
  cx18_writel(cx, 14419840U, (void *)(& (cx->scb)->hpu2cpu_mb_offset));
#line 177
  cx18_writel(cx, 14419904U, (void *)(& (cx->scb)->ppu2cpu_mb_offset));
#line 179
  cx18_writel(cx, 14419968U, (void *)(& (cx->scb)->epu2cpu_mb_offset));
#line 181
  cx18_writel(cx, 14420032U, (void *)(& (cx->scb)->cpu2apu_mb_offset));
#line 183
  cx18_writel(cx, 14420096U, (void *)(& (cx->scb)->hpu2apu_mb_offset));
#line 185
  cx18_writel(cx, 14420160U, (void *)(& (cx->scb)->ppu2apu_mb_offset));
#line 187
  cx18_writel(cx, 14420224U, (void *)(& (cx->scb)->epu2apu_mb_offset));
#line 189
  cx18_writel(cx, 14420288U, (void *)(& (cx->scb)->cpu2hpu_mb_offset));
#line 191
  cx18_writel(cx, 14420352U, (void *)(& (cx->scb)->apu2hpu_mb_offset));
#line 193
  cx18_writel(cx, 14420416U, (void *)(& (cx->scb)->ppu2hpu_mb_offset));
#line 195
  cx18_writel(cx, 14420480U, (void *)(& (cx->scb)->epu2hpu_mb_offset));
#line 197
  cx18_writel(cx, 14420544U, (void *)(& (cx->scb)->cpu2ppu_mb_offset));
#line 199
  cx18_writel(cx, 14420608U, (void *)(& (cx->scb)->apu2ppu_mb_offset));
#line 201
  cx18_writel(cx, 14420672U, (void *)(& (cx->scb)->hpu2ppu_mb_offset));
#line 203
  cx18_writel(cx, 14420736U, (void *)(& (cx->scb)->epu2ppu_mb_offset));
#line 205
  cx18_writel(cx, 14420800U, (void *)(& (cx->scb)->cpu2epu_mb_offset));
#line 207
  cx18_writel(cx, 14420864U, (void *)(& (cx->scb)->apu2epu_mb_offset));
#line 209
  cx18_writel(cx, 14420928U, (void *)(& (cx->scb)->hpu2epu_mb_offset));
#line 211
  cx18_writel(cx, 14420992U, (void *)(& (cx->scb)->ppu2epu_mb_offset));
#line 214
  cx18_writel(cx, 14418016U, (void *)(& (cx->scb)->ipc_offset));
#line 217
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->epu_state));
#line 218
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void *ldv_kmem_cache_alloc_824(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 350
  ldv_check_alloc_flags(flags);
#line 352
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 353
  return ((void *)0);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
int ldv_pskb_expand_head_830(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 394
  ldv_check_alloc_flags(flags);
#line 396
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 396
  return (tmp);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv_skb_clone_832(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 410
  ldv_check_alloc_flags(flags);
#line 412
  tmp = skb_clone(ldv_func_arg1, flags);
#line 412
  return (tmp);
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv_skb_copy_834(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 426
  ldv_check_alloc_flags(flags);
#line 428
  tmp = skb_copy(ldv_func_arg1, flags);
#line 428
  return (tmp);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_835(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 434
  ldv_check_alloc_flags(flags);
#line 436
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 436
  return (tmp);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_836(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 442
  ldv_check_alloc_flags(flags);
#line 444
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 444
  return (tmp);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_837(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 450
  ldv_check_alloc_flags(flags);
#line 452
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 452
  return (tmp);
}
}
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
int ldv_pskb_expand_head_838(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 460
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 460
  return (tmp);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
int ldv_pskb_expand_head_839(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 466
  ldv_check_alloc_flags(flags);
#line 468
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 468
  return (tmp);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
struct sk_buff *ldv_skb_clone_840(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 474
  ldv_check_alloc_flags(flags);
#line 476
  tmp = skb_clone(ldv_func_arg1, flags);
#line 476
  return (tmp);
}
}
#line 195 "include/linux/module.h"
extern void *__symbol_get(char const   * ) ;
#line 455
extern void __symbol_put(char const   * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_866(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 99 "drivers/media/dvb-core/dvbdev.h"
extern int dvb_register_adapter(struct dvb_adapter * , char const   * , struct module * ,
                                struct device * , short * ) ;
#line 102
extern int dvb_unregister_adapter(struct dvb_adapter * ) ;
#line 116 "drivers/media/dvb-core/dmxdev.h"
extern int dvb_dmxdev_init(struct dmxdev * , struct dvb_adapter * ) ;
#line 117
extern void dvb_dmxdev_release(struct dmxdev * ) ;
#line 141 "drivers/media/dvb-core/dvb_demux.h"
extern int dvb_dmx_init(struct dvb_demux * ) ;
#line 142
extern void dvb_dmx_release(struct dvb_demux * ) ;
#line 423 "drivers/media/dvb-core/dvb_frontend.h"
extern int dvb_register_frontend(struct dvb_adapter * , struct dvb_frontend * ) ;
#line 426
extern int dvb_unregister_frontend(struct dvb_frontend * ) ;
#line 428
extern void dvb_frontend_detach(struct dvb_frontend * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_874(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_882(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_876(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_872(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_880(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_881(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_877(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_878(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_879(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 46 "drivers/media/dvb-core/dvb_net.h"
extern void dvb_net_release(struct dvb_net * ) ;
#line 47
extern int dvb_net_init(struct dvb_adapter * , struct dvb_net * , struct dmx_demux * ) ;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___7(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_51298;
  ldv_51297: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_51296;
  } else {

  }
#line 74
  i = i + 1;
  ldv_51298: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_51297;
  } else {

  }
  ldv_51296: ;
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect___7(struct cx18 *cx , u32 val , void *addr ,
                                            u32 eval , u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_51311;
  ldv_51310: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_51308;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_51309;
  } else {

  }
  ldv_51308: 
#line 88
  i = i + 1;
  ldv_51311: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_51310;
  } else {

  }
  ldv_51309: ;
#line 95
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg___3(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 158
  cx18_writel___7(cx, val, cx->reg_mem + (unsigned long )reg);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect___7(struct cx18 *cx , u32 val , u32 reg ,
                                               u32 eval , u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect___7(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 66 "drivers/media/dvb-frontends/mt352.h"
__inline static int mt352_write(struct dvb_frontend *fe , u8 const   *buf , int len ) 
{ 
  int r ;

  {
#line 67
  r = 0;
#line 68
  if ((unsigned long )fe->ops.write != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                 u8 const   * , int  ))0)) {
#line 69
    r = (*(fe->ops.write))(fe, buf, len);
  } else {

  }
#line 70
  return (r);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static short adapter_nr[8U]  = 
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct mxl5005s_config hauppauge_hvr1600_tuner  = 
#line 150
     {99U, 5380000U, 16000000U, 1U, 3U, 1U, 1U, 1U, 0U, 200U, 252U, 1U, 0U, 2U, 0U};
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct s5h1409_config hauppauge_hvr1600_config  = 
#line 168
     {25U, 1U, 1U, 44000U, 0U, 1U, 1U, 1U};
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct s5h1411_config hcw_s5h1411_config  =    {1U, 0U, 1U, 4000U, 44000U, 1U, 1U};
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct tda18271_std_map hauppauge_tda18271_std_map  = 
#line 192
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {5380U, 3U, 3U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {4000U, 3U, 0U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct tda18271_config hauppauge_tda18271_config  = 
#line 199
     {& hauppauge_tda18271_std_map, 0, 2, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct zl10353_config leadtek_dvr3100h_demod  = 
#line 209
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static int yuan_mpc718_mt352_reqfw(struct cx18_stream *stream , struct firmware  const  **fw ) 
{ 
  struct cx18 *cx ;
  char const   *fn ;
  int ret ;
  size_t sz ;

  {
#line 235
  cx = stream->cx;
#line 236
  fn = "dvb-cx18-mpc718-mt352.fw";
#line 239
  ret = request_firmware(fw, fn, & (cx->pci_dev)->dev);
#line 240
  if (ret != 0) {
#line 241
    printk("\v%s: Unable to open firmware file %s\n", (char *)(& cx->v4l2_dev.name),
           fn);
  } else {
#line 243
    sz = (*fw)->size;
#line 244
    if ((sz <= 1UL || sz > 64UL) || (int )sz & 1) {
#line 245
      printk("\v%s: Firmware %s has a bad size: %lu bytes\n", (char *)(& cx->v4l2_dev.name),
             fn, sz);
#line 247
      ret = -84;
#line 248
      release_firmware(*fw);
#line 249
      *fw = (struct firmware  const  *)0;
    } else {

    }
  }
#line 253
  if (ret != 0) {
#line 254
    printk("\v%s: The MPC718 board variant with the MT352 DVB-Tdemodualtor will not work without it\n",
           (char *)(& cx->v4l2_dev.name));
#line 256
    printk("\v%s: Run \'linux/Documentation/dvb/get_dvb_firmware mpc718\' if you need the firmware\n",
           (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 259
  return (ret);
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static int yuan_mpc718_mt352_init(struct dvb_frontend *fe ) 
{ 
  struct cx18_dvb *dvb ;
  struct dvb_adapter  const  *__mptr ;
  struct cx18_stream *stream ;
  struct firmware  const  *fw ;
  int ret ;
  int i ;
  u8 buf[3U] ;

  {
#line 264
  __mptr = (struct dvb_adapter  const  *)fe->dvb;
#line 264
  dvb = (struct cx18_dvb *)__mptr + 0xfffffffffffffdd8UL;
#line 266
  stream = dvb->stream;
#line 267
  fw = (struct firmware  const  *)0;
#line 272
  ret = yuan_mpc718_mt352_reqfw(stream, & fw);
#line 273
  if (ret != 0) {
#line 274
    return (ret);
  } else {

  }
#line 277
  i = 0;
#line 277
  goto ldv_51895;
  ldv_51894: 
#line 278
  buf[0] = *(fw->data + (unsigned long )i);
#line 280
  switch ((int )buf[0]) {
  case 85: ;
#line 283
  goto ldv_51889;
  case 84: 
#line 288
  buf[1] = 114U;
#line 289
  buf[2] = 73U;
#line 290
  mt352_write(fe, (u8 const   *)(& buf), 3);
#line 291
  goto ldv_51889;
  case 87: ;
#line 294
  goto ldv_51889;
  case 86: 
#line 297
  buf[1] = 49U;
#line 298
  buf[2] = 192U;
#line 299
  mt352_write(fe, (u8 const   *)(& buf), 3);
#line 300
  goto ldv_51889;
  default: 
#line 303
  buf[1] = *(fw->data + ((unsigned long )i + 1UL));
#line 304
  mt352_write(fe, (u8 const   *)(& buf), 2);
#line 305
  goto ldv_51889;
  }
  ldv_51889: 
#line 277
  i = i + 2;
  ldv_51895: ;
#line 277
  if ((unsigned long )i < (unsigned long )fw->size) {
#line 279
    goto ldv_51894;
  } else {

  }
#line 309
  buf[0] = 93U;
#line 310
  buf[1] = 1U;
#line 311
  mt352_write(fe, (u8 const   *)(& buf), 2);
#line 312
  release_firmware(fw);
#line 313
  return (0);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct mt352_config yuan_mpc718_mt352_demod  =    {15U, 20480, 4560, 1, & yuan_mpc718_mt352_init};
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct zl10353_config yuan_mpc718_zl10353_demod  = 
#line 324
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static struct zl10353_config gotview_dvd3_zl10353_demod  = 
#line 332
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 340
static int dvb_register(struct cx18_stream *stream ) ;
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static int cx18_dvb_start_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct cx18_stream *stream ;
  struct cx18 *cx ;
  int ret ;
  u32 v ;
  int tmp ;

  {
#line 348
  demux = feed->demux;
#line 349
  stream = (struct cx18_stream *)demux->priv;
#line 354
  if ((unsigned long )stream == (unsigned long )((struct cx18_stream *)0)) {
#line 355
    return (-22);
  } else {

  }
#line 357
  cx = stream->cx;
#line 358
  if ((cx18_debug & 2) != 0) {
#line 358
    printk("\016%s:  info: Start feed: pid = 0x%x index = %d\n", (char *)(& cx->v4l2_dev.name),
           (int )feed->pid, feed->index);
  } else {

  }
#line 361
  mutex_lock_nested(& cx->serialize_lock, 0U);
#line 362
  ret = cx18_init_on_first_open(cx);
#line 363
  mutex_unlock(& cx->serialize_lock);
#line 364
  if (ret != 0) {
#line 365
    printk("\v%s: Failed to initialize firmware starting DVB feed\n", (char *)(& cx->v4l2_dev.name));
#line 366
    return (ret);
  } else {

  }
#line 368
  ret = -22;
#line 370
  switch ((cx->card)->type) {
  case 0: ;
  case 1: ;
  case 9: 
#line 374
  v = cx18_read_reg(cx, 14000128U);
#line 375
  v = v | 4194304U;
#line 376
  v = v | 8192U;
#line 377
  v = v | 65536U;
#line 378
  v = v | 131072U;
#line 379
  v = v | 786432U;
#line 380
  cx18_write_reg___3(cx, v, 14000128U);
#line 381
  goto ldv_51913;
  case 7: ;
  case 3: ;
  case 8: ;
  default: ;
#line 390
  goto ldv_51913;
  }
  ldv_51913: ;
#line 393
  if ((unsigned long )demux->dmx.frontend == (unsigned long )((struct dmx_frontend *)0)) {
#line 394
    return (-22);
  } else {

  }
#line 396
  mutex_lock_nested(& (stream->dvb)->feedlock, 0U);
#line 397
  tmp = (stream->dvb)->feeding;
#line 397
  (stream->dvb)->feeding = (stream->dvb)->feeding + 1;
#line 397
  if (tmp == 0) {
#line 398
    if ((cx18_debug & 2) != 0) {
#line 398
      printk("\016%s:  info: Starting Transport DMA\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 399
    mutex_lock_nested(& cx->serialize_lock, 0U);
#line 400
    set_bit(4L, (unsigned long volatile   *)(& stream->s_flags));
#line 401
    ret = cx18_start_v4l2_encode_stream(stream);
#line 402
    if (ret < 0) {
#line 403
      if ((cx18_debug & 2) != 0) {
#line 403
        printk("\016%s:  info: Failed to start Transport DMA\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 404
      (stream->dvb)->feeding = (stream->dvb)->feeding - 1;
#line 405
      if ((stream->dvb)->feeding == 0) {
#line 406
        clear_bit(4L, (unsigned long volatile   *)(& stream->s_flags));
      } else {

      }
    } else {

    }
#line 408
    mutex_unlock(& cx->serialize_lock);
  } else {
#line 410
    ret = 0;
  }
#line 411
  mutex_unlock(& (stream->dvb)->feedlock);
#line 413
  return (ret);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static int cx18_dvb_stop_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct cx18_stream *stream ;
  struct cx18 *cx ;
  int ret ;

  {
#line 419
  demux = feed->demux;
#line 420
  stream = (struct cx18_stream *)demux->priv;
#line 422
  ret = -22;
#line 424
  if ((unsigned long )stream != (unsigned long )((struct cx18_stream *)0)) {
#line 425
    cx = stream->cx;
#line 426
    if ((cx18_debug & 2) != 0) {
#line 426
      printk("\016%s:  info: Stop feed: pid = 0x%x index = %d\n", (char *)(& cx->v4l2_dev.name),
             (int )feed->pid, feed->index);
    } else {

    }
#line 429
    mutex_lock_nested(& (stream->dvb)->feedlock, 0U);
#line 430
    (stream->dvb)->feeding = (stream->dvb)->feeding - 1;
#line 430
    if ((stream->dvb)->feeding == 0) {
#line 431
      if ((cx18_debug & 2) != 0) {
#line 431
        printk("\016%s:  info: Stopping Transport DMA\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 432
      mutex_lock_nested(& cx->serialize_lock, 0U);
#line 433
      ret = cx18_stop_v4l2_encode_stream(stream, 0);
#line 434
      mutex_unlock(& cx->serialize_lock);
    } else {
#line 436
      ret = 0;
    }
#line 437
    mutex_unlock(& (stream->dvb)->feedlock);
  } else {

  }
#line 440
  return (ret);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
int cx18_dvb_register(struct cx18_stream *stream ) 
{ 
  struct cx18 *cx ;
  struct cx18_dvb *dvb ;
  struct dvb_adapter *dvb_adapter ;
  struct dvb_demux *dvbdemux ;
  struct dmx_demux *dmx ;
  int ret ;
  struct lock_class_key __key ;

  {
#line 445
  cx = stream->cx;
#line 446
  dvb = stream->dvb;
#line 452
  if ((unsigned long )dvb == (unsigned long )((struct cx18_dvb *)0)) {
#line 453
    return (-22);
  } else {

  }
#line 455
  dvb->enabled = 0;
#line 456
  dvb->stream = stream;
#line 458
  ret = dvb_register_adapter(& dvb->dvb_adapter, "cx18", & __this_module, & (cx->pci_dev)->dev,
                             (short *)(& adapter_nr));
#line 461
  if (ret < 0) {
#line 462
    goto err_out;
  } else {

  }
#line 464
  dvb_adapter = & dvb->dvb_adapter;
#line 466
  dvbdemux = & dvb->demux;
#line 468
  dvbdemux->priv = (void *)stream;
#line 470
  dvbdemux->filternum = 256;
#line 471
  dvbdemux->feednum = 256;
#line 472
  dvbdemux->start_feed = & cx18_dvb_start_feed;
#line 473
  dvbdemux->stop_feed = & cx18_dvb_stop_feed;
#line 474
  dvbdemux->dmx.capabilities = 13U;
#line 476
  ret = dvb_dmx_init(dvbdemux);
#line 477
  if (ret < 0) {
#line 478
    goto err_dvb_unregister_adapter;
  } else {

  }
#line 480
  dmx = & dvbdemux->dmx;
#line 482
  dvb->hw_frontend.source = 1;
#line 483
  dvb->mem_frontend.source = 0;
#line 484
  dvb->dmxdev.filternum = 256;
#line 485
  dvb->dmxdev.demux = dmx;
#line 487
  ret = dvb_dmxdev_init(& dvb->dmxdev, dvb_adapter);
#line 488
  if (ret < 0) {
#line 489
    goto err_dvb_dmx_release;
  } else {

  }
#line 491
  ret = (*(dmx->add_frontend))(dmx, & dvb->hw_frontend);
#line 492
  if (ret < 0) {
#line 493
    goto err_dvb_dmxdev_release;
  } else {

  }
#line 495
  ret = (*(dmx->add_frontend))(dmx, & dvb->mem_frontend);
#line 496
  if (ret < 0) {
#line 497
    goto err_remove_hw_frontend;
  } else {

  }
#line 499
  ret = (*(dmx->connect_frontend))(dmx, & dvb->hw_frontend);
#line 500
  if (ret < 0) {
#line 501
    goto err_remove_mem_frontend;
  } else {

  }
#line 503
  ret = dvb_register(stream);
#line 504
  if (ret < 0) {
#line 505
    goto err_disconnect_frontend;
  } else {

  }
#line 507
  dvb_net_init(dvb_adapter, & dvb->dvbnet, dmx);
#line 509
  printk("\016%s: DVB Frontend registered\n", (char *)(& cx->v4l2_dev.name));
#line 510
  printk("\016%s: Registered DVB adapter%d for %s (%d x %d.%02d kB)\n", (char *)(& cx->v4l2_dev.name),
         (stream->dvb)->dvb_adapter.num, stream->name, stream->buffers, stream->buf_size / 1024U,
         ((stream->buf_size * 100U) / 1024U) % 100U);
#line 515
  __mutex_init(& dvb->feedlock, "&dvb->feedlock", & __key);
#line 516
  dvb->enabled = 1;
#line 517
  return (ret);
  err_disconnect_frontend: 
#line 520
  (*(dmx->disconnect_frontend))(dmx);
  err_remove_mem_frontend: 
#line 522
  (*(dmx->remove_frontend))(dmx, & dvb->mem_frontend);
  err_remove_hw_frontend: 
#line 524
  (*(dmx->remove_frontend))(dmx, & dvb->hw_frontend);
  err_dvb_dmxdev_release: 
#line 526
  dvb_dmxdev_release(& dvb->dmxdev);
  err_dvb_dmx_release: 
#line 528
  dvb_dmx_release(dvbdemux);
  err_dvb_unregister_adapter: 
#line 530
  dvb_unregister_adapter(dvb_adapter);
  err_out: ;
#line 532
  return (ret);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void cx18_dvb_unregister(struct cx18_stream *stream ) 
{ 
  struct cx18 *cx ;
  struct cx18_dvb *dvb ;
  struct dvb_adapter *dvb_adapter ;
  struct dvb_demux *dvbdemux ;
  struct dmx_demux *dmx ;

  {
#line 537
  cx = stream->cx;
#line 538
  dvb = stream->dvb;
#line 543
  printk("\016%s: unregister DVB\n", (char *)(& cx->v4l2_dev.name));
#line 545
  if ((unsigned long )dvb == (unsigned long )((struct cx18_dvb *)0) || dvb->enabled == 0) {
#line 546
    return;
  } else {

  }
#line 548
  dvb_adapter = & dvb->dvb_adapter;
#line 549
  dvbdemux = & dvb->demux;
#line 550
  dmx = & dvbdemux->dmx;
#line 552
  (*(dmx->close))(dmx);
#line 553
  dvb_net_release(& dvb->dvbnet);
#line 554
  (*(dmx->remove_frontend))(dmx, & dvb->mem_frontend);
#line 555
  (*(dmx->remove_frontend))(dmx, & dvb->hw_frontend);
#line 556
  dvb_dmxdev_release(& dvb->dmxdev);
#line 557
  dvb_dmx_release(dvbdemux);
#line 558
  dvb_unregister_frontend(dvb->fe);
#line 559
  dvb_frontend_detach(dvb->fe);
#line 560
  dvb_unregister_adapter(dvb_adapter);
#line 561
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
static int dvb_register(struct cx18_stream *stream ) 
{ 
  struct cx18_dvb *dvb ;
  struct cx18 *cx ;
  int ret ;
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , struct i2c_adapter * , struct mxl5005s_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , struct i2c_adapter * , struct mxl5005s_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;
  void *__r___1 ;
  struct dvb_frontend *(*__a___1)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___10 ;
  struct dvb_frontend *(*tmp___11)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___12 ;
  struct dvb_frontend *tmp___13 ;
  void *__r___2 ;
  struct dvb_frontend *(*__a___2)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___15 ;
  struct dvb_frontend *(*tmp___16)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                   struct tda18271_config * ) ;
  void *tmp___17 ;
  struct dvb_frontend *tmp___18 ;
  void *__r___3 ;
  struct dvb_frontend *(*__a___3)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___20 ;
  struct dvb_frontend *(*tmp___21)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___22 ;
  struct dvb_frontend *tmp___23 ;
  struct dvb_frontend *fe ;
  struct xc2028_config cfg ;
  struct xc2028_ctrl ctrl ;
  void *__r___4 ;
  struct dvb_frontend *(*__a___4)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___25 ;
  struct dvb_frontend *(*tmp___26)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___27 ;
  struct dvb_frontend *tmp___28 ;
  void *__r___5 ;
  struct dvb_frontend *(*__a___5)(struct mt352_config  const  * , struct i2c_adapter * ) ;
  void *tmp___30 ;
  struct dvb_frontend *(*tmp___31)(struct mt352_config  const  * , struct i2c_adapter * ) ;
  void *tmp___32 ;
  struct dvb_frontend *tmp___33 ;
  void *__r___6 ;
  struct dvb_frontend *(*__a___6)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___35 ;
  struct dvb_frontend *(*tmp___36)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___37 ;
  struct dvb_frontend *tmp___38 ;
  struct dvb_frontend *fe___0 ;
  struct xc2028_config cfg___0 ;
  struct xc2028_ctrl ctrl___0 ;
  void *__r___7 ;
  struct dvb_frontend *(*__a___7)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___40 ;
  struct dvb_frontend *(*tmp___41)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___42 ;
  struct dvb_frontend *tmp___43 ;
  void *__r___8 ;
  struct dvb_frontend *(*__a___8)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___45 ;
  struct dvb_frontend *(*tmp___46)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___47 ;
  struct dvb_frontend *tmp___48 ;
  struct dvb_frontend *fe___1 ;
  struct xc2028_config cfg___1 ;
  struct xc2028_ctrl ctrl___1 ;
  void *__r___9 ;
  struct dvb_frontend *(*__a___9)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___50 ;
  struct dvb_frontend *(*tmp___51)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___52 ;
  struct dvb_frontend *tmp___53 ;

  {
#line 568
  dvb = stream->dvb;
#line 569
  cx = stream->cx;
#line 570
  ret = 0;
#line 572
  switch ((cx->card)->type) {
  case 0: ;
  case 1: 
#line 575
  __r = (void *)0;
#line 575
  tmp___2 = __symbol_get("s5h1409_attach");
#line 575
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 575
  if (tmp___1) {

  } else {
#line 575
    __request_module(1, "symbol:s5h1409_attach");
#line 575
    tmp___0 = __symbol_get("s5h1409_attach");
#line 575
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1409_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 575
  __a = tmp___1;
#line 575
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 575
    tmp___3 = (*__a)((struct s5h1409_config  const  *)(& hauppauge_hvr1600_config),
                     (struct i2c_adapter *)(& cx->i2c_adap));
#line 575
    __r = (void *)tmp___3;
#line 575
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 575
      __symbol_put("s5h1409_attach");
    } else {

    }
  } else {
#line 575
    printk("\vDVB: Unable to find symbol s5h1409_attach()\n");
  }
#line 575
  dvb->fe = (struct dvb_frontend *)__r;
#line 578
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 579
    __r___0 = (void *)0;
#line 579
    tmp___7 = __symbol_get("mxl5005s_attach");
#line 579
    tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                         struct mxl5005s_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct i2c_adapter * ,
                                                                                                                                           struct mxl5005s_config * ))0);
#line 579
    if (tmp___6) {

    } else {
#line 579
      __request_module(1, "symbol:mxl5005s_attach");
#line 579
      tmp___5 = __symbol_get("mxl5005s_attach");
#line 579
      tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                          struct mxl5005s_config * ))tmp___5;
    }
#line 579
    __a___0 = tmp___6;
#line 579
    if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct i2c_adapter * ,
                                                                              struct mxl5005s_config * ))0)) {
#line 579
      tmp___8 = (*__a___0)(dvb->fe, (struct i2c_adapter *)(& cx->i2c_adap), & hauppauge_hvr1600_tuner);
#line 579
      __r___0 = (void *)tmp___8;
#line 579
      if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 579
        __symbol_put("mxl5005s_attach");
      } else {

      }
    } else {
#line 579
      printk("\vDVB: Unable to find symbol mxl5005s_attach()\n");
    }
#line 582
    ret = 0;
  } else {

  }
#line 584
  goto ldv_51964;
  case 9: 
#line 586
  __r___1 = (void *)0;
#line 586
  tmp___12 = __symbol_get("s5h1411_attach");
#line 586
  tmp___11 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                        struct i2c_adapter * ))tmp___12) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 586
  if (tmp___11) {

  } else {
#line 586
    __request_module(1, "symbol:s5h1411_attach");
#line 586
    tmp___10 = __symbol_get("s5h1411_attach");
#line 586
    tmp___11 = (struct dvb_frontend *(*)(struct s5h1411_config  const  * , struct i2c_adapter * ))tmp___10;
  }
#line 586
  __a___1 = tmp___11;
#line 586
  if ((unsigned long )__a___1 != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 586
    tmp___13 = (*__a___1)((struct s5h1411_config  const  *)(& hcw_s5h1411_config),
                          (struct i2c_adapter *)(& cx->i2c_adap));
#line 586
    __r___1 = (void *)tmp___13;
#line 586
    if ((unsigned long )__r___1 == (unsigned long )((void *)0)) {
#line 586
      __symbol_put("s5h1411_attach");
    } else {

    }
  } else {
#line 586
    printk("\vDVB: Unable to find symbol s5h1411_attach()\n");
  }
#line 586
  dvb->fe = (struct dvb_frontend *)__r___1;
#line 589
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 590
    __r___2 = (void *)0;
#line 590
    tmp___17 = __symbol_get("tda18271_attach");
#line 590
    tmp___16 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          u8  , struct i2c_adapter * ,
                                                          struct tda18271_config * ))tmp___17) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                             u8  ,
                                                                                                                                             struct i2c_adapter * ,
                                                                                                                                             struct tda18271_config * ))0);
#line 590
    if (tmp___16) {

    } else {
#line 590
      __request_module(1, "symbol:tda18271_attach");
#line 590
      tmp___15 = __symbol_get("tda18271_attach");
#line 590
      tmp___16 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                           struct tda18271_config * ))tmp___15;
    }
#line 590
    __a___2 = tmp___16;
#line 590
    if ((unsigned long )__a___2 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              u8  ,
                                                                              struct i2c_adapter * ,
                                                                              struct tda18271_config * ))0)) {
#line 590
      tmp___18 = (*__a___2)(dvb->fe, 96, (struct i2c_adapter *)(& cx->i2c_adap), & hauppauge_tda18271_config);
#line 590
      __r___2 = (void *)tmp___18;
#line 590
      if ((unsigned long )__r___2 == (unsigned long )((void *)0)) {
#line 590
        __symbol_put("tda18271_attach");
      } else {

      }
    } else {
#line 590
      printk("\vDVB: Unable to find symbol tda18271_attach()\n");
    }
  } else {

  }
#line 593
  goto ldv_51964;
  case 7: 
#line 595
  __r___3 = (void *)0;
#line 595
  tmp___22 = __symbol_get("zl10353_attach");
#line 595
  tmp___21 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                        struct i2c_adapter * ))tmp___22) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 595
  if (tmp___21) {

  } else {
#line 595
    __request_module(1, "symbol:zl10353_attach");
#line 595
    tmp___20 = __symbol_get("zl10353_attach");
#line 595
    tmp___21 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___20;
  }
#line 595
  __a___3 = tmp___21;
#line 595
  if ((unsigned long )__a___3 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 595
    tmp___23 = (*__a___3)((struct zl10353_config  const  *)(& leadtek_dvr3100h_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 595
    __r___3 = (void *)tmp___23;
#line 595
    if ((unsigned long )__r___3 == (unsigned long )((void *)0)) {
#line 595
      __symbol_put("zl10353_attach");
    } else {

    }
  } else {
#line 595
    printk("\vDVB: Unable to find symbol zl10353_attach()\n");
  }
#line 595
  dvb->fe = (struct dvb_frontend *)__r___3;
#line 598
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 600
    cfg.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 600
    cfg.i2c_addr = 97U;
#line 600
    cfg.ctrl = (struct xc2028_ctrl *)0;
#line 605
    ctrl.fname = (char *)"xc3028-v27.fw";
#line 605
    ctrl.max_len = 64;
#line 605
    ctrl.msleep = 0;
#line 605
    ctrl.scode_table = 0U;
#line 605
    ctrl.mts = (unsigned char)0;
#line 605
    ctrl.input1 = (unsigned char)0;
#line 605
    ctrl.vhfbw7 = (unsigned char)0;
#line 605
    ctrl.uhfbw8 = (unsigned char)0;
#line 605
    ctrl.disable_power_mgmt = (unsigned char)0;
#line 605
    ctrl.read_not_reliable = (unsigned char)0;
#line 605
    ctrl.demod = 4560U;
#line 605
    ctrl.type = 0U;
#line 612
    __r___4 = (void *)0;
#line 612
    tmp___27 = __symbol_get("xc2028_attach");
#line 612
    tmp___26 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___27) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 612
    if (tmp___26) {

    } else {
#line 612
      __request_module(1, "symbol:xc2028_attach");
#line 612
      tmp___25 = __symbol_get("xc2028_attach");
#line 612
      tmp___26 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___25;
    }
#line 612
    __a___4 = tmp___26;
#line 612
    if ((unsigned long )__a___4 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 612
      tmp___28 = (*__a___4)(dvb->fe, & cfg);
#line 612
      __r___4 = (void *)tmp___28;
#line 612
      if ((unsigned long )__r___4 == (unsigned long )((void *)0)) {
#line 612
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 612
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 612
    fe = (struct dvb_frontend *)__r___4;
#line 613
    if ((unsigned long )fe != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                      void * ))0)) {
#line 614
      (*(fe->ops.tuner_ops.set_config))(fe, (void *)(& ctrl));
    } else {

    }
  } else {

  }
#line 616
  goto ldv_51964;
  case 3: 
#line 623
  __r___5 = (void *)0;
#line 623
  tmp___32 = __symbol_get("mt352_attach");
#line 623
  tmp___31 = (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                        struct i2c_adapter * ))tmp___32) != (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 623
  if (tmp___31) {

  } else {
#line 623
    __request_module(1, "symbol:mt352_attach");
#line 623
    tmp___30 = __symbol_get("mt352_attach");
#line 623
    tmp___31 = (struct dvb_frontend *(*)(struct mt352_config  const  * , struct i2c_adapter * ))tmp___30;
  }
#line 623
  __a___5 = tmp___31;
#line 623
  if ((unsigned long )__a___5 != (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 623
    tmp___33 = (*__a___5)((struct mt352_config  const  *)(& yuan_mpc718_mt352_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 623
    __r___5 = (void *)tmp___33;
#line 623
    if ((unsigned long )__r___5 == (unsigned long )((void *)0)) {
#line 623
      __symbol_put("mt352_attach");
    } else {

    }
  } else {
#line 623
    printk("\vDVB: Unable to find symbol mt352_attach()\n");
  }
#line 623
  dvb->fe = (struct dvb_frontend *)__r___5;
#line 626
  if ((unsigned long )dvb->fe == (unsigned long )((struct dvb_frontend *)0)) {
#line 627
    __r___6 = (void *)0;
#line 627
    tmp___37 = __symbol_get("zl10353_attach");
#line 627
    tmp___36 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                          struct i2c_adapter * ))tmp___37) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                         struct i2c_adapter * ))0);
#line 627
    if (tmp___36) {

    } else {
#line 627
      __request_module(1, "symbol:zl10353_attach");
#line 627
      tmp___35 = __symbol_get("zl10353_attach");
#line 627
      tmp___36 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___35;
    }
#line 627
    __a___6 = tmp___36;
#line 627
    if ((unsigned long )__a___6 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                              struct i2c_adapter * ))0)) {
#line 627
      tmp___38 = (*__a___6)((struct zl10353_config  const  *)(& yuan_mpc718_zl10353_demod),
                            (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 627
      __r___6 = (void *)tmp___38;
#line 627
      if ((unsigned long )__r___6 == (unsigned long )((void *)0)) {
#line 627
        __symbol_put("zl10353_attach");
      } else {

      }
    } else {
#line 627
      printk("\vDVB: Unable to find symbol zl10353_attach()\n");
    }
#line 627
    dvb->fe = (struct dvb_frontend *)__r___6;
  } else {

  }
#line 630
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 632
    cfg___0.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 632
    cfg___0.i2c_addr = 97U;
#line 632
    cfg___0.ctrl = (struct xc2028_ctrl *)0;
#line 637
    ctrl___0.fname = (char *)"xc3028-v27.fw";
#line 637
    ctrl___0.max_len = 64;
#line 637
    ctrl___0.msleep = 0;
#line 637
    ctrl___0.scode_table = 0U;
#line 637
    ctrl___0.mts = (unsigned char)0;
#line 637
    ctrl___0.input1 = (unsigned char)0;
#line 637
    ctrl___0.vhfbw7 = (unsigned char)0;
#line 637
    ctrl___0.uhfbw8 = (unsigned char)0;
#line 637
    ctrl___0.disable_power_mgmt = (unsigned char)0;
#line 637
    ctrl___0.read_not_reliable = (unsigned char)0;
#line 637
    ctrl___0.demod = 4560U;
#line 637
    ctrl___0.type = 0U;
#line 644
    __r___7 = (void *)0;
#line 644
    tmp___42 = __symbol_get("xc2028_attach");
#line 644
    tmp___41 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___42) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 644
    if (tmp___41) {

    } else {
#line 644
      __request_module(1, "symbol:xc2028_attach");
#line 644
      tmp___40 = __symbol_get("xc2028_attach");
#line 644
      tmp___41 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___40;
    }
#line 644
    __a___7 = tmp___41;
#line 644
    if ((unsigned long )__a___7 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 644
      tmp___43 = (*__a___7)(dvb->fe, & cfg___0);
#line 644
      __r___7 = (void *)tmp___43;
#line 644
      if ((unsigned long )__r___7 == (unsigned long )((void *)0)) {
#line 644
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 644
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 644
    fe___0 = (struct dvb_frontend *)__r___7;
#line 645
    if ((unsigned long )fe___0 != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe___0->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                              void * ))0)) {
#line 646
      (*(fe___0->ops.tuner_ops.set_config))(fe___0, (void *)(& ctrl___0));
    } else {

    }
  } else {

  }
#line 648
  goto ldv_51964;
  case 8: 
#line 650
  __r___8 = (void *)0;
#line 650
  tmp___47 = __symbol_get("zl10353_attach");
#line 650
  tmp___46 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                        struct i2c_adapter * ))tmp___47) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 650
  if (tmp___46) {

  } else {
#line 650
    __request_module(1, "symbol:zl10353_attach");
#line 650
    tmp___45 = __symbol_get("zl10353_attach");
#line 650
    tmp___46 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___45;
  }
#line 650
  __a___8 = tmp___46;
#line 650
  if ((unsigned long )__a___8 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 650
    tmp___48 = (*__a___8)((struct zl10353_config  const  *)(& gotview_dvd3_zl10353_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 650
    __r___8 = (void *)tmp___48;
#line 650
    if ((unsigned long )__r___8 == (unsigned long )((void *)0)) {
#line 650
      __symbol_put("zl10353_attach");
    } else {

    }
  } else {
#line 650
    printk("\vDVB: Unable to find symbol zl10353_attach()\n");
  }
#line 650
  dvb->fe = (struct dvb_frontend *)__r___8;
#line 653
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 655
    cfg___1.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 655
    cfg___1.i2c_addr = 97U;
#line 655
    cfg___1.ctrl = (struct xc2028_ctrl *)0;
#line 660
    ctrl___1.fname = (char *)"xc3028-v27.fw";
#line 660
    ctrl___1.max_len = 64;
#line 660
    ctrl___1.msleep = 0;
#line 660
    ctrl___1.scode_table = 0U;
#line 660
    ctrl___1.mts = (unsigned char)0;
#line 660
    ctrl___1.input1 = (unsigned char)0;
#line 660
    ctrl___1.vhfbw7 = (unsigned char)0;
#line 660
    ctrl___1.uhfbw8 = (unsigned char)0;
#line 660
    ctrl___1.disable_power_mgmt = (unsigned char)0;
#line 660
    ctrl___1.read_not_reliable = (unsigned char)0;
#line 660
    ctrl___1.demod = 4560U;
#line 660
    ctrl___1.type = 0U;
#line 667
    __r___9 = (void *)0;
#line 667
    tmp___52 = __symbol_get("xc2028_attach");
#line 667
    tmp___51 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___52) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 667
    if (tmp___51) {

    } else {
#line 667
      __request_module(1, "symbol:xc2028_attach");
#line 667
      tmp___50 = __symbol_get("xc2028_attach");
#line 667
      tmp___51 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___50;
    }
#line 667
    __a___9 = tmp___51;
#line 667
    if ((unsigned long )__a___9 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 667
      tmp___53 = (*__a___9)(dvb->fe, & cfg___1);
#line 667
      __r___9 = (void *)tmp___53;
#line 667
      if ((unsigned long )__r___9 == (unsigned long )((void *)0)) {
#line 667
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 667
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 667
    fe___1 = (struct dvb_frontend *)__r___9;
#line 668
    if ((unsigned long )fe___1 != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe___1->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                              void * ))0)) {
#line 669
      (*(fe___1->ops.tuner_ops.set_config))(fe___1, (void *)(& ctrl___1));
    } else {

    }
  } else {

  }
#line 671
  goto ldv_51964;
  default: ;
#line 674
  goto ldv_51964;
  }
  ldv_51964: ;
#line 677
  if ((unsigned long )dvb->fe == (unsigned long )((struct dvb_frontend *)0)) {
#line 678
    printk("\v%s: frontend initialization failed\n", (char *)(& cx->v4l2_dev.name));
#line 679
    return (-1);
  } else {

  }
#line 682
  (dvb->fe)->callback = & cx18_reset_tuner_gpio;
#line 684
  ret = dvb_register_frontend(& dvb->dvb_adapter, dvb->fe);
#line 685
  if (ret < 0) {
#line 686
    if ((unsigned long )(dvb->fe)->ops.release != (unsigned long )((void (*)(struct dvb_frontend * ))0)) {
#line 687
      (*((dvb->fe)->ops.release))(dvb->fe);
    } else {

    }
#line 688
    return (ret);
  } else {

  }
#line 696
  cx18_write_reg_expect___7(cx, 8388736U, 13045796U, 128U, 8388736U);
#line 702
  return (ret);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  struct dvb_frontend *ldvarg25 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 709
  tmp = ldv_zalloc(1288UL);
#line 709
  ldvarg25 = (struct dvb_frontend *)tmp;
#line 711
  tmp___0 = __VERIFIER_nondet_int();
#line 711
  switch (tmp___0) {
  case 0: ;
#line 714
  if (ldv_state_variable_3 == 1) {
#line 716
    yuan_mpc718_mt352_init(ldvarg25);
#line 718
    ldv_state_variable_3 = 1;
  } else {

  }
#line 721
  goto ldv_52012;
  default: 
#line 722
  ldv_stop();
  }
  ldv_52012: ;
#line 726
  return;
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void *ldv_kmem_cache_alloc_866(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 857
  ldv_check_alloc_flags(flags);
#line 859
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 860
  return ((void *)0);
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
int ldv_pskb_expand_head_872(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 901
  ldv_check_alloc_flags(flags);
#line 903
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 903
  return (tmp);
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_874(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 917
  ldv_check_alloc_flags(flags);
#line 919
  tmp = skb_clone(ldv_func_arg1, flags);
#line 919
  return (tmp);
}
}
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv_skb_copy_876(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 933
  ldv_check_alloc_flags(flags);
#line 935
  tmp = skb_copy(ldv_func_arg1, flags);
#line 935
  return (tmp);
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_877(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 941
  ldv_check_alloc_flags(flags);
#line 943
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 943
  return (tmp);
}
}
#line 946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_878(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 949
  ldv_check_alloc_flags(flags);
#line 951
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 951
  return (tmp);
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_879(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 957
  ldv_check_alloc_flags(flags);
#line 959
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 959
  return (tmp);
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
int ldv_pskb_expand_head_880(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 965
  ldv_check_alloc_flags(flags);
#line 967
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 967
  return (tmp);
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
int ldv_pskb_expand_head_881(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 973
  ldv_check_alloc_flags(flags);
#line 975
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 975
  return (tmp);
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_882(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 981
  ldv_check_alloc_flags(flags);
#line 983
  tmp = skb_clone(ldv_func_arg1, flags);
#line 983
  return (tmp);
}
}
#line 54 "./arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 54
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 54
  return (ret);
}
}
#line 55 "./arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 55
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 62 "./arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 62
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 63
  return;
}
}
#line 63 "./arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
#line 63
  __asm__  volatile   ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_908(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_916(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_924(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_918(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_914(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_922(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_923(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_919(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_920(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_921(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u16 cx18_readw(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned short tmp ;

  {
#line 100
  tmp = readw((void const volatile   *)addr);
#line 100
  return (tmp);
}
}
#line 104 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writew_noretry(struct cx18 *cx , u16 val , void *addr ) 
{ 


  {
#line 106
  writew((int )val, (void volatile   *)addr);
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writew(struct cx18 *cx , u16 val , void *addr ) 
{ 
  int i ;
  u16 tmp ;

  {
#line 112
  i = 0;
#line 112
  goto ldv_51325;
  ldv_51324: 
#line 113
  cx18_writew_noretry(cx, (int )val, addr);
#line 114
  tmp = cx18_readw(cx, (void const   *)addr);
#line 114
  if ((int )tmp == (int )val) {
#line 115
    goto ldv_51323;
  } else {

  }
#line 112
  i = i + 1;
  ldv_51325: ;
#line 112
  if (i <= 9) {
#line 114
    goto ldv_51324;
  } else {

  }
  ldv_51323: ;
#line 119
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u8 cx18_readb(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned char tmp ;

  {
#line 121
  tmp = readb((void const volatile   *)addr);
#line 121
  return (tmp);
}
}
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writeb_noretry(struct cx18 *cx , u8 val , void *addr ) 
{ 


  {
#line 127
  writeb((int )val, (void volatile   *)addr);
#line 128
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writeb(struct cx18 *cx , u8 val , void *addr ) 
{ 
  int i ;
  u8 tmp ;

  {
#line 133
  i = 0;
#line 133
  goto ldv_51343;
  ldv_51342: 
#line 134
  cx18_writeb_noretry(cx, (int )val, addr);
#line 135
  tmp = cx18_readb(cx, (void const   *)addr);
#line 135
  if ((int )tmp == (int )val) {
#line 136
    goto ldv_51341;
  } else {

  }
#line 133
  i = i + 1;
  ldv_51343: ;
#line 133
  if (i <= 9) {
#line 135
    goto ldv_51342;
  } else {

  }
  ldv_51341: ;
#line 140
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_memset_io(struct cx18 *cx , void *addr , int val , size_t count ) 
{ 
  u8 *dst ;
  u16 val2 ;
  u32 val4 ;

  {
#line 125
  dst = (u8 *)addr;
#line 126
  val2 = (u16 )((int )((short )(val << 8)) | (int )((short )val));
#line 127
  val4 = (u32 )((int )val2 | ((int )val2 << 16));
#line 130
  if (count != 0UL && (int )((unsigned long )dst) & 1) {
#line 131
    cx18_writeb(cx, (int )((unsigned char )val), (void *)dst);
#line 132
    count = count - 1UL;
#line 133
    dst = dst + 1;
  } else {

  }
#line 135
  if (count > 1UL && ((unsigned long )dst & 2UL) != 0UL) {
#line 136
    cx18_writew(cx, (int )val2, (void *)dst);
#line 137
    count = count - 2UL;
#line 138
    dst = dst + 2UL;
  } else {

  }
#line 140
  goto ldv_51416;
  ldv_51415: 
#line 141
  cx18_writel(cx, val4, (void *)dst);
#line 142
  count = count - 4UL;
#line 143
  dst = dst + 4UL;
  ldv_51416: ;
#line 140
  if (count > 3UL) {
#line 142
    goto ldv_51415;
  } else {

  }

#line 145
  if (count > 1UL) {
#line 146
    cx18_writew(cx, (int )val2, (void *)dst);
#line 147
    count = count - 2UL;
#line 148
    dst = dst + 2UL;
  } else {

  }
#line 150
  if (count != 0UL) {
#line 151
    cx18_writeb(cx, (int )((unsigned char )val), (void *)dst);
  } else {

  }
#line 152
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_sw1_irq_enable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 156
  cx18_write_reg_expect(cx, val, 13054212U, ~ val, val);
#line 157
  tmp = cx18_read_reg(cx, 13054236U);
#line 157
  cx->sw1_irq_mask = tmp | val;
#line 158
  cx18_write_reg(cx, cx->sw1_irq_mask, 13054236U);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_sw1_irq_disable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 163
  tmp = cx18_read_reg(cx, 13054236U);
#line 163
  cx->sw1_irq_mask = tmp & ~ val;
#line 164
  cx18_write_reg(cx, cx->sw1_irq_mask, 13054236U);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_sw2_irq_enable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 169
  cx18_write_reg_expect(cx, val, 13054276U, ~ val, val);
#line 170
  tmp = cx18_read_reg(cx, 13054300U);
#line 170
  cx->sw2_irq_mask = tmp | val;
#line 171
  cx18_write_reg(cx, cx->sw2_irq_mask, 13054300U);
#line 172
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_sw2_irq_disable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 176
  tmp = cx18_read_reg(cx, 13054300U);
#line 176
  cx->sw2_irq_mask = tmp & ~ val;
#line 177
  cx18_write_reg(cx, cx->sw2_irq_mask, 13054300U);
#line 178
  return;
}
}
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_sw2_irq_disable_cpu(struct cx18 *cx , u32 val ) 
{ 
  u32 r ;

  {
#line 183
  r = cx18_read_reg(cx, 13054296U);
#line 184
  cx18_write_reg(cx, ~ val & r, 13054296U);
#line 185
  return;
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void cx18_setup_page(struct cx18 *cx , u32 addr ) 
{ 
  u32 val ;

  {
#line 190
  val = cx18_read_reg(cx, 13631736U);
#line 191
  val = (val & 4294959359U) | ((addr >> 17) & 7936U);
#line 192
  cx18_write_reg(cx, val, 13631736U);
#line 193
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void *ldv_kmem_cache_alloc_908(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 325
  ldv_check_alloc_flags(flags);
#line 327
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 328
  return ((void *)0);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
int ldv_pskb_expand_head_914(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 369
  ldv_check_alloc_flags(flags);
#line 371
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 371
  return (tmp);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv_skb_clone_916(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 385
  ldv_check_alloc_flags(flags);
#line 387
  tmp = skb_clone(ldv_func_arg1, flags);
#line 387
  return (tmp);
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv_skb_copy_918(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 401
  ldv_check_alloc_flags(flags);
#line 403
  tmp = skb_copy(ldv_func_arg1, flags);
#line 403
  return (tmp);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_919(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 409
  ldv_check_alloc_flags(flags);
#line 411
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 411
  return (tmp);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_920(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 417
  ldv_check_alloc_flags(flags);
#line 419
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 419
  return (tmp);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_921(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 425
  ldv_check_alloc_flags(flags);
#line 427
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 427
  return (tmp);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
int ldv_pskb_expand_head_922(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 433
  ldv_check_alloc_flags(flags);
#line 435
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 435
  return (tmp);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
int ldv_pskb_expand_head_923(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 441
  ldv_check_alloc_flags(flags);
#line 443
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 443
  return (tmp);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
struct sk_buff *ldv_skb_clone_924(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 449
  ldv_check_alloc_flags(flags);
#line 451
  tmp = skb_clone(ldv_func_arg1, flags);
#line 451
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3544/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
