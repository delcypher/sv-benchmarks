extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 327 "./arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 412 "include/linux/printk.h"
struct completion;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 465
struct kmem_cache;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 178 "include/linux/mutex.h"
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 266 "include/linux/timer.h"
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14120_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14126_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14136_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14138_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14136_144 ldv_14136 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14140_142 {
   union __anonunion_ldv_14138_143 ldv_14138 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14142_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14140_142 ldv_14140 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14143_139 {
   union __anonunion_ldv_14126_140 ldv_14126 ;
   union __anonunion_ldv_14142_141 ldv_14142 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14150_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14155_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14150_146 ldv_14150 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14161_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 ldv_14120 ;
   struct __anonstruct_ldv_14143_139 ldv_14143 ;
   union __anonunion_ldv_14155_145 ldv_14155 ;
   union __anonunion_ldv_14161_147 ldv_14161 ;
   unsigned long debug_flags ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14524_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14524_153 ldv_14524 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14668_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14668_154 ldv_14668 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15343_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15343_155 ldv_15343 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15963_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15969_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_15970_156 {
   struct __anonstruct_ldv_15963_157 ldv_15963 ;
   struct __anonstruct_ldv_15969_158 ldv_15969 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15970_156 ldv_15970 ;
};
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
struct fmc_driver;
#line 24
struct fmc_device;
#line 29
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195
struct of_device_id;
#line 195
struct acpi_device_id;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1198 "include/linux/device.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 73 "include/linux/firmware.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 69 "include/linux/io.h"
struct fmc_fru_id {
   char *manufacturer ;
   char *product_name ;
};
#line 47 "include/linux/fmc.h"
struct fmc_sdb_one_id {
   uint64_t vendor ;
   uint32_t device ;
};
#line 59 "include/linux/fmc.h"
struct fmc_sdb_id {
   struct fmc_sdb_one_id *cores ;
   int cores_nr ;
};
#line 63 "include/linux/fmc.h"
struct fmc_device_id {
   struct fmc_fru_id *fru_id ;
   int fru_id_nr ;
   struct fmc_sdb_id *sdb_id ;
   int sdb_id_nr ;
};
#line 70 "include/linux/fmc.h"
struct fmc_driver {
   unsigned long version ;
   struct device_driver driver ;
   int (*probe)(struct fmc_device * ) ;
   int (*remove)(struct fmc_device * ) ;
   struct fmc_device_id  const  id_table ;
   int busid_n ;
   int busid_val[32U] ;
   int gw_n ;
   char *gw_val[32U] ;
};
#line 87 "include/linux/fmc.h"
struct fmc_gpio {
   char *carrier_name ;
   int gpio ;
   int _gpio ;
   int mode ;
   int irqmode ;
};
#line 107 "include/linux/fmc.h"
struct fmc_operations {
   uint32_t (*read32)(struct fmc_device * , int  ) ;
   void (*write32)(struct fmc_device * , uint32_t  , int  ) ;
   int (*validate)(struct fmc_device * , struct fmc_driver * ) ;
   int (*reprogram)(struct fmc_device * , struct fmc_driver * , char * ) ;
   int (*irq_request)(struct fmc_device * , irqreturn_t (*)(int  , void * ) , char * ,
                      int  ) ;
   void (*irq_ack)(struct fmc_device * ) ;
   int (*irq_free)(struct fmc_device * ) ;
   int (*gpio_config)(struct fmc_device * , struct fmc_gpio * , int  ) ;
   int (*read_ee)(struct fmc_device * , int  , void * , int  ) ;
   int (*write_ee)(struct fmc_device * , int  , void const   * , int  ) ;
};
#line 148
struct sdb_array;
#line 148 "include/linux/fmc.h"
struct fmc_device {
   unsigned long version ;
   unsigned long flags ;
   struct module *owner ;
   struct fmc_fru_id id ;
   struct fmc_operations *op ;
   int irq ;
   int eeprom_len ;
   int eeprom_addr ;
   uint8_t *eeprom ;
   char *carrier_name ;
   void *carrier_data ;
   void *fpga_base ;
   void *slot_base ;
   struct fmc_device **devarray ;
   int slot_id ;
   int nr_slots ;
   unsigned long memlen ;
   struct device dev ;
   struct device *hwdev ;
   unsigned long sdbfs_entry ;
   struct sdb_array *sdb ;
   uint32_t device_id ;
   char *mezzanine_name ;
   void *mezzanine_data ;
};
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
struct ff_dev {
   struct fmc_device *fmc[4U] ;
   struct device dev ;
};
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14126_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 120 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 25
  return ((void *)error);
}
}
#line 28 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 30
  return ((long )ptr);
}
}
#line 33 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 35
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 35
  return (tmp != 0L);
}
}
#line 36 "include/linux/timer.h"
extern struct tvec_base boot_tvec_bases ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 355
extern struct workqueue_struct *system_wq ;
#line 433
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 485 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 489
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
#line 489
  return (tmp);
}
}
#line 558 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 561
  return (tmp);
}
}
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 316
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int ldv_state_variable_2  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int ref_cnt  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
struct fmc_driver *ff_fmc_operations_group0  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
struct fmc_device *ff_fmc_operations_group1  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int ldv_state_variable_1  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int ldv_state_variable_0  ;
#line 28
void ldv_initialize_fmc_operations_1(void) ;
#line 816 "include/linux/device.h"
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 916
extern int device_register(struct device * ) ;
#line 917
extern void device_unregister(struct device * ) ;
#line 1005
extern void put_device(struct device * ) ;
#line 1042
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1044
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1048
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 227 "include/linux/fmc.h"
extern int fmc_device_register_n(struct fmc_device ** , int  ) ;
#line 228
extern void fmc_device_unregister_n(struct fmc_device ** , int  ) ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static char *ff_eeprom[4U]  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_nr_eeprom  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_nr_dev  =    1;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static char ff_eeimg[4U][8192U]  = { {        1,        0,        0,        1, 
            0,        12,        0,        -14, 
            1,        11,        0,        -78, 
            -122,        -121,        -53,        102, 
            97,        107,        101,        45, 
            118,        101,        110,        100, 
            111,        114,        -41,        102, 
            97,        107,        101,        45, 
            100,        101,        115,        105, 
            103,        110,        45,        102, 
            111,        114,        45,        116, 
            101,        115,        116,        105, 
            110,        103,        -59,        48, 
            49,        50,        51,        52, 
            -60,        110,        111,        110, 
            101,        -38,        50,        48, 
            49,        50,        45,        49, 
            49,        45,        49,        57, 
            32,        50,        50,        58, 
            52,        50,        58,        51, 
            48,        46,        48,        55, 
            52,        48,        53,        53, 
            -63,        0,        0,        0, 
            0,        0,        0,        -121, 
            2,        2,        13,        -9, 
            -8,        2,        -80,        4, 
            116,        4,        -20,        4, 
            0,        0,        0,        0, 
            -24,        3,        2,        2, 
            13,        92,        -109,        1, 
            74,        1,        57,        1, 
            90,        1,        0,        0, 
            0,        0,        -72,        11, 
            2,        2,        13,        99, 
            -116,        0,        -6,        0, 
            -19,        0,        6,        1, 
            0,        0,        0,        0, 
            -96,        15,        1,        2, 
            13,        -5,        -11,        5, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            1,        2,        13,        -4, 
            -12,        4,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        1,        2, 
            13,        -3,        -13,        3, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            -6,        -126,        11,        -22, 
            -113,        -94,        18,        0, 
            0,        30,        68,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            83,        68,        66,        45, 
            0,        3,        1,        1, 
            0,        0,        0,        0, 
            0,        0,        1,        0, 
            0,        0,        0,        0, 
            0,        0,        1,        -60, 
            70,        105,        108,        101, 
            68,        97,        116,        97, 
            46,        32,        32,        32, 
            0,        0,        0,        1, 
            0,        0,        0,        0, 
            46,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        4, 
            0,        0,        0,        0, 
            0,        0,        1,        -64, 
            0,        0,        0,        0, 
            0,        0,        1,        -60, 
            70,        105,        108,        101, 
            68,        97,        116,        97, 
            110,        97,        109,        101, 
            0,        0,        0,        1, 
            0,        0,        0,        0, 
            110,        97,        109,        101, 
            32,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        1, 
            0,        0,        0,        0, 
            0,        0,        0,        4, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        -33, 
            70,        105,        108,        101, 
            68,        97,        116,        97, 
            73,        80,        77,        73, 
            0,        0,        0,        1, 
            0,        0,        0,        0, 
            73,        80,        77,        73, 
            45,        70,        82,        85, 
            32,        32,        32,        32, 
            32,        32,        32,        32, 
            32,        32,        32,        1, 
            102,        97,        107,        101, 
            10}};
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static struct ff_dev *ff_current_dev  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_reprogram(struct fmc_device *fmc , struct fmc_driver *drv , char *gw ) 
{ 
  struct firmware  const  *fw ;
  int ret ;

  {
#line 130
  if ((unsigned long )gw == (unsigned long )((char *)0)) {
#line 132
    fmc->flags = fmc->flags & 0xfffffffffffffffdUL;
#line 133
    fmc->flags = fmc->flags | 1UL;
#line 134
    return (0);
  } else {

  }
#line 137
  _dev_info((struct device  const  *)(& fmc->dev), "reprogramming with %s\n", gw);
#line 138
  ret = request_firmware(& fw, (char const   *)gw, & fmc->dev);
#line 139
  if (ret < 0) {
#line 140
    dev_warn((struct device  const  *)(& fmc->dev), "request firmware \"%s\": error %i\n",
             gw, ret);
#line 142
    goto out;
  } else {

  }
#line 144
  fmc->flags = fmc->flags & 0xfffffffffffffffeUL;
#line 145
  fmc->flags = fmc->flags | 2UL;
  out: 
#line 148
  release_firmware(fw);
#line 149
  return (ret);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_irq_request(struct fmc_device *fmc , irqreturn_t (*handler)(int  , void * ) ,
                          char *name , int flags ) 
{ 


  {
#line 155
  return (-95);
}
}
#line 165
static struct ff_dev *ff_dev_create(void) ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static void ff_work_fn(struct work_struct *work ) 
{ 
  struct ff_dev *ff ;
  int ret ;
  bool tmp ;

  {
#line 169
  ff = ff_current_dev;
#line 172
  fmc_device_unregister_n((struct fmc_device **)(& ff->fmc), ff_nr_dev);
#line 173
  device_unregister(& ff->dev);
#line 174
  ff_current_dev = (struct ff_dev *)0;
#line 176
  ff = ff_dev_create();
#line 177
  tmp = IS_ERR((void const   *)ff);
#line 177
  if ((int )tmp) {
#line 178
    printk("\f%s: can\'t re-create FMC devices\n", "ff_work_fn");
#line 179
    return;
  } else {

  }
#line 181
  ret = fmc_device_register_n((struct fmc_device **)(& ff->fmc), ff_nr_dev);
#line 182
  if (ret < 0) {
#line 183
    dev_warn((struct device  const  *)(& ff->dev), "can\'t re-register FMC devices\n");
#line 184
    device_unregister(& ff->dev);
#line 185
    return;
  } else {

  }
#line 188
  ff_current_dev = ff;
#line 189
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static struct delayed_work ff_work  =    {{{137438953424L}, {& ff_work.work.entry, & ff_work.work.entry}, & ff_work_fn,
     {(struct lock_class_key *)(& ff_work.work), {0, 0}, "(ff_work).work", 0, 0UL}},
    {{0, (struct list_head *)1953723489}, 0UL, (struct tvec_base *)((unsigned long )(& boot_tvec_bases) + 2UL),
     & delayed_work_timer_fn, (unsigned long )(& ff_work), -1, 0, 0, {(char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0},
     {(struct lock_class_key *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared:191",
      {0, 0}, "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared:191",
      0, 0UL}}, 0, 0};
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_eeprom_read(struct fmc_device *fmc , uint32_t offset , void *buf , size_t size ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 198
  if (offset > 8192U) {
#line 199
    return (-22);
  } else {

  }
#line 200
  if ((size_t )offset + size > 8192UL) {
#line 201
    size = (size_t )(8192U - offset);
  } else {

  }
#line 202
  __len = size;
#line 202
  __ret = __builtin_memcpy(buf, (void const   *)fmc->eeprom + (unsigned long )offset,
                           __len);
#line 203
  return ((int )size);
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_eeprom_write(struct fmc_device *fmc , uint32_t offset , void const   *buf ,
                           size_t size ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 209
  if (offset > 8192U) {
#line 210
    return (-22);
  } else {

  }
#line 211
  if ((size_t )offset + size > 8192UL) {
#line 212
    size = (size_t )(8192U - offset);
  } else {

  }
#line 213
  _dev_info((struct device  const  *)(& fmc->dev), "write_eeprom: offset %i, size %zi\n",
            (int )offset, size);
#line 215
  __len = size;
#line 215
  __ret = __builtin_memcpy((void *)fmc->eeprom + (unsigned long )offset, buf, __len);
#line 216
  schedule_delayed_work(& ff_work, 500UL);
#line 217
  return ((int )size);
}
}
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_read_ee(struct fmc_device *fmc , int pos , void *data , int len ) 
{ 
  int tmp ;

  {
#line 223
  if ((fmc->flags & 1UL) == 0UL) {
#line 224
    return (-95);
  } else {

  }
#line 225
  tmp = ff_eeprom_read(fmc, (uint32_t )pos, data, (size_t )len);
#line 225
  return (tmp);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_write_ee(struct fmc_device *fmc , int pos , void const   *data , int len ) 
{ 
  int tmp ;

  {
#line 231
  if ((fmc->flags & 1UL) == 0UL) {
#line 232
    return (-95);
  } else {

  }
#line 233
  tmp = ff_eeprom_write(fmc, (uint32_t )pos, data, (size_t )len);
#line 233
  return (tmp);
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static uint32_t ff_readl(struct fmc_device *fmc , int offset ) 
{ 


  {
#line 239
  return (0U);
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static void ff_writel(struct fmc_device *fmc , uint32_t value , int offset ) 
{ 


  {
#line 244
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_validate(struct fmc_device *fmc , struct fmc_driver *drv ) 
{ 
  int i ;

  {
#line 252
  if (drv->busid_n == 0) {
#line 253
    return (0);
  } else {

  }
#line 254
  i = 0;
#line 254
  goto ldv_19577;
  ldv_19576: ;
#line 255
  if ((uint32_t )drv->busid_val[i] == fmc->device_id) {
#line 256
    return (i);
  } else {

  }
#line 254
  i = i + 1;
  ldv_19577: ;
#line 254
  if (drv->busid_n > i) {
#line 256
    goto ldv_19576;
  } else {

  }

#line 257
  return (-2);
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static struct fmc_operations ff_fmc_operations  = 
#line 262
     {& ff_readl, & ff_writel, & ff_validate, & ff_reprogram, & ff_irq_request, 0, 0,
    0, & ff_read_ee, & ff_write_ee};
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static void ff_dev_release(struct device *dev ) 
{ 
  struct ff_dev *ff ;
  struct device  const  *__mptr ;

  {
#line 275
  __mptr = (struct device  const  *)dev;
#line 275
  ff = (struct ff_dev *)__mptr + 0xffffffffffffffe0UL;
#line 276
  kfree((void const   *)ff);
#line 277
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static struct fmc_device ff_template_fmc  = 
#line 279
     {196608UL, 1UL, & __this_module, {0, 0}, & ff_fmc_operations, 0, 8192, 0, 0, (char *)"fake-fmc-carrier",
    0, 0, 0, 0, 0, 0, 4096UL, {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0},
                                                                      0, {0, {0, 0},
                                                                          0, 0, 0UL}},
                                                                     {{0, 0}, 0UL,
                                                                      0, 0, 0UL, 0,
                                                                      0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                                                      {0, {0, 0},
                                                                       0, 0, 0UL}},
                                                                     0, 0}, (unsigned char)0,
                                      (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                      (unsigned char)0}, 0, 0, {{0}, {{{{{0U}}, 0U,
                                                                        0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                {0, 0}, 0, 0, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                               0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0,
                                            (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
                                            (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0U}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                            {0, 0}, {0U, {{{{{{0U}}, 0U, 0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                          {0, 0}}}, 0, (_Bool)0, (_Bool)0,
                                            {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0},
                                             {0, {0, 0}, 0, 0, 0UL}}, 0UL, {{0L},
                                                                            {0, 0},
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
                                            {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0,
                                                                    0, 0UL}}}}, {0,
                                                                                 0}},
                                            {0}, {0}, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            0, 0, 0, 0, 0UL, 0UL, 0UL, 0UL, 0, 0,
                                            0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
                               0, 0, {0, 0}, 0, {0}, 0U, 0U, {{{{{0U}}, 0U, 0U, 0,
                                                                {0, {0, 0}, 0, 0,
                                                                 0UL}}}}, {0, 0},
                               {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0},
    (struct device *)0, 0UL, 0, 61441U, 0, 0};
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static struct ff_dev *ff_dev_create(void) 
{ 
  struct ff_dev *ff ;
  struct fmc_device *fmc ;
  int i ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 297
  tmp = kzalloc(1448UL, 208U);
#line 297
  ff = (struct ff_dev *)tmp;
#line 298
  if ((unsigned long )ff == (unsigned long )((struct ff_dev *)0)) {
#line 299
    tmp___0 = ERR_PTR(-12L);
#line 299
    return ((struct ff_dev *)tmp___0);
  } else {

  }
#line 300
  dev_set_name(& ff->dev, "fake-fmc-carrier");
#line 301
  ff->dev.release = & ff_dev_release;
#line 303
  ret = device_register(& ff->dev);
#line 304
  if (ret < 0) {
#line 305
    put_device(& ff->dev);
#line 306
    tmp___1 = ERR_PTR((long )ret);
#line 306
    return ((struct ff_dev *)tmp___1);
  } else {

  }
#line 310
  i = 0;
#line 310
  goto ldv_19595;
  ldv_19594: 
#line 311
  tmp___2 = kmemdup((void const   *)(& ff_template_fmc), 1592UL, 208U);
#line 311
  fmc = (struct fmc_device *)tmp___2;
#line 313
  fmc->hwdev = & ff->dev;
#line 314
  fmc->carrier_data = (void *)ff;
#line 315
  fmc->nr_slots = ff_nr_dev;
#line 317
  fmc->eeprom = (uint8_t *)(& ff_eeimg) + (unsigned long )i;
#line 318
  fmc->eeprom_addr = (i + 40) * 2;
#line 319
  fmc->slot_id = i;
#line 320
  ff->fmc[i] = fmc;
#line 322
  ff_template_fmc.device_id = ff_template_fmc.device_id + 1U;
#line 310
  i = i + 1;
  ldv_19595: ;
#line 310
  if (i < ff_nr_dev) {
#line 312
    goto ldv_19594;
  } else {

  }

#line 324
  return (ff);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static int ff_init(void) 
{ 
  struct ff_dev *ff ;
  struct firmware  const  *fw ;
  int i ;
  int len ;
  int ret ;
  size_t __len ;
  void *__ret ;
  long tmp ;
  bool tmp___0 ;
  size_t tmp___1 ;
  size_t __min1 ;
  size_t __min2 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 332
  ret = 0;
#line 335
  i = 1;
#line 335
  goto ldv_19609;
  ldv_19608: 
#line 336
  __len = 8192UL;
#line 336
  if (__len > 63UL) {
#line 336
    __ret = __memcpy((void *)(& ff_eeimg) + (unsigned long )i, (void const   *)(& ff_eeimg),
                     __len);
  } else {
#line 336
    __ret = __builtin_memcpy((void *)(& ff_eeimg) + (unsigned long )i, (void const   *)(& ff_eeimg),
                             __len);
  }
#line 335
  i = i + 1;
  ldv_19609: ;
#line 335
  if (i <= 3) {
#line 337
    goto ldv_19608;
  } else {

  }

#line 338
  if (ff_nr_eeprom > ff_nr_dev) {
#line 339
    ff_nr_dev = ff_nr_eeprom;
  } else {

  }
#line 341
  ff = ff_dev_create();
#line 342
  tmp___0 = IS_ERR((void const   *)ff);
#line 342
  if ((int )tmp___0) {
#line 343
    tmp = PTR_ERR((void const   *)ff);
#line 343
    return ((int )tmp);
  } else {

  }
#line 346
  i = 0;
#line 346
  goto ldv_19619;
  ldv_19618: 
#line 347
  tmp___1 = strlen((char const   *)ff_eeprom[i]);
#line 347
  if (tmp___1 == 0UL) {
#line 348
    goto ldv_19611;
  } else {

  }
#line 349
  ret = request_firmware(& fw, (char const   *)ff_eeprom[i], & ff->dev);
#line 350
  if (ret < 0) {
#line 351
    dev_err((struct device  const  *)(& ff->dev), "Mezzanine %i: can\'t load \"%s\" (error %i)\n",
            i, ff_eeprom[i], - ret);
  } else {
#line 354
    __min1 = fw->size;
#line 354
    __min2 = 8192UL;
#line 354
    len = (int )(__min1 < __min2 ? __min1 : __min2);
#line 355
    __len___0 = (size_t )len;
#line 355
    __ret___0 = __builtin_memcpy((void *)(& ff_eeimg) + (unsigned long )i, (void const   *)fw->data,
                                 __len___0);
#line 356
    release_firmware(fw);
#line 357
    _dev_info((struct device  const  *)(& ff->dev), "Mezzanine %i: eeprom \"%s\"\n",
              i, ff_eeprom[i]);
  }
  ldv_19611: 
#line 346
  i = i + 1;
  ldv_19619: ;
#line 346
  if (i < ff_nr_eeprom) {
#line 348
    goto ldv_19618;
  } else {

  }
#line 362
  ret = fmc_device_register_n((struct fmc_device **)(& ff->fmc), ff_nr_dev);
#line 363
  if (ret != 0) {
#line 364
    device_unregister(& ff->dev);
#line 365
    return (ret);
  } else {

  }
#line 367
  ff_current_dev = ff;
#line 368
  return (ret);
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
static void ff_exit(void) 
{ 


  {
#line 373
  if ((unsigned long )ff_current_dev != (unsigned long )((struct ff_dev *)0)) {
#line 374
    fmc_device_unregister_n((struct fmc_device **)(& ff_current_dev->fmc), ff_nr_dev);
#line 375
    device_unregister(& ff_current_dev->dev);
  } else {

  }
#line 377
  cancel_delayed_work_sync(& ff_work);
#line 378
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int ldv_retval_0  ;
#line 386
extern int ldv_probe_1(void) ;
#line 387
extern void ldv_initialize(void) ;
#line 388
extern void ldv_check_final_state(void) ;
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
irqreturn_t (*ldvarg12)(int  , void * )  ;
#line 390
extern int ldv_release_1(void) ;
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
void ldv_initialize_fmc_operations_1(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 395
  tmp = ldv_zalloc(568UL);
#line 395
  ff_fmc_operations_group0 = (struct fmc_driver *)tmp;
#line 396
  tmp___0 = ldv_zalloc(1592UL);
#line 396
  ff_fmc_operations_group1 = (struct fmc_device *)tmp___0;
#line 397
  return;
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
int main(void) 
{ 
  char *ldvarg11 ;
  void *tmp ;
  int ldvarg7 ;
  int tmp___0 ;
  char *ldvarg3 ;
  void *tmp___1 ;
  int ldvarg0 ;
  int tmp___2 ;
  void *ldvarg5 ;
  void *tmp___3 ;
  int ldvarg6 ;
  int tmp___4 ;
  void *ldvarg8 ;
  void *tmp___5 ;
  uint32_t ldvarg1 ;
  int ldvarg4 ;
  int tmp___6 ;
  int ldvarg10 ;
  int tmp___7 ;
  int ldvarg9 ;
  int tmp___8 ;
  int ldvarg2 ;
  int tmp___9 ;
  struct work_struct *ldvarg14 ;
  void *tmp___10 ;
  unsigned long ldvarg13 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 409
  tmp = ldv_zalloc(1UL);
#line 409
  ldvarg11 = (char *)tmp;
#line 410
  tmp___0 = __VERIFIER_nondet_int();
#line 410
  ldvarg7 = tmp___0;
#line 411
  tmp___1 = ldv_zalloc(1UL);
#line 411
  ldvarg3 = (char *)tmp___1;
#line 412
  tmp___2 = __VERIFIER_nondet_int();
#line 412
  ldvarg0 = tmp___2;
#line 413
  tmp___3 = ldv_zalloc(1UL);
#line 413
  ldvarg5 = tmp___3;
#line 414
  tmp___4 = __VERIFIER_nondet_int();
#line 414
  ldvarg6 = tmp___4;
#line 415
  tmp___5 = ldv_zalloc(1UL);
#line 415
  ldvarg8 = tmp___5;
#line 417
  tmp___6 = __VERIFIER_nondet_int();
#line 417
  ldvarg4 = tmp___6;
#line 418
  tmp___7 = __VERIFIER_nondet_int();
#line 418
  ldvarg10 = tmp___7;
#line 419
  tmp___8 = __VERIFIER_nondet_int();
#line 419
  ldvarg9 = tmp___8;
#line 420
  tmp___9 = __VERIFIER_nondet_int();
#line 420
  ldvarg2 = tmp___9;
#line 421
  tmp___10 = ldv_zalloc(80UL);
#line 421
  ldvarg14 = (struct work_struct *)tmp___10;
#line 422
  tmp___11 = __VERIFIER_nondet_ulong();
#line 422
  ldvarg13 = tmp___11;
#line 407
  ldv_initialize();
#line 416
  memset((void *)(& ldvarg1), 0, 4UL);
#line 424
  ldv_state_variable_1 = 0;
#line 425
  ref_cnt = 0;
#line 426
  ldv_state_variable_0 = 1;
#line 427
  ldv_state_variable_2 = 0;
  ldv_19700: 
#line 429
  tmp___12 = __VERIFIER_nondet_int();
#line 429
  switch (tmp___12) {
  case 0: ;
#line 433
  if (ldv_state_variable_1 != 0) {
#line 434
    tmp___13 = __VERIFIER_nondet_int();
#line 434
    switch (tmp___13) {
    case 0: ;
#line 437
    if (ldv_state_variable_1 == 1) {
#line 439
      ff_validate(ff_fmc_operations_group1, ff_fmc_operations_group0);
#line 441
      ldv_state_variable_1 = 1;
    } else {

    }
#line 444
    if (ldv_state_variable_1 == 2) {
#line 446
      ff_validate(ff_fmc_operations_group1, ff_fmc_operations_group0);
#line 448
      ldv_state_variable_1 = 2;
    } else {

    }
#line 451
    goto ldv_19677;
    case 1: ;
#line 454
    if (ldv_state_variable_1 == 1) {
#line 456
      ff_irq_request(ff_fmc_operations_group1, ldvarg12, ldvarg11, ldvarg10);
#line 458
      ldv_state_variable_1 = 1;
    } else {

    }
#line 461
    if (ldv_state_variable_1 == 2) {
#line 463
      ff_irq_request(ff_fmc_operations_group1, ldvarg12, ldvarg11, ldvarg10);
#line 465
      ldv_state_variable_1 = 2;
    } else {

    }
#line 468
    goto ldv_19677;
    case 2: ;
#line 471
    if (ldv_state_variable_1 == 2) {
#line 473
      ff_write_ee(ff_fmc_operations_group1, ldvarg9, (void const   *)ldvarg8, ldvarg7);
#line 475
      ldv_state_variable_1 = 2;
    } else {

    }
#line 478
    goto ldv_19677;
    case 3: ;
#line 481
    if (ldv_state_variable_1 == 2) {
#line 483
      ff_read_ee(ff_fmc_operations_group1, ldvarg6, ldvarg5, ldvarg4);
#line 485
      ldv_state_variable_1 = 2;
    } else {

    }
#line 488
    goto ldv_19677;
    case 4: ;
#line 491
    if (ldv_state_variable_1 == 1) {
#line 493
      ff_reprogram(ff_fmc_operations_group1, ff_fmc_operations_group0, ldvarg3);
#line 495
      ldv_state_variable_1 = 1;
    } else {

    }
#line 498
    if (ldv_state_variable_1 == 2) {
#line 500
      ff_reprogram(ff_fmc_operations_group1, ff_fmc_operations_group0, ldvarg3);
#line 502
      ldv_state_variable_1 = 2;
    } else {

    }
#line 505
    goto ldv_19677;
    case 5: ;
#line 508
    if (ldv_state_variable_1 == 1) {
#line 510
      ff_readl(ff_fmc_operations_group1, ldvarg2);
#line 512
      ldv_state_variable_1 = 1;
    } else {

    }
#line 515
    if (ldv_state_variable_1 == 2) {
#line 517
      ff_readl(ff_fmc_operations_group1, ldvarg2);
#line 519
      ldv_state_variable_1 = 2;
    } else {

    }
#line 522
    goto ldv_19677;
    case 6: ;
#line 525
    if (ldv_state_variable_1 == 1) {
#line 527
      ff_writel(ff_fmc_operations_group1, ldvarg1, ldvarg0);
#line 529
      ldv_state_variable_1 = 1;
    } else {

    }
#line 532
    if (ldv_state_variable_1 == 2) {
#line 534
      ff_writel(ff_fmc_operations_group1, ldvarg1, ldvarg0);
#line 536
      ldv_state_variable_1 = 2;
    } else {

    }
#line 539
    goto ldv_19677;
    case 7: ;
#line 542
    if (ldv_state_variable_1 == 2) {
#line 544
      ldv_release_1();
#line 546
      ldv_state_variable_1 = 1;
#line 547
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 550
    goto ldv_19677;
    case 8: ;
#line 553
    if (ldv_state_variable_1 == 1) {
#line 555
      ldv_probe_1();
#line 557
      ldv_state_variable_1 = 2;
#line 558
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 561
    goto ldv_19677;
    default: 
#line 562
    ldv_stop();
    }
    ldv_19677: ;
  } else {

  }
#line 566
  goto ldv_19687;
  case 1: ;
#line 570
  if (ldv_state_variable_0 != 0) {
#line 571
    tmp___14 = __VERIFIER_nondet_int();
#line 571
    switch (tmp___14) {
    case 0: ;
#line 574
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 576
      ff_exit();
#line 577
      ldv_state_variable_0 = 2;
#line 578
      goto ldv_final;
    } else {

    }
#line 581
    goto ldv_19691;
    case 1: ;
#line 584
    if (ldv_state_variable_0 == 1) {
#line 586
      ldv_retval_0 = ff_init();
#line 588
      if (ldv_retval_0 == 0) {
#line 589
        ldv_state_variable_0 = 3;
#line 590
        ldv_state_variable_2 = 1;
#line 591
        ldv_state_variable_1 = 1;
#line 592
        ldv_initialize_fmc_operations_1();
      } else {

      }
#line 594
      if (ldv_retval_0 != 0) {
#line 595
        ldv_state_variable_0 = 2;
#line 596
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 600
    goto ldv_19691;
    default: 
#line 601
    ldv_stop();
    }
    ldv_19691: ;
  } else {

  }
#line 605
  goto ldv_19687;
  case 2: ;
#line 609
  if (ldv_state_variable_2 != 0) {
#line 610
    tmp___15 = __VERIFIER_nondet_int();
#line 610
    switch (tmp___15) {
    case 0: ;
#line 613
    if (ldv_state_variable_2 == 1) {
#line 615
      ff_work_fn(ldvarg14);
#line 617
      ldv_state_variable_2 = 1;
    } else {

    }
#line 620
    goto ldv_19696;
    case 1: ;
#line 623
    if (ldv_state_variable_2 == 1) {
#line 625
      delayed_work_timer_fn(ldvarg13);
#line 627
      ldv_state_variable_2 = 1;
    } else {

    }
#line 630
    goto ldv_19696;
    default: 
#line 631
    ldv_stop();
    }
    ldv_19696: ;
  } else {

  }
#line 635
  goto ldv_19687;
  default: 
#line 636
  ldv_stop();
  }
  ldv_19687: ;
#line 638
  goto ldv_19700;
  ldv_final: 
#line 640
  ldv_check_final_state();
#line 641
  return 0;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 774
  ldv_check_alloc_flags(flags);
#line 776
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 777
  return ((void *)0);
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/dscv/ri/43_2a/drivers/fmc/fmc-fakedev.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 782
  ldv_check_alloc_flags(flags);
#line 783
  return ((void *)0);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/882/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
