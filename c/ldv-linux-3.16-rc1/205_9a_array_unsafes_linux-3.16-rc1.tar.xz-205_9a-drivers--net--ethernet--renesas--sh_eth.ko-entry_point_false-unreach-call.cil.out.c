extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 163 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 168 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1016_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1031_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1032_8 {
   struct __anonstruct_ldv_1016_9 ldv_1016 ;
   struct __anonstruct_ldv_1031_10 ldv_1031 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1032_8 ldv_1032 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 395 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1452_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1452_15 ldv_1452 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2969_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2969_20 ldv_2969 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5280_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5286_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5287_24 {
   struct __anonstruct_ldv_5280_25 ldv_5280 ;
   struct __anonstruct_ldv_5286_26 ldv_5286 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5287_24 ldv_5287 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5296_27 ldv_5296 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6337_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6338_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6337_31 ldv_6337 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6338_30 ldv_6338 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct optimistic_spin_queue;
#line 88
struct rw_semaphore;
#line 89 "include/linux/rbtree.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 920 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 113 "include/linux/completion.h"
struct vm_area_struct;
#line 114
struct inode;
#line 115
struct notifier_block;
#line 59 "include/linux/uprobes.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178 "include/linux/mutex.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
#line 10 "include/linux/mmdebug.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 72 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 167 "./arch/x86/include/asm/mpspec.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_98 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_98 nodemask_t;
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_99 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_99 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_12049_131 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_12053_132 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_12054_130 {
   struct __anonstruct_ldv_12049_131 ldv_12049 ;
   struct __anonstruct_ldv_12053_132 ldv_12053 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_12054_130 ldv_12054 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12163_133 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12169_135 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_12179_139 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12181_138 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_12179_139 ldv_12179 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_12183_137 {
   union __anonunion_ldv_12181_138 ldv_12181 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12185_136 {
   unsigned long counters ;
   struct __anonstruct_ldv_12183_137 ldv_12183 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_12186_134 {
   union __anonunion_ldv_12169_135 ldv_12169 ;
   union __anonunion_ldv_12185_136 ldv_12185 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_12193_141 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12198_140 {
   struct list_head lru ;
   struct __anonstruct_ldv_12193_141 ldv_12193 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_12204_142 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_12163_133 ldv_12163 ;
   struct __anonstruct_ldv_12186_134 ldv_12186 ;
   union __anonunion_ldv_12198_140 ldv_12198 ;
   union __anonunion_ldv_12204_142 ldv_12204 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_144 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_143 {
   struct __anonstruct_linear_144 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_143 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 217 "./include/uapi/asm-generic/fcntl.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion_ldv_12534_145 {
   struct iovec  const  *iov ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_12534_145 ldv_12534 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 18
struct cred;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 54 "include/uapi/linux/net.h"
struct poll_table_struct;
#line 55
struct pipe_inode_info;
#line 56
struct net;
#line 73
struct fasync_struct;
#line 94 "include/linux/net.h"
struct sock;
#line 120
struct kiocb;
#line 906 "include/linux/mmzone.h"
struct ctl_table;
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 338 "include/linux/slab.h"
union __anonunion_ldv_13917_146 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 338 "include/linux/slab.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_13917_146 ldv_13917 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14061_147 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14061_147 ldv_14061 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct kobject;
#line 463
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 469 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_148 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_148 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_149 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_149 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct bin_attribute;
#line 37 "include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 252 "include/linux/kobject.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 501 "include/linux/slab.h"
struct __anonstruct_ldv_14953_151 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 501 "include/linux/slab.h"
struct __anonstruct_ldv_14959_152 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 501 "include/linux/slab.h"
union __anonunion_ldv_14960_150 {
   struct __anonstruct_ldv_14953_151 ldv_14953 ;
   struct __anonstruct_ldv_14959_152 ldv_14959 ;
};
#line 501 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_14960_150 ldv_14960 ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 155
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "./arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195
struct of_device_id;
#line 195
struct acpi_device_id;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 2112 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 38 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1153 "include/linux/dmaengine.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 474 "include/linux/hrtimer.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 218 "include/linux/capability.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_155 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_155 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_157 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_158 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_159 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_160 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_161 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_162 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_163 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_156 {
   int _pad[28U] ;
   struct __anonstruct__kill_157 _kill ;
   struct __anonstruct__timer_158 _timer ;
   struct __anonstruct__rt_159 _rt ;
   struct __anonstruct__sigchld_160 _sigchld ;
   struct __anonstruct__sigfault_161 _sigfault ;
   struct __anonstruct__sigpoll_162 _sigpoll ;
   struct __anonstruct__sigsys_163 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_156 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 459
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 466
struct pid_namespace;
#line 466 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_22930_167 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_22932_166 {
   struct __anonstruct_ldv_22930_167 ldv_22930 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_22932_166 ldv_22932 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 193
struct assoc_array_ptr;
#line 193 "include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_23076_168 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_23084_169 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_23097_171 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_23098_170 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_23097_171 ldv_23097 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_172 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_174 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_23113_173 {
   union __anonunion_payload_174 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_23076_168 ldv_23076 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_23084_169 ldv_23084 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_23098_170 ldv_23098 ;
   union __anonunion_type_data_172 type_data ;
   union __anonunion_ldv_23113_173 ldv_23113 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct tty_struct;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct backing_dev_info;
#line 779
struct reclaim_state;
#line 780 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1026
struct io_context;
#line 1060
struct uts_namespace;
#line 1061 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct files_struct;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 18 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 137 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 147 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 360 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 361 "include/linux/skbuff.h"
struct __anonstruct_ldv_24862_179 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 361 "include/linux/skbuff.h"
union __anonunion_ldv_24863_178 {
   u64 v64 ;
   struct __anonstruct_ldv_24862_179 ldv_24862 ;
};
#line 361 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_ldv_24863_178 ldv_24863 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_24882_180 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 414
struct sec_path;
#line 414 "include/linux/skbuff.h"
struct __anonstruct_ldv_24898_182 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_24899_181 {
   __wsum csum ;
   struct __anonstruct_ldv_24898_182 ldv_24898 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_24938_183 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_24944_184 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 414 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_24882_180 ldv_24882 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_24899_181 ldv_24899 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_24938_183 ldv_24938 ;
   __u32 secmark ;
   union __anonunion_ldv_24944_184 ldv_24944 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 641
struct dst_entry;
#line 17 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct mdiobb_ctrl;
#line 45
struct platform_device;
#line 69
struct ethtool_ringparam;
#line 71
struct ethtool_cmd;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
struct kernel_param;
#line 53 "include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_26733_189 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_26733_189 ldv_26733 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 359 "include/linux/irq.h"
struct proc_dir_entry;
#line 450 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 663 "include/linux/interrupt.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 84 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 48 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 53
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 59 "include/linux/pm_qos.h"
union __anonunion_data_192 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 59 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_192 data ;
   struct device *dev ;
};
#line 68
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 74 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 88 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 93 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 54 "include/linux/delay.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_193 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_193 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_194 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_194 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_195 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_195 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_196 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_196 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_197 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_197 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_198 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_198 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_199 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_199 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_200 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_200 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_201 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_202 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_201 ifr_ifrn ;
   union __anonunion_ifr_ifru_202 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_29109_205 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_29110_204 {
   struct __anonstruct_ldv_29109_205 ldv_29109 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_29110_204 ldv_29110 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct_ldv_29133_207 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion_ldv_29135_206 {
   struct __anonstruct_ldv_29133_207 ldv_29133 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_29135_206 ldv_29135 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_208 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_208 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_29496_210 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_29498_209 {
   struct __anonstruct_ldv_29496_210 ldv_29496 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_29498_209 ldv_29498 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct kstatfs;
#line 62
struct swap_info_struct;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_211 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_211 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_30023_212 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_30023_212 ldv_30023 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30437_215 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30457_216 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30474_217 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_30437_215 ldv_30437 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_30457_216 ldv_30457 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_30474_217 ldv_30474 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_218 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_218 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_220 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_219 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_220 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_219 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 703 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 187 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 211 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 259 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 288 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 305 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 441 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 469 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 568 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 600 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 642 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 675 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 691 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 711 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 722 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 741 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 767 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 933 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 941 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1017 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[103U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 102
struct neighbour;
#line 102 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 35 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 35
struct rt6_info;
#line 35
struct rt6_statistics;
#line 35
struct fib6_table;
#line 35 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 80 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 86 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
#line 21
struct sctp_mib;
#line 22 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 324 "include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 24 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 29 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 43 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 48 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 53 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 64 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 72
struct ip_conntrack_stat;
#line 72
struct nf_ct_event_notifier;
#line 72
struct nf_exp_event_notifier;
#line 72 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 111
struct nft_af_info;
#line 112 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 499 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 17 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 74
struct net_generic;
#line 75
struct netns_ipvs;
#line 76 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 400 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 205 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 919 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 3161 "include/linux/security.h"
struct mnt_namespace;
#line 3162
struct ipc_namespace;
#line 3163 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 180 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 547 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 28 "include/linux/if_link.h"
struct netpoll_info;
#line 29
struct phy_device;
#line 30
struct wireless_dev;
#line 61 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 106 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 125 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 186
struct neigh_parms;
#line 187 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 207 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 212 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 241 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 292 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 336
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 384 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 385 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 522
struct Qdisc;
#line 522 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 591 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 603 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 615 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 666 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 689 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 724 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 740 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 753 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_adj_list_246 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_247 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187
struct iw_handler_def;
#line 1187
struct iw_public_data;
#line 1187
struct forwarding_accel_ops;
#line 1187
struct vlan_info;
#line 1187
struct tipc_bearer;
#line 1187
struct in_device;
#line 1187
struct dn_dev;
#line 1187
struct inet6_dev;
#line 1187
struct cpu_rmap;
#line 1187
struct pcpu_lstats;
#line 1187
struct pcpu_sw_netstats;
#line 1187
struct pcpu_dstats;
#line 1187
struct pcpu_vstats;
#line 1187 "include/linux/netdevice.h"
union __anonunion_ldv_40087_248 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1187
struct garp_port;
#line 1187
struct mrp_port;
#line 1187
struct rtnl_link_ops;
#line 1187 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_246 adj_list ;
   struct __anonstruct_all_adj_list_247 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_40087_248 ldv_40087 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1806 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2548
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 479 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 628
struct mfd_cell;
#line 629 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 172 "include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
   bool prevent_deferred_probe ;
};
#line 338 "include/linux/mii.h"
enum ldv_30861 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_30861 phy_interface_t;
#line 126
enum ldv_30913 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_30913 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   int *irq ;
};
#line 211
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 226 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 320
struct phy_driver;
#line 320 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 423 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   struct device_driver driver ;
};
#line 721 "include/linux/phy.h"
struct mdiobb_ops {
   struct module *owner ;
   void (*set_mdc)(struct mdiobb_ctrl * , int  ) ;
   void (*set_mdio_dir)(struct mdiobb_ctrl * , int  ) ;
   void (*set_mdio_data)(struct mdiobb_ctrl * , int  ) ;
   int (*get_mdio_data)(struct mdiobb_ctrl * ) ;
};
#line 32 "include/linux/mdio-bitbang.h"
struct mdiobb_ctrl {
   struct mdiobb_ops  const  *ops ;
   int (*reset)(struct mii_bus * ) ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 42 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 417 "include/linux/clk.h"
struct sh_eth_plat_data {
   int phy ;
   int phy_irq ;
   int edmac_endian ;
   phy_interface_t phy_interface ;
   void (*set_mdio_gate)(void * ) ;
   unsigned char mac_addr[6U] ;
   unsigned char no_ether_link : 1 ;
   unsigned char ether_link_active_low : 1 ;
   unsigned char needs_init : 1 ;
};
#line 453 "include/linux/of_mdio.h"
struct sh_eth_txdesc {
   u32 status ;
   u16 pad0 ;
   u16 buffer_length ;
   u32 addr ;
   u32 pad1 ;
};
#line 434 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
struct sh_eth_rxdesc {
   u32 status ;
   u16 frame_length ;
   u16 buffer_length ;
   u32 addr ;
   u32 pad0 ;
};
#line 450 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
struct sh_eth_cpu_data {
   void (*chip_reset)(struct net_device * ) ;
   void (*set_duplex)(struct net_device * ) ;
   void (*set_rate)(struct net_device * ) ;
   int register_type ;
   unsigned long eesipr_value ;
   unsigned long ecsr_value ;
   unsigned long ecsipr_value ;
   unsigned long fdr_value ;
   unsigned long fcftr_value ;
   unsigned long rpadir_value ;
   unsigned long tx_check ;
   unsigned long eesr_err_check ;
   unsigned long irq_flags ;
   unsigned char no_psr : 1 ;
   unsigned char apr : 1 ;
   unsigned char mpr : 1 ;
   unsigned char tpauser : 1 ;
   unsigned char bculr : 1 ;
   unsigned char tsu : 1 ;
   unsigned char hw_swap : 1 ;
   unsigned char rpadir : 1 ;
   unsigned char no_trimd : 1 ;
   unsigned char no_ade : 1 ;
   unsigned char hw_crc : 1 ;
   unsigned char select_mii : 1 ;
   unsigned char shift_rd0 : 1 ;
   unsigned char rmiimode : 1 ;
};
#line 490 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
struct sh_eth_private {
   struct platform_device *pdev ;
   struct sh_eth_cpu_data *cd ;
   u16 const   *reg_offset ;
   void *addr ;
   void *tsu_addr ;
   u32 num_rx_ring ;
   u32 num_tx_ring ;
   dma_addr_t rx_desc_dma ;
   dma_addr_t tx_desc_dma ;
   struct sh_eth_rxdesc *rx_ring ;
   struct sh_eth_txdesc *tx_ring ;
   struct sk_buff **rx_skbuff ;
   struct sk_buff **tx_skbuff ;
   spinlock_t lock ;
   u32 cur_rx ;
   u32 dirty_rx ;
   u32 cur_tx ;
   u32 dirty_tx ;
   u32 rx_buf_sz ;
   int edmac_endian ;
   struct napi_struct napi ;
   u32 phy_id ;
   struct mii_bus *mii_bus ;
   struct phy_device *phydev ;
   int link ;
   phy_interface_t phy_interface ;
   int msg_enable ;
   int speed ;
   int duplex ;
   int port ;
   int vlan_num_ids ;
   unsigned char no_ether_link : 1 ;
   unsigned char ether_link_active_low : 1 ;
};
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct bb_info {
   void (*set_gate)(void * ) ;
   struct mdiobb_ctrl ctrl ;
   void *addr ;
   u32 mmd_msk ;
   u32 mdo_msk ;
   u32 mdi_msk ;
   u32 mdc_msk ;
};
#line 4520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
typedef int ldv_func_ret_type;
#line 4549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
typedef int ldv_func_ret_type___0;
#line 4586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
typedef int ldv_func_ret_type___1;
#line 484 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_257 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 484 "include/linux/skbuff.h"
union __anonunion____missing_field_name_256 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_257 __annonCompField63 ;
};
#line 484 "include/linux/skbuff.h"
union __anonunion____missing_field_name_258 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 484 "include/linux/skbuff.h"
union __anonunion____missing_field_name_259 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 484 "include/linux/skbuff.h"
struct sk_buff___0 {
   struct sk_buff___0 *next ;
   struct sk_buff___0 *prev ;
   union __anonunion_ldv_24882_180 __annonCompField62 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48]  __attribute__((__aligned__(8))) ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion____missing_field_name_256 __annonCompField64 ;
   __u32 priority ;
   __u8 ignore_df : 1 ;
   __u8 cloned : 1 ;
   __u8 ip_summed : 2 ;
   __u8 nohdr : 1 ;
   __u8 nfctinfo : 3 ;
   __u8 pkt_type : 3 ;
   __u8 fclone : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 peeked : 1 ;
   __u8 nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff___0 *skb ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   __u8 ndisc_nodetype : 2 ;
   __u8 pfmemalloc : 1 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_hash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 head_frag : 1 ;
   __u8 encapsulation : 1 ;
   __u8 encap_hdr_csum : 1 ;
   __u8 csum_valid : 1 ;
   __u8 csum_complete_sw : 1 ;
   union __anonunion____missing_field_name_258 __annonCompField65 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_259 __annonCompField66 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 4 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
typedef void *Element;
#line 5 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
typedef Element Set;
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 358 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 165 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 391
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 5
void *ldv_err_ptr(long error ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 802 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 804
  if (tmp != 0L) {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
    ldv_4822: ;
#line 804
    goto ldv_4822;
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 155 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 8 "include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 17 "include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
#line 19
  __local_bh_disable_ip((unsigned long )((void *)0), 512U);
#line 21
  return;
}
}
#line 23
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 30 "include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
#line 32
  __local_bh_enable_ip((unsigned long )((void *)0), 512U);
#line 34
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 32
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6338.rlock);
}
}
#line 301 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 303
  _raw_spin_lock(& lock->ldv_6338.rlock);
#line 304
  return;
}
}
#line 341 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 343
  _raw_spin_unlock(& lock->ldv_6338.rlock);
#line 344
  return;
}
}
#line 356 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 358
  _raw_spin_unlock_irqrestore(& lock->ldv_6338.rlock, flags);
#line 359
  return;
}
}
#line 112 "./arch/x86/include/asm/io.h"
__inline static phys_addr_t virt_to_phys(void volatile   *address ) 
{ 
  unsigned long tmp ;

  {
#line 114
  tmp = __phys_addr((unsigned long )address);
#line 114
  return ((phys_addr_t )tmp);
}
}
#line 130 "./arch/x86/include/asm/io.h"
__inline static void *phys_to_virt(phys_addr_t address ) 
{ 


  {
#line 132
  return ((void *)((unsigned long )address + 0xffff880000000000UL));
}
}
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 174 "include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 16 "include/linux/random.h"
extern void get_random_bytes(void * , int  ) ;
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 315
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 559 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 561
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 562
    return ((void *)0);
  } else {

  }
#line 563
  tmp = __kmalloc(n * size, flags);
#line 563
  return (tmp);
}
}
#line 607 "include/linux/device.h"
extern void *devm_kmalloc(struct device * , size_t  , gfp_t  ) ;
#line 608 "include/linux/device.h"
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) 
{ 
  void *tmp ;

  {
#line 610
  tmp = devm_kmalloc(dev, size, gfp | 32768U);
#line 610
  return (tmp);
}
}
#line 612 "include/linux/device.h"
__inline static void *devm_kmalloc_array(struct device *dev , size_t n , size_t size ,
                                         gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 615
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 616
    return ((void *)0);
  } else {

  }
#line 617
  tmp = devm_kmalloc(dev, n * size, flags);
#line 617
  return (tmp);
}
}
#line 633
extern void *devm_ioremap_resource(struct device * , struct resource * ) ;
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 954 "include/linux/device.h"
__inline static void *dev_get_platdata(struct device  const  *dev ) 
{ 


  {
#line 956
  return ((void *)dev->platform_data);
}
}
#line 1042
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1044
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 69 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 71
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 76 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 78
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 59
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 27 "./arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_20746: ;
#line 19
    goto ldv_20746;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_20755: ;
#line 36
    goto ldv_20755;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 97 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 101
  tmp = get_dma_ops(dev);
#line 101
  ops = tmp;
#line 103
  tmp___0 = valid_dma_direction((int )dir);
#line 103
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 103
  if (tmp___1 != 0L) {
#line 103
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (103), "i" (12UL));
    ldv_20805: ;
#line 103
    goto ldv_20805;
  } else {

  }
#line 104
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 107
  return;
}
}
#line 103 "./arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "./arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "./arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "./arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("./arch/x86/include/asm/dma-mapping.h", 166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 717 "include/linux/skbuff.h"
void ldv_kfree_skb_6(struct sk_buff *ldv_func_arg1 ) ;
#line 721
void ldv_kfree_skb_7(struct sk_buff *ldv_func_arg1 ) ;
#line 725
void ldv_kfree_skb_8(struct sk_buff *ldv_func_arg1 ) ;
#line 729
void ldv_kfree_skb_11(struct sk_buff *ldv_func_arg1 ) ;
#line 736
void ldv_consume_skb_5(struct sk_buff *ldv_func_arg1 ) ;
#line 1565
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 1666 "include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
#line 1668
  skb->data = skb->data + (unsigned long )len;
#line 1669
  skb->tail = skb->tail + (sk_buff_data_t )len;
#line 1670
  return;
}
}
#line 2046
__inline static struct sk_buff *ldv_netdev_alloc_skb_12(struct net_device *dev , unsigned int length ) ;
#line 2050
__inline static struct sk_buff *ldv_netdev_alloc_skb_12(struct net_device *dev , unsigned int length ) ;
#line 3118 "include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 3120
  return;
}
}
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
extern struct sk_buff___0 *ldv_skb_alloc(void) ;
#line 12
extern void ldv_skb_free(struct sk_buff___0 * ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 21
extern u32 __VERIFIER_nondet_u32(void) ;
#line 22
extern u16 __VERIFIER_nondet_u16(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_8  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_15  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_0  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_5  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_13  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_12  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh_eth_ethtool_ops_group2  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct device *sh_eth_dev_pm_ops_group1  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh_eth_netdev_ops_group1  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_14  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh7763_data_group0  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct mdiobb_ctrl *bb_ops_group0  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *r8a777x_data_group0  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_9  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh7734_data_group0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh7724_data_group0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh7757_data_group0  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ref_cnt  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_1  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_7  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct platform_device *sh_eth_driver_group0  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_10  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *r8a7740_data_group0  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *r8a779x_data_group0  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_6  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_16  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh7757_data_giga_group0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_2  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_11  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *sh_eth_netdev_ops_tsu_group1  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct net_device *r7s72100_data_group0  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_3  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct ethtool_ringparam *sh_eth_ethtool_ops_group1  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_state_variable_4  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct ethtool_cmd *sh_eth_ethtool_ops_group0  ;
#line 72
void ldv_initialize_sh_eth_cpu_data_13(void) ;
#line 73
void ldv_initialize_sh_eth_cpu_data_11(void) ;
#line 74
void ldv_initialize_platform_driver_2(void) ;
#line 75
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 76
void ldv_net_device_ops_4(void) ;
#line 77
void ldv_initialize_sh_eth_cpu_data_10(void) ;
#line 78
void ldv_initialize_ethtool_ops_6(void) ;
#line 79
void choose_interrupt_1(void) ;
#line 80
void ldv_initialize_sh_eth_cpu_data_9(void) ;
#line 81
void ldv_net_device_ops_5(void) ;
#line 82
void ldv_initialize_mdiobb_ops_7(void) ;
#line 83
void ldv_initialize_sh_eth_cpu_data_8(void) ;
#line 84
void disable_suitable_irq_1(int line , void *data ) ;
#line 85
int ldv_irq_1(int state , int line , void *data ) ;
#line 86
void activate_suitable_irq_1(int line , void *data ) ;
#line 87
void ldv_initialize_sh_eth_cpu_data_15(void) ;
#line 89
void ldv_initialize_sh_eth_cpu_data_16(void) ;
#line 90
void ldv_initialize_sh_eth_cpu_data_12(void) ;
#line 91
void ldv_dev_pm_ops_3(void) ;
#line 92
void ldv_initialize_sh_eth_cpu_data_14(void) ;
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 123 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_14(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 149
void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 153
void ldv_free_irq_16(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 65 "include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 387 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 389 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 391
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
#line 391
  return (tmp != 0);
}
}
#line 403 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 405
  tmp = napi_disable_pending(n);
#line 405
  if (tmp) {
#line 405
    tmp___0 = 0;
  } else {
#line 405
    tmp___0 = 1;
  }
#line 405
  if (tmp___0) {
#line 405
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 405
    if (tmp___1 == 0) {
#line 405
      tmp___2 = 1;
    } else {
#line 405
      tmp___2 = 0;
    }
  } else {
#line 405
    tmp___2 = 0;
  }
#line 405
  return ((bool )tmp___2);
}
}
#line 439
extern void napi_complete(struct napi_struct * ) ;
#line 474 "include/linux/netdevice.h"
__inline static void napi_disable(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 476
  __might_sleep("include/linux/netdevice.h", 476, 0);
#line 477
  set_bit(1L, (unsigned long volatile   *)(& n->state));
#line 478
  goto ldv_39580;
  ldv_39579: 
#line 479
  msleep(1U);
  ldv_39580: 
#line 478
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 478
  if (tmp != 0) {
#line 480
    goto ldv_39579;
  } else {

  }
#line 480
  clear_bit(1L, (unsigned long volatile   *)(& n->state));
#line 481
  return;
}
}
#line 490 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 492
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 492
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 492
  if (tmp___0 != 0L) {
#line 492
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (492), "i" (12UL));
    ldv_39585: ;
#line 492
    goto ldv_39585;
  } else {

  }
#line 493
  __asm__  volatile   ("": : : "memory");
#line 494
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
#line 495
  return;
}
}
#line 1621 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1624
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1687 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1689
  return ((void *)dev + 3264U);
}
}
#line 1718
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1727
extern void netif_napi_del(struct napi_struct * ) ;
#line 1975
extern void free_netdev(struct net_device * ) ;
#line 1978
void ldv_free_netdev_18(struct net_device *dev ) ;
#line 1982
void ldv_free_netdev_20(struct net_device *dev ) ;
#line 2148
extern void __netif_schedule(struct Qdisc * ) ;
#line 2164 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2166
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2167
  return;
}
}
#line 2175 "include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2177
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2177
  netif_tx_start_queue(tmp);
#line 2178
  return;
}
}
#line 2190 "include/linux/netdevice.h"
__inline static void netif_tx_wake_queue(struct netdev_queue *dev_queue ) 
{ 
  int tmp ;

  {
#line 2192
  tmp = test_and_clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2192
  if (tmp != 0) {
#line 2193
    __netif_schedule(dev_queue->qdisc);
  } else {

  }
#line 2194
  return;
}
}
#line 2195 "include/linux/netdevice.h"
__inline static void netif_wake_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2197
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2197
  netif_tx_wake_queue(tmp);
#line 2198
  return;
}
}
#line 2210 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 2212
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 2212
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp != 0L) {
#line 2212
    warn_slowpath_null("include/linux/netdevice.h", 2212);
  } else {

  }
#line 2212
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp___0 != 0L) {
#line 2213
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
#line 2214
    return;
  } else {

  }
#line 2216
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2217
  return;
}
}
#line 2226 "include/linux/netdevice.h"
__inline static void netif_stop_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2228
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2228
  netif_tx_stop_queue(tmp);
#line 2229
  return;
}
}
#line 2398 "include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2400
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
#line 2400
  return (tmp != 0);
}
}
#line 2554
extern void __dev_kfree_skb_irq(struct sk_buff * , enum skb_free_reason  ) ;
#line 2576 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_irq(struct sk_buff *skb ) 
{ 


  {
#line 2578
  __dev_kfree_skb_irq(skb, 1);
#line 2579
  return;
}
}
#line 2598
extern int netif_receive_skb(struct sk_buff * ) ;
#line 2818 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 2820
  spin_lock(& txq->_xmit_lock);
#line 2821
  txq->xmit_lock_owner = cpu;
#line 2822
  return;
}
}
#line 2838 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 2840
  txq->xmit_lock_owner = -1;
#line 2841
  spin_unlock(& txq->_xmit_lock);
#line 2842
  return;
}
}
#line 2930 "include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2935
  local_bh_disable();
#line 2936
  __vpp_verify = (void const   *)0;
#line 2936
  switch (4UL) {
  case 1UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_41068;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_41068;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_41068;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_41068;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_41068: 
#line 2936
  pscr_ret__ = pfo_ret__;
#line 2936
  goto ldv_41074;
  case 2UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_41078;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_41078;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_41078;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_41078;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_41078: 
#line 2936
  pscr_ret__ = pfo_ret_____0;
#line 2936
  goto ldv_41074;
  case 4UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_41087;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_41087;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_41087;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_41087;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_41087: 
#line 2936
  pscr_ret__ = pfo_ret_____1;
#line 2936
  goto ldv_41074;
  case 8UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_41096;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_41096;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_41096;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_41096;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_41096: 
#line 2936
  pscr_ret__ = pfo_ret_____2;
#line 2936
  goto ldv_41074;
  default: 
#line 2936
  __bad_size_call_parameter();
#line 2936
  goto ldv_41074;
  }
  ldv_41074: 
#line 2936
  cpu = pscr_ret__;
#line 2937
  i = 0U;
#line 2937
  goto ldv_41106;
  ldv_41105: 
#line 2938
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2938
  txq = tmp;
#line 2940
  __netif_tx_lock(txq, cpu);
#line 2941
  netif_tx_stop_queue(txq);
#line 2942
  __netif_tx_unlock(txq);
#line 2937
  i = i + 1U;
  ldv_41106: ;
#line 2937
  if (dev->num_tx_queues > i) {
#line 2939
    goto ldv_41105;
  } else {

  }
#line 2944
  local_bh_enable();
#line 2945
  return;
}
}
#line 2998
extern int register_netdev(struct net_device * ) ;
#line 3001
int ldv_register_netdev_17(struct net_device *dev ) ;
#line 3003
extern void unregister_netdev(struct net_device * ) ;
#line 3006
void ldv_unregister_netdev_19(struct net_device *dev ) ;
#line 3395
extern int netdev_err(struct net_device  const  * , char const   *  , ...) ;
#line 3397
extern int netdev_warn(struct net_device  const  * , char const   *  , ...) ;
#line 3401
extern int netdev_info(struct net_device  const  * , char const   *  , ...) ;
#line 32 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 45
extern int eth_mac_addr(struct net_device * , void * ) ;
#line 46
extern int eth_change_mtu(struct net_device * , int  ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 89 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 92
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 107 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 109
  return (((int )*addr & 1) != 0);
}
}
#line 160 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 164
  tmp = is_multicast_ether_addr(addr);
#line 164
  if (tmp) {
#line 164
    tmp___0 = 0;
  } else {
#line 164
    tmp___0 = 1;
  }
#line 164
  if (tmp___0) {
#line 164
    tmp___1 = is_zero_ether_addr(addr);
#line 164
    if (tmp___1) {
#line 164
      tmp___2 = 0;
    } else {
#line 164
      tmp___2 = 1;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___3 = 1;
    } else {
#line 164
      tmp___3 = 0;
    }
  } else {
#line 164
    tmp___3 = 0;
  }
#line 164
  return ((bool )tmp___3);
}
}
#line 174 "include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr ) 
{ 


  {
#line 176
  get_random_bytes((void *)addr, 6);
#line 177
  *addr = (unsigned int )*addr & 254U;
#line 178
  *addr = (u8 )((unsigned int )*addr | 2U);
#line 179
  return;
}
}
#line 214 "include/linux/etherdevice.h"
__inline static void eth_hw_addr_random(struct net_device *dev ) 
{ 


  {
#line 216
  dev->addr_assign_type = 1U;
#line 217
  eth_random_addr(dev->dev_addr);
#line 218
  return;
}
}
#line 266 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 269
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 272
  return (fold == 0U);
}
}
#line 50 "include/linux/platform_device.h"
extern struct resource *platform_get_resource(struct platform_device * , unsigned int  ,
                                              unsigned int  ) ;
#line 52
extern int platform_get_irq(struct platform_device * , unsigned int  ) ;
#line 192
extern int __platform_driver_register(struct platform_driver * , struct module * ) ;
#line 196
int ldv___platform_driver_register_21(struct platform_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ) ;
#line 198
extern void platform_driver_unregister(struct platform_driver * ) ;
#line 201
void ldv_platform_driver_unregister_22(struct platform_driver *drv ) ;
#line 210 "include/linux/platform_device.h"
__inline static void *platform_get_drvdata(struct platform_device  const  *pdev ) 
{ 
  void *tmp ;

  {
#line 212
  tmp = dev_get_drvdata(& pdev->dev);
#line 212
  return (tmp);
}
}
#line 215 "include/linux/platform_device.h"
__inline static void platform_set_drvdata(struct platform_device *pdev , void *data ) 
{ 


  {
#line 218
  dev_set_drvdata(& pdev->dev, data);
#line 219
  return;
}
}
#line 198 "include/linux/phy.h"
extern int mdiobus_register(struct mii_bus * ) ;
#line 199
extern void mdiobus_unregister(struct mii_bus * ) ;
#line 660
extern struct phy_device *phy_connect(struct net_device * , char const   * , void (*)(struct net_device * ) ,
                                      phy_interface_t  ) ;
#line 663
extern void phy_disconnect(struct phy_device * ) ;
#line 665
extern void phy_start(struct phy_device * ) ;
#line 666
extern void phy_stop(struct phy_device * ) ;
#line 667
extern int phy_start_aneg(struct phy_device * ) ;
#line 695
extern int phy_ethtool_sset(struct phy_device * , struct ethtool_cmd * ) ;
#line 696
extern int phy_ethtool_gset(struct phy_device * , struct ethtool_cmd * ) ;
#line 697
extern int phy_mii_ioctl(struct phy_device * , struct ifreq * , int  ) ;
#line 699
extern void phy_print_status(struct phy_device * ) ;
#line 40 "include/linux/mdio-bitbang.h"
extern struct mii_bus *alloc_mdio_bitbang(struct mdiobb_ctrl * ) ;
#line 43
extern void free_mdio_bitbang(struct mii_bus * ) ;
#line 527 "include/linux/of.h"
__inline static struct device_node *of_parse_phandle(struct device_node  const  *np ,
                                                     char const   *phandle_name ,
                                                     int index ) 
{ 


  {
#line 531
  return ((struct device_node *)0);
}
}
#line 81 "include/linux/of_device.h"
__inline static struct of_device_id  const  *__of_match_device(struct of_device_id  const  *matches ,
                                                               struct device  const  *dev ) 
{ 


  {
#line 84
  return ((struct of_device_id  const  *)0);
}
}
#line 42 "include/linux/pm_runtime.h"
extern int __pm_runtime_idle(struct device * , int  ) ;
#line 44
extern int __pm_runtime_resume(struct device * , int  ) ;
#line 48
extern void pm_runtime_enable(struct device * ) ;
#line 49
extern void __pm_runtime_disable(struct device * , bool  ) ;
#line 217 "include/linux/pm_runtime.h"
__inline static int pm_runtime_get_sync(struct device *dev ) 
{ 
  int tmp ;

  {
#line 219
  tmp = __pm_runtime_resume(dev, 4);
#line 219
  return (tmp);
}
}
#line 222 "include/linux/pm_runtime.h"
__inline static int pm_runtime_put(struct device *dev ) 
{ 
  int tmp ;

  {
#line 224
  tmp = __pm_runtime_idle(dev, 5);
#line 224
  return (tmp);
}
}
#line 233 "include/linux/pm_runtime.h"
__inline static int pm_runtime_put_sync(struct device *dev ) 
{ 
  int tmp ;

  {
#line 235
  tmp = __pm_runtime_idle(dev, 4);
#line 235
  return (tmp);
}
}
#line 258 "include/linux/pm_runtime.h"
__inline static void pm_runtime_disable(struct device *dev ) 
{ 


  {
#line 260
  __pm_runtime_disable(dev, 1);
#line 261
  return;
}
}
#line 32 "include/linux/of_mdio.h"
__inline static int of_mdiobus_register(struct mii_bus *mdio , struct device_node *np ) 
{ 
  int tmp ;

  {
#line 39
  tmp = mdiobus_register(mdio);
#line 39
  return (tmp);
}
}
#line 47 "include/linux/of_mdio.h"
__inline static struct phy_device *of_phy_connect(struct net_device *dev , struct device_node *phy_np ,
                                                  void (*hndlr)(struct net_device * ) ,
                                                  u32 flags , phy_interface_t iface ) 
{ 


  {
#line 52
  return ((struct phy_device *)0);
}
}
#line 527 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static void sh_eth_soft_swap(char *src , int len ) 
{ 


  {
#line 529
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static void sh_eth_write(struct net_device *ndev , unsigned long data , int enum_index ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 542
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 542
  mdp = (struct sh_eth_private *)tmp;
#line 544
  iowrite32((u32 )data, mdp->addr + (unsigned long )*(mdp->reg_offset + (unsigned long )enum_index));
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static unsigned long sh_eth_read(struct net_device *ndev , int enum_index ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 550
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 550
  mdp = (struct sh_eth_private *)tmp;
#line 552
  tmp___0 = ioread32(mdp->addr + (unsigned long )*(mdp->reg_offset + (unsigned long )enum_index));
#line 552
  return ((unsigned long )tmp___0);
}
}
#line 555 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static void *sh_eth_tsu_get_offset(struct sh_eth_private *mdp , int enum_index ) 
{ 


  {
#line 558
  return (mdp->tsu_addr + (unsigned long )*(mdp->reg_offset + (unsigned long )enum_index));
}
}
#line 561 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static void sh_eth_tsu_write(struct sh_eth_private *mdp , unsigned long data ,
                                      int enum_index ) 
{ 


  {
#line 564
  iowrite32((u32 )data, mdp->tsu_addr + (unsigned long )*(mdp->reg_offset + (unsigned long )enum_index));
#line 565
  return;
}
}
#line 567 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/renesas/sh_eth.h"
__inline static unsigned long sh_eth_tsu_read(struct sh_eth_private *mdp , int enum_index ) 
{ 
  unsigned int tmp ;

  {
#line 570
  tmp = ioread32(mdp->tsu_addr + (unsigned long )*(mdp->reg_offset + (unsigned long )enum_index));
#line 570
  return ((unsigned long )tmp);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   sh_eth_offset_gigabit[109U]  = 
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
  {      0U,      1024U,      1032U,      1040U, 
        1064U,      1072U,      16U,      20U, 
        24U,      28U,      48U,      52U, 
        56U,      60U,      1080U,      1088U, 
        1096U,      1104U,      1112U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      1128U, 
        1120U,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        1280U,      1296U,      1304U,      1312U, 
        1320U,      (unsigned short)0,      1324U,      1288U, 
        (unsigned short)0,      1364U,      1368U,      1372U, 
        1376U,      1888U,      (unsigned short)0,      1380U, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      1456U, 
        1460U,      1472U,      1480U,      1792U, 
        1800U,      1808U,      (unsigned short)0,      1856U, 
        1864U,      1872U,      1880U,      1896U, 
        1904U,      1912U,      (unsigned short)0,      1252U, 
        1936U,      0U,      4U,      16U, 
        20U,      24U,      32U,      36U, 
        40U,      44U,      48U,      52U, 
        56U,      64U,      68U,      (unsigned short)0, 
        (unsigned short)0,      80U,      84U,      72U, 
        76U,      88U,      92U,      96U, 
        100U,      112U,      116U,      120U, 
        124U,      256U,      260U,      504U, 
        508U,      128U,      132U,      136U, 
        140U,      144U,      148U,      160U, 
        160U,      168U,      172U,      176U, 
        180U};
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   sh_eth_offset_fast_rz[109U]  = 
#line 244
  {      0U,      1024U,      1032U,      1040U, 
        1064U,      1072U,      16U,      20U, 
        24U,      28U,      48U,      52U, 
        56U,      60U,      1080U,      1088U, 
        1096U,      1104U,      1112U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      1128U, 
        1120U,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        1280U,      1296U,      1304U,      1312U, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      1288U, 
        (unsigned short)0,      1364U,      1368U,      1372U, 
        1376U,      1888U,      (unsigned short)0,      1380U, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      1472U,      1480U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      1856U, 
        1864U,      1872U,      1880U,      (unsigned short)0, 
        (unsigned short)0,      1912U,      (unsigned short)0,      1252U, 
        (unsigned short)0,      0U,      4U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      88U,      (unsigned short)0,      96U, 
        100U,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      256U,      260U,      504U, 
        508U,      128U,      132U,      136U, 
        140U};
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   sh_eth_offset_fast_rcar[109U]  = 
#line 303
  {      (unsigned short)0,      512U,      520U,      528U, 
        552U,      560U,      536U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      544U,      (unsigned short)0, 
        (unsigned short)0,      (unsigned short)0,      568U,      576U, 
        584U,      592U,      600U,      (unsigned short)0, 
        612U,      616U,      620U,      624U, 
        (unsigned short)0,      636U,      (unsigned short)0,      (unsigned short)0, 
        768U,      784U,      792U,      800U, 
        808U,      832U,      (unsigned short)0,      776U, 
        848U,      852U,      856U,      (unsigned short)0, 
        (unsigned short)0,      1012U,      864U,      868U, 
        872U,      (unsigned short)0,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      960U,      968U,      976U, 
        980U,      984U,      988U,      996U, 
        1000U,      1004U,      1008U,      (unsigned short)0, 
        (unsigned short)0,      1016U};
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   sh_eth_offset_fast_sh4[109U]  = 
#line 349
  {      (unsigned short)0,      0U,      8U,      16U, 
        40U,      48U,      24U,      216U, 
        (unsigned short)0,      (unsigned short)0,      32U,      204U, 
        (unsigned short)0,      (unsigned short)0,      56U,      64U, 
        72U,      80U,      88U,      (unsigned short)0, 
        100U,      104U,      (unsigned short)0,      112U, 
        120U,      124U,      200U,      212U, 
        256U,      272U,      280U,      288U, 
        296U,      320U,      (unsigned short)0,      264U, 
        336U,      340U,      344U,      (unsigned short)0, 
        (unsigned short)0,      500U,      352U,      356U, 
        360U,      (unsigned short)0,      364U,      (unsigned short)0, 
        (unsigned short)0,      448U,      456U,      464U, 
        468U,      472U,      476U,      484U, 
        488U,      492U,      496U,      (unsigned short)0, 
        (unsigned short)0,      504U,      508U};
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   sh_eth_offset_fast_sh3_sh2[109U]  = 
#line 401
  {      (unsigned short)0,      0U,      4U,      8U, 
        20U,      24U,      12U,      80U, 
        (unsigned short)0,      (unsigned short)0,      16U,      68U, 
        (unsigned short)0,      (unsigned short)0,      28U,      32U, 
        36U,      40U,      44U,      48U, 
        (unsigned short)0,      (unsigned short)0,      (unsigned short)0,      52U, 
        56U,      60U,      64U,      76U, 
        352U,      356U,      360U,      364U, 
        380U,      (unsigned short)0,      (unsigned short)0,      376U, 
        436U,      440U,      444U,      (unsigned short)0, 
        (unsigned short)0,      420U,      (unsigned short)0,      452U, 
        (unsigned short)0,      460U,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      368U,      372U,      384U, 
        388U,      392U,      396U,      404U, 
        408U,      412U,      416U,      (unsigned short)0, 
        (unsigned short)0,      424U,      (unsigned short)0,      (unsigned short)0, 
        (unsigned short)0,      0U,      4U,      16U, 
        20U,      24U,      32U,      36U, 
        40U,      44U,      48U,      52U, 
        56U,      (unsigned short)0,      (unsigned short)0,      64U, 
        68U,      80U,      84U,      72U, 
        76U,      (unsigned short)0,      (unsigned short)0,      96U, 
        100U,      112U,      116U,      120U, 
        124U,      256U,      260U,      (unsigned short)0, 
        508U,      128U,      132U,      136U, 
        140U,      144U,      148U,      160U, 
        160U,      168U,      172U,      176U, 
        180U};
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static bool sh_eth_is_gether(struct sh_eth_private *mdp ) 
{ 


  {
#line 492
  return ((unsigned long )mdp->reg_offset == (unsigned long )((u16 const   *)(& sh_eth_offset_gigabit)));
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static bool sh_eth_is_rz_fast_ether(struct sh_eth_private *mdp ) 
{ 


  {
#line 497
  return ((unsigned long )mdp->reg_offset == (unsigned long )((u16 const   *)(& sh_eth_offset_fast_rz)));
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_select_mii(struct net_device *ndev ) 
{ 
  u32 value ;
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 502
  value = 0U;
#line 503
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 503
  mdp = (struct sh_eth_private *)tmp;
#line 505
  switch ((unsigned int )mdp->phy_interface) {
  case 2U: 
#line 507
  value = 2U;
#line 508
  goto ldv_44457;
  case 1U: 
#line 510
  value = 1U;
#line 511
  goto ldv_44457;
  case 6U: 
#line 513
  value = 0U;
#line 514
  goto ldv_44457;
  default: 
#line 516
  netdev_warn((struct net_device  const  *)ndev, "PHY interface mode was not setup. Set to MII.\n");
#line 518
  value = 1U;
#line 519
  goto ldv_44457;
  }
  ldv_44457: 
#line 522
  sh_eth_write(ndev, (unsigned long )value, 64);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_duplex(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 527
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 527
  mdp = (struct sh_eth_private *)tmp;
#line 529
  if (mdp->duplex != 0) {
#line 530
    tmp___0 = sh_eth_read(ndev, 28);
#line 530
    sh_eth_write(ndev, tmp___0 | 2UL, 28);
  } else {
#line 532
    tmp___1 = sh_eth_read(ndev, 28);
#line 532
    sh_eth_write(ndev, tmp___1 & 0xfffffffffffffffdUL, 28);
  }
#line 533
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_rate_r8a777x(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 538
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 538
  mdp = (struct sh_eth_private *)tmp;
#line 540
  switch (mdp->speed) {
  case 10: 
#line 542
  tmp___0 = sh_eth_read(ndev, 28);
#line 542
  sh_eth_write(ndev, tmp___0 & 0xfffffffffffffffbUL, 28);
#line 543
  goto ldv_44470;
  case 100: 
#line 545
  tmp___1 = sh_eth_read(ndev, 28);
#line 545
  sh_eth_write(ndev, tmp___1 | 4UL, 28);
#line 546
  goto ldv_44470;
  default: ;
#line 548
  goto ldv_44470;
  }
  ldv_44470: ;
#line 551
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data r8a777x_data  = 
#line 553
     {0, & sh_eth_set_duplex, & sh_eth_set_rate_r8a777x, 2, 33489055UL, 21UL, 21UL,
    0UL, 0UL, 0UL, 2100992UL, 1197146112UL, 0UL, (unsigned char)0, 1U, 1U, 1U, (unsigned char)0,
    (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data r8a779x_data  = 
#line 575
     {0, & sh_eth_set_duplex, & sh_eth_set_rate_r8a777x, 2, 33489055UL, 21UL, 21UL,
    0UL, 0UL, 0UL, 2100992UL, 1197146112UL, 0UL, (unsigned char)0, 1U, 1U, 1U, (unsigned char)0,
    (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, 1U};
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_rate_sh7724(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 600
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 600
  mdp = (struct sh_eth_private *)tmp;
#line 602
  switch (mdp->speed) {
  case 10: 
#line 604
  tmp___0 = sh_eth_read(ndev, 28);
#line 604
  sh_eth_write(ndev, tmp___0 & 0xffffffffffffffefUL, 28);
#line 605
  goto ldv_44480;
  case 100: 
#line 607
  tmp___1 = sh_eth_read(ndev, 28);
#line 607
  sh_eth_write(ndev, tmp___1 | 16UL, 28);
#line 608
  goto ldv_44480;
  default: ;
#line 610
  goto ldv_44480;
  }
  ldv_44480: ;
#line 613
  return;
}
}
#line 615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7724_data  = 
#line 615
     {0, & sh_eth_set_duplex, & sh_eth_set_rate_sh7724, 3, 33489055UL, 21UL, 21UL, 0UL,
    0UL, 131072UL, 2100992UL, 1197146112UL, 0UL, (unsigned char)0, 1U, 1U, 1U, (unsigned char)0,
    (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_rate_sh7757(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 640
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 640
  mdp = (struct sh_eth_private *)tmp;
#line 642
  switch (mdp->speed) {
  case 10: 
#line 644
  sh_eth_write(ndev, 0UL, 62);
#line 645
  goto ldv_44489;
  case 100: 
#line 647
  sh_eth_write(ndev, 1UL, 62);
#line 648
  goto ldv_44489;
  default: ;
#line 650
  goto ldv_44489;
  }
  ldv_44489: ;
#line 653
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7757_data  = 
#line 655
     {0, & sh_eth_set_duplex, & sh_eth_set_rate_sh7757, 3, 25165823UL, 0UL, 0UL, 0UL,
    0UL, 131072UL, 2100992UL, 1197146112UL, 128UL, (unsigned char)0, 1U, 1U, 1U, (unsigned char)0,
    (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_chip_reset_giga(struct net_device *ndev ) 
{ 
  int i ;
  unsigned long mahr[2U] ;
  unsigned long malr[2U] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;

  {
#line 687
  i = 0;
#line 687
  goto ldv_44500;
  ldv_44499: 
#line 688
  tmp = ioread32((void *)((unsigned long )(i * 2048) + 4276094408UL));
#line 688
  malr[i] = (unsigned long )tmp;
#line 689
  tmp___0 = ioread32((void *)((unsigned long )(i * 2048) + 4276094400UL));
#line 689
  mahr[i] = (unsigned long )tmp___0;
#line 687
  i = i + 1;
  ldv_44500: ;
#line 687
  if (i <= 1) {
#line 689
    goto ldv_44499;
  } else {

  }
#line 693
  iowrite32(1U, (void *)4276099072L);
#line 694
  if (1) {
#line 694
    __const_udelay(4295000UL);
  } else {
#line 694
    __ms = 1UL;
#line 694
    goto ldv_44504;
    ldv_44503: 
#line 694
    __const_udelay(4295000UL);
    ldv_44504: 
#line 694
    tmp___1 = __ms;
#line 694
    __ms = __ms - 1UL;
#line 694
    if (tmp___1 != 0UL) {
#line 696
      goto ldv_44503;
    } else {

    }

  }
#line 697
  i = 0;
#line 697
  goto ldv_44507;
  ldv_44506: 
#line 698
  iowrite32((u32 )malr[i], (void *)((unsigned long )(i * 2048) + 4276094408UL));
#line 699
  iowrite32((u32 )mahr[i], (void *)((unsigned long )(i * 2048) + 4276094400UL));
#line 697
  i = i + 1;
  ldv_44507: ;
#line 697
  if (i <= 1) {
#line 699
    goto ldv_44506;
  } else {

  }

#line 704
  return;
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_rate_giga(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 705
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 705
  mdp = (struct sh_eth_private *)tmp;
#line 707
  switch (mdp->speed) {
  case 10: 
#line 709
  sh_eth_write(ndev, 0UL, 47);
#line 710
  goto ldv_44514;
  case 100: 
#line 712
  sh_eth_write(ndev, 16UL, 47);
#line 713
  goto ldv_44514;
  case 1000: 
#line 715
  sh_eth_write(ndev, 32UL, 47);
#line 716
  goto ldv_44514;
  default: ;
#line 718
  goto ldv_44514;
  }
  ldv_44514: ;
#line 721
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7757_data_giga  = 
#line 723
     {& sh_eth_chip_reset_giga, & sh_eth_set_duplex, & sh_eth_set_rate_giga, 0, 25165823UL,
    3UL, 7UL, 1839UL, 0UL, 131072UL, 538968064UL, 3344629760UL, 128UL, (unsigned char)0,
    1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_chip_reset(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;

  {
#line 755
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 755
  mdp = (struct sh_eth_private *)tmp;
#line 758
  sh_eth_tsu_write(mdp, 1UL, 65);
#line 759
  if (1) {
#line 759
    __const_udelay(4295000UL);
  } else {
#line 759
    __ms = 1UL;
#line 759
    goto ldv_44525;
    ldv_44524: 
#line 759
    __const_udelay(4295000UL);
    ldv_44525: 
#line 759
    tmp___0 = __ms;
#line 759
    __ms = __ms - 1UL;
#line 759
    if (tmp___0 != 0UL) {
#line 761
      goto ldv_44524;
    } else {

    }

  }
#line 768
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_rate_gether(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 764
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 764
  mdp = (struct sh_eth_private *)tmp;
#line 766
  switch (mdp->speed) {
  case 10: 
#line 768
  sh_eth_write(ndev, 0UL, 47);
#line 769
  goto ldv_44532;
  case 100: 
#line 771
  sh_eth_write(ndev, 4UL, 47);
#line 772
  goto ldv_44532;
  case 1000: 
#line 774
  sh_eth_write(ndev, 1UL, 47);
#line 775
  goto ldv_44532;
  default: ;
#line 777
  goto ldv_44532;
  }
  ldv_44532: ;
#line 780
  return;
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7734_data  = 
#line 782
     {& sh_eth_chip_reset, & sh_eth_set_duplex, & sh_eth_set_rate_gether, 0, 25165823UL,
    3UL, 7UL, 0UL, 0UL, 0UL, 538968064UL, 3344629760UL, 0UL, (unsigned char)0, 1U,
    1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7763_data  = 
#line 811
     {& sh_eth_chip_reset, & sh_eth_set_duplex, & sh_eth_set_rate_gether, 0, 25165823UL,
    3UL, 7UL, 0UL, 0UL, 0UL, 538968064UL, 3344564224UL, 128UL, (unsigned char)0, 1U,
    1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_chip_reset_r8a7740(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;

  {
#line 840
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 840
  mdp = (struct sh_eth_private *)tmp;
#line 843
  sh_eth_tsu_write(mdp, 1UL, 65);
#line 844
  if (1) {
#line 844
    __const_udelay(4295000UL);
  } else {
#line 844
    __ms = 1UL;
#line 844
    goto ldv_44544;
    ldv_44543: 
#line 844
    __const_udelay(4295000UL);
    ldv_44544: 
#line 844
    tmp___0 = __ms;
#line 844
    __ms = __ms - 1UL;
#line 844
    if (tmp___0 != 0UL) {
#line 846
      goto ldv_44543;
    } else {

    }

  }
#line 846
  sh_eth_select_mii(ndev);
#line 847
  return;
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data r8a7740_data  = 
#line 850
     {& sh_eth_chip_reset_r8a7740, & sh_eth_set_duplex, & sh_eth_set_rate_gether, 0,
    25165823UL, 3UL, 7UL, 1807UL, 0UL, 131072UL, 538968064UL, 3344629760UL, 0UL, (unsigned char)0,
    1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0};
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data r7s72100_data  = 
#line 882
     {& sh_eth_chip_reset, & sh_eth_set_duplex, 0, 1, 4286513311UL, 1UL, 1UL, 1807UL,
    0UL, 131072UL, 538968064UL, 3344629760UL, 0UL, 1U, 1U, 1U, 1U, (unsigned char)0,
    1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0};
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh7619_data  = 
#line 912
     {0, 0, 0, 4, 25165823UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, (unsigned char)0,
    1U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct sh_eth_cpu_data sh771x_data  = 
#line 923
     {0, 0, 0, 4, 25165823UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_default_cpu_data(struct sh_eth_cpu_data *cd ) 
{ 


  {
#line 932
  if (cd->ecsr_value == 0UL) {
#line 933
    cd->ecsr_value = 55UL;
  } else {

  }
#line 935
  if (cd->ecsipr_value == 0UL) {
#line 936
    cd->ecsipr_value = 55UL;
  } else {

  }
#line 938
  if (cd->fcftr_value == 0UL) {
#line 939
    cd->fcftr_value = 458759UL;
  } else {

  }
#line 942
  if (cd->fdr_value == 0UL) {
#line 943
    cd->fdr_value = 1799UL;
  } else {

  }
#line 945
  if (cd->tx_check == 0UL) {
#line 946
    cd->tx_check = 2100992UL;
  } else {

  }
#line 948
  if (cd->eesr_err_check == 0UL) {
#line 949
    cd->eesr_err_check = 1205534720UL;
  } else {

  }
#line 950
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_check_reset(struct net_device *ndev ) 
{ 
  int ret ;
  int cnt ;
  unsigned long tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;

  {
#line 954
  ret = 0;
#line 955
  cnt = 100;
#line 957
  goto ldv_44564;
  ldv_44563: 
#line 958
  tmp = sh_eth_read(ndev, 1);
#line 958
  if ((tmp & 3UL) == 0UL) {
#line 959
    goto ldv_44558;
  } else {

  }
#line 960
  if (1) {
#line 960
    __const_udelay(4295000UL);
  } else {
#line 960
    __ms = 1UL;
#line 960
    goto ldv_44561;
    ldv_44560: 
#line 960
    __const_udelay(4295000UL);
    ldv_44561: 
#line 960
    tmp___0 = __ms;
#line 960
    __ms = __ms - 1UL;
#line 960
    if (tmp___0 != 0UL) {
#line 962
      goto ldv_44560;
    } else {

    }

  }
#line 961
  cnt = cnt - 1;
  ldv_44564: ;
#line 957
  if (cnt > 0) {
#line 959
    goto ldv_44563;
  } else {

  }
  ldv_44558: ;
#line 963
  if (cnt <= 0) {
#line 964
    netdev_err((struct net_device  const  *)ndev, "Device reset failed\n");
#line 965
    ret = -110;
  } else {

  }
#line 967
  return (ret);
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_reset(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int ret ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 972
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 972
  mdp = (struct sh_eth_private *)tmp;
#line 973
  ret = 0;
#line 975
  tmp___4 = sh_eth_is_gether(mdp);
#line 975
  if ((int )tmp___4) {
#line 975
    goto _L;
  } else {
#line 975
    tmp___5 = sh_eth_is_rz_fast_ether(mdp);
#line 975
    if ((int )tmp___5) {
      _L: /* CIL Label */ 
#line 976
      sh_eth_write(ndev, 3UL, 0);
#line 977
      tmp___0 = sh_eth_read(ndev, 1);
#line 977
      sh_eth_write(ndev, tmp___0 | 3UL, 1);
#line 980
      ret = sh_eth_check_reset(ndev);
#line 981
      if (ret != 0) {
#line 982
        return (ret);
      } else {

      }
#line 985
      sh_eth_write(ndev, 0UL, 6);
#line 986
      sh_eth_write(ndev, 0UL, 7);
#line 987
      sh_eth_write(ndev, 0UL, 8);
#line 988
      sh_eth_write(ndev, 0UL, 9);
#line 989
      sh_eth_write(ndev, 0UL, 10);
#line 990
      sh_eth_write(ndev, 0UL, 11);
#line 991
      sh_eth_write(ndev, 0UL, 12);
#line 992
      sh_eth_write(ndev, 0UL, 13);
#line 995
      if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) != 0U) {
#line 996
        sh_eth_write(ndev, 0UL, 63);
      } else {

      }
#line 999
      if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) != 0U) {
#line 1000
        sh_eth_select_mii(ndev);
      } else {

      }
    } else {
#line 1002
      tmp___1 = sh_eth_read(ndev, 1);
#line 1002
      sh_eth_write(ndev, tmp___1 | 1UL, 1);
#line 1004
      if (1) {
#line 1004
        __const_udelay(12885000UL);
      } else {
#line 1004
        __ms = 3UL;
#line 1004
        goto ldv_44572;
        ldv_44571: 
#line 1004
        __const_udelay(4295000UL);
        ldv_44572: 
#line 1004
        tmp___2 = __ms;
#line 1004
        __ms = __ms - 1UL;
#line 1004
        if (tmp___2 != 0UL) {
#line 1006
          goto ldv_44571;
        } else {

        }

      }
#line 1005
      tmp___3 = sh_eth_read(ndev, 1);
#line 1005
      sh_eth_write(ndev, tmp___3 & 0xfffffffffffffffeUL, 1);
    }
  }
#line 1009
  return (ret);
}
}
#line 1022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_receive_align(struct sk_buff *skb ) 
{ 


  {
#line 1024
  skb_reserve(skb, 2);
#line 1025
  return;
}
}
#line 1030 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static __u32 cpu_to_edmac(struct sh_eth_private *mdp , u32 x ) 
{ 
  __u32 tmp ;

  {
#line 1032
  switch (mdp->edmac_endian) {
  case 0: ;
#line 1034
  return (x);
  case 1: 
#line 1036
  tmp = __fswab32(x);
#line 1036
  return (tmp);
  }
#line 1038
  return (x);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void update_mac_address(struct net_device *ndev ) 
{ 


  {
#line 1055
  sh_eth_write(ndev, (unsigned long )(((((int )*(ndev->dev_addr) << 24) | ((int )*(ndev->dev_addr + 1UL) << 16)) | ((int )*(ndev->dev_addr + 2UL) << 8)) | (int )*(ndev->dev_addr + 3UL)),
               49);
#line 1058
  sh_eth_write(ndev, (unsigned long )(((int )*(ndev->dev_addr + 4UL) << 8) | (int )*(ndev->dev_addr + 5UL)),
               50);
#line 1060
  return;
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void read_mac_address(struct net_device *ndev , unsigned char *mac ) 
{ 
  size_t __len ;
  void *__ret ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 1071
  if ((((((unsigned int )*mac != 0U || (unsigned int )*(mac + 1UL) != 0U) || (unsigned int )*(mac + 2UL) != 0U) || (unsigned int )*(mac + 3UL) != 0U) || (unsigned int )*(mac + 4UL) != 0U) || (unsigned int )*(mac + 5UL) != 0U) {
#line 1072
    __len = 6UL;
#line 1072
    if (__len > 63UL) {
#line 1072
      __ret = __memcpy((void *)ndev->dev_addr, (void const   *)mac, __len);
    } else {
#line 1072
      __ret = __builtin_memcpy((void *)ndev->dev_addr, (void const   *)mac, __len);
    }
  } else {
#line 1074
    tmp = sh_eth_read(ndev, 49);
#line 1074
    *(ndev->dev_addr) = (unsigned char )(tmp >> 24);
#line 1075
    tmp___0 = sh_eth_read(ndev, 49);
#line 1075
    *(ndev->dev_addr + 1UL) = (unsigned char )(tmp___0 >> 16);
#line 1076
    tmp___1 = sh_eth_read(ndev, 49);
#line 1076
    *(ndev->dev_addr + 2UL) = (unsigned char )(tmp___1 >> 8);
#line 1077
    tmp___2 = sh_eth_read(ndev, 49);
#line 1077
    *(ndev->dev_addr + 3UL) = (unsigned char )tmp___2;
#line 1078
    tmp___3 = sh_eth_read(ndev, 50);
#line 1078
    *(ndev->dev_addr + 4UL) = (unsigned char )(tmp___3 >> 8);
#line 1079
    tmp___4 = sh_eth_read(ndev, 50);
#line 1079
    *(ndev->dev_addr + 5UL) = (unsigned char )tmp___4;
  }
#line 1081
  return;
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static unsigned long sh_eth_get_edtrr_trns(struct sh_eth_private *mdp ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 1085
  tmp = sh_eth_is_gether(mdp);
#line 1085
  if ((int )tmp) {
#line 1086
    return (3UL);
  } else {
#line 1085
    tmp___0 = sh_eth_is_rz_fast_ether(mdp);
#line 1085
    if ((int )tmp___0) {
#line 1086
      return (3UL);
    } else {
#line 1088
      return (1UL);
    }
  }
}
}
#line 1102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void bb_set(void *addr , u32 msk ) 
{ 
  unsigned int tmp ;

  {
#line 1104
  tmp = ioread32(addr);
#line 1104
  iowrite32(tmp | msk, addr);
#line 1105
  return;
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void bb_clr(void *addr , u32 msk ) 
{ 
  unsigned int tmp ;

  {
#line 1110
  tmp = ioread32(addr);
#line 1110
  iowrite32(tmp & ~ msk, addr);
#line 1111
  return;
}
}
#line 1114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int bb_read(void *addr , u32 msk ) 
{ 
  unsigned int tmp ;

  {
#line 1116
  tmp = ioread32(addr);
#line 1116
  return ((tmp & msk) != 0U);
}
}
#line 1120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_mmd_ctrl(struct mdiobb_ctrl *ctrl , int bit ) 
{ 
  struct bb_info *bitbang ;
  struct mdiobb_ctrl  const  *__mptr ;

  {
#line 1122
  __mptr = (struct mdiobb_ctrl  const  *)ctrl;
#line 1122
  bitbang = (struct bb_info *)__mptr + 0xfffffffffffffff8UL;
#line 1124
  if ((unsigned long )bitbang->set_gate != (unsigned long )((void (*)(void * ))0)) {
#line 1125
    (*(bitbang->set_gate))(bitbang->addr);
  } else {

  }
#line 1127
  if (bit != 0) {
#line 1128
    bb_set(bitbang->addr, bitbang->mmd_msk);
  } else {
#line 1130
    bb_clr(bitbang->addr, bitbang->mmd_msk);
  }
#line 1131
  return;
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_set_mdio(struct mdiobb_ctrl *ctrl , int bit ) 
{ 
  struct bb_info *bitbang ;
  struct mdiobb_ctrl  const  *__mptr ;

  {
#line 1136
  __mptr = (struct mdiobb_ctrl  const  *)ctrl;
#line 1136
  bitbang = (struct bb_info *)__mptr + 0xfffffffffffffff8UL;
#line 1138
  if ((unsigned long )bitbang->set_gate != (unsigned long )((void (*)(void * ))0)) {
#line 1139
    (*(bitbang->set_gate))(bitbang->addr);
  } else {

  }
#line 1141
  if (bit != 0) {
#line 1142
    bb_set(bitbang->addr, bitbang->mdo_msk);
  } else {
#line 1144
    bb_clr(bitbang->addr, bitbang->mdo_msk);
  }
#line 1145
  return;
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_get_mdio(struct mdiobb_ctrl *ctrl ) 
{ 
  struct bb_info *bitbang ;
  struct mdiobb_ctrl  const  *__mptr ;
  int tmp ;

  {
#line 1150
  __mptr = (struct mdiobb_ctrl  const  *)ctrl;
#line 1150
  bitbang = (struct bb_info *)__mptr + 0xfffffffffffffff8UL;
#line 1152
  if ((unsigned long )bitbang->set_gate != (unsigned long )((void (*)(void * ))0)) {
#line 1153
    (*(bitbang->set_gate))(bitbang->addr);
  } else {

  }
#line 1155
  tmp = bb_read(bitbang->addr, bitbang->mdi_msk);
#line 1155
  return (tmp);
}
}
#line 1159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_mdc_ctrl(struct mdiobb_ctrl *ctrl , int bit ) 
{ 
  struct bb_info *bitbang ;
  struct mdiobb_ctrl  const  *__mptr ;

  {
#line 1161
  __mptr = (struct mdiobb_ctrl  const  *)ctrl;
#line 1161
  bitbang = (struct bb_info *)__mptr + 0xfffffffffffffff8UL;
#line 1163
  if ((unsigned long )bitbang->set_gate != (unsigned long )((void (*)(void * ))0)) {
#line 1164
    (*(bitbang->set_gate))(bitbang->addr);
  } else {

  }
#line 1166
  if (bit != 0) {
#line 1167
    bb_set(bitbang->addr, bitbang->mdc_msk);
  } else {
#line 1169
    bb_clr(bitbang->addr, bitbang->mdc_msk);
  }
#line 1170
  return;
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct mdiobb_ops bb_ops  =    {& __this_module, & sh_mdc_ctrl, & sh_mmd_ctrl, & sh_set_mdio, & sh_get_mdio};
#line 1182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_ring_free(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int i ;

  {
#line 1184
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1184
  mdp = (struct sh_eth_private *)tmp;
#line 1188
  if ((unsigned long )mdp->rx_skbuff != (unsigned long )((struct sk_buff **)0)) {
#line 1189
    i = 0;
#line 1189
    goto ldv_44657;
    ldv_44656: ;
#line 1190
    if ((unsigned long )*(mdp->rx_skbuff + (unsigned long )i) != (unsigned long )((struct sk_buff *)0)) {
#line 1191
      ldv_skb_free(*(mdp->rx_skbuff + (unsigned long )i));
    } else {

    }
#line 1189
    i = i + 1;
    ldv_44657: ;
#line 1189
    if ((u32 )i < mdp->num_rx_ring) {
#line 1191
      goto ldv_44656;
    } else {

    }

  } else {

  }
#line 1194
  kfree((void const   *)mdp->rx_skbuff);
#line 1195
  mdp->rx_skbuff = (struct sk_buff **)0;
#line 1198
  if ((unsigned long )mdp->tx_skbuff != (unsigned long )((struct sk_buff **)0)) {
#line 1199
    i = 0;
#line 1199
    goto ldv_44660;
    ldv_44659: ;
#line 1200
    if ((unsigned long )*(mdp->tx_skbuff + (unsigned long )i) != (unsigned long )((struct sk_buff *)0)) {
#line 1201
      ldv_skb_free(*(mdp->tx_skbuff + (unsigned long )i));
    } else {

    }
#line 1199
    i = i + 1;
    ldv_44660: ;
#line 1199
    if ((u32 )i < mdp->num_tx_ring) {
#line 1201
      goto ldv_44659;
    } else {

    }

  } else {

  }
#line 1204
  kfree((void const   *)mdp->tx_skbuff);
#line 1205
  mdp->tx_skbuff = (struct sk_buff **)0;
#line 1206
  return;
}
}
#line 1209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_ring_format(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int i ;
  struct sk_buff *skb ;
  struct sh_eth_rxdesc *rxdesc ;
  struct sh_eth_txdesc *txdesc ;
  int rx_ringsize ;
  int tx_ringsize ;
  phys_addr_t tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  __u32 tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  __u32 tmp___6 ;

  {
#line 1211
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1211
  mdp = (struct sh_eth_private *)tmp;
#line 1214
  rxdesc = (struct sh_eth_rxdesc *)0;
#line 1215
  txdesc = (struct sh_eth_txdesc *)0;
#line 1216
  rx_ringsize = (int )(mdp->num_rx_ring * 16U);
#line 1217
  tx_ringsize = (int )(mdp->num_tx_ring * 16U);
#line 1219
  mdp->cur_rx = 0U;
#line 1220
  mdp->cur_tx = 0U;
#line 1221
  mdp->dirty_rx = 0U;
#line 1222
  mdp->dirty_tx = 0U;
#line 1224
  memset((void *)mdp->rx_ring, 0, (size_t )rx_ringsize);
#line 1227
  i = 0;
#line 1227
  goto ldv_44674;
  ldv_44673: 
#line 1229
  *(mdp->rx_skbuff + (unsigned long )i) = (struct sk_buff *)0;
#line 1230
  skb = ldv_netdev_alloc_skb_12(ndev, mdp->rx_buf_sz);
#line 1231
  *(mdp->rx_skbuff + (unsigned long )i) = skb;
#line 1232
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1233
    goto ldv_44672;
  } else {

  }
#line 1234
  dma_map_single_attrs(& ndev->dev, (void *)skb->data, (size_t )mdp->rx_buf_sz, 2,
                       (struct dma_attrs *)0);
#line 1236
  sh_eth_set_receive_align(skb);
#line 1239
  rxdesc = mdp->rx_ring + (unsigned long )i;
#line 1240
  tmp___0 = virt_to_phys((void volatile   *)(((unsigned long )skb->data + 3UL) & 0xfffffffffffffffcUL));
#line 1240
  rxdesc->addr = (u32 )tmp___0;
#line 1241
  rxdesc->status = cpu_to_edmac(mdp, 2952790016U);
#line 1244
  rxdesc->buffer_length = ((unsigned int )((u16 )mdp->rx_buf_sz) + 15U) & 65520U;
#line 1246
  if (i == 0) {
#line 1247
    sh_eth_write(ndev, (unsigned long )mdp->rx_desc_dma, 10);
#line 1248
    tmp___1 = sh_eth_is_gether(mdp);
#line 1248
    if ((int )tmp___1) {
#line 1250
      sh_eth_write(ndev, (unsigned long )mdp->rx_desc_dma, 11);
    } else {
#line 1248
      tmp___2 = sh_eth_is_rz_fast_ether(mdp);
#line 1248
      if ((int )tmp___2) {
#line 1250
        sh_eth_write(ndev, (unsigned long )mdp->rx_desc_dma, 11);
      } else {

      }
    }
  } else {

  }
#line 1227
  i = i + 1;
  ldv_44674: ;
#line 1227
  if ((u32 )i < mdp->num_rx_ring) {
#line 1229
    goto ldv_44673;
  } else {

  }
  ldv_44672: 
#line 1254
  mdp->dirty_rx = (u32 )i - mdp->num_rx_ring;
#line 1257
  tmp___3 = cpu_to_edmac(mdp, 1073741824U);
#line 1257
  rxdesc->status = rxdesc->status | tmp___3;
#line 1259
  memset((void *)mdp->tx_ring, 0, (size_t )tx_ringsize);
#line 1262
  i = 0;
#line 1262
  goto ldv_44676;
  ldv_44675: 
#line 1263
  *(mdp->tx_skbuff + (unsigned long )i) = (struct sk_buff *)0;
#line 1264
  txdesc = mdp->tx_ring + (unsigned long )i;
#line 1265
  txdesc->status = cpu_to_edmac(mdp, 805306368U);
#line 1266
  txdesc->buffer_length = 0U;
#line 1267
  if (i == 0) {
#line 1269
    sh_eth_write(ndev, (unsigned long )mdp->tx_desc_dma, 6);
#line 1270
    tmp___4 = sh_eth_is_gether(mdp);
#line 1270
    if ((int )tmp___4) {
#line 1272
      sh_eth_write(ndev, (unsigned long )mdp->tx_desc_dma, 7);
    } else {
#line 1270
      tmp___5 = sh_eth_is_rz_fast_ether(mdp);
#line 1270
      if ((int )tmp___5) {
#line 1272
        sh_eth_write(ndev, (unsigned long )mdp->tx_desc_dma, 7);
      } else {

      }
    }
  } else {

  }
#line 1262
  i = i + 1;
  ldv_44676: ;
#line 1262
  if ((u32 )i < mdp->num_tx_ring) {
#line 1264
    goto ldv_44675;
  } else {

  }
#line 1276
  tmp___6 = cpu_to_edmac(mdp, 1073741824U);
#line 1276
  txdesc->status = txdesc->status | tmp___6;
#line 1277
  return;
}
}
#line 1280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_ring_init(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int rx_ringsize ;
  int tx_ringsize ;
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1282
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1282
  mdp = (struct sh_eth_private *)tmp;
#line 1283
  ret = 0;
#line 1290
  mdp->rx_buf_sz = ndev->mtu > 1492U ? ((ndev->mtu + 33U) & 4294967288U) + 18U : 1538U;
#line 1292
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1293
    mdp->rx_buf_sz = mdp->rx_buf_sz;
  } else {

  }
#line 1296
  tmp___0 = kmalloc_array((size_t )mdp->num_rx_ring, 8UL, 208U);
#line 1296
  mdp->rx_skbuff = (struct sk_buff **)tmp___0;
#line 1298
  if ((unsigned long )mdp->rx_skbuff == (unsigned long )((struct sk_buff **)0)) {
#line 1299
    ret = -12;
#line 1300
    return (ret);
  } else {

  }
#line 1303
  tmp___1 = kmalloc_array((size_t )mdp->num_tx_ring, 8UL, 208U);
#line 1303
  mdp->tx_skbuff = (struct sk_buff **)tmp___1;
#line 1305
  if ((unsigned long )mdp->tx_skbuff == (unsigned long )((struct sk_buff **)0)) {
#line 1306
    ret = -12;
#line 1307
    goto skb_ring_free;
  } else {

  }
#line 1311
  rx_ringsize = (int )(mdp->num_rx_ring * 16U);
#line 1312
  tmp___2 = dma_alloc_attrs((struct device *)0, (size_t )rx_ringsize, & mdp->rx_desc_dma,
                            208U, (struct dma_attrs *)0);
#line 1312
  mdp->rx_ring = (struct sh_eth_rxdesc *)tmp___2;
#line 1314
  if ((unsigned long )mdp->rx_ring == (unsigned long )((struct sh_eth_rxdesc *)0)) {
#line 1315
    ret = -12;
#line 1316
    goto desc_ring_free;
  } else {

  }
#line 1319
  mdp->dirty_rx = 0U;
#line 1322
  tx_ringsize = (int )(mdp->num_tx_ring * 16U);
#line 1323
  tmp___3 = dma_alloc_attrs((struct device *)0, (size_t )tx_ringsize, & mdp->tx_desc_dma,
                            208U, (struct dma_attrs *)0);
#line 1323
  mdp->tx_ring = (struct sh_eth_txdesc *)tmp___3;
#line 1325
  if ((unsigned long )mdp->tx_ring == (unsigned long )((struct sh_eth_txdesc *)0)) {
#line 1326
    ret = -12;
#line 1327
    goto desc_ring_free;
  } else {

  }
#line 1329
  return (ret);
  desc_ring_free: 
#line 1333
  dma_free_attrs((struct device *)0, (size_t )rx_ringsize, (void *)mdp->rx_ring, mdp->rx_desc_dma,
                 (struct dma_attrs *)0);
  skb_ring_free: 
#line 1337
  sh_eth_ring_free(ndev);
#line 1338
  mdp->tx_ring = (struct sh_eth_txdesc *)0;
#line 1339
  mdp->rx_ring = (struct sh_eth_rxdesc *)0;
#line 1341
  return (ret);
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_free_dma_buffer(struct sh_eth_private *mdp ) 
{ 
  int ringsize ;

  {
#line 1348
  if ((unsigned long )mdp->rx_ring != (unsigned long )((struct sh_eth_rxdesc *)0)) {
#line 1349
    ringsize = (int )(mdp->num_rx_ring * 16U);
#line 1350
    dma_free_attrs((struct device *)0, (size_t )ringsize, (void *)mdp->rx_ring, mdp->rx_desc_dma,
                   (struct dma_attrs *)0);
#line 1352
    mdp->rx_ring = (struct sh_eth_rxdesc *)0;
  } else {

  }
#line 1355
  if ((unsigned long )mdp->tx_ring != (unsigned long )((struct sh_eth_txdesc *)0)) {
#line 1356
    ringsize = (int )(mdp->num_tx_ring * 16U);
#line 1357
    dma_free_attrs((struct device *)0, (size_t )ringsize, (void *)mdp->tx_ring, mdp->tx_desc_dma,
                   (struct dma_attrs *)0);
#line 1359
    mdp->tx_ring = (struct sh_eth_txdesc *)0;
  } else {

  }
#line 1361
  return;
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_dev_init(struct net_device *ndev , bool start ) 
{ 
  int ret ;
  struct sh_eth_private *mdp ;
  void *tmp ;
  u32 val ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1365
  ret = 0;
#line 1366
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1366
  mdp = (struct sh_eth_private *)tmp;
#line 1370
  ret = sh_eth_reset(ndev);
#line 1371
  if (ret != 0) {
#line 1372
    return (ret);
  } else {

  }
#line 1374
  if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) != 0U) {
#line 1375
    sh_eth_write(ndev, 1UL, 22);
  } else {

  }
#line 1378
  sh_eth_ring_format(ndev);
#line 1379
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1380
    sh_eth_write(ndev, (mdp->cd)->rpadir_value, 24);
  } else {

  }
#line 1383
  sh_eth_write(ndev, 0UL, 5);
#line 1386
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1387
    sh_eth_write(ndev, 64UL, 1);
  } else {
#line 1390
    sh_eth_write(ndev, 0UL, 1);
  }
#line 1393
  sh_eth_write(ndev, (mdp->cd)->fdr_value, 17);
#line 1394
  sh_eth_write(ndev, 0UL, 16);
#line 1397
  sh_eth_write(ndev, 1UL, 18);
#line 1399
  sh_eth_write(ndev, 656UL, 14);
#line 1401
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1402
    sh_eth_write(ndev, 2048UL, 48);
  } else {

  }
#line 1404
  sh_eth_write(ndev, (mdp->cd)->fcftr_value, 23);
#line 1406
  if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) == 0U) {
#line 1407
    sh_eth_write(ndev, 0UL, 25);
  } else {

  }
#line 1410
  sh_eth_write(ndev, (unsigned long )(ndev->mtu + 22U), 35);
#line 1413
  tmp___0 = sh_eth_read(ndev, 4);
#line 1413
  sh_eth_write(ndev, tmp___0, 4);
#line 1414
  if ((int )start) {
#line 1415
    sh_eth_write(ndev, (mdp->cd)->eesipr_value, 5);
  } else {

  }
#line 1418
  tmp___1 = sh_eth_read(ndev, 28);
#line 1418
  val = (((u32 )tmp___1 & 2U) | (mdp->duplex != 0 ? 2U : 0U)) | 524384U;
#line 1421
  sh_eth_write(ndev, (unsigned long )val, 28);
#line 1423
  if ((unsigned long )(mdp->cd)->set_rate != (unsigned long )((void (*)(struct net_device * ))0)) {
#line 1424
    (*((mdp->cd)->set_rate))(ndev);
  } else {

  }
#line 1427
  sh_eth_write(ndev, (mdp->cd)->ecsr_value, 29);
#line 1430
  if ((int )start) {
#line 1431
    sh_eth_write(ndev, (mdp->cd)->ecsipr_value, 30);
  } else {

  }
#line 1434
  update_mac_address(ndev);
#line 1437
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1438
    sh_eth_write(ndev, 1UL, 37);
  } else {

  }
#line 1439
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1440
    sh_eth_write(ndev, 1UL, 38);
  } else {

  }
#line 1441
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1442
    sh_eth_write(ndev, 0UL, 43);
  } else {

  }
#line 1444
  if ((int )start) {
#line 1446
    sh_eth_write(ndev, 1UL, 3);
#line 1448
    netif_start_queue(ndev);
  } else {

  }
#line 1451
  return (ret);
}
}
#line 1455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_txfree(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct sh_eth_txdesc *txdesc ;
  int free_num ;
  int entry ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 1457
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1457
  mdp = (struct sh_eth_private *)tmp;
#line 1459
  free_num = 0;
#line 1460
  entry = 0;
#line 1462
  goto ldv_44707;
  ldv_44706: 
#line 1463
  entry = (int )(mdp->dirty_tx % mdp->num_tx_ring);
#line 1464
  txdesc = mdp->tx_ring + (unsigned long )entry;
#line 1465
  tmp___0 = cpu_to_edmac(mdp, 2147483648U);
#line 1465
  if ((txdesc->status & tmp___0) != 0U) {
#line 1466
    goto ldv_44705;
  } else {

  }
#line 1468
  if ((unsigned long )*(mdp->tx_skbuff + (unsigned long )entry) != (unsigned long )((struct sk_buff *)0)) {
#line 1469
    dma_unmap_single_attrs(& ndev->dev, (dma_addr_t )txdesc->addr, (size_t )txdesc->buffer_length,
                           1, (struct dma_attrs *)0);
#line 1471
    dev_kfree_skb_irq(*(mdp->tx_skbuff + (unsigned long )entry));
#line 1472
    *(mdp->tx_skbuff + (unsigned long )entry) = (struct sk_buff *)0;
#line 1473
    free_num = free_num + 1;
  } else {

  }
#line 1475
  txdesc->status = cpu_to_edmac(mdp, 805306368U);
#line 1476
  if ((u32 )entry >= mdp->num_tx_ring - 1U) {
#line 1477
    tmp___1 = cpu_to_edmac(mdp, 1073741824U);
#line 1477
    txdesc->status = txdesc->status | tmp___1;
  } else {

  }
#line 1479
  ndev->stats.tx_packets = ndev->stats.tx_packets + 1UL;
#line 1480
  ndev->stats.tx_bytes = ndev->stats.tx_bytes + (unsigned long )txdesc->buffer_length;
#line 1462
  mdp->dirty_tx = mdp->dirty_tx + 1U;
  ldv_44707: ;
#line 1462
  if (mdp->cur_tx != mdp->dirty_tx) {
#line 1464
    goto ldv_44706;
  } else {

  }
  ldv_44705: ;
#line 1482
  return (free_num);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_rx(struct net_device *ndev , u32 intr_status , int *quota ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct sh_eth_rxdesc *rxdesc ;
  int entry ;
  int boguscnt ;
  struct sk_buff *skb ;
  u16 pkt_len ;
  u32 desc_status ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  phys_addr_t tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  u32 count ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 1488
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1488
  mdp = (struct sh_eth_private *)tmp;
#line 1491
  entry = (int )(mdp->cur_rx % mdp->num_rx_ring);
#line 1492
  boguscnt = (int )((mdp->dirty_rx + mdp->num_rx_ring) - mdp->cur_rx);
#line 1494
  pkt_len = 0U;
#line 1497
  rxdesc = mdp->rx_ring + (unsigned long )entry;
#line 1498
  goto ldv_44722;
  ldv_44721: 
#line 1499
  desc_status = cpu_to_edmac(mdp, rxdesc->status);
#line 1500
  pkt_len = rxdesc->frame_length;
#line 1502
  boguscnt = boguscnt - 1;
#line 1502
  if (boguscnt < 0) {
#line 1503
    goto ldv_44720;
  } else {

  }
#line 1505
  if (*quota <= 0) {
#line 1506
    goto ldv_44720;
  } else {

  }
#line 1508
  *quota = *quota - 1;
#line 1510
  if ((desc_status & 268435456U) == 0U) {
#line 1511
    ndev->stats.rx_length_errors = ndev->stats.rx_length_errors + 1UL;
  } else {

  }
#line 1519
  if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) != 0U) {
#line 1520
    desc_status = desc_status >> 16;
  } else {

  }
#line 1522
  if ((desc_status & 575U) != 0U) {
#line 1524
    ndev->stats.rx_errors = ndev->stats.rx_errors + 1UL;
#line 1525
    if ((int )desc_status & 1) {
#line 1526
      ndev->stats.rx_crc_errors = ndev->stats.rx_crc_errors + 1UL;
    } else {

    }
#line 1527
    if ((desc_status & 2U) != 0U) {
#line 1528
      ndev->stats.rx_frame_errors = ndev->stats.rx_frame_errors + 1UL;
    } else {

    }
#line 1529
    if ((desc_status & 4U) != 0U) {
#line 1530
      ndev->stats.rx_length_errors = ndev->stats.rx_length_errors + 1UL;
    } else {

    }
#line 1531
    if ((desc_status & 8U) != 0U) {
#line 1532
      ndev->stats.rx_length_errors = ndev->stats.rx_length_errors + 1UL;
    } else {

    }
#line 1533
    if ((desc_status & 32U) != 0U) {
#line 1534
      ndev->stats.rx_missed_errors = ndev->stats.rx_missed_errors + 1UL;
    } else {

    }
#line 1535
    if ((desc_status & 512U) != 0U) {
#line 1536
      ndev->stats.rx_over_errors = ndev->stats.rx_over_errors + 1UL;
    } else {

    }
  } else {
#line 1538
    if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U) {
#line 1539
      tmp___0 = phys_to_virt((phys_addr_t )(rxdesc->addr + 3U) & 4294967292ULL);
#line 1539
      sh_eth_soft_swap((char *)tmp___0, (int )pkt_len + 2);
    } else {

    }
#line 1542
    skb = *(mdp->rx_skbuff + (unsigned long )entry);
#line 1543
    *(mdp->rx_skbuff + (unsigned long )entry) = (struct sk_buff *)0;
#line 1544
    if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 1545
      skb_reserve(skb, 0);
    } else {

    }
#line 1546
    dma_sync_single_for_cpu(& ndev->dev, (dma_addr_t )rxdesc->addr, (size_t )mdp->rx_buf_sz,
                            2);
#line 1549
    skb_put(skb, (unsigned int )pkt_len);
#line 1550
    skb->protocol = eth_type_trans(skb, ndev);
#line 1551
    netif_receive_skb(skb);
#line 1552
    ndev->stats.rx_packets = ndev->stats.rx_packets + 1UL;
#line 1553
    ndev->stats.rx_bytes = ndev->stats.rx_bytes + (unsigned long )pkt_len;
  }
#line 1555
  mdp->cur_rx = mdp->cur_rx + 1U;
#line 1555
  entry = (int )(mdp->cur_rx % mdp->num_rx_ring);
#line 1556
  rxdesc = mdp->rx_ring + (unsigned long )entry;
  ldv_44722: 
#line 1498
  tmp___1 = cpu_to_edmac(mdp, 2147483648U);
#line 1498
  if ((rxdesc->status & tmp___1) == 0U) {
#line 1500
    goto ldv_44721;
  } else {

  }
  ldv_44720: ;
#line 1560
  goto ldv_44725;
  ldv_44724: 
#line 1561
  entry = (int )(mdp->dirty_rx % mdp->num_rx_ring);
#line 1562
  rxdesc = mdp->rx_ring + (unsigned long )entry;
#line 1564
  rxdesc->buffer_length = ((unsigned int )((u16 )mdp->rx_buf_sz) + 15U) & 65520U;
#line 1566
  if ((unsigned long )*(mdp->rx_skbuff + (unsigned long )entry) == (unsigned long )((struct sk_buff *)0)) {
#line 1567
    skb = ldv_netdev_alloc_skb_12(ndev, mdp->rx_buf_sz);
#line 1568
    *(mdp->rx_skbuff + (unsigned long )entry) = skb;
#line 1569
    if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1570
      goto ldv_44723;
    } else {

    }
#line 1571
    dma_map_single_attrs(& ndev->dev, (void *)skb->data, (size_t )mdp->rx_buf_sz,
                         2, (struct dma_attrs *)0);
#line 1573
    sh_eth_set_receive_align(skb);
#line 1575
    skb_checksum_none_assert((struct sk_buff  const  *)skb);
#line 1576
    tmp___2 = virt_to_phys((void volatile   *)(((unsigned long )skb->data + 3UL) & 0xfffffffffffffffcUL));
#line 1576
    rxdesc->addr = (u32 )tmp___2;
  } else {

  }
#line 1578
  if ((u32 )entry >= mdp->num_rx_ring - 1U) {
#line 1579
    tmp___3 = cpu_to_edmac(mdp, 4026531840U);
#line 1579
    rxdesc->status = rxdesc->status | tmp___3;
  } else {
#line 1582
    tmp___4 = cpu_to_edmac(mdp, 2952790016U);
#line 1582
    rxdesc->status = rxdesc->status | tmp___4;
  }
#line 1560
  mdp->dirty_rx = mdp->dirty_rx + 1U;
  ldv_44725: ;
#line 1560
  if (mdp->cur_rx != mdp->dirty_rx) {
#line 1562
    goto ldv_44724;
  } else {

  }
  ldv_44723: 
#line 1588
  tmp___7 = sh_eth_read(ndev, 3);
#line 1588
  if ((tmp___7 & 1UL) == 0UL) {
#line 1590
    if ((intr_status & 131072U) != 0U) {
#line 1591
      tmp___5 = sh_eth_read(ndev, 11);
#line 1591
      tmp___6 = sh_eth_read(ndev, 10);
#line 1591
      count = (u32 )((tmp___5 - tmp___6) >> 4);
#line 1594
      mdp->cur_rx = count;
#line 1595
      mdp->dirty_rx = count;
    } else {

    }
#line 1597
    sh_eth_write(ndev, 1UL, 3);
  } else {

  }
#line 1600
  return (*quota <= 0);
}
}
#line 1603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_rcv_snd_disable(struct net_device *ndev ) 
{ 
  unsigned long tmp ;

  {
#line 1606
  tmp = sh_eth_read(ndev, 28);
#line 1606
  sh_eth_write(ndev, tmp & 0xffffffffffffff9fUL, 28);
#line 1607
  return;
}
}
#line 1610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_rcv_snd_enable(struct net_device *ndev ) 
{ 
  unsigned long tmp ;

  {
#line 1613
  tmp = sh_eth_read(ndev, 28);
#line 1613
  sh_eth_write(ndev, tmp | 96UL, 28);
#line 1614
  return;
}
}
#line 1618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_error(struct net_device *ndev , int intr_status ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  u32 felic_stat ;
  u32 link_stat ;
  u32 mask ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  u32 edtrr ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 1620
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1620
  mdp = (struct sh_eth_private *)tmp;
#line 1625
  if ((intr_status & 4194304) != 0) {
#line 1626
    tmp___0 = sh_eth_read(ndev, 29);
#line 1626
    felic_stat = (u32 )tmp___0;
#line 1627
    sh_eth_write(ndev, (unsigned long )felic_stat, 29);
#line 1628
    if ((int )felic_stat & 1) {
#line 1629
      ndev->stats.tx_carrier_errors = ndev->stats.tx_carrier_errors + 1UL;
    } else {

    }
#line 1630
    if ((felic_stat & 4U) != 0U) {
#line 1632
      if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U || (unsigned int )*((unsigned char *)mdp + 428UL) != 0U) {
#line 1633
        goto ignore_link;
      } else {
#line 1635
        tmp___1 = sh_eth_read(ndev, 32);
#line 1635
        link_stat = (u32 )tmp___1;
#line 1636
        if ((unsigned int )*((unsigned char *)mdp + 428UL) != 0U) {
#line 1637
          link_stat = ~ link_stat;
        } else {

        }
      }
#line 1639
      if ((link_stat & 1U) == 0U) {
#line 1640
        sh_eth_rcv_snd_disable(ndev);
      } else {
#line 1643
        tmp___2 = sh_eth_read(ndev, 5);
#line 1643
        sh_eth_write(ndev, tmp___2 & 0xffffffffffbfffffUL, 5);
#line 1646
        tmp___3 = sh_eth_read(ndev, 29);
#line 1646
        sh_eth_write(ndev, tmp___3, 29);
#line 1648
        tmp___4 = sh_eth_read(ndev, 5);
#line 1648
        sh_eth_write(ndev, tmp___4 | 4194304UL, 5);
#line 1651
        sh_eth_rcv_snd_enable(ndev);
      }
    } else {

    }
  } else {

  }
  ignore_link: ;
#line 1657
  if ((intr_status & 1073741824) != 0) {
#line 1659
    if ((intr_status & 67108864) != 0) {
#line 1660
      ndev->stats.tx_aborted_errors = ndev->stats.tx_aborted_errors + 1UL;
#line 1661
      if ((mdp->msg_enable & 128) != 0) {
#line 1661
        netdev_err((struct net_device  const  *)ndev, "Transmit Abort\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 1665
  if ((intr_status & 33554432) != 0) {
#line 1667
    if ((intr_status & 16777216) != 0) {
#line 1669
      ndev->stats.rx_frame_errors = ndev->stats.rx_frame_errors + 1UL;
#line 1670
      if ((mdp->msg_enable & 64) != 0) {
#line 1670
        netdev_err((struct net_device  const  *)ndev, "Receive Abort\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 1674
  if ((intr_status & 1048576) != 0) {
#line 1676
    ndev->stats.tx_fifo_errors = ndev->stats.tx_fifo_errors + 1UL;
#line 1677
    if ((mdp->msg_enable & 128) != 0) {
#line 1677
      netdev_err((struct net_device  const  *)ndev, "Transmit Descriptor Empty\n");
    } else {

    }
  } else {

  }
#line 1680
  if ((intr_status & 524288) != 0) {
#line 1682
    ndev->stats.tx_fifo_errors = ndev->stats.tx_fifo_errors + 1UL;
#line 1683
    if ((mdp->msg_enable & 128) != 0) {
#line 1683
      netdev_err((struct net_device  const  *)ndev, "Transmit FIFO Under flow\n");
    } else {

    }
  } else {

  }
#line 1686
  if ((intr_status & 131072) != 0) {
#line 1688
    ndev->stats.rx_over_errors = ndev->stats.rx_over_errors + 1UL;
#line 1689
    if ((mdp->msg_enable & 64) != 0) {
#line 1689
      netdev_err((struct net_device  const  *)ndev, "Receive Descriptor Empty\n");
    } else {

    }
  } else {

  }
#line 1692
  if ((intr_status & 65536) != 0) {
#line 1694
    ndev->stats.rx_fifo_errors = ndev->stats.rx_fifo_errors + 1UL;
#line 1695
    if ((mdp->msg_enable & 64) != 0) {
#line 1695
      netdev_err((struct net_device  const  *)ndev, "Receive FIFO Overflow\n");
    } else {

    }
  } else {

  }
#line 1698
  if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) == 0U && (intr_status & 8388608) != 0) {
#line 1700
    ndev->stats.tx_fifo_errors = ndev->stats.tx_fifo_errors + 1UL;
#line 1701
    if ((mdp->msg_enable & 128) != 0) {
#line 1701
      netdev_err((struct net_device  const  *)ndev, "Address Error\n");
    } else {

    }
  } else {

  }
#line 1704
  mask = 1150812160U;
#line 1705
  if ((unsigned int )*((unsigned char *)mdp->cd + 105UL) != 0U) {
#line 1706
    mask = mask & 4286578687U;
  } else {

  }
#line 1707
  if (((u32 )intr_status & mask) != 0U) {
#line 1709
    tmp___5 = sh_eth_read(ndev, 2);
#line 1709
    edtrr = (u32 )tmp___5;
#line 1712
    netdev_err((struct net_device  const  *)ndev, "TX error. status=%8.8x cur_tx=%8.8x dirty_tx=%8.8x state=%8.8x EDTRR=%8.8x.\n",
               intr_status, mdp->cur_tx, mdp->dirty_tx, (unsigned int )ndev->state,
               edtrr);
#line 1716
    sh_eth_txfree(ndev);
#line 1719
    tmp___7 = sh_eth_get_edtrr_trns(mdp);
#line 1719
    if ((unsigned long )edtrr != tmp___7) {
#line 1721
      tmp___6 = sh_eth_get_edtrr_trns(mdp);
#line 1721
      sh_eth_write(ndev, tmp___6, 2);
    } else {

    }
#line 1724
    netif_wake_queue(ndev);
  } else {

  }
#line 1726
  return;
}
}
#line 1728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static irqreturn_t sh_eth_interrupt(int irq , void *netdev ) 
{ 
  struct net_device *ndev ;
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct sh_eth_cpu_data *cd ;
  irqreturn_t ret ;
  unsigned long intr_status ;
  unsigned long intr_enable ;
  bool tmp___0 ;

  {
#line 1730
  ndev = (struct net_device *)netdev;
#line 1731
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1731
  mdp = (struct sh_eth_private *)tmp;
#line 1732
  cd = mdp->cd;
#line 1733
  ret = 0;
#line 1736
  spin_lock(& mdp->lock);
#line 1739
  intr_status = sh_eth_read(ndev, 4);
#line 1745
  intr_enable = sh_eth_read(ndev, 5);
#line 1746
  intr_status = (intr_enable | 4194304UL) & intr_status;
#line 1747
  if ((((cd->tx_check | cd->eesr_err_check) | 262303UL) & intr_status) != 0UL) {
#line 1748
    ret = 1;
  } else {
#line 1750
    goto other_irq;
  }
#line 1752
  if ((intr_status & 262303UL) != 0UL) {
#line 1753
    tmp___0 = napi_schedule_prep(& mdp->napi);
#line 1753
    if ((int )tmp___0) {
#line 1755
      sh_eth_write(ndev, intr_enable & 0xfffffffffffbff60UL, 5);
#line 1757
      __napi_schedule(& mdp->napi);
    } else {
#line 1759
      netdev_warn((struct net_device  const  *)ndev, "ignoring interrupt, status 0x%08lx, mask 0x%08lx.\n",
                  intr_status, intr_enable);
    }
  } else {

  }
#line 1766
  if ((cd->tx_check & intr_status) != 0UL) {
#line 1768
    sh_eth_write(ndev, cd->tx_check & intr_status, 4);
#line 1770
    sh_eth_txfree(ndev);
#line 1771
    netif_wake_queue(ndev);
  } else {

  }
#line 1774
  if ((cd->eesr_err_check & intr_status) != 0UL) {
#line 1776
    sh_eth_write(ndev, cd->eesr_err_check & intr_status, 4);
#line 1778
    sh_eth_error(ndev, (int )intr_status);
  } else {

  }
  other_irq: 
#line 1782
  spin_unlock(& mdp->lock);
#line 1784
  return (ret);
}
}
#line 1787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_poll(struct napi_struct *napi , int budget ) 
{ 
  struct sh_eth_private *mdp ;
  struct napi_struct  const  *__mptr ;
  struct net_device *ndev ;
  int quota ;
  unsigned long intr_status ;
  int tmp ;

  {
#line 1789
  __mptr = (struct napi_struct  const  *)napi;
#line 1789
  mdp = (struct sh_eth_private *)__mptr + 0xffffffffffffff40UL;
#line 1791
  ndev = napi->dev;
#line 1792
  quota = budget;
  ldv_44766: 
#line 1796
  intr_status = sh_eth_read(ndev, 4);
#line 1797
  if ((intr_status & 262303UL) == 0UL) {
#line 1798
    goto ldv_44764;
  } else {

  }
#line 1800
  sh_eth_write(ndev, intr_status & 262303UL, 4);
#line 1802
  tmp = sh_eth_rx(ndev, (u32 )intr_status, & quota);
#line 1802
  if (tmp != 0) {
#line 1803
    goto out;
  } else {

  }
#line 1804
  goto ldv_44766;
  ldv_44764: 
#line 1806
  napi_complete(napi);
#line 1809
  sh_eth_write(ndev, (mdp->cd)->eesipr_value, 5);
  out: ;
#line 1811
  return (budget - quota);
}
}
#line 1815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_adjust_link(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct phy_device *phydev ;
  int new_state ;
  unsigned long tmp___0 ;

  {
#line 1817
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1817
  mdp = (struct sh_eth_private *)tmp;
#line 1818
  phydev = mdp->phydev;
#line 1819
  new_state = 0;
#line 1821
  if (phydev->link != 0) {
#line 1822
    if (phydev->duplex != mdp->duplex) {
#line 1823
      new_state = 1;
#line 1824
      mdp->duplex = phydev->duplex;
#line 1825
      if ((unsigned long )(mdp->cd)->set_duplex != (unsigned long )((void (*)(struct net_device * ))0)) {
#line 1826
        (*((mdp->cd)->set_duplex))(ndev);
      } else {

      }
    } else {

    }
#line 1829
    if (phydev->speed != mdp->speed) {
#line 1830
      new_state = 1;
#line 1831
      mdp->speed = phydev->speed;
#line 1832
      if ((unsigned long )(mdp->cd)->set_rate != (unsigned long )((void (*)(struct net_device * ))0)) {
#line 1833
        (*((mdp->cd)->set_rate))(ndev);
      } else {

      }
    } else {

    }
#line 1835
    if (mdp->link == 0) {
#line 1836
      tmp___0 = sh_eth_read(ndev, 28);
#line 1836
      sh_eth_write(ndev, tmp___0 & 0xfffffffffffeffffUL, 28);
#line 1839
      new_state = 1;
#line 1840
      mdp->link = phydev->link;
#line 1841
      if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U || (unsigned int )*((unsigned char *)mdp + 428UL) != 0U) {
#line 1842
        sh_eth_rcv_snd_enable(ndev);
      } else {

      }
    } else {

    }
  } else
#line 1844
  if (mdp->link != 0) {
#line 1845
    new_state = 1;
#line 1846
    mdp->link = 0;
#line 1847
    mdp->speed = 0;
#line 1848
    mdp->duplex = -1;
#line 1849
    if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U || (unsigned int )*((unsigned char *)mdp + 428UL) != 0U) {
#line 1850
      sh_eth_rcv_snd_disable(ndev);
    } else {

    }
  } else {

  }
#line 1853
  if (new_state != 0 && (mdp->msg_enable & 4) != 0) {
#line 1854
    phy_print_status(phydev);
  } else {

  }
#line 1855
  return;
}
}
#line 1858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_phy_init(struct net_device *ndev ) 
{ 
  struct device_node *np ;
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct phy_device *phydev ;
  struct device_node *pn ;
  void *tmp___0 ;
  char phy_id[20U] ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 1860
  np = (ndev->dev.parent)->of_node;
#line 1861
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1861
  mdp = (struct sh_eth_private *)tmp;
#line 1862
  phydev = (struct phy_device *)0;
#line 1864
  mdp->link = 0;
#line 1865
  mdp->speed = 0;
#line 1866
  mdp->duplex = -1;
#line 1869
  if ((unsigned long )np != (unsigned long )((struct device_node *)0)) {
#line 1872
    pn = of_parse_phandle((struct device_node  const  *)np, "phy-handle", 0);
#line 1873
    phydev = of_phy_connect(ndev, pn, & sh_eth_adjust_link, 0U, mdp->phy_interface);
#line 1877
    if ((unsigned long )phydev == (unsigned long )((struct phy_device *)0)) {
#line 1878
      tmp___0 = ERR_PTR(-2L);
#line 1878
      phydev = (struct phy_device *)tmp___0;
    } else {

    }
  } else {
#line 1882
    snprintf((char *)(& phy_id), 20UL, "%s:%02x", (char *)(& (mdp->mii_bus)->id),
             mdp->phy_id);
#line 1885
    phydev = phy_connect(ndev, (char const   *)(& phy_id), & sh_eth_adjust_link, mdp->phy_interface);
  }
#line 1889
  tmp___2 = IS_ERR((void const   *)phydev);
#line 1889
  if ((int )tmp___2) {
#line 1890
    netdev_err((struct net_device  const  *)ndev, "failed to connect PHY\n");
#line 1891
    tmp___1 = PTR_ERR((void const   *)phydev);
#line 1891
    return ((int )tmp___1);
  } else {

  }
#line 1894
  netdev_info((struct net_device  const  *)ndev, "attached PHY %d (IRQ %d) to driver %s\n",
              phydev->addr, phydev->irq, (phydev->drv)->name);
#line 1897
  mdp->phydev = phydev;
#line 1899
  return (0);
}
}
#line 1903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_phy_start(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int ret ;

  {
#line 1905
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1905
  mdp = (struct sh_eth_private *)tmp;
#line 1908
  ret = sh_eth_phy_init(ndev);
#line 1909
  if (ret != 0) {
#line 1910
    return (ret);
  } else {

  }
#line 1912
  phy_start(mdp->phydev);
#line 1914
  return (0);
}
}
#line 1917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_get_settings(struct net_device *ndev , struct ethtool_cmd *ecmd ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1920
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1920
  mdp = (struct sh_eth_private *)tmp;
#line 1924
  tmp___0 = spinlock_check(& mdp->lock);
#line 1924
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1925
  ret = phy_ethtool_gset(mdp->phydev, ecmd);
#line 1926
  spin_unlock_irqrestore(& mdp->lock, flags);
#line 1928
  return (ret);
}
}
#line 1931 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_set_settings(struct net_device *ndev , struct ethtool_cmd *ecmd ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;

  {
#line 1934
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1934
  mdp = (struct sh_eth_private *)tmp;
#line 1938
  tmp___0 = spinlock_check(& mdp->lock);
#line 1938
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1941
  sh_eth_rcv_snd_disable(ndev);
#line 1943
  ret = phy_ethtool_sset(mdp->phydev, ecmd);
#line 1944
  if (ret != 0) {
#line 1945
    goto error_exit;
  } else {

  }
#line 1947
  if ((unsigned int )ecmd->duplex == 1U) {
#line 1948
    mdp->duplex = 1;
  } else {
#line 1950
    mdp->duplex = 0;
  }
#line 1952
  if ((unsigned long )(mdp->cd)->set_duplex != (unsigned long )((void (*)(struct net_device * ))0)) {
#line 1953
    (*((mdp->cd)->set_duplex))(ndev);
  } else {

  }
  error_exit: ;
#line 1956
  if (1) {
#line 1956
    __const_udelay(4295000UL);
  } else {
#line 1956
    __ms = 1UL;
#line 1956
    goto ldv_44809;
    ldv_44808: 
#line 1956
    __const_udelay(4295000UL);
    ldv_44809: 
#line 1956
    tmp___1 = __ms;
#line 1956
    __ms = __ms - 1UL;
#line 1956
    if (tmp___1 != 0UL) {
#line 1958
      goto ldv_44808;
    } else {

    }

  }
#line 1959
  sh_eth_rcv_snd_enable(ndev);
#line 1961
  spin_unlock_irqrestore(& mdp->lock, flags);
#line 1963
  return (ret);
}
}
#line 1966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_nway_reset(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1968
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1968
  mdp = (struct sh_eth_private *)tmp;
#line 1972
  tmp___0 = spinlock_check(& mdp->lock);
#line 1972
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1973
  ret = phy_start_aneg(mdp->phydev);
#line 1974
  spin_unlock_irqrestore(& mdp->lock, flags);
#line 1976
  return (ret);
}
}
#line 1979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u32 sh_eth_get_msglevel(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 1981
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1981
  mdp = (struct sh_eth_private *)tmp;
#line 1982
  return ((u32 )mdp->msg_enable);
}
}
#line 1985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_msglevel(struct net_device *ndev , u32 value ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 1987
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1987
  mdp = (struct sh_eth_private *)tmp;
#line 1988
  mdp->msg_enable = (int )value;
#line 1989
  return;
}
}
#line 1991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static char const   sh_eth_gstrings_stats[4U][32U]  = { {        'r',        'x',        '_',        'c', 
            'u',        'r',        'r',        'e', 
            'n',        't',        '\000'}, 
   {        't',        'x',        '_',        'c', 
            'u',        'r',        'r',        'e', 
            'n',        't',        '\000'}, 
   {        'r',        'x',        '_',        'd', 
            'i',        'r',        't',        'y', 
            '\000'}, 
   {        't',        'x',        '_',        'd', 
            'i',        'r',        't',        'y', 
            '\000'}};
#line 1997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_get_sset_count(struct net_device *netdev , int sset ) 
{ 


  {
#line 1999
  switch (sset) {
  case 1: ;
#line 2001
  return (4);
  default: ;
#line 2003
  return (-95);
  }
}
}
#line 2007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_get_ethtool_stats(struct net_device *ndev , struct ethtool_stats *stats ,
                                     u64 *data ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2010
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2010
  mdp = (struct sh_eth_private *)tmp;
#line 2011
  i = 0;
#line 2014
  tmp___0 = i;
#line 2014
  i = i + 1;
#line 2014
  *(data + (unsigned long )tmp___0) = (u64 )mdp->cur_rx;
#line 2015
  tmp___1 = i;
#line 2015
  i = i + 1;
#line 2015
  *(data + (unsigned long )tmp___1) = (u64 )mdp->cur_tx;
#line 2016
  tmp___2 = i;
#line 2016
  i = i + 1;
#line 2016
  *(data + (unsigned long )tmp___2) = (u64 )mdp->dirty_rx;
#line 2017
  tmp___3 = i;
#line 2017
  i = i + 1;
#line 2017
  *(data + (unsigned long )tmp___3) = (u64 )mdp->dirty_tx;
#line 2018
  return;
}
}
#line 2020 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_get_strings(struct net_device *ndev , u32 stringset , u8 *data ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 2022
  switch (stringset) {
  case 1U: 
#line 2024
  __len = 128UL;
#line 2024
  if (__len > 63UL) {
#line 2024
    __ret = __memcpy((void *)data, (void const   *)(& sh_eth_gstrings_stats), __len);
  } else {
#line 2024
    __ret = __builtin_memcpy((void *)data, (void const   *)(& sh_eth_gstrings_stats),
                             __len);
  }
#line 2026
  goto ldv_44854;
  }
  ldv_44854: ;
#line 2029
  return;
}
}
#line 2030 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_get_ringparam(struct net_device *ndev , struct ethtool_ringparam *ring ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 2033
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2033
  mdp = (struct sh_eth_private *)tmp;
#line 2035
  ring->rx_max_pending = 1024U;
#line 2036
  ring->tx_max_pending = 1024U;
#line 2037
  ring->rx_pending = mdp->num_rx_ring;
#line 2038
  ring->tx_pending = mdp->num_tx_ring;
#line 2039
  return;
}
}
#line 2041 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_set_ringparam(struct net_device *ndev , struct ethtool_ringparam *ring ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int ret ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2044
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2044
  mdp = (struct sh_eth_private *)tmp;
#line 2047
  if (((ring->tx_pending > 1024U || ring->rx_pending > 1024U) || ring->tx_pending <= 63U) || ring->rx_pending <= 63U) {
#line 2051
    return (-22);
  } else {

  }
#line 2052
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
#line 2053
    return (-22);
  } else {

  }
#line 2055
  tmp___0 = netif_running((struct net_device  const  *)ndev);
#line 2055
  if ((int )tmp___0) {
#line 2056
    netif_tx_disable(ndev);
#line 2058
    sh_eth_write(ndev, 0UL, 5);
#line 2060
    sh_eth_write(ndev, 0UL, 2);
#line 2061
    sh_eth_write(ndev, 0UL, 3);
#line 2062
    synchronize_irq((unsigned int )ndev->irq);
  } else {

  }
#line 2066
  sh_eth_ring_free(ndev);
#line 2068
  sh_eth_free_dma_buffer(mdp);
#line 2071
  mdp->num_rx_ring = ring->rx_pending;
#line 2072
  mdp->num_tx_ring = ring->tx_pending;
#line 2074
  ret = sh_eth_ring_init(ndev);
#line 2075
  if (ret < 0) {
#line 2076
    netdev_err((struct net_device  const  *)ndev, "%s: sh_eth_ring_init failed.\n",
               "sh_eth_set_ringparam");
#line 2077
    return (ret);
  } else {

  }
#line 2079
  ret = sh_eth_dev_init(ndev, 0);
#line 2080
  if (ret < 0) {
#line 2081
    netdev_err((struct net_device  const  *)ndev, "%s: sh_eth_dev_init failed.\n",
               "sh_eth_set_ringparam");
#line 2082
    return (ret);
  } else {

  }
#line 2085
  tmp___1 = netif_running((struct net_device  const  *)ndev);
#line 2085
  if ((int )tmp___1) {
#line 2086
    sh_eth_write(ndev, (mdp->cd)->eesipr_value, 5);
#line 2088
    sh_eth_write(ndev, 1UL, 3);
#line 2089
    netif_wake_queue(ndev);
  } else {

  }
#line 2092
  return (0);
}
}
#line 2095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct ethtool_ops  const  sh_eth_ethtool_ops  = 
#line 2095
     {& sh_eth_get_settings, & sh_eth_set_settings, 0, 0, 0, 0, 0, & sh_eth_get_msglevel,
    & sh_eth_set_msglevel, & sh_eth_nway_reset, & ethtool_op_get_link, 0, 0, 0, 0,
    0, & sh_eth_get_ringparam, & sh_eth_set_ringparam, 0, 0, 0, & sh_eth_get_strings,
    0, & sh_eth_get_ethtool_stats, 0, 0, 0, 0, & sh_eth_get_sset_count, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_open(struct net_device *ndev ) 
{ 
  int ret ;
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 2112
  ret = 0;
#line 2113
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2113
  mdp = (struct sh_eth_private *)tmp;
#line 2115
  pm_runtime_get_sync(& (mdp->pdev)->dev);
#line 2117
  napi_enable(& mdp->napi);
#line 2119
  ret = ldv_request_irq_14((unsigned int )ndev->irq, & sh_eth_interrupt, (mdp->cd)->irq_flags,
                           (char const   *)(& ndev->name), (void *)ndev);
#line 2121
  if (ret != 0) {
#line 2122
    netdev_err((struct net_device  const  *)ndev, "Can not assign IRQ number\n");
#line 2123
    goto out_napi_off;
  } else {

  }
#line 2127
  ret = sh_eth_ring_init(ndev);
#line 2128
  if (ret != 0) {
#line 2129
    goto out_free_irq;
  } else {

  }
#line 2132
  ret = sh_eth_dev_init(ndev, 1);
#line 2133
  if (ret != 0) {
#line 2134
    goto out_free_irq;
  } else {

  }
#line 2137
  ret = sh_eth_phy_start(ndev);
#line 2138
  if (ret != 0) {
#line 2139
    goto out_free_irq;
  } else {

  }
#line 2141
  return (ret);
  out_free_irq: 
#line 2144
  ldv_free_irq_15((unsigned int )ndev->irq, (void *)ndev);
  out_napi_off: 
#line 2146
  napi_disable(& mdp->napi);
#line 2147
  pm_runtime_put_sync(& (mdp->pdev)->dev);
#line 2148
  return (ret);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_tx_timeout(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct sh_eth_rxdesc *rxdesc ;
  int i ;
  unsigned long tmp___0 ;

  {
#line 2154
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2154
  mdp = (struct sh_eth_private *)tmp;
#line 2158
  netif_stop_queue(ndev);
#line 2160
  if ((mdp->msg_enable & 8) != 0) {
#line 2162
    tmp___0 = sh_eth_read(ndev, 4);
#line 2162
    netdev_err((struct net_device  const  *)ndev, "transmit timed out, status %8.8x, resetting...\n",
               (int )tmp___0);
  } else {

  }
#line 2165
  ndev->stats.tx_errors = ndev->stats.tx_errors + 1UL;
#line 2168
  i = 0;
#line 2168
  goto ldv_44882;
  ldv_44881: 
#line 2169
  rxdesc = mdp->rx_ring + (unsigned long )i;
#line 2170
  rxdesc->status = 0U;
#line 2171
  rxdesc->addr = 3135176912U;
#line 2172
  if ((unsigned long )*(mdp->rx_skbuff + (unsigned long )i) != (unsigned long )((struct sk_buff *)0)) {
#line 2173
    ldv_skb_free(*(mdp->rx_skbuff + (unsigned long )i));
  } else {

  }
#line 2174
  *(mdp->rx_skbuff + (unsigned long )i) = (struct sk_buff *)0;
#line 2168
  i = i + 1;
  ldv_44882: ;
#line 2168
  if ((u32 )i < mdp->num_rx_ring) {
#line 2170
    goto ldv_44881;
  } else {

  }
#line 2176
  i = 0;
#line 2176
  goto ldv_44885;
  ldv_44884: ;
#line 2177
  if ((unsigned long )*(mdp->tx_skbuff + (unsigned long )i) != (unsigned long )((struct sk_buff *)0)) {
#line 2178
    ldv_skb_free(*(mdp->tx_skbuff + (unsigned long )i));
  } else {

  }
#line 2179
  *(mdp->tx_skbuff + (unsigned long )i) = (struct sk_buff *)0;
#line 2176
  i = i + 1;
  ldv_44885: ;
#line 2176
  if ((u32 )i < mdp->num_tx_ring) {
#line 2178
    goto ldv_44884;
  } else {

  }
#line 2183
  sh_eth_dev_init(ndev, 1);
#line 2184
  return;
}
}
#line 2187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_start_xmit(struct sk_buff *skb , struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct sh_eth_txdesc *txdesc ;
  u32 entry ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  dma_addr_t tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
#line 2189
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2189
  mdp = (struct sh_eth_private *)tmp;
#line 2194
  tmp___0 = spinlock_check(& mdp->lock);
#line 2194
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2195
  if (mdp->cur_tx - mdp->dirty_tx >= mdp->num_tx_ring - 4U) {
#line 2196
    tmp___1 = sh_eth_txfree(ndev);
#line 2196
    if (tmp___1 == 0) {
#line 2197
      if ((mdp->msg_enable & 256) != 0) {
#line 2197
        netdev_warn((struct net_device  const  *)ndev, "TxFD exhausted.\n");
      } else {

      }
#line 2198
      netif_stop_queue(ndev);
#line 2199
      spin_unlock_irqrestore(& mdp->lock, flags);
#line 2200
      return (16);
    } else {

    }
  } else {

  }
#line 2203
  spin_unlock_irqrestore(& mdp->lock, flags);
#line 2205
  entry = mdp->cur_tx % mdp->num_tx_ring;
#line 2206
  *(mdp->tx_skbuff + (unsigned long )entry) = skb;
#line 2207
  txdesc = mdp->tx_ring + (unsigned long )entry;
#line 2209
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U) {
#line 2210
    tmp___2 = phys_to_virt((phys_addr_t )(txdesc->addr + 3U) & 4294967292ULL);
#line 2210
    sh_eth_soft_swap((char *)tmp___2, (int )(skb->len + 2U));
  } else {

  }
#line 2212
  tmp___3 = dma_map_single_attrs(& ndev->dev, (void *)skb->data, (size_t )skb->len,
                                 1, (struct dma_attrs *)0);
#line 2212
  txdesc->addr = (u32 )tmp___3;
#line 2214
  if (skb->len <= 59U) {
#line 2215
    txdesc->buffer_length = 60U;
  } else {
#line 2217
    txdesc->buffer_length = (u16 )skb->len;
  }
#line 2219
  if (mdp->num_tx_ring - 1U <= entry) {
#line 2220
    tmp___4 = cpu_to_edmac(mdp, 3221225472U);
#line 2220
    txdesc->status = txdesc->status | tmp___4;
  } else {
#line 2222
    tmp___5 = cpu_to_edmac(mdp, 2147483648U);
#line 2222
    txdesc->status = txdesc->status | tmp___5;
  }
#line 2224
  mdp->cur_tx = mdp->cur_tx + 1U;
#line 2226
  tmp___7 = sh_eth_read(ndev, 2);
#line 2226
  tmp___8 = sh_eth_get_edtrr_trns(mdp);
#line 2226
  if ((tmp___7 & tmp___8) == 0UL) {
#line 2227
    tmp___6 = sh_eth_get_edtrr_trns(mdp);
#line 2227
    sh_eth_write(ndev, tmp___6, 2);
  } else {

  }
#line 2229
  return (0);
}
}
#line 2233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_close(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;

  {
#line 2235
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2235
  mdp = (struct sh_eth_private *)tmp;
#line 2237
  netif_stop_queue(ndev);
#line 2240
  sh_eth_write(ndev, 0UL, 5);
#line 2243
  sh_eth_write(ndev, 0UL, 2);
#line 2244
  sh_eth_write(ndev, 0UL, 3);
#line 2247
  if ((unsigned long )mdp->phydev != (unsigned long )((struct phy_device *)0)) {
#line 2248
    phy_stop(mdp->phydev);
#line 2249
    phy_disconnect(mdp->phydev);
  } else {

  }
#line 2252
  ldv_free_irq_16((unsigned int )ndev->irq, (void *)ndev);
#line 2254
  napi_disable(& mdp->napi);
#line 2257
  sh_eth_ring_free(ndev);
#line 2260
  sh_eth_free_dma_buffer(mdp);
#line 2262
  pm_runtime_put_sync(& (mdp->pdev)->dev);
#line 2264
  return (0);
}
}
#line 2267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct net_device_stats *sh_eth_get_stats(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  bool tmp___7 ;

  {
#line 2269
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2269
  mdp = (struct sh_eth_private *)tmp;
#line 2271
  tmp___0 = sh_eth_is_rz_fast_ether(mdp);
#line 2271
  if ((int )tmp___0) {
#line 2272
    return (& ndev->stats);
  } else {

  }
#line 2274
  pm_runtime_get_sync(& (mdp->pdev)->dev);
#line 2276
  tmp___1 = sh_eth_read(ndev, 51);
#line 2276
  ndev->stats.tx_dropped = ndev->stats.tx_dropped + tmp___1;
#line 2277
  sh_eth_write(ndev, 0UL, 51);
#line 2278
  tmp___2 = sh_eth_read(ndev, 52);
#line 2278
  ndev->stats.collisions = ndev->stats.collisions + tmp___2;
#line 2279
  sh_eth_write(ndev, 0UL, 52);
#line 2280
  tmp___3 = sh_eth_read(ndev, 53);
#line 2280
  ndev->stats.tx_carrier_errors = ndev->stats.tx_carrier_errors + tmp___3;
#line 2281
  sh_eth_write(ndev, 0UL, 53);
#line 2282
  tmp___7 = sh_eth_is_gether(mdp);
#line 2282
  if ((int )tmp___7) {
#line 2283
    tmp___4 = sh_eth_read(ndev, 59);
#line 2283
    ndev->stats.tx_carrier_errors = ndev->stats.tx_carrier_errors + tmp___4;
#line 2284
    sh_eth_write(ndev, 0UL, 59);
#line 2285
    tmp___5 = sh_eth_read(ndev, 60);
#line 2285
    ndev->stats.tx_carrier_errors = ndev->stats.tx_carrier_errors + tmp___5;
#line 2286
    sh_eth_write(ndev, 0UL, 60);
  } else {
#line 2288
    tmp___6 = sh_eth_read(ndev, 54);
#line 2288
    ndev->stats.tx_carrier_errors = ndev->stats.tx_carrier_errors + tmp___6;
#line 2289
    sh_eth_write(ndev, 0UL, 54);
  }
#line 2291
  pm_runtime_put_sync(& (mdp->pdev)->dev);
#line 2293
  return (& ndev->stats);
}
}
#line 2297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_do_ioctl(struct net_device *ndev , struct ifreq *rq , int cmd ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  struct phy_device *phydev ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2299
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2299
  mdp = (struct sh_eth_private *)tmp;
#line 2300
  phydev = mdp->phydev;
#line 2302
  tmp___0 = netif_running((struct net_device  const  *)ndev);
#line 2302
  if (tmp___0) {
#line 2302
    tmp___1 = 0;
  } else {
#line 2302
    tmp___1 = 1;
  }
#line 2302
  if (tmp___1) {
#line 2303
    return (-22);
  } else {

  }
#line 2305
  if ((unsigned long )phydev == (unsigned long )((struct phy_device *)0)) {
#line 2306
    return (-19);
  } else {

  }
#line 2308
  tmp___2 = phy_mii_ioctl(phydev, rq, cmd);
#line 2308
  return (tmp___2);
}
}
#line 2312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void *sh_eth_tsu_get_post_reg_offset(struct sh_eth_private *mdp , int entry ) 
{ 
  void *tmp ;

  {
#line 2315
  tmp = sh_eth_tsu_get_offset(mdp, 89);
#line 2315
  return (tmp + (unsigned long )((entry / 8) * 4));
}
}
#line 2318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u32 sh_eth_tsu_get_post_mask(int entry ) 
{ 


  {
#line 2320
  return ((u32 )(15 << (7 - entry % 8) * 4));
}
}
#line 2323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u32 sh_eth_tsu_get_post_bit(struct sh_eth_private *mdp , int entry ) 
{ 


  {
#line 2325
  return ((u32 )((8 >> (mdp->port << 1)) << (7 - entry % 8) * 4));
}
}
#line 2328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_tsu_enable_cam_entry_post(struct net_device *ndev , int entry ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  u32 tmp___0 ;
  void *reg_offset ;
  u32 tmp___1 ;

  {
#line 2331
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2331
  mdp = (struct sh_eth_private *)tmp;
#line 2335
  reg_offset = sh_eth_tsu_get_post_reg_offset(mdp, entry);
#line 2336
  tmp___0 = ioread32(reg_offset);
#line 2337
  tmp___1 = sh_eth_tsu_get_post_bit(mdp, entry);
#line 2337
  iowrite32(tmp___1 | tmp___0, reg_offset);
#line 2338
  return;
}
}
#line 2340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static bool sh_eth_tsu_disable_cam_entry_post(struct net_device *ndev , int entry ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  u32 post_mask ;
  u32 ref_mask ;
  u32 tmp___0 ;
  void *reg_offset ;
  u32 tmp___1 ;

  {
#line 2343
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2343
  mdp = (struct sh_eth_private *)tmp;
#line 2347
  reg_offset = sh_eth_tsu_get_post_reg_offset(mdp, entry);
#line 2348
  post_mask = sh_eth_tsu_get_post_mask(entry);
#line 2349
  tmp___1 = sh_eth_tsu_get_post_bit(mdp, entry);
#line 2349
  ref_mask = tmp___1 & ~ post_mask;
#line 2351
  tmp___0 = ioread32(reg_offset);
#line 2352
  iowrite32(~ post_mask & tmp___0, reg_offset);
#line 2355
  return ((tmp___0 & ref_mask) != 0U);
}
}
#line 2358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_busy(struct net_device *ndev ) 
{ 
  int timeout ;
  struct sh_eth_private *mdp ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 2360
  timeout = 50000;
#line 2361
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2361
  mdp = (struct sh_eth_private *)tmp;
#line 2363
  goto ldv_44947;
  ldv_44946: 
#line 2364
  __const_udelay(42950UL);
#line 2365
  timeout = timeout - 1;
#line 2366
  if (timeout <= 0) {
#line 2367
    netdev_err((struct net_device  const  *)ndev, "%s: timeout\n", "sh_eth_tsu_busy");
#line 2368
    return (-110);
  } else {

  }
  ldv_44947: 
#line 2363
  tmp___0 = sh_eth_tsu_read(mdp, 87);
#line 2363
  if ((int )tmp___0 & 1) {
#line 2365
    goto ldv_44946;
  } else {

  }

#line 2372
  return (0);
}
}
#line 2375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_write_entry(struct net_device *ndev , void *reg , u8 const   *addr ) 
{ 
  u32 val ;
  int tmp ;
  int tmp___0 ;

  {
#line 2380
  val = (u32 )(((((int )*addr << 24) | ((int )*(addr + 1UL) << 16)) | ((int )*(addr + 2UL) << 8)) | (int )*(addr + 3UL));
#line 2381
  iowrite32(val, reg);
#line 2382
  tmp = sh_eth_tsu_busy(ndev);
#line 2382
  if (tmp < 0) {
#line 2383
    return (-16);
  } else {

  }
#line 2385
  val = (u32 )(((int )*(addr + 4UL) << 8) | (int )*(addr + 5UL));
#line 2386
  iowrite32(val, reg + 4UL);
#line 2387
  tmp___0 = sh_eth_tsu_busy(ndev);
#line 2387
  if (tmp___0 < 0) {
#line 2388
    return (-16);
  } else {

  }
#line 2390
  return (0);
}
}
#line 2393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_tsu_read_entry(void *reg , u8 *addr ) 
{ 
  u32 val ;

  {
#line 2397
  val = ioread32(reg);
#line 2398
  *addr = (u8 )(val >> 24);
#line 2399
  *(addr + 1UL) = (u8 )(val >> 16);
#line 2400
  *(addr + 2UL) = (u8 )(val >> 8);
#line 2401
  *(addr + 3UL) = (u8 )val;
#line 2402
  val = ioread32(reg + 4UL);
#line 2403
  *(addr + 4UL) = (u8 )(val >> 8);
#line 2404
  *(addr + 5UL) = (u8 )val;
#line 2405
  return;
}
}
#line 2408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_find_entry(struct net_device *ndev , u8 const   *addr ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  void *reg_offset ;
  void *tmp___0 ;
  int i ;
  u8 c_addr[6U] ;
  bool tmp___1 ;

  {
#line 2410
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2410
  mdp = (struct sh_eth_private *)tmp;
#line 2411
  tmp___0 = sh_eth_tsu_get_offset(mdp, 93);
#line 2411
  reg_offset = tmp___0;
#line 2415
  i = 0;
#line 2415
  goto ldv_44969;
  ldv_44968: 
#line 2416
  sh_eth_tsu_read_entry(reg_offset, (u8 *)(& c_addr));
#line 2417
  tmp___1 = ether_addr_equal(addr, (u8 const   *)(& c_addr));
#line 2417
  if ((int )tmp___1) {
#line 2418
    return (i);
  } else {

  }
#line 2415
  i = i + 1;
#line 2415
  reg_offset = reg_offset + 8UL;
  ldv_44969: ;
#line 2415
  if (i <= 31) {
#line 2417
    goto ldv_44968;
  } else {

  }

#line 2421
  return (-2);
}
}
#line 2424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_find_empty(struct net_device *ndev ) 
{ 
  u8 blank[6U] ;
  int entry ;

  {
#line 2429
  memset((void *)(& blank), 0, 6UL);
#line 2430
  entry = sh_eth_tsu_find_entry(ndev, (u8 const   *)(& blank));
#line 2431
  return (entry >= 0 ? entry : -12);
}
}
#line 2434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_disable_cam_entry_table(struct net_device *ndev , int entry ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  void *reg_offset ;
  void *tmp___0 ;
  int ret ;
  u8 blank[6U] ;
  unsigned long tmp___1 ;

  {
#line 2437
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2437
  mdp = (struct sh_eth_private *)tmp;
#line 2438
  tmp___0 = sh_eth_tsu_get_offset(mdp, 93);
#line 2438
  reg_offset = tmp___0;
#line 2442
  tmp___1 = sh_eth_tsu_read(mdp, 88);
#line 2442
  sh_eth_tsu_write(mdp, tmp___1 & (unsigned long )(~ (1 << (31 - entry))), 88);
#line 2445
  memset((void *)(& blank), 0, 6UL);
#line 2446
  ret = sh_eth_tsu_write_entry(ndev, reg_offset + (unsigned long )(entry * 8), (u8 const   *)(& blank));
#line 2447
  if (ret < 0) {
#line 2448
    return (ret);
  } else {

  }
#line 2449
  return (0);
}
}
#line 2452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_add_entry(struct net_device *ndev , u8 const   *addr ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  void *reg_offset ;
  void *tmp___0 ;
  int i ;
  int ret ;
  unsigned long tmp___1 ;

  {
#line 2454
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2454
  mdp = (struct sh_eth_private *)tmp;
#line 2455
  tmp___0 = sh_eth_tsu_get_offset(mdp, 93);
#line 2455
  reg_offset = tmp___0;
#line 2458
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U) {
#line 2459
    return (0);
  } else {

  }
#line 2461
  i = sh_eth_tsu_find_entry(ndev, addr);
#line 2462
  if (i < 0) {
#line 2464
    i = sh_eth_tsu_find_empty(ndev);
#line 2465
    if (i < 0) {
#line 2466
      return (-12);
    } else {

    }
#line 2467
    ret = sh_eth_tsu_write_entry(ndev, reg_offset + (unsigned long )(i * 8), addr);
#line 2468
    if (ret < 0) {
#line 2469
      return (ret);
    } else {

    }
#line 2472
    tmp___1 = sh_eth_tsu_read(mdp, 88);
#line 2472
    sh_eth_tsu_write(mdp, tmp___1 | (unsigned long )(1 << (31 - i)), 88);
  } else {

  }
#line 2477
  sh_eth_tsu_enable_cam_entry_post(ndev, i);
#line 2479
  return (0);
}
}
#line 2482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_del_entry(struct net_device *ndev , u8 const   *addr ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int i ;
  int ret ;
  bool tmp___0 ;

  {
#line 2484
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2484
  mdp = (struct sh_eth_private *)tmp;
#line 2487
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U) {
#line 2488
    return (0);
  } else {

  }
#line 2490
  i = sh_eth_tsu_find_entry(ndev, addr);
#line 2491
  if (i != 0) {
#line 2493
    tmp___0 = sh_eth_tsu_disable_cam_entry_post(ndev, i);
#line 2493
    if ((int )tmp___0) {
#line 2494
      goto done;
    } else {

    }
#line 2497
    ret = sh_eth_tsu_disable_cam_entry_table(ndev, i);
#line 2498
    if (ret < 0) {
#line 2499
      return (ret);
    } else {

    }
  } else {

  }
  done: ;
#line 2502
  return (0);
}
}
#line 2505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_tsu_purge_all(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int i ;
  int ret ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 2507
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2507
  mdp = (struct sh_eth_private *)tmp;
#line 2510
  tmp___0 = ldv__builtin_expect((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U,
                             0L);
#line 2510
  if (tmp___0 != 0L) {
#line 2511
    return (0);
  } else {

  }
#line 2513
  i = 0;
#line 2513
  goto ldv_45008;
  ldv_45007: 
#line 2514
  tmp___1 = sh_eth_tsu_disable_cam_entry_post(ndev, i);
#line 2514
  if ((int )tmp___1) {
#line 2515
    goto ldv_45006;
  } else {

  }
#line 2518
  ret = sh_eth_tsu_disable_cam_entry_table(ndev, i);
#line 2519
  if (ret < 0) {
#line 2520
    return (ret);
  } else {

  }
  ldv_45006: 
#line 2513
  i = i + 1;
  ldv_45008: ;
#line 2513
  if (i <= 31) {
#line 2515
    goto ldv_45007;
  } else {

  }

#line 2523
  return (0);
}
}
#line 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_tsu_purge_mcast(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  u8 addr[6U] ;
  void *reg_offset ;
  void *tmp___0 ;
  int i ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 2528
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2528
  mdp = (struct sh_eth_private *)tmp;
#line 2530
  tmp___0 = sh_eth_tsu_get_offset(mdp, 93);
#line 2530
  reg_offset = tmp___0;
#line 2533
  tmp___1 = ldv__builtin_expect((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U,
                             0L);
#line 2533
  if (tmp___1 != 0L) {
#line 2534
    return;
  } else {

  }
#line 2536
  i = 0;
#line 2536
  goto ldv_45018;
  ldv_45017: 
#line 2537
  sh_eth_tsu_read_entry(reg_offset, (u8 *)(& addr));
#line 2538
  tmp___2 = is_multicast_ether_addr((u8 const   *)(& addr));
#line 2538
  if ((int )tmp___2) {
#line 2539
    sh_eth_tsu_del_entry(ndev, (u8 const   *)(& addr));
  } else {

  }
#line 2536
  i = i + 1;
#line 2536
  reg_offset = reg_offset + 8UL;
  ldv_45018: ;
#line 2536
  if (i <= 31) {
#line 2538
    goto ldv_45017;
  } else {

  }

#line 2543
  return;
}
}
#line 2544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_set_multicast_list(struct net_device *ndev ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  u32 ecmr_bits ;
  int mcast_all ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  unsigned long tmp___1 ;
  struct netdev_hw_addr *ha ;
  struct list_head  const  *__mptr ;
  bool tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2546
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2546
  mdp = (struct sh_eth_private *)tmp;
#line 2548
  mcast_all = 0;
#line 2551
  tmp___0 = spinlock_check(& mdp->lock);
#line 2551
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2555
  tmp___1 = sh_eth_read(ndev, 28);
#line 2555
  ecmr_bits = ((u32 )tmp___1 & 4294959102U) | 8192U;
#line 2557
  if ((ndev->flags & 4096U) == 0U) {
#line 2558
    sh_eth_tsu_purge_mcast(ndev);
#line 2559
    mcast_all = 1;
  } else {

  }
#line 2561
  if ((ndev->flags & 512U) != 0U) {
#line 2562
    sh_eth_tsu_purge_mcast(ndev);
#line 2563
    ecmr_bits = ecmr_bits & 4294959103U;
#line 2564
    mcast_all = 1;
  } else {

  }
#line 2567
  if ((ndev->flags & 256U) != 0U) {
#line 2568
    sh_eth_tsu_purge_all(ndev);
#line 2569
    ecmr_bits = (ecmr_bits & 4294959102U) | 1U;
  } else
#line 2570
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 2572
    __mptr = (struct list_head  const  *)ndev->mc.list.next;
#line 2572
    ha = (struct netdev_hw_addr *)__mptr;
#line 2572
    goto ldv_45037;
    ldv_45036: ;
#line 2573
    if (mcast_all != 0) {
#line 2573
      tmp___2 = is_multicast_ether_addr((u8 const   *)(& ha->addr));
#line 2573
      if ((int )tmp___2) {
#line 2574
        goto ldv_45035;
      } else {

      }
    } else {

    }
#line 2576
    tmp___3 = sh_eth_tsu_add_entry(ndev, (u8 const   *)(& ha->addr));
#line 2576
    if (tmp___3 < 0) {
#line 2577
      if (mcast_all == 0) {
#line 2578
        sh_eth_tsu_purge_mcast(ndev);
#line 2579
        ecmr_bits = ecmr_bits & 4294959103U;
#line 2580
        mcast_all = 1;
      } else {

      }
    } else {

    }
    ldv_45035: 
#line 2572
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 2572
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_45037: ;
#line 2572
    if ((unsigned long )(& ha->list) != (unsigned long )(& ndev->mc.list)) {
#line 2574
      goto ldv_45036;
    } else {

    }

  } else {
#line 2586
    ecmr_bits = (ecmr_bits & 4294959102U) | 8192U;
  }
#line 2590
  sh_eth_write(ndev, (unsigned long )ecmr_bits, 28);
#line 2592
  spin_unlock_irqrestore(& mdp->lock, flags);
#line 2593
  return;
}
}
#line 2595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_get_vtag_index(struct sh_eth_private *mdp ) 
{ 


  {
#line 2597
  if (mdp->port == 0) {
#line 2598
    return (85);
  } else {
#line 2600
    return (86);
  }
}
}
#line 2603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_vlan_rx_add_vid(struct net_device *ndev , __be16 proto , u16 vid ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int vtag_reg_index ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 2606
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2606
  mdp = (struct sh_eth_private *)tmp;
#line 2607
  tmp___0 = sh_eth_get_vtag_index(mdp);
#line 2607
  vtag_reg_index = tmp___0;
#line 2609
  tmp___1 = ldv__builtin_expect((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U,
                             0L);
#line 2609
  if (tmp___1 != 0L) {
#line 2610
    return (-1);
  } else {

  }
#line 2613
  if ((unsigned int )vid == 0U) {
#line 2614
    return (0);
  } else {

  }
#line 2616
  mdp->vlan_num_ids = mdp->vlan_num_ids + 1;
#line 2621
  if (mdp->vlan_num_ids > 1) {
#line 2623
    sh_eth_tsu_write(mdp, 0UL, vtag_reg_index);
#line 2624
    return (0);
  } else {

  }
#line 2627
  sh_eth_tsu_write(mdp, (unsigned long )(((unsigned int )vid & 4095U) | 2147483648U),
                   vtag_reg_index);
#line 2630
  return (0);
}
}
#line 2633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_vlan_rx_kill_vid(struct net_device *ndev , __be16 proto , u16 vid ) 
{ 
  struct sh_eth_private *mdp ;
  void *tmp ;
  int vtag_reg_index ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 2636
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2636
  mdp = (struct sh_eth_private *)tmp;
#line 2637
  tmp___0 = sh_eth_get_vtag_index(mdp);
#line 2637
  vtag_reg_index = tmp___0;
#line 2639
  tmp___1 = ldv__builtin_expect((unsigned int )*((unsigned char *)mdp->cd + 104UL) == 0U,
                             0L);
#line 2639
  if (tmp___1 != 0L) {
#line 2640
    return (-1);
  } else {

  }
#line 2643
  if ((unsigned int )vid == 0U) {
#line 2644
    return (0);
  } else {

  }
#line 2646
  mdp->vlan_num_ids = mdp->vlan_num_ids - 1;
#line 2647
  sh_eth_tsu_write(mdp, 0UL, vtag_reg_index);
#line 2649
  return (0);
}
}
#line 2653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_tsu_init(struct sh_eth_private *mdp ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 2655
  tmp = sh_eth_is_rz_fast_ether(mdp);
#line 2655
  if ((int )tmp) {
#line 2656
    sh_eth_tsu_write(mdp, 0UL, 88);
#line 2657
    return;
  } else {

  }
#line 2660
  sh_eth_tsu_write(mdp, 0UL, 67);
#line 2661
  sh_eth_tsu_write(mdp, 0UL, 68);
#line 2662
  sh_eth_tsu_write(mdp, 0UL, 69);
#line 2663
  sh_eth_tsu_write(mdp, 12UL, 70);
#line 2664
  sh_eth_tsu_write(mdp, 12UL, 71);
#line 2665
  sh_eth_tsu_write(mdp, 0UL, 72);
#line 2666
  sh_eth_tsu_write(mdp, 0UL, 73);
#line 2667
  sh_eth_tsu_write(mdp, 0UL, 74);
#line 2668
  sh_eth_tsu_write(mdp, 0UL, 75);
#line 2669
  sh_eth_tsu_write(mdp, 12288UL, 76);
#line 2670
  tmp___0 = sh_eth_is_gether(mdp);
#line 2670
  if ((int )tmp___0) {
#line 2671
    sh_eth_tsu_write(mdp, 0UL, 77);
#line 2672
    sh_eth_tsu_write(mdp, 0UL, 78);
  } else {
#line 2674
    sh_eth_tsu_write(mdp, 0UL, 79);
#line 2675
    sh_eth_tsu_write(mdp, 0UL, 80);
  }
#line 2677
  sh_eth_tsu_write(mdp, 0UL, 81);
#line 2678
  sh_eth_tsu_write(mdp, 0UL, 82);
#line 2679
  sh_eth_tsu_write(mdp, 0UL, 88);
#line 2680
  sh_eth_tsu_write(mdp, 0UL, 89);
#line 2681
  sh_eth_tsu_write(mdp, 0UL, 90);
#line 2682
  sh_eth_tsu_write(mdp, 0UL, 91);
#line 2683
  sh_eth_tsu_write(mdp, 0UL, 92);
#line 2684
  return;
}
}
#line 2687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_mdio_release(struct sh_eth_private *mdp ) 
{ 


  {
#line 2690
  mdiobus_unregister(mdp->mii_bus);
#line 2693
  free_mdio_bitbang(mdp->mii_bus);
#line 2695
  return (0);
}
}
#line 2699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_mdio_init(struct sh_eth_private *mdp , struct sh_eth_plat_data *pd ) 
{ 
  int ret ;
  int i ;
  struct bb_info *bitbang ;
  struct platform_device *pdev ;
  struct device *dev ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2704
  pdev = mdp->pdev;
#line 2705
  dev = & (mdp->pdev)->dev;
#line 2708
  tmp = devm_kzalloc(dev, 48UL, 208U);
#line 2708
  bitbang = (struct bb_info *)tmp;
#line 2709
  if ((unsigned long )bitbang == (unsigned long )((struct bb_info *)0)) {
#line 2710
    return (-12);
  } else {

  }
#line 2713
  bitbang->addr = mdp->addr + (unsigned long )*(mdp->reg_offset + 31UL);
#line 2714
  bitbang->set_gate = pd->set_mdio_gate;
#line 2715
  bitbang->mdi_msk = 8U;
#line 2716
  bitbang->mdo_msk = 4U;
#line 2717
  bitbang->mmd_msk = 2U;
#line 2718
  bitbang->mdc_msk = 1U;
#line 2719
  bitbang->ctrl.ops = (struct mdiobb_ops  const  *)(& bb_ops);
#line 2722
  mdp->mii_bus = alloc_mdio_bitbang(& bitbang->ctrl);
#line 2723
  if ((unsigned long )mdp->mii_bus == (unsigned long )((struct mii_bus *)0)) {
#line 2724
    return (-12);
  } else {

  }
#line 2727
  (mdp->mii_bus)->name = "sh_mii";
#line 2728
  (mdp->mii_bus)->parent = dev;
#line 2729
  snprintf((char *)(& (mdp->mii_bus)->id), 17UL, "%s-%x", pdev->name, pdev->id);
#line 2733
  tmp___0 = devm_kmalloc_array(dev, 32UL, 4UL, 208U);
#line 2733
  (mdp->mii_bus)->irq = (int *)tmp___0;
#line 2735
  if ((unsigned long )(mdp->mii_bus)->irq == (unsigned long )((int *)0)) {
#line 2736
    ret = -12;
#line 2737
    goto out_free_bus;
  } else {

  }
#line 2741
  if ((unsigned long )dev->of_node != (unsigned long )((struct device_node *)0)) {
#line 2742
    ret = of_mdiobus_register(mdp->mii_bus, dev->of_node);
  } else {
#line 2744
    i = 0;
#line 2744
    goto ldv_45073;
    ldv_45072: 
#line 2745
    *((mdp->mii_bus)->irq + (unsigned long )i) = -1;
#line 2744
    i = i + 1;
    ldv_45073: ;
#line 2744
    if (i <= 31) {
#line 2746
      goto ldv_45072;
    } else {

    }

#line 2746
    if (pd->phy_irq > 0) {
#line 2747
      *((mdp->mii_bus)->irq + (unsigned long )pd->phy) = pd->phy_irq;
    } else {

    }
#line 2749
    ret = mdiobus_register(mdp->mii_bus);
  }
#line 2752
  if (ret != 0) {
#line 2753
    goto out_free_bus;
  } else {

  }
#line 2755
  return (0);
  out_free_bus: 
#line 2758
  free_mdio_bitbang(mdp->mii_bus);
#line 2759
  return (ret);
}
}
#line 2762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static u16 const   *sh_eth_get_register_offset(int register_type ) 
{ 
  u16 const   *reg_offset ;

  {
#line 2764
  reg_offset = (u16 const   *)0U;
#line 2766
  switch (register_type) {
  case 0: 
#line 2768
  reg_offset = (u16 const   *)(& sh_eth_offset_gigabit);
#line 2769
  goto ldv_45080;
  case 1: 
#line 2771
  reg_offset = (u16 const   *)(& sh_eth_offset_fast_rz);
#line 2772
  goto ldv_45080;
  case 2: 
#line 2774
  reg_offset = (u16 const   *)(& sh_eth_offset_fast_rcar);
#line 2775
  goto ldv_45080;
  case 3: 
#line 2777
  reg_offset = (u16 const   *)(& sh_eth_offset_fast_sh4);
#line 2778
  goto ldv_45080;
  case 4: 
#line 2780
  reg_offset = (u16 const   *)(& sh_eth_offset_fast_sh3_sh2);
#line 2781
  goto ldv_45080;
  default: ;
#line 2783
  goto ldv_45080;
  }
  ldv_45080: ;
#line 2786
  return (reg_offset);
}
}
#line 2789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct net_device_ops  const  sh_eth_netdev_ops  = 
#line 2789
     {0, 0, & sh_eth_open, & sh_eth_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& sh_eth_start_xmit),
    0, 0, 0, & eth_mac_addr, & eth_validate_addr, & sh_eth_do_ioctl, 0, & eth_change_mtu,
    0, & sh_eth_tx_timeout, 0, & sh_eth_get_stats, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0};
#line 2801 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct net_device_ops  const  sh_eth_netdev_ops_tsu  = 
#line 2801
     {0, 0, & sh_eth_open, & sh_eth_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& sh_eth_start_xmit),
    0, 0, & sh_eth_set_multicast_list, & eth_mac_addr, & eth_validate_addr, & sh_eth_do_ioctl,
    0, & eth_change_mtu, 0, & sh_eth_tx_timeout, 0, & sh_eth_get_stats, & sh_eth_vlan_rx_add_vid,
    & sh_eth_vlan_rx_kill_vid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static struct sh_eth_plat_data *sh_eth_parse_dt(struct device *dev ) 
{ 


  {
#line 2854
  return ((struct sh_eth_plat_data *)0);
}
}
#line 2858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_drv_probe(struct platform_device *pdev ) 
{ 
  int ret ;
  int devno ;
  struct resource *res ;
  struct net_device *ndev ;
  struct sh_eth_private *mdp ;
  struct sh_eth_plat_data *pd ;
  void *tmp ;
  struct platform_device_id  const  *id ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  struct lock_class_key __key ;
  struct of_device_id  const  *match ;
  bool tmp___4 ;
  int tmp___5 ;
  struct resource *rtsu ;
  long tmp___6 ;
  bool tmp___7 ;

  {
#line 2860
  devno = 0;
#line 2862
  ndev = (struct net_device *)0;
#line 2863
  mdp = (struct sh_eth_private *)0;
#line 2864
  tmp = dev_get_platdata((struct device  const  *)(& pdev->dev));
#line 2864
  pd = (struct sh_eth_plat_data *)tmp;
#line 2865
  id = pdev->id_entry;
#line 2868
  res = platform_get_resource(pdev, 512U, 0U);
#line 2869
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct resource *)0),
                             0L);
#line 2869
  if (tmp___0 != 0L) {
#line 2870
    dev_err((struct device  const  *)(& pdev->dev), "invalid resource\n");
#line 2871
    return (-22);
  } else {

  }
#line 2874
  ndev = alloc_etherdev_mqs(432, 1U, 1U);
#line 2875
  if ((unsigned long )ndev == (unsigned long )((struct net_device *)0)) {
#line 2876
    return (-12);
  } else {

  }
#line 2878
  pm_runtime_enable(& pdev->dev);
#line 2879
  pm_runtime_get_sync(& pdev->dev);
#line 2882
  ndev->base_addr = (unsigned long )res->start;
#line 2883
  devno = pdev->id;
#line 2884
  if (devno < 0) {
#line 2885
    devno = 0;
  } else {

  }
#line 2887
  ndev->dma = 255U;
#line 2888
  ret = platform_get_irq(pdev, 0U);
#line 2889
  if (ret < 0) {
#line 2890
    ret = -19;
#line 2891
    goto out_release;
  } else {

  }
#line 2893
  ndev->irq = ret;
#line 2895
  ndev->dev.parent = & pdev->dev;
#line 2897
  tmp___1 = netdev_priv((struct net_device  const  *)ndev);
#line 2897
  mdp = (struct sh_eth_private *)tmp___1;
#line 2898
  mdp->num_tx_ring = 64U;
#line 2899
  mdp->num_rx_ring = 64U;
#line 2900
  mdp->addr = devm_ioremap_resource(& pdev->dev, res);
#line 2901
  tmp___3 = IS_ERR((void const   *)mdp->addr);
#line 2901
  if ((int )tmp___3) {
#line 2902
    tmp___2 = PTR_ERR((void const   *)mdp->addr);
#line 2902
    ret = (int )tmp___2;
#line 2903
    goto out_release;
  } else {

  }
#line 2906
  spinlock_check(& mdp->lock);
#line 2906
  __raw_spin_lock_init(& mdp->lock.ldv_6338.rlock, "&(&mdp->lock)->rlock", & __key);
#line 2907
  mdp->pdev = pdev;
#line 2909
  if ((unsigned long )pdev->dev.of_node != (unsigned long )((struct device_node *)0)) {
#line 2910
    pd = sh_eth_parse_dt(& pdev->dev);
  } else {

  }
#line 2911
  if ((unsigned long )pd == (unsigned long )((struct sh_eth_plat_data *)0)) {
#line 2912
    dev_err((struct device  const  *)(& pdev->dev), "no platform data\n");
#line 2913
    ret = -22;
#line 2914
    goto out_release;
  } else {

  }
#line 2918
  mdp->phy_id = (u32 )pd->phy;
#line 2919
  mdp->phy_interface = pd->phy_interface;
#line 2921
  mdp->edmac_endian = pd->edmac_endian;
#line 2922
  mdp->no_ether_link = pd->no_ether_link;
#line 2923
  mdp->ether_link_active_low = pd->ether_link_active_low;
#line 2926
  if ((unsigned long )id != (unsigned long )((struct platform_device_id  const  *)0)) {
#line 2927
    mdp->cd = (struct sh_eth_cpu_data *)id->driver_data;
  } else {
#line 2931
    match = __of_match_device((struct of_device_id  const  *)0, (struct device  const  *)(& pdev->dev));
#line 2933
    mdp->cd = (struct sh_eth_cpu_data *)match->data;
  }
#line 2935
  mdp->reg_offset = sh_eth_get_register_offset((mdp->cd)->register_type);
#line 2936
  if ((unsigned long )mdp->reg_offset == (unsigned long )((u16 const   *)0U)) {
#line 2937
    dev_err((struct device  const  *)(& pdev->dev), "Unknown register type (%d)\n",
            (mdp->cd)->register_type);
#line 2939
    ret = -22;
#line 2940
    goto out_release;
  } else {

  }
#line 2942
  sh_eth_set_default_cpu_data(mdp->cd);
#line 2945
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 2946
    ndev->netdev_ops = & sh_eth_netdev_ops_tsu;
  } else {
#line 2948
    ndev->netdev_ops = & sh_eth_netdev_ops;
  }
#line 2949
  ndev->ethtool_ops = & sh_eth_ethtool_ops;
#line 2950
  ndev->watchdog_timeo = 1250;
#line 2953
  mdp->msg_enable = 204;
#line 2956
  read_mac_address(ndev, (unsigned char *)(& pd->mac_addr));
#line 2957
  tmp___4 = is_valid_ether_addr((u8 const   *)ndev->dev_addr);
#line 2957
  if (tmp___4) {
#line 2957
    tmp___5 = 0;
  } else {
#line 2957
    tmp___5 = 1;
  }
#line 2957
  if (tmp___5) {
#line 2958
    dev_warn((struct device  const  *)(& pdev->dev), "no valid MAC address supplied, using a random one.\n");
#line 2960
    eth_hw_addr_random(ndev);
  } else {

  }
#line 2964
  if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 2966
    rtsu = platform_get_resource(pdev, 512U, 1U);
#line 2967
    mdp->tsu_addr = devm_ioremap_resource(& pdev->dev, rtsu);
#line 2968
    tmp___7 = IS_ERR((void const   *)mdp->tsu_addr);
#line 2968
    if ((int )tmp___7) {
#line 2969
      tmp___6 = PTR_ERR((void const   *)mdp->tsu_addr);
#line 2969
      ret = (int )tmp___6;
#line 2970
      goto out_release;
    } else {

    }
#line 2972
    mdp->port = devno % 2;
#line 2973
    ndev->features = 512ULL;
  } else {

  }
#line 2977
  if (devno == 0 || (unsigned int )*((unsigned char *)pd + 30UL) != 0U) {
#line 2978
    if ((unsigned long )(mdp->cd)->chip_reset != (unsigned long )((void (*)(struct net_device * ))0)) {
#line 2979
      (*((mdp->cd)->chip_reset))(ndev);
    } else {

    }
#line 2981
    if ((unsigned int )*((unsigned char *)mdp->cd + 104UL) != 0U) {
#line 2983
      sh_eth_tsu_init(mdp);
    } else {

    }
  } else {

  }
#line 2988
  ret = sh_mdio_init(mdp, pd);
#line 2989
  if (ret != 0) {
#line 2990
    dev_err((struct device  const  *)(& ndev->dev), "failed to initialise MDIO\n");
#line 2991
    goto out_release;
  } else {

  }
#line 2994
  netif_napi_add(ndev, & mdp->napi, & sh_eth_poll, 64);
#line 2997
  ret = ldv_register_netdev_17(ndev);
#line 2998
  if (ret != 0) {
#line 2999
    goto out_napi_del;
  } else {

  }
#line 3002
  netdev_info((struct net_device  const  *)ndev, "Base address at 0x%x, %pM, IRQ %d.\n",
              (unsigned int )ndev->base_addr, ndev->dev_addr, ndev->irq);
#line 3005
  pm_runtime_put(& pdev->dev);
#line 3006
  platform_set_drvdata(pdev, (void *)ndev);
#line 3008
  return (ret);
  out_napi_del: 
#line 3011
  netif_napi_del(& mdp->napi);
#line 3012
  sh_mdio_release(mdp);
  out_release: ;
#line 3016
  if ((unsigned long )ndev != (unsigned long )((struct net_device *)0)) {
#line 3017
    ldv_free_netdev_18(ndev);
  } else {

  }
#line 3019
  pm_runtime_put(& pdev->dev);
#line 3020
  pm_runtime_disable(& pdev->dev);
#line 3021
  return (ret);
}
}
#line 3024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_drv_remove(struct platform_device *pdev ) 
{ 
  struct net_device *ndev ;
  void *tmp ;
  struct sh_eth_private *mdp ;
  void *tmp___0 ;

  {
#line 3026
  tmp = platform_get_drvdata((struct platform_device  const  *)pdev);
#line 3026
  ndev = (struct net_device *)tmp;
#line 3027
  tmp___0 = netdev_priv((struct net_device  const  *)ndev);
#line 3027
  mdp = (struct sh_eth_private *)tmp___0;
#line 3029
  ldv_unregister_netdev_19(ndev);
#line 3030
  netif_napi_del(& mdp->napi);
#line 3031
  sh_mdio_release(mdp);
#line 3032
  pm_runtime_disable(& pdev->dev);
#line 3033
  ldv_free_netdev_20(ndev);
#line 3035
  return (0);
}
}
#line 3039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_runtime_nop(struct device *dev ) 
{ 


  {
#line 3048
  return (0);
}
}
#line 3051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct dev_pm_ops  const  sh_eth_dev_pm_ops  = 
#line 3051
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & sh_eth_runtime_nop,
    & sh_eth_runtime_nop, 0};
#line 3060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct platform_device_id sh_eth_id_table[13U]  = 
#line 3060
  {      {{'s', 'h', '7', '6', '1', '9', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7619_data)}, 
        {{'s',
       'h', '7', '7', '1', 'x', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh771x_data)}, 
        {{'s',
       'h', '7', '7', '2', '4', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7724_data)}, 
        {{'s',
       'h', '7', '7', '3', '4', '-', 'g', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7734_data)}, 
        {{'s',
       'h', '7', '7', '5', '7', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7757_data)}, 
        {{'s',
       'h', '7', '7', '5', '7', '-', 'g', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7757_data_giga)}, 
        {{'s',
       'h', '7', '7', '6', '3', '-', 'g', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& sh7763_data)}, 
        {{'r',
       '7', 's', '7', '2', '1', '0', '0', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& r7s72100_data)}, 
        {{'r',
       '8', 'a', '7', '7', '4', '0', '-', 'g', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& r8a7740_data)}, 
        {{'r',
       '8', 'a', '7', '7', '7', 'x', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& r8a777x_data)}, 
        {{'r',
       '8', 'a', '7', '7', '9', '0', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& r8a779x_data)}, 
        {{'r',
       '8', 'a', '7', '7', '9', '1', '-', 'e', 't', 'h', 'e', 'r', '\000'}, (unsigned long )(& r8a779x_data)}};
#line 3075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
struct platform_device_id  const  __mod_platform__sh_eth_id_table_device_table  ;
#line 3077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static struct platform_driver sh_eth_driver  = 
#line 3077
     {& sh_eth_drv_probe, & sh_eth_drv_remove, 0, 0, 0, {"sh-eth", 0, 0, 0, (_Bool)0,
                                                       (struct of_device_id  const  *)0,
                                                       0, 0, 0, 0, 0, 0, 0, & sh_eth_dev_pm_ops,
                                                       0}, (struct platform_device_id  const  *)(& sh_eth_id_table),
    (_Bool)0};
#line 3088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static int sh_eth_driver_init(void) 
{ 
  int tmp ;

  {
#line 3088
  tmp = ldv___platform_driver_register_21(& sh_eth_driver, & __this_module);
#line 3088
  return (tmp);
}
}
#line 3088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
static void sh_eth_driver_exit(void) 
{ 


  {
#line 3088
  ldv_platform_driver_unregister_22(& sh_eth_driver);
#line 3089
  return;
}
}
#line 3094
extern int ldv_ndo_init_4(void) ;
#line 3095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_2  ;
#line 3096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_5  ;
#line 3097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_0  ;
#line 3098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_4  ;
#line 3099 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_6  ;
#line 3100
extern int ldv_ndo_init_5(void) ;
#line 3101
void ldv_initialize(void) ;
#line 3102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_1  ;
#line 3103
extern int ldv_ndo_uninit_4(void) ;
#line 3104
void ldv_check_final_state(void) ;
#line 3105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_3  ;
#line 3106
extern int ldv_ndo_uninit_5(void) ;
#line 3107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_retval_7  ;
#line 3110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_13(void) 
{ 
  void *tmp ;

  {
#line 3111
  tmp = ldv_zalloc(3264UL);
#line 3111
  sh7757_data_group0 = (struct net_device *)tmp;
#line 3112
  return;
}
}
#line 3114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_11(void) 
{ 
  void *tmp ;

  {
#line 3115
  tmp = ldv_zalloc(3264UL);
#line 3115
  sh7734_data_group0 = (struct net_device *)tmp;
#line 3116
  return;
}
}
#line 3118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_platform_driver_2(void) 
{ 
  void *tmp ;

  {
#line 3119
  tmp = ldv_zalloc(1464UL);
#line 3119
  sh_eth_driver_group0 = (struct platform_device *)tmp;
#line 3120
  return;
}
}
#line 3122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 3123
  if ((unsigned long )handler == (unsigned long )(& sh_eth_interrupt)) {
#line 3124
    return (1);
  } else {

  }
#line 3126
  return (0);
}
}
#line 3130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_net_device_ops_4(void) 
{ 
  void *tmp ;

  {
#line 3131
  tmp = ldv_zalloc(3264UL);
#line 3131
  sh_eth_netdev_ops_tsu_group1 = (struct net_device *)tmp;
#line 3132
  return;
}
}
#line 3135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_10(void) 
{ 
  void *tmp ;

  {
#line 3136
  tmp = ldv_zalloc(3264UL);
#line 3136
  sh7763_data_group0 = (struct net_device *)tmp;
#line 3137
  return;
}
}
#line 3139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_ethtool_ops_6(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 3140
  tmp = ldv_zalloc(44UL);
#line 3140
  sh_eth_ethtool_ops_group0 = (struct ethtool_cmd *)tmp;
#line 3141
  tmp___0 = ldv_zalloc(36UL);
#line 3141
  sh_eth_ethtool_ops_group1 = (struct ethtool_ringparam *)tmp___0;
#line 3142
  tmp___1 = ldv_zalloc(3264UL);
#line 3142
  sh_eth_ethtool_ops_group2 = (struct net_device *)tmp___1;
#line 3143
  return;
}
}
#line 3145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 3146
  tmp = __VERIFIER_nondet_int();
#line 3146
  switch (tmp) {
  case 0: 
#line 3148
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 3150
  goto ldv_45184;
  case 1: 
#line 3152
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 3154
  goto ldv_45184;
  case 2: 
#line 3156
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 3158
  goto ldv_45184;
  case 3: 
#line 3160
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 3162
  goto ldv_45184;
  default: 
#line 3163
  ldv_stop();
  }
  ldv_45184: ;
#line 3165
  return;
}
}
#line 3169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_9(void) 
{ 
  void *tmp ;

  {
#line 3170
  tmp = ldv_zalloc(3264UL);
#line 3170
  r8a7740_data_group0 = (struct net_device *)tmp;
#line 3171
  return;
}
}
#line 3173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_net_device_ops_5(void) 
{ 
  void *tmp ;

  {
#line 3174
  tmp = ldv_zalloc(3264UL);
#line 3174
  sh_eth_netdev_ops_group1 = (struct net_device *)tmp;
#line 3175
  return;
}
}
#line 3178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_mdiobb_ops_7(void) 
{ 
  void *tmp ;

  {
#line 3179
  tmp = ldv_zalloc(16UL);
#line 3179
  bb_ops_group0 = (struct mdiobb_ctrl *)tmp;
#line 3180
  return;
}
}
#line 3182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_8(void) 
{ 
  void *tmp ;

  {
#line 3183
  tmp = ldv_zalloc(3264UL);
#line 3183
  r7s72100_data_group0 = (struct net_device *)tmp;
#line 3184
  return;
}
}
#line 3186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 3187
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 3188
    ldv_irq_1_0 = 0;
#line 3189
    return;
  } else {

  }
#line 3191
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 3192
    ldv_irq_1_1 = 0;
#line 3193
    return;
  } else {

  }
#line 3195
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 3196
    ldv_irq_1_2 = 0;
#line 3197
    return;
  } else {

  }
#line 3199
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 3200
    ldv_irq_1_3 = 0;
#line 3201
    return;
  } else {

  }
#line 3203
  return;
}
}
#line 3207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;

  {
#line 3209
  if (state != 0) {
#line 3210
    tmp = __VERIFIER_nondet_int();
#line 3210
    switch (tmp) {
    case 0: ;
#line 3212
    if (state == 1) {
#line 3213
      LDV_IN_INTERRUPT = 2;
#line 3214
      irq_retval = sh_eth_interrupt(line, data);
#line 3215
      LDV_IN_INTERRUPT = 1;
#line 3216
      return (state);
    } else {

    }
#line 3219
    goto ldv_45212;
    default: 
#line 3220
    ldv_stop();
    }
    ldv_45212: ;
  } else {

  }
#line 3223
  return (state);
}
}
#line 3227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 3228
  if (ldv_irq_1_0 == 0) {
#line 3229
    ldv_irq_line_1_0 = line;
#line 3230
    ldv_irq_data_1_0 = data;
#line 3231
    ldv_irq_1_0 = 1;
#line 3232
    return;
  } else {

  }
#line 3234
  if (ldv_irq_1_1 == 0) {
#line 3235
    ldv_irq_line_1_1 = line;
#line 3236
    ldv_irq_data_1_1 = data;
#line 3237
    ldv_irq_1_1 = 1;
#line 3238
    return;
  } else {

  }
#line 3240
  if (ldv_irq_1_2 == 0) {
#line 3241
    ldv_irq_line_1_2 = line;
#line 3242
    ldv_irq_data_1_2 = data;
#line 3243
    ldv_irq_1_2 = 1;
#line 3244
    return;
  } else {

  }
#line 3246
  if (ldv_irq_1_3 == 0) {
#line 3247
    ldv_irq_line_1_3 = line;
#line 3248
    ldv_irq_data_1_3 = data;
#line 3249
    ldv_irq_1_3 = 1;
#line 3250
    return;
  } else {

  }
#line 3252
  return;
}
}
#line 3256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_15(void) 
{ 
  void *tmp ;

  {
#line 3257
  tmp = ldv_zalloc(3264UL);
#line 3257
  r8a779x_data_group0 = (struct net_device *)tmp;
#line 3258
  return;
}
}
#line 3261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_16(void) 
{ 
  void *tmp ;

  {
#line 3262
  tmp = ldv_zalloc(3264UL);
#line 3262
  r8a777x_data_group0 = (struct net_device *)tmp;
#line 3263
  return;
}
}
#line 3265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_12(void) 
{ 
  void *tmp ;

  {
#line 3266
  tmp = ldv_zalloc(3264UL);
#line 3266
  sh7757_data_giga_group0 = (struct net_device *)tmp;
#line 3267
  return;
}
}
#line 3269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_dev_pm_ops_3(void) 
{ 
  void *tmp ;

  {
#line 3270
  tmp = ldv_zalloc(1416UL);
#line 3270
  sh_eth_dev_pm_ops_group1 = (struct device *)tmp;
#line 3271
  return;
}
}
#line 3274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_initialize_sh_eth_cpu_data_14(void) 
{ 
  void *tmp ;

  {
#line 3275
  tmp = ldv_zalloc(3264UL);
#line 3275
  sh7724_data_group0 = (struct net_device *)tmp;
#line 3276
  return;
}
}
#line 3298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int main(void) 
{ 
  int ldvarg1 ;
  int tmp ;
  int ldvarg0 ;
  int tmp___0 ;
  int ldvarg2 ;
  int tmp___1 ;
  int ldvarg8 ;
  int tmp___2 ;
  u32 ldvarg7 ;
  u32 tmp___3 ;
  u32 ldvarg4 ;
  u32 tmp___4 ;
  u8 *ldvarg3 ;
  void *tmp___5 ;
  u64 *ldvarg5 ;
  void *tmp___6 ;
  struct ethtool_stats *ldvarg6 ;
  void *tmp___7 ;
  int ldvarg11 ;
  int tmp___8 ;
  u16 ldvarg12 ;
  u16 tmp___9 ;
  u16 ldvarg16 ;
  u16 tmp___10 ;
  struct ifreq *ldvarg15 ;
  void *tmp___11 ;
  __be16 ldvarg17 ;
  int ldvarg14 ;
  int tmp___12 ;
  __be16 ldvarg13 ;
  struct sk_buff *ldvarg10 ;
  void *tmp___13 ;
  void *ldvarg9 ;
  void *tmp___14 ;
  int ldvarg21 ;
  int tmp___15 ;
  void *ldvarg18 ;
  void *tmp___16 ;
  int ldvarg20 ;
  int tmp___17 ;
  struct ifreq *ldvarg22 ;
  void *tmp___18 ;
  struct sk_buff *ldvarg19 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 3301
  tmp = __VERIFIER_nondet_int();
#line 3301
  ldvarg1 = tmp;
#line 3302
  tmp___0 = __VERIFIER_nondet_int();
#line 3302
  ldvarg0 = tmp___0;
#line 3303
  tmp___1 = __VERIFIER_nondet_int();
#line 3303
  ldvarg2 = tmp___1;
#line 3304
  tmp___2 = __VERIFIER_nondet_int();
#line 3304
  ldvarg8 = tmp___2;
#line 3305
  tmp___3 = __VERIFIER_nondet_u32();
#line 3305
  ldvarg7 = tmp___3;
#line 3306
  tmp___4 = __VERIFIER_nondet_u32();
#line 3306
  ldvarg4 = tmp___4;
#line 3307
  tmp___5 = ldv_zalloc(1UL);
#line 3307
  ldvarg3 = (u8 *)tmp___5;
#line 3308
  tmp___6 = ldv_zalloc(8UL);
#line 3308
  ldvarg5 = (u64 *)tmp___6;
#line 3309
  tmp___7 = ldv_zalloc(8UL);
#line 3309
  ldvarg6 = (struct ethtool_stats *)tmp___7;
#line 3310
  tmp___8 = __VERIFIER_nondet_int();
#line 3310
  ldvarg11 = tmp___8;
#line 3311
  tmp___9 = __VERIFIER_nondet_u16();
#line 3311
  ldvarg12 = tmp___9;
#line 3312
  tmp___10 = __VERIFIER_nondet_u16();
#line 3312
  ldvarg16 = tmp___10;
#line 3313
  tmp___11 = ldv_zalloc(40UL);
#line 3313
  ldvarg15 = (struct ifreq *)tmp___11;
#line 3315
  tmp___12 = __VERIFIER_nondet_int();
#line 3315
  ldvarg14 = tmp___12;
#line 3317
  tmp___13 = ldv_zalloc(232UL);
#line 3317
  ldvarg10 = (struct sk_buff *)tmp___13;
#line 3318
  tmp___14 = ldv_zalloc(1UL);
#line 3318
  ldvarg9 = tmp___14;
#line 3319
  tmp___15 = __VERIFIER_nondet_int();
#line 3319
  ldvarg21 = tmp___15;
#line 3320
  tmp___16 = ldv_zalloc(1UL);
#line 3320
  ldvarg18 = tmp___16;
#line 3321
  tmp___17 = __VERIFIER_nondet_int();
#line 3321
  ldvarg20 = tmp___17;
#line 3322
  tmp___18 = ldv_zalloc(40UL);
#line 3322
  ldvarg22 = (struct ifreq *)tmp___18;
#line 3323
  tmp___19 = ldv_zalloc(232UL);
#line 3323
  ldvarg19 = (struct sk_buff *)tmp___19;
#line 3299
  ldv_initialize();
#line 3314
  memset((void *)(& ldvarg17), 0, 2UL);
#line 3316
  memset((void *)(& ldvarg13), 0, 2UL);
#line 3325
  ldv_state_variable_11 = 0;
#line 3326
  ldv_state_variable_7 = 0;
#line 3327
  ldv_state_variable_2 = 0;
#line 3329
  ldv_state_variable_1 = 1;
#line 3330
  ref_cnt = 0;
#line 3331
  ldv_state_variable_0 = 1;
#line 3332
  ldv_state_variable_16 = 0;
#line 3333
  ldv_state_variable_13 = 0;
#line 3334
  ldv_state_variable_6 = 0;
#line 3335
  ldv_state_variable_3 = 0;
#line 3336
  ldv_state_variable_9 = 0;
#line 3337
  ldv_state_variable_12 = 0;
#line 3338
  ldv_state_variable_14 = 0;
#line 3339
  ldv_state_variable_15 = 0;
#line 3340
  ldv_state_variable_8 = 0;
#line 3341
  ldv_state_variable_4 = 0;
#line 3342
  ldv_state_variable_10 = 0;
#line 3343
  ldv_state_variable_5 = 0;
  ldv_45413: 
#line 3345
  tmp___20 = __VERIFIER_nondet_int();
#line 3345
  switch (tmp___20) {
  case 0: ;
#line 3349
  if (ldv_state_variable_11 != 0) {
#line 3350
    tmp___21 = __VERIFIER_nondet_int();
#line 3350
    switch (tmp___21) {
    case 0: ;
#line 3353
    if (ldv_state_variable_11 == 1) {
#line 3355
      sh_eth_chip_reset(sh7734_data_group0);
#line 3357
      ldv_state_variable_11 = 1;
    } else {

    }
#line 3360
    goto ldv_45295;
    case 1: ;
#line 3363
    if (ldv_state_variable_11 == 1) {
#line 3365
      sh_eth_set_rate_gether(sh7734_data_group0);
#line 3367
      ldv_state_variable_11 = 1;
    } else {

    }
#line 3370
    goto ldv_45295;
    case 2: ;
#line 3373
    if (ldv_state_variable_11 == 1) {
#line 3375
      sh_eth_set_duplex(sh7734_data_group0);
#line 3377
      ldv_state_variable_11 = 1;
    } else {

    }
#line 3380
    goto ldv_45295;
    default: 
#line 3381
    ldv_stop();
    }
    ldv_45295: ;
  } else {

  }
#line 3385
  goto ldv_45299;
  case 1: ;
#line 3389
  if (ldv_state_variable_7 != 0) {
#line 3390
    tmp___22 = __VERIFIER_nondet_int();
#line 3390
    switch (tmp___22) {
    case 0: ;
#line 3393
    if (ldv_state_variable_7 == 1) {
#line 3395
      sh_mmd_ctrl(bb_ops_group0, ldvarg2);
#line 3397
      ldv_state_variable_7 = 1;
    } else {

    }
#line 3400
    goto ldv_45302;
    case 1: ;
#line 3403
    if (ldv_state_variable_7 == 1) {
#line 3405
      sh_set_mdio(bb_ops_group0, ldvarg1);
#line 3407
      ldv_state_variable_7 = 1;
    } else {

    }
#line 3410
    goto ldv_45302;
    case 2: ;
#line 3413
    if (ldv_state_variable_7 == 1) {
#line 3415
      sh_get_mdio(bb_ops_group0);
#line 3417
      ldv_state_variable_7 = 1;
    } else {

    }
#line 3420
    goto ldv_45302;
    case 3: ;
#line 3423
    if (ldv_state_variable_7 == 1) {
#line 3425
      sh_mdc_ctrl(bb_ops_group0, ldvarg0);
#line 3427
      ldv_state_variable_7 = 1;
    } else {

    }
#line 3430
    goto ldv_45302;
    default: 
#line 3431
    ldv_stop();
    }
    ldv_45302: ;
  } else {

  }
#line 3435
  goto ldv_45299;
  case 2: ;
#line 3439
  if (ldv_state_variable_2 != 0) {
#line 3440
    tmp___23 = __VERIFIER_nondet_int();
#line 3440
    switch (tmp___23) {
    case 0: ;
#line 3443
    if (ldv_state_variable_2 == 1) {
#line 3445
      ldv_retval_0 = sh_eth_drv_probe(sh_eth_driver_group0);
#line 3447
      if (ldv_retval_0 == 0) {
#line 3448
        ldv_state_variable_2 = 2;
#line 3449
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 3453
    goto ldv_45309;
    case 1: ;
#line 3456
    if (ldv_state_variable_2 == 2) {
#line 3458
      sh_eth_drv_remove(sh_eth_driver_group0);
#line 3460
      ldv_state_variable_2 = 1;
#line 3461
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 3464
    goto ldv_45309;
    default: 
#line 3465
    ldv_stop();
    }
    ldv_45309: ;
  } else {

  }
#line 3469
  goto ldv_45299;
  case 3: ;
#line 3473
  if (ldv_state_variable_1 != 0) {
#line 3474
    choose_interrupt_1();
  } else {

  }
#line 3477
  goto ldv_45299;
  case 4: ;
#line 3481
  if (ldv_state_variable_0 != 0) {
#line 3482
    tmp___24 = __VERIFIER_nondet_int();
#line 3482
    switch (tmp___24) {
    case 0: ;
#line 3485
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 3487
      sh_eth_driver_exit();
#line 3488
      ldv_state_variable_0 = 2;
#line 3489
      goto ldv_final;
    } else {

    }
#line 3492
    goto ldv_45316;
    case 1: ;
#line 3495
    if (ldv_state_variable_0 == 1) {
#line 3497
      ldv_retval_1 = sh_eth_driver_init();
#line 3499
      if (ldv_retval_1 == 0) {
#line 3500
        ldv_state_variable_0 = 3;
#line 3501
        ldv_state_variable_13 = 1;
#line 3502
        ldv_initialize_sh_eth_cpu_data_13();
#line 3503
        ldv_state_variable_10 = 1;
#line 3504
        ldv_initialize_sh_eth_cpu_data_10();
#line 3505
        ldv_state_variable_16 = 1;
#line 3506
        ldv_initialize_sh_eth_cpu_data_16();
#line 3507
        ldv_state_variable_8 = 1;
#line 3508
        ldv_initialize_sh_eth_cpu_data_8();
#line 3509
        ldv_state_variable_14 = 1;
#line 3510
        ldv_initialize_sh_eth_cpu_data_14();
#line 3511
        ldv_state_variable_15 = 1;
#line 3512
        ldv_initialize_sh_eth_cpu_data_15();
#line 3513
        ldv_state_variable_12 = 1;
#line 3514
        ldv_initialize_sh_eth_cpu_data_12();
#line 3515
        ldv_state_variable_9 = 1;
#line 3516
        ldv_initialize_sh_eth_cpu_data_9();
#line 3517
        ldv_state_variable_7 = 1;
#line 3518
        ldv_initialize_mdiobb_ops_7();
#line 3519
        ldv_state_variable_3 = 1;
#line 3520
        ldv_dev_pm_ops_3();
#line 3521
        ldv_state_variable_11 = 1;
#line 3522
        ldv_initialize_sh_eth_cpu_data_11();
#line 3523
        ldv_state_variable_6 = 1;
#line 3524
        ldv_initialize_ethtool_ops_6();
      } else {

      }
#line 3526
      if (ldv_retval_1 != 0) {
#line 3527
        ldv_state_variable_0 = 2;
#line 3528
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 3532
    goto ldv_45316;
    default: 
#line 3533
    ldv_stop();
    }
    ldv_45316: ;
  } else {

  }
#line 3537
  goto ldv_45299;
  case 5: ;
#line 3541
  if (ldv_state_variable_16 != 0) {
#line 3542
    tmp___25 = __VERIFIER_nondet_int();
#line 3542
    switch (tmp___25) {
    case 0: ;
#line 3545
    if (ldv_state_variable_16 == 1) {
#line 3547
      sh_eth_set_rate_r8a777x(r8a777x_data_group0);
#line 3549
      ldv_state_variable_16 = 1;
    } else {

    }
#line 3552
    goto ldv_45321;
    case 1: ;
#line 3555
    if (ldv_state_variable_16 == 1) {
#line 3557
      sh_eth_set_duplex(r8a777x_data_group0);
#line 3559
      ldv_state_variable_16 = 1;
    } else {

    }
#line 3562
    goto ldv_45321;
    default: 
#line 3563
    ldv_stop();
    }
    ldv_45321: ;
  } else {

  }
#line 3567
  goto ldv_45299;
  case 6: ;
#line 3571
  if (ldv_state_variable_13 != 0) {
#line 3572
    tmp___26 = __VERIFIER_nondet_int();
#line 3572
    switch (tmp___26) {
    case 0: ;
#line 3575
    if (ldv_state_variable_13 == 1) {
#line 3577
      sh_eth_set_rate_sh7757(sh7757_data_group0);
#line 3579
      ldv_state_variable_13 = 1;
    } else {

    }
#line 3582
    goto ldv_45326;
    case 1: ;
#line 3585
    if (ldv_state_variable_13 == 1) {
#line 3587
      sh_eth_set_duplex(sh7757_data_group0);
#line 3589
      ldv_state_variable_13 = 1;
    } else {

    }
#line 3592
    goto ldv_45326;
    default: 
#line 3593
    ldv_stop();
    }
    ldv_45326: ;
  } else {

  }
#line 3597
  goto ldv_45299;
  case 7: ;
#line 3601
  if (ldv_state_variable_6 != 0) {
#line 3602
    tmp___27 = __VERIFIER_nondet_int();
#line 3602
    switch (tmp___27) {
    case 0: ;
#line 3605
    if (ldv_state_variable_6 == 1) {
#line 3607
      sh_eth_get_sset_count(sh_eth_ethtool_ops_group2, ldvarg8);
#line 3609
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3612
    goto ldv_45331;
    case 1: ;
#line 3615
    if (ldv_state_variable_6 == 1) {
#line 3617
      sh_eth_get_settings(sh_eth_ethtool_ops_group2, sh_eth_ethtool_ops_group0);
#line 3619
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3622
    goto ldv_45331;
    case 2: ;
#line 3625
    if (ldv_state_variable_6 == 1) {
#line 3627
      sh_eth_set_msglevel(sh_eth_ethtool_ops_group2, ldvarg7);
#line 3629
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3632
    goto ldv_45331;
    case 3: ;
#line 3635
    if (ldv_state_variable_6 == 1) {
#line 3637
      sh_eth_set_settings(sh_eth_ethtool_ops_group2, sh_eth_ethtool_ops_group0);
#line 3639
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3642
    goto ldv_45331;
    case 4: ;
#line 3645
    if (ldv_state_variable_6 == 1) {
#line 3647
      sh_eth_get_ethtool_stats(sh_eth_ethtool_ops_group2, ldvarg6, ldvarg5);
#line 3649
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3652
    goto ldv_45331;
    case 5: ;
#line 3655
    if (ldv_state_variable_6 == 1) {
#line 3657
      sh_eth_get_strings(sh_eth_ethtool_ops_group2, ldvarg4, ldvarg3);
#line 3659
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3662
    goto ldv_45331;
    case 6: ;
#line 3665
    if (ldv_state_variable_6 == 1) {
#line 3667
      sh_eth_nway_reset(sh_eth_ethtool_ops_group2);
#line 3669
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3672
    goto ldv_45331;
    case 7: ;
#line 3675
    if (ldv_state_variable_6 == 1) {
#line 3677
      sh_eth_get_ringparam(sh_eth_ethtool_ops_group2, sh_eth_ethtool_ops_group1);
#line 3679
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3682
    goto ldv_45331;
    case 8: ;
#line 3685
    if (ldv_state_variable_6 == 1) {
#line 3687
      sh_eth_get_msglevel(sh_eth_ethtool_ops_group2);
#line 3689
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3692
    goto ldv_45331;
    case 9: ;
#line 3695
    if (ldv_state_variable_6 == 1) {
#line 3697
      sh_eth_set_ringparam(sh_eth_ethtool_ops_group2, sh_eth_ethtool_ops_group1);
#line 3699
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3702
    goto ldv_45331;
    case 10: ;
#line 3705
    if (ldv_state_variable_6 == 1) {
#line 3707
      ethtool_op_get_link(sh_eth_ethtool_ops_group2);
#line 3709
      ldv_state_variable_6 = 1;
    } else {

    }
#line 3712
    goto ldv_45331;
    default: 
#line 3713
    ldv_stop();
    }
    ldv_45331: ;
  } else {

  }
#line 3717
  goto ldv_45299;
  case 8: ;
#line 3721
  if (ldv_state_variable_3 != 0) {
#line 3722
    tmp___28 = __VERIFIER_nondet_int();
#line 3722
    switch (tmp___28) {
    case 0: ;
#line 3725
    if (ldv_state_variable_3 == 2) {
#line 3727
      ldv_retval_3 = sh_eth_runtime_nop(sh_eth_dev_pm_ops_group1);
#line 3728
      if (ldv_retval_3 == 0) {
#line 3729
        ldv_state_variable_3 = 1;
#line 3730
        ref_cnt = ref_cnt - 1;
      } else {

      }
    } else {

    }
#line 3734
    goto ldv_45345;
    case 1: ;
#line 3737
    if (ldv_state_variable_3 == 1) {
#line 3739
      ldv_retval_2 = sh_eth_runtime_nop(sh_eth_dev_pm_ops_group1);
#line 3740
      if (ldv_retval_2 == 0) {
#line 3741
        ldv_state_variable_3 = 2;
#line 3742
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 3746
    goto ldv_45345;
    default: 
#line 3747
    ldv_stop();
    }
    ldv_45345: ;
  } else {

  }
#line 3751
  goto ldv_45299;
  case 9: ;
#line 3755
  if (ldv_state_variable_9 != 0) {
#line 3756
    tmp___29 = __VERIFIER_nondet_int();
#line 3756
    switch (tmp___29) {
    case 0: ;
#line 3759
    if (ldv_state_variable_9 == 1) {
#line 3761
      sh_eth_chip_reset_r8a7740(r8a7740_data_group0);
#line 3763
      ldv_state_variable_9 = 1;
    } else {

    }
#line 3766
    goto ldv_45350;
    case 1: ;
#line 3769
    if (ldv_state_variable_9 == 1) {
#line 3771
      sh_eth_set_rate_gether(r8a7740_data_group0);
#line 3773
      ldv_state_variable_9 = 1;
    } else {

    }
#line 3776
    goto ldv_45350;
    case 2: ;
#line 3779
    if (ldv_state_variable_9 == 1) {
#line 3781
      sh_eth_set_duplex(r8a7740_data_group0);
#line 3783
      ldv_state_variable_9 = 1;
    } else {

    }
#line 3786
    goto ldv_45350;
    default: 
#line 3787
    ldv_stop();
    }
    ldv_45350: ;
  } else {

  }
#line 3791
  goto ldv_45299;
  case 10: ;
#line 3795
  if (ldv_state_variable_12 != 0) {
#line 3796
    tmp___30 = __VERIFIER_nondet_int();
#line 3796
    switch (tmp___30) {
    case 0: ;
#line 3799
    if (ldv_state_variable_12 == 1) {
#line 3801
      sh_eth_chip_reset_giga(sh7757_data_giga_group0);
#line 3803
      ldv_state_variable_12 = 1;
    } else {

    }
#line 3806
    goto ldv_45356;
    case 1: ;
#line 3809
    if (ldv_state_variable_12 == 1) {
#line 3811
      sh_eth_set_rate_giga(sh7757_data_giga_group0);
#line 3813
      ldv_state_variable_12 = 1;
    } else {

    }
#line 3816
    goto ldv_45356;
    case 2: ;
#line 3819
    if (ldv_state_variable_12 == 1) {
#line 3821
      sh_eth_set_duplex(sh7757_data_giga_group0);
#line 3823
      ldv_state_variable_12 = 1;
    } else {

    }
#line 3826
    goto ldv_45356;
    default: 
#line 3827
    ldv_stop();
    }
    ldv_45356: ;
  } else {

  }
#line 3831
  goto ldv_45299;
  case 11: ;
#line 3835
  if (ldv_state_variable_14 != 0) {
#line 3836
    tmp___31 = __VERIFIER_nondet_int();
#line 3836
    switch (tmp___31) {
    case 0: ;
#line 3839
    if (ldv_state_variable_14 == 1) {
#line 3841
      sh_eth_set_rate_sh7724(sh7724_data_group0);
#line 3843
      ldv_state_variable_14 = 1;
    } else {

    }
#line 3846
    goto ldv_45362;
    case 1: ;
#line 3849
    if (ldv_state_variable_14 == 1) {
#line 3851
      sh_eth_set_duplex(sh7724_data_group0);
#line 3853
      ldv_state_variable_14 = 1;
    } else {

    }
#line 3856
    goto ldv_45362;
    default: 
#line 3857
    ldv_stop();
    }
    ldv_45362: ;
  } else {

  }
#line 3861
  goto ldv_45299;
  case 12: ;
#line 3865
  if (ldv_state_variable_15 != 0) {
#line 3866
    tmp___32 = __VERIFIER_nondet_int();
#line 3866
    switch (tmp___32) {
    case 0: ;
#line 3869
    if (ldv_state_variable_15 == 1) {
#line 3871
      sh_eth_set_rate_r8a777x(r8a779x_data_group0);
#line 3873
      ldv_state_variable_15 = 1;
    } else {

    }
#line 3876
    goto ldv_45367;
    case 1: ;
#line 3879
    if (ldv_state_variable_15 == 1) {
#line 3881
      sh_eth_set_duplex(r8a779x_data_group0);
#line 3883
      ldv_state_variable_15 = 1;
    } else {

    }
#line 3886
    goto ldv_45367;
    default: 
#line 3887
    ldv_stop();
    }
    ldv_45367: ;
  } else {

  }
#line 3891
  goto ldv_45299;
  case 13: ;
#line 3895
  if (ldv_state_variable_8 != 0) {
#line 3896
    tmp___33 = __VERIFIER_nondet_int();
#line 3896
    switch (tmp___33) {
    case 0: ;
#line 3899
    if (ldv_state_variable_8 == 1) {
#line 3901
      sh_eth_chip_reset(r7s72100_data_group0);
#line 3903
      ldv_state_variable_8 = 1;
    } else {

    }
#line 3906
    goto ldv_45372;
    case 1: ;
#line 3909
    if (ldv_state_variable_8 == 1) {
#line 3911
      sh_eth_set_duplex(r7s72100_data_group0);
#line 3913
      ldv_state_variable_8 = 1;
    } else {

    }
#line 3916
    goto ldv_45372;
    default: 
#line 3917
    ldv_stop();
    }
    ldv_45372: ;
  } else {

  }
#line 3921
  goto ldv_45299;
  case 14: ;
#line 3925
  if (ldv_state_variable_4 != 0) {
#line 3926
    tmp___34 = __VERIFIER_nondet_int();
#line 3926
    switch (tmp___34) {
    case 0: ;
#line 3929
    if (ldv_state_variable_4 == 3) {
#line 3931
      sh_eth_close(sh_eth_netdev_ops_tsu_group1);
#line 3932
      ldv_state_variable_4 = 2;
    } else {

    }
#line 3935
    goto ldv_45377;
    case 1: ;
#line 3938
    if (ldv_state_variable_4 == 1) {
#line 3940
      sh_eth_set_multicast_list(sh_eth_netdev_ops_tsu_group1);
#line 3942
      ldv_state_variable_4 = 1;
    } else {

    }
#line 3945
    if (ldv_state_variable_4 == 3) {
#line 3947
      sh_eth_set_multicast_list(sh_eth_netdev_ops_tsu_group1);
#line 3949
      ldv_state_variable_4 = 3;
    } else {

    }
#line 3952
    if (ldv_state_variable_4 == 2) {
#line 3954
      sh_eth_set_multicast_list(sh_eth_netdev_ops_tsu_group1);
#line 3956
      ldv_state_variable_4 = 2;
    } else {

    }
#line 3959
    goto ldv_45377;
    case 2: ;
#line 3962
    if (ldv_state_variable_4 == 1) {
#line 3964
      eth_validate_addr(sh_eth_netdev_ops_tsu_group1);
#line 3966
      ldv_state_variable_4 = 1;
    } else {

    }
#line 3969
    if (ldv_state_variable_4 == 3) {
#line 3971
      eth_validate_addr(sh_eth_netdev_ops_tsu_group1);
#line 3973
      ldv_state_variable_4 = 3;
    } else {

    }
#line 3976
    if (ldv_state_variable_4 == 2) {
#line 3978
      eth_validate_addr(sh_eth_netdev_ops_tsu_group1);
#line 3980
      ldv_state_variable_4 = 2;
    } else {

    }
#line 3983
    goto ldv_45377;
    case 3: ;
#line 3986
    if (ldv_state_variable_4 == 1) {
#line 3988
      sh_eth_vlan_rx_kill_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg17, (int )ldvarg16);
#line 3990
      ldv_state_variable_4 = 1;
    } else {

    }
#line 3993
    if (ldv_state_variable_4 == 3) {
#line 3995
      sh_eth_vlan_rx_kill_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg17, (int )ldvarg16);
#line 3997
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4000
    if (ldv_state_variable_4 == 2) {
#line 4002
      sh_eth_vlan_rx_kill_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg17, (int )ldvarg16);
#line 4004
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4007
    goto ldv_45377;
    case 4: ;
#line 4010
    if (ldv_state_variable_4 == 1) {
#line 4012
      sh_eth_do_ioctl(sh_eth_netdev_ops_tsu_group1, ldvarg15, ldvarg14);
#line 4014
      ldv_state_variable_4 = 1;
    } else {

    }
#line 4017
    if (ldv_state_variable_4 == 3) {
#line 4019
      sh_eth_do_ioctl(sh_eth_netdev_ops_tsu_group1, ldvarg15, ldvarg14);
#line 4021
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4024
    if (ldv_state_variable_4 == 2) {
#line 4026
      sh_eth_do_ioctl(sh_eth_netdev_ops_tsu_group1, ldvarg15, ldvarg14);
#line 4028
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4031
    goto ldv_45377;
    case 5: ;
#line 4034
    if (ldv_state_variable_4 == 1) {
#line 4036
      sh_eth_vlan_rx_add_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg13, (int )ldvarg12);
#line 4038
      ldv_state_variable_4 = 1;
    } else {

    }
#line 4041
    if (ldv_state_variable_4 == 3) {
#line 4043
      sh_eth_vlan_rx_add_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg13, (int )ldvarg12);
#line 4045
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4048
    if (ldv_state_variable_4 == 2) {
#line 4050
      sh_eth_vlan_rx_add_vid(sh_eth_netdev_ops_tsu_group1, (int )ldvarg13, (int )ldvarg12);
#line 4052
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4055
    goto ldv_45377;
    case 6: ;
#line 4058
    if (ldv_state_variable_4 == 1) {
#line 4060
      sh_eth_get_stats(sh_eth_netdev_ops_tsu_group1);
#line 4062
      ldv_state_variable_4 = 1;
    } else {

    }
#line 4065
    if (ldv_state_variable_4 == 3) {
#line 4067
      sh_eth_get_stats(sh_eth_netdev_ops_tsu_group1);
#line 4069
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4072
    if (ldv_state_variable_4 == 2) {
#line 4074
      sh_eth_get_stats(sh_eth_netdev_ops_tsu_group1);
#line 4076
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4079
    goto ldv_45377;
    case 7: ;
#line 4082
    if (ldv_state_variable_4 == 3) {
#line 4084
      eth_change_mtu(sh_eth_netdev_ops_tsu_group1, ldvarg11);
#line 4086
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4089
    if (ldv_state_variable_4 == 2) {
#line 4091
      eth_change_mtu(sh_eth_netdev_ops_tsu_group1, ldvarg11);
#line 4093
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4096
    goto ldv_45377;
    case 8: ;
#line 4099
    if (ldv_state_variable_4 == 2) {
#line 4101
      ldv_retval_5 = sh_eth_open(sh_eth_netdev_ops_tsu_group1);
#line 4102
      if (ldv_retval_5 == 0) {
#line 4103
        ldv_state_variable_4 = 3;
      } else {

      }
    } else {

    }
#line 4107
    goto ldv_45377;
    case 9: ;
#line 4110
    if (ldv_state_variable_4 == 3) {
#line 4112
      sh_eth_start_xmit(ldvarg10, sh_eth_netdev_ops_tsu_group1);
#line 4114
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4117
    goto ldv_45377;
    case 10: ;
#line 4120
    if (ldv_state_variable_4 == 1) {
#line 4122
      eth_mac_addr(sh_eth_netdev_ops_tsu_group1, ldvarg9);
#line 4124
      ldv_state_variable_4 = 1;
    } else {

    }
#line 4127
    if (ldv_state_variable_4 == 3) {
#line 4129
      eth_mac_addr(sh_eth_netdev_ops_tsu_group1, ldvarg9);
#line 4131
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4134
    if (ldv_state_variable_4 == 2) {
#line 4136
      eth_mac_addr(sh_eth_netdev_ops_tsu_group1, ldvarg9);
#line 4138
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4141
    goto ldv_45377;
    case 11: ;
#line 4144
    if (ldv_state_variable_4 == 1) {
#line 4146
      sh_eth_tx_timeout(sh_eth_netdev_ops_tsu_group1);
#line 4148
      ldv_state_variable_4 = 1;
    } else {

    }
#line 4151
    if (ldv_state_variable_4 == 3) {
#line 4153
      sh_eth_tx_timeout(sh_eth_netdev_ops_tsu_group1);
#line 4155
      ldv_state_variable_4 = 3;
    } else {

    }
#line 4158
    if (ldv_state_variable_4 == 2) {
#line 4160
      sh_eth_tx_timeout(sh_eth_netdev_ops_tsu_group1);
#line 4162
      ldv_state_variable_4 = 2;
    } else {

    }
#line 4165
    goto ldv_45377;
    case 12: ;
#line 4168
    if (ldv_state_variable_4 == 2) {
#line 4170
      ldv_ndo_uninit_4();
#line 4171
      ldv_state_variable_4 = 1;
#line 4172
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 4175
    goto ldv_45377;
    case 13: ;
#line 4178
    if (ldv_state_variable_4 == 1) {
#line 4180
      ldv_retval_4 = ldv_ndo_init_4();
#line 4181
      if (ldv_retval_4 == 0) {
#line 4182
        ldv_state_variable_4 = 2;
#line 4183
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 4187
    goto ldv_45377;
    default: 
#line 4188
    ldv_stop();
    }
    ldv_45377: ;
  } else {

  }
#line 4192
  goto ldv_45299;
  case 15: ;
#line 4196
  if (ldv_state_variable_10 != 0) {
#line 4197
    tmp___35 = __VERIFIER_nondet_int();
#line 4197
    switch (tmp___35) {
    case 0: ;
#line 4200
    if (ldv_state_variable_10 == 1) {
#line 4202
      sh_eth_chip_reset(sh7763_data_group0);
#line 4204
      ldv_state_variable_10 = 1;
    } else {

    }
#line 4207
    goto ldv_45394;
    case 1: ;
#line 4210
    if (ldv_state_variable_10 == 1) {
#line 4212
      sh_eth_set_rate_gether(sh7763_data_group0);
#line 4214
      ldv_state_variable_10 = 1;
    } else {

    }
#line 4217
    goto ldv_45394;
    case 2: ;
#line 4220
    if (ldv_state_variable_10 == 1) {
#line 4222
      sh_eth_set_duplex(sh7763_data_group0);
#line 4224
      ldv_state_variable_10 = 1;
    } else {

    }
#line 4227
    goto ldv_45394;
    default: 
#line 4228
    ldv_stop();
    }
    ldv_45394: ;
  } else {

  }
#line 4232
  goto ldv_45299;
  case 16: ;
#line 4236
  if (ldv_state_variable_5 != 0) {
#line 4237
    tmp___36 = __VERIFIER_nondet_int();
#line 4237
    switch (tmp___36) {
    case 0: ;
#line 4240
    if (ldv_state_variable_5 == 3) {
#line 4242
      sh_eth_close(sh_eth_netdev_ops_group1);
#line 4243
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4246
    goto ldv_45400;
    case 1: ;
#line 4249
    if (ldv_state_variable_5 == 1) {
#line 4251
      eth_validate_addr(sh_eth_netdev_ops_group1);
#line 4253
      ldv_state_variable_5 = 1;
    } else {

    }
#line 4256
    if (ldv_state_variable_5 == 3) {
#line 4258
      eth_validate_addr(sh_eth_netdev_ops_group1);
#line 4260
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4263
    if (ldv_state_variable_5 == 2) {
#line 4265
      eth_validate_addr(sh_eth_netdev_ops_group1);
#line 4267
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4270
    goto ldv_45400;
    case 2: ;
#line 4273
    if (ldv_state_variable_5 == 1) {
#line 4275
      sh_eth_do_ioctl(sh_eth_netdev_ops_group1, ldvarg22, ldvarg21);
#line 4277
      ldv_state_variable_5 = 1;
    } else {

    }
#line 4280
    if (ldv_state_variable_5 == 3) {
#line 4282
      sh_eth_do_ioctl(sh_eth_netdev_ops_group1, ldvarg22, ldvarg21);
#line 4284
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4287
    if (ldv_state_variable_5 == 2) {
#line 4289
      sh_eth_do_ioctl(sh_eth_netdev_ops_group1, ldvarg22, ldvarg21);
#line 4291
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4294
    goto ldv_45400;
    case 3: ;
#line 4297
    if (ldv_state_variable_5 == 1) {
#line 4299
      sh_eth_get_stats(sh_eth_netdev_ops_group1);
#line 4301
      ldv_state_variable_5 = 1;
    } else {

    }
#line 4304
    if (ldv_state_variable_5 == 3) {
#line 4306
      sh_eth_get_stats(sh_eth_netdev_ops_group1);
#line 4308
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4311
    if (ldv_state_variable_5 == 2) {
#line 4313
      sh_eth_get_stats(sh_eth_netdev_ops_group1);
#line 4315
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4318
    goto ldv_45400;
    case 4: ;
#line 4321
    if (ldv_state_variable_5 == 3) {
#line 4323
      eth_change_mtu(sh_eth_netdev_ops_group1, ldvarg20);
#line 4325
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4328
    if (ldv_state_variable_5 == 2) {
#line 4330
      eth_change_mtu(sh_eth_netdev_ops_group1, ldvarg20);
#line 4332
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4335
    goto ldv_45400;
    case 5: ;
#line 4338
    if (ldv_state_variable_5 == 2) {
#line 4340
      ldv_retval_7 = sh_eth_open(sh_eth_netdev_ops_group1);
#line 4341
      if (ldv_retval_7 == 0) {
#line 4342
        ldv_state_variable_5 = 3;
      } else {

      }
    } else {

    }
#line 4346
    goto ldv_45400;
    case 6: ;
#line 4349
    if (ldv_state_variable_5 == 3) {
#line 4351
      sh_eth_start_xmit(ldvarg19, sh_eth_netdev_ops_group1);
#line 4353
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4356
    goto ldv_45400;
    case 7: ;
#line 4359
    if (ldv_state_variable_5 == 1) {
#line 4361
      eth_mac_addr(sh_eth_netdev_ops_group1, ldvarg18);
#line 4363
      ldv_state_variable_5 = 1;
    } else {

    }
#line 4366
    if (ldv_state_variable_5 == 3) {
#line 4368
      eth_mac_addr(sh_eth_netdev_ops_group1, ldvarg18);
#line 4370
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4373
    if (ldv_state_variable_5 == 2) {
#line 4375
      eth_mac_addr(sh_eth_netdev_ops_group1, ldvarg18);
#line 4377
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4380
    goto ldv_45400;
    case 8: ;
#line 4383
    if (ldv_state_variable_5 == 1) {
#line 4385
      sh_eth_tx_timeout(sh_eth_netdev_ops_group1);
#line 4387
      ldv_state_variable_5 = 1;
    } else {

    }
#line 4390
    if (ldv_state_variable_5 == 3) {
#line 4392
      sh_eth_tx_timeout(sh_eth_netdev_ops_group1);
#line 4394
      ldv_state_variable_5 = 3;
    } else {

    }
#line 4397
    if (ldv_state_variable_5 == 2) {
#line 4399
      sh_eth_tx_timeout(sh_eth_netdev_ops_group1);
#line 4401
      ldv_state_variable_5 = 2;
    } else {

    }
#line 4404
    goto ldv_45400;
    case 9: ;
#line 4407
    if (ldv_state_variable_5 == 2) {
#line 4409
      ldv_ndo_uninit_5();
#line 4410
      ldv_state_variable_5 = 1;
#line 4411
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 4414
    goto ldv_45400;
    case 10: ;
#line 4417
    if (ldv_state_variable_5 == 1) {
#line 4419
      ldv_retval_6 = ldv_ndo_init_5();
#line 4420
      if (ldv_retval_6 == 0) {
#line 4421
        ldv_state_variable_5 = 2;
#line 4422
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 4426
    goto ldv_45400;
    default: 
#line 4427
    ldv_stop();
    }
    ldv_45400: ;
  } else {

  }
#line 4431
  goto ldv_45299;
  default: 
#line 4432
  ldv_stop();
  }
  ldv_45299: ;
#line 4434
  goto ldv_45413;
  ldv_final: 
#line 4436
  ldv_check_final_state();
#line 4437
  return 0;
}
}
#line 4440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 4443
  tmp = ldv_err_ptr(error);
#line 4443
  return (tmp);
}
}
#line 4446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 4449
  tmp = ldv_ptr_err(ptr);
#line 4449
  return (tmp);
}
}
#line 4452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 4455
  tmp = ldv_is_err(ptr);
#line 4455
  return (tmp);
}
}
#line 4464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_consume_skb_5(struct sk_buff *ldv_func_arg1 ) 
{ 


  {
#line 4467
  ldv_skb_free(ldv_func_arg1);
#line 4468
  return;
}
}
#line 4470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_kfree_skb_6(struct sk_buff *ldv_func_arg1 ) 
{ 


  {
#line 4473
  ldv_skb_free(ldv_func_arg1);
#line 4474
  return;
}
}
#line 4476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_kfree_skb_7(struct sk_buff *ldv_func_arg1 ) 
{ 


  {
#line 4479
  ldv_skb_free(ldv_func_arg1);
#line 4480
  return;
}
}
#line 4482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_kfree_skb_8(struct sk_buff *ldv_func_arg1 ) 
{ 


  {
#line 4485
  ldv_skb_free(ldv_func_arg1);
#line 4486
  return;
}
}
#line 4500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_kfree_skb_11(struct sk_buff *ldv_func_arg1 ) 
{ 


  {
#line 4503
  ldv_skb_free(ldv_func_arg1);
#line 4504
  return;
}
}
#line 4506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static struct sk_buff *ldv_netdev_alloc_skb_12(struct net_device *dev , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4509
  tmp = ldv_skb_alloc();
#line 4509
  return (tmp);
}
}
#line 4518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
__inline static int ldv_request_irq_14(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 4522
  tmp = request_irq(irq, handler, flags, name, dev);
#line 4522
  ldv_func_res = tmp;
#line 4524
  tmp___0 = reg_check_1(handler);
#line 4524
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 4525
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 4528
  return (ldv_func_res);
}
}
#line 4531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 4534
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 4536
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 4537
  return;
}
}
#line 4539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_free_irq_16(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 4542
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 4544
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 4545
  return;
}
}
#line 4547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv_register_netdev_17(struct net_device *dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 4551
  tmp = register_netdev(dev);
#line 4551
  ldv_func_res = tmp;
#line 4553
  ldv_state_variable_4 = 1;
#line 4554
  ldv_net_device_ops_4();
#line 4557
  return (ldv_func_res);
}
}
#line 4560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_free_netdev_18(struct net_device *dev ) 
{ 


  {
#line 4563
  free_netdev(dev);
#line 4565
  ldv_state_variable_4 = 0;
#line 4566
  return;
}
}
#line 4568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_unregister_netdev_19(struct net_device *dev ) 
{ 


  {
#line 4571
  unregister_netdev(dev);
#line 4573
  ldv_state_variable_4 = 0;
#line 4574
  return;
}
}
#line 4576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_free_netdev_20(struct net_device *dev ) 
{ 


  {
#line 4579
  free_netdev(dev);
#line 4581
  ldv_state_variable_4 = 0;
#line 4582
  return;
}
}
#line 4584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
int ldv___platform_driver_register_21(struct platform_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 4588
  tmp = __platform_driver_register(ldv_func_arg1, ldv_func_arg2);
#line 4588
  ldv_func_res = tmp;
#line 4590
  ldv_state_variable_2 = 1;
#line 4590
  ldv_initialize_platform_driver_2();
#line 4593
  return (ldv_func_res);
}
}
#line 4596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/dscv/ri/205_9a/drivers/net/ethernet/renesas/sh_eth.o.c.prepared"
void ldv_platform_driver_unregister_22(struct platform_driver *drv ) 
{ 


  {
#line 4599
  platform_driver_unregister(drv);
#line 4601
  ldv_state_variable_2 = 0;
#line 4602
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 8 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
Element set_impl[15]  ;
#line 9 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
int last_index  =    0;
#line 11
__inline static void ldv_set_init(Set set )  __attribute__((__no_instrument_function__)) ;
#line 11 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
__inline static void ldv_set_init(Set set ) 
{ 


  {
#line 13
  set = set_impl;
#line 14
  last_index = 0;
#line 15
  return;
}
}
#line 17
__inline static void ldv_set_add(Set set , Element e )  __attribute__((__no_instrument_function__)) ;
#line 17 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
__inline static void ldv_set_add(Set set , Element e ) 
{ 
  int i ;

  {
#line 20
  i = 0;
#line 20
  while (1) {
#line 20
    if (i < last_index) {

    } else {
#line 20
      break;
    }
#line 21
    if ((unsigned long )set_impl[i] == (unsigned long )e) {
#line 24
      return;
    } else {

    }
#line 20
    i = i + 1;
  }
#line 28
  if (last_index < 15) {
#line 29
    set_impl[last_index] = e;
#line 30
    last_index = last_index + 1;
  } else {

  }
#line 36
  return;
}
}
#line 38
__inline static void ldv_set_remove(Set set , Element e )  __attribute__((__no_instrument_function__)) ;
#line 38 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
__inline static void ldv_set_remove(Set set , Element e ) 
{ 
  int i ;
  int deleted_index ;

  {
#line 41
  deleted_index = -1;
#line 42
  i = 0;
#line 42
  while (1) {
#line 42
    if (i < last_index) {

    } else {
#line 42
      break;
    }
#line 43
    if ((unsigned long )set_impl[i] == (unsigned long )e) {
#line 45
      deleted_index = i;
#line 46
      break;
    } else {

    }
#line 42
    i = i + 1;
  }
#line 49
  if (deleted_index != -1) {
#line 51
    i = deleted_index + 1;
#line 51
    while (1) {
#line 51
      if (i < last_index) {

      } else {
#line 51
        break;
      }
#line 52
      set_impl[i - 1] = set_impl[i];
#line 51
      i = i + 1;
    }
#line 54
    last_index = last_index - 1;
  } else {

  }
#line 57
  return;
}
}
#line 59
__inline static int ldv_set_contains(Set set , Element e )  __attribute__((__no_instrument_function__)) ;
#line 59 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
__inline static int ldv_set_contains(Set set , Element e ) 
{ 
  int i ;

  {
#line 62
  i = 0;
#line 62
  while (1) {
#line 62
    if (i < last_index) {

    } else {
#line 62
      break;
    }
#line 63
    if ((unsigned long )set_impl[i] == (unsigned long )e) {
#line 64
      return (1);
    } else {

    }
#line 62
    i = i + 1;
  }
#line 67
  return (0);
}
}
#line 70
__inline static int ldv_set_is_empty(Set set )  __attribute__((__no_instrument_function__)) ;
#line 70 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/array-set-impl.h"
__inline static int ldv_set_is_empty(Set set ) 
{ 


  {
#line 72
  return (last_index == 0);
}
}
#line 5 "/home/ldvuser/ldv/inst-cpa/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 8
  return ((unsigned long )ptr > 2012UL);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 15
  return ((void *)(2012L - error));
}
}
#line 19 "/home/ldvuser/ldv/inst-cpa/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 26 "/home/ldvuser/ldv/inst-cpa/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp___7 ;
  int tmp___8 ;

  {
#line 29
  if (! ptr) {
#line 29
    tmp___8 = 1;
  } else {
#line 29
    tmp___7 = ldv_is_err((unsigned long )ptr);
#line 29
    if (tmp___7) {
#line 29
      tmp___8 = 1;
    } else {
#line 29
      tmp___8 = 0;
    }
  }
#line 29
  return (tmp___8);
}
}
#line 9 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
Set LDV_SKBS  ;
#line 12 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
struct sk_buff___0 *ldv_skb_alloc(void) 
{ 
  void *skb ;
  void *tmp___7 ;

  {
#line 16
  tmp___7 = ldv_zalloc(sizeof(struct sk_buff___0 ));
#line 16
  skb = (struct sk_buff___0 *)tmp___7;
#line 18
  if (! skb) {
#line 21
    return ((void *)0);
  } else {
#line 27
    ldv_set_add(LDV_SKBS, skb);
#line 29
    return (skb);
  }
}
}
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 38
  ldv_set_init(LDV_SKBS);
#line 39
  return;
}
}
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
void ldv_skb_free(struct sk_buff___0 *skb ) 
{ 


  {
#line 47
  ldv_set_remove(LDV_SKBS, skb);
#line 48
  return;
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
int ldv_skb_free_int(struct sk_buff___0 *skb ) 
{ 


  {
#line 56
  ldv_set_remove(LDV_SKBS, skb);
#line 57
  return (0);
}
}
#line 68
struct sk_buff___0 *ldv_netdev_alloc_skb(void) ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
struct sk_buff___0 *ldv_dev_alloc_skb(void) 
{ 
  void *skb ;
  int tmp___7 ;

  {
#line 68
  tmp___7 = (int )ldv_netdev_alloc_skb();
#line 68
  skb = tmp___7;
#line 70
  return (skb);
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
struct sk_buff___0 *ldv_netdev_alloc_skb(void) 
{ 
  struct sk_buff___0 *tmp___7 ;

  {
#line 79
  tmp___7 = ldv_skb_alloc();
#line 79
  return (tmp___7);
}
}
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
int ldv_skb_current(struct sk_buff___0 *skb ) 
{ 
  int tmp___7 ;

  {
#line 88
  tmp___7 = ldv_set_contains(LDV_SKBS, skb);
#line 88
  if (tmp___7) {
#line 91
    return (1);
  } else {
#line 96
    return (0);
  }
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/net/--X--defaultlinux-3.16-rc1.tar.xz--X--205_9a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/1307/dscv_tempdir/rule-instrumentor/205_9a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 
  int tmp___7 ;

  {
#line 104
  tmp___7 = ldv_set_is_empty(LDV_SKBS);
#line 104
  if (tmp___7) {

  } else {
#line 104
    ldv_error();
  }
#line 105
  return;
}
}
