extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 327 "./arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
#line 433 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 167 "./arch/x86/include/asm/fixmap.h"
struct notifier_block;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 906 "include/linux/mmzone.h"
struct ctl_table;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13760_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13762_128 {
   struct __anonstruct_ldv_13760_129 ldv_13760 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13762_128 ldv_13762 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 24 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14006_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14010_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_14011_135 {
   struct __anonstruct_ldv_14006_136 ldv_14006 ;
   struct __anonstruct_ldv_14010_137 ldv_14010 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14011_135 ldv_14011 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14120_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14126_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14136_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14138_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14136_144 ldv_14136 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14140_142 {
   union __anonunion_ldv_14138_143 ldv_14138 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14142_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14140_142 ldv_14140 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14143_139 {
   union __anonunion_ldv_14126_140 ldv_14126 ;
   union __anonunion_ldv_14142_141 ldv_14142 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14150_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14155_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14150_146 ldv_14150 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14161_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 ldv_14120 ;
   struct __anonstruct_ldv_14143_139 ldv_14143 ;
   union __anonunion_ldv_14155_145 ldv_14155 ;
   union __anonunion_ldv_14161_147 ldv_14161 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14524_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14524_153 ldv_14524 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14668_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14668_154 ldv_14668 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15343_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15343_155 ldv_15343 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15963_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15969_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_15970_156 {
   struct __anonstruct_ldv_15963_157 ldv_15963 ;
   struct __anonstruct_ldv_15969_158 ldv_15969 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15970_156 ldv_15970 ;
};
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct usb_interface;
#line 31
struct pvr2_dvb_adapter;
#line 43
struct v4l2_ext_controls;
#line 49
struct v4l2_control;
#line 58
struct i2c_adapter;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 262 "include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 628
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 218 "include/linux/capability.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_170 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_171 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_170 _sigpoll ;
   struct __anonstruct__sigsys_171 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 11 "include/linux/signal.h"
struct user_struct;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 459
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 466
struct pid_namespace;
#line 466 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_19048_174 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_19056_175 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_19069_177 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_19070_176 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_19069_177 ldv_19069 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_178 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_180 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_19085_179 {
   union __anonunion_payload_180 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_19048_174 ldv_19048 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_19056_175 ldv_19056 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_19070_176 ldv_19070 ;
   union __anonunion_type_data_178 type_data ;
   union __anonunion_ldv_19085_179 ldv_19085 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct tty_struct;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct backing_dev_info;
#line 779
struct reclaim_state;
#line 780 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1026
struct io_context;
#line 1060
struct pipe_inode_info;
#line 1061
struct uts_namespace;
#line 1062 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct files_struct;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 42 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 783 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_client;
#line 42
struct i2c_board_info;
#line 198 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
};
#line 248 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   int irq ;
};
#line 335 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
};
#line 381 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_bus_recovery_info * ) ;
   void (*unprepare_recovery)(struct i2c_bus_recovery_info * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 420 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct writeback_control;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 2112 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 30 "include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 995 "include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1005 "include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1024 "include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1034 "include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1046 "include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1067 "include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1098 "include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1111 "include/uapi/linux/input.h"
union __anonunion_u_185 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1111 "include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_185 u ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_24618_187 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_24619_186 {
   struct __anonstruct_ldv_24618_187 ldv_24618 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_24619_186 ldv_24619 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct_ldv_24642_189 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion_ldv_24644_188 {
   struct __anonstruct_ldv_24642_189 ldv_24642 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_24644_188 ldv_24644 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_190 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_190 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_25005_192 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_25007_191 {
   struct __anonstruct_ldv_25005_192 ldv_25005 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_25007_191 ldv_25007 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct iovec;
#line 62
struct kiocb;
#line 63
struct poll_table_struct;
#line 64
struct kstatfs;
#line 65
struct swap_info_struct;
#line 66
struct iov_iter;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_193 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_193 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_25536_194 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_25536_194 ldv_25536 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_25950_197 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_25970_198 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_25987_199 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_25950_197 ldv_25950 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_25970_198 ldv_25970 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_25987_199 ldv_25987 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_200 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_200 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 855
struct net;
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_202 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_201 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_202 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_201 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 2765 "include/linux/fs.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 532
enum rc_type {
    RC_TYPE_UNKNOWN = 0,
    RC_TYPE_OTHER = 1,
    RC_TYPE_LIRC = 2,
    RC_TYPE_RC5 = 3,
    RC_TYPE_RC5X = 4,
    RC_TYPE_RC5_SZ = 5,
    RC_TYPE_JVC = 6,
    RC_TYPE_SONY12 = 7,
    RC_TYPE_SONY15 = 8,
    RC_TYPE_SONY20 = 9,
    RC_TYPE_NEC = 10,
    RC_TYPE_SANYO = 11,
    RC_TYPE_MCE_KBD = 12,
    RC_TYPE_RC6_0 = 13,
    RC_TYPE_RC6_6A_20 = 14,
    RC_TYPE_RC6_6A_24 = 15,
    RC_TYPE_RC6_6A_32 = 16,
    RC_TYPE_RC6_MCE = 17,
    RC_TYPE_SHARP = 18
} ;
#line 554 "include/linux/input.h"
struct rc_map_table {
   u32 scancode ;
   u32 keycode ;
};
#line 69 "include/media/rc-map.h"
struct rc_map {
   struct rc_map_table *scan ;
   unsigned int size ;
   unsigned int len ;
   unsigned int alloc ;
   enum rc_type rc_type ;
   char const   *name ;
   spinlock_t lock ;
};
#line 26 "include/media/rc-core.h"
enum rc_driver_type {
    RC_DRIVER_SCANCODE = 0,
    RC_DRIVER_IR_RAW = 1
} ;
#line 31 "include/media/rc-core.h"
struct rc_scancode_filter {
   u32 data ;
   u32 mask ;
};
#line 52
struct ir_raw_event_ctrl;
#line 52 "include/media/rc-core.h"
struct rc_dev {
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[5U] ;
   char const   *input_name ;
   char const   *input_phys ;
   struct input_id input_id ;
   char *driver_name ;
   char const   *map_name ;
   struct rc_map rc_map ;
   struct mutex lock ;
   unsigned long devno ;
   struct ir_raw_event_ctrl *raw ;
   struct input_dev *input_dev ;
   enum rc_driver_type driver_type ;
   bool idle ;
   u64 allowed_protocols[2U] ;
   u64 enabled_protocols[2U] ;
   u32 users ;
   u32 scanmask ;
   void *priv ;
   spinlock_t keylock ;
   bool keypressed ;
   unsigned long keyup_jiffies ;
   struct timer_list timer_keyup ;
   u32 last_keycode ;
   u32 last_scancode ;
   u8 last_toggle ;
   u32 timeout ;
   u32 min_timeout ;
   u32 max_timeout ;
   u32 rx_resolution ;
   u32 tx_resolution ;
   struct rc_scancode_filter scancode_filters[2U] ;
   int (*change_protocol)(struct rc_dev * , u64 * ) ;
   int (*change_wakeup_protocol)(struct rc_dev * , u64 * ) ;
   int (*open)(struct rc_dev * ) ;
   void (*close)(struct rc_dev * ) ;
   int (*s_tx_mask)(struct rc_dev * , u32  ) ;
   int (*s_tx_carrier)(struct rc_dev * , u32  ) ;
   int (*s_tx_duty_cycle)(struct rc_dev * , u32  ) ;
   int (*s_rx_carrier_range)(struct rc_dev * , u32  , u32  ) ;
   int (*tx_ir)(struct rc_dev * , unsigned int * , unsigned int  ) ;
   void (*s_idle)(struct rc_dev * , bool  ) ;
   int (*s_learning_mode)(struct rc_dev * , int  ) ;
   int (*s_carrier_report)(struct rc_dev * , int  ) ;
   int (*s_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
   int (*s_wakeup_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
};
#line 308
struct IR_i2c;
#line 309 "include/media/rc-core.h"
struct IR_i2c {
   char *ir_codes ;
   struct i2c_client *c ;
   struct rc_dev *rc ;
   unsigned char old ;
   u32 polling_interval ;
   struct delayed_work work ;
   char name[32U] ;
   char phys[32U] ;
   int (*get_key)(struct IR_i2c * , u32 * , u32 * ) ;
};
#line 25 "include/media/ir-kbd-i2c.h"
enum ir_kbd_get_key_fn {
    IR_KBD_GET_KEY_CUSTOM = 0,
    IR_KBD_GET_KEY_PIXELVIEW = 1,
    IR_KBD_GET_KEY_HAUP = 2,
    IR_KBD_GET_KEY_KNC1 = 3,
    IR_KBD_GET_KEY_FUSIONHDTV = 4,
    IR_KBD_GET_KEY_HAUP_XVR = 5,
    IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 6
} ;
#line 35 "include/media/ir-kbd-i2c.h"
struct IR_i2c_init_data {
   char *ir_codes ;
   char const   *name ;
   u64 type ;
   u32 polling_interval ;
   int (*get_key)(struct IR_i2c * , u32 * , u32 * ) ;
   enum ir_kbd_get_key_fn internal_get_key_func ;
   struct rc_dev *rc_dev ;
};
#line 52
struct pvr2_hdw;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 106 "./include/uapi/linux/v4l2-common.h"
enum v4l2_mpeg_stream_type {
    V4L2_MPEG_STREAM_TYPE_MPEG2_PS = 0,
    V4L2_MPEG_STREAM_TYPE_MPEG2_TS = 1,
    V4L2_MPEG_STREAM_TYPE_MPEG1_SS = 2,
    V4L2_MPEG_STREAM_TYPE_MPEG2_DVD = 3,
    V4L2_MPEG_STREAM_TYPE_MPEG1_VCD = 4,
    V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5
} ;
#line 115
enum v4l2_mpeg_stream_vbi_fmt {
    V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,
    V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1
} ;
#line 120
enum v4l2_mpeg_audio_sampling_freq {
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2
} ;
#line 126
enum v4l2_mpeg_audio_encoding {
    V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
    V4L2_MPEG_AUDIO_ENCODING_AAC = 3,
    V4L2_MPEG_AUDIO_ENCODING_AC3 = 4
} ;
#line 151
enum v4l2_mpeg_audio_l2_bitrate {
    V4L2_MPEG_AUDIO_L2_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L2_BITRATE_48K = 1,
    V4L2_MPEG_AUDIO_L2_BITRATE_56K = 2,
    V4L2_MPEG_AUDIO_L2_BITRATE_64K = 3,
    V4L2_MPEG_AUDIO_L2_BITRATE_80K = 4,
    V4L2_MPEG_AUDIO_L2_BITRATE_96K = 5,
    V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
    V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
    V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
    V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
    V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
    V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
    V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
    V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13
} ;
#line 185
enum v4l2_mpeg_audio_mode {
    V4L2_MPEG_AUDIO_MODE_STEREO = 0,
    V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
    V4L2_MPEG_AUDIO_MODE_DUAL = 2,
    V4L2_MPEG_AUDIO_MODE_MONO = 3
} ;
#line 192
enum v4l2_mpeg_audio_mode_extension {
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4 = 0,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8 = 1,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3
} ;
#line 199
enum v4l2_mpeg_audio_emphasis {
    V4L2_MPEG_AUDIO_EMPHASIS_NONE = 0,
    V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
    V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17 = 2
} ;
#line 205
enum v4l2_mpeg_audio_crc {
    V4L2_MPEG_AUDIO_CRC_NONE = 0,
    V4L2_MPEG_AUDIO_CRC_CRC16 = 1
} ;
#line 210
enum v4l2_mpeg_audio_ac3_bitrate {
    V4L2_MPEG_AUDIO_AC3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_AC3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_AC3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_AC3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_AC3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_AC3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_AC3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
    V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
    V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
    V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
    V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
    V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18
} ;
#line 241
enum v4l2_mpeg_video_encoding {
    V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2
} ;
#line 247
enum v4l2_mpeg_video_aspect {
    V4L2_MPEG_VIDEO_ASPECT_1x1 = 0,
    V4L2_MPEG_VIDEO_ASPECT_4x3 = 1,
    V4L2_MPEG_VIDEO_ASPECT_16x9 = 2,
    V4L2_MPEG_VIDEO_ASPECT_221x100 = 3
} ;
#line 254
enum v4l2_mpeg_video_bitrate_mode {
    V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
    V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1
} ;
#line 407
enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO = 1
} ;
#line 412
enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE = 3,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4
} ;
#line 420
enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1
} ;
#line 425
enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO = 1
} ;
#line 430
enum v4l2_mpeg_cx2341x_video_median_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG = 4
} ;
#line 603
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 611 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 216 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 460 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 473 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 482 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29089_205 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 482 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion_ldv_29089_205 ldv_29089 ;
   __u32 reserved[2U] ;
};
#line 501 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 510 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29108_206 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 510 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion_ldv_29108_206 ldv_29108 ;
   __u32 reserved[2U] ;
};
#line 781 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 793 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 806 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 816 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 848 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1040 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29242_209 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1040 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_ldv_29242_209 ldv_29242 ;
};
#line 1102 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1120 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1143 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29265_210 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1143 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion_ldv_29265_210 ldv_29265 ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1248 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29295_211 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
};
#line 1248 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion_ldv_29295_211 ldv_29295 ;
};
#line 1259 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1267
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9
} ;
#line 1279 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1296 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29327_212 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1296 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion_ldv_29327_212 ldv_29327 ;
   __u32 reserved ;
};
#line 1307 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1343 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1353 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1392 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1560 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1580 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1602 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1626 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1752 "include/uapi/linux/videodev2.h"
union __anonunion_parm_221 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1752 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_221 parm ;
};
#line 1826 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 1836 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_29535_224 {
   __u32 addr ;
   char name[32U] ;
};
#line 1836 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_ldv_29535_224 ldv_29535 ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 359 "include/linux/irq.h"
struct proc_dir_entry;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 450 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 272 "include/linux/pm_runtime.h"
struct usb_device;
#line 274
struct wusb_dev;
#line 275
struct ep_device;
#line 276 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char reset_running : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 206 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 235 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 299 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 311 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 323
struct mon_bus;
#line 323 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 374
struct usb_tt;
#line 375
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 388 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 409 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 448 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1179 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1221
struct urb;
#line 1222 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1241 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 163 "include/linux/poll.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 129 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 132
struct media_pad;
#line 132 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 53
struct media_device;
#line 53 "include/media/media-entity.h"
struct __anonstruct_v4l_233 {
   u32 major ;
   u32 minor ;
};
#line 53 "include/media/media-entity.h"
struct __anonstruct_fb_234 {
   u32 major ;
   u32 minor ;
};
#line 53 "include/media/media-entity.h"
struct __anonstruct_alsa_235 {
   u32 card ;
   u32 device ;
   u32 subdevice ;
};
#line 53 "include/media/media-entity.h"
union __anonunion_info_232 {
   struct __anonstruct_v4l_233 v4l ;
   struct __anonstruct_fb_234 fb ;
   struct __anonstruct_alsa_235 alsa ;
   int dvb ;
};
#line 53 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_232 info ;
};
#line 156
struct video_device;
#line 157
struct v4l2_device;
#line 158
struct v4l2_ctrl_handler;
#line 159 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 63 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 81
struct vb2_queue;
#line 81
struct v4l2_ioctl_ops;
#line 81 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream;
#line 91
struct pvr2_ctrl;
#line 92
enum pvr2_ctl_type {
    pvr2_ctl_int = 0,
    pvr2_ctl_enum = 1,
    pvr2_ctl_bitmask = 2,
    pvr2_ctl_bool = 3
} ;
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
enum pvr2_config {
    pvr2_config_empty = 0,
    pvr2_config_mpeg = 1,
    pvr2_config_vbi = 2,
    pvr2_config_pcm = 3,
    pvr2_config_rawvideo = 4
} ;
#line 344 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
enum v4l2_mbus_pixelcode {
    V4L2_MBUS_FMT_FIXED = 1,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_BE = 4097,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE = 4098,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE = 4099,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE = 4100,
    V4L2_MBUS_FMT_BGR565_2X8_BE = 4101,
    V4L2_MBUS_FMT_BGR565_2X8_LE = 4102,
    V4L2_MBUS_FMT_RGB565_2X8_BE = 4103,
    V4L2_MBUS_FMT_RGB565_2X8_LE = 4104,
    V4L2_MBUS_FMT_RGB666_1X18 = 4105,
    V4L2_MBUS_FMT_RGB888_1X24 = 4106,
    V4L2_MBUS_FMT_RGB888_2X12_BE = 4107,
    V4L2_MBUS_FMT_RGB888_2X12_LE = 4108,
    V4L2_MBUS_FMT_ARGB8888_1X32 = 4109,
    V4L2_MBUS_FMT_Y8_1X8 = 8193,
    V4L2_MBUS_FMT_UV8_1X8 = 8213,
    V4L2_MBUS_FMT_UYVY8_1_5X8 = 8194,
    V4L2_MBUS_FMT_VYUY8_1_5X8 = 8195,
    V4L2_MBUS_FMT_YUYV8_1_5X8 = 8196,
    V4L2_MBUS_FMT_YVYU8_1_5X8 = 8197,
    V4L2_MBUS_FMT_UYVY8_2X8 = 8198,
    V4L2_MBUS_FMT_VYUY8_2X8 = 8199,
    V4L2_MBUS_FMT_YUYV8_2X8 = 8200,
    V4L2_MBUS_FMT_YVYU8_2X8 = 8201,
    V4L2_MBUS_FMT_Y10_1X10 = 8202,
    V4L2_MBUS_FMT_UYVY10_2X10 = 8216,
    V4L2_MBUS_FMT_VYUY10_2X10 = 8217,
    V4L2_MBUS_FMT_YUYV10_2X10 = 8203,
    V4L2_MBUS_FMT_YVYU10_2X10 = 8204,
    V4L2_MBUS_FMT_Y12_1X12 = 8211,
    V4L2_MBUS_FMT_UYVY8_1X16 = 8207,
    V4L2_MBUS_FMT_VYUY8_1X16 = 8208,
    V4L2_MBUS_FMT_YUYV8_1X16 = 8209,
    V4L2_MBUS_FMT_YVYU8_1X16 = 8210,
    V4L2_MBUS_FMT_YDYUYDYV8_1X16 = 8212,
    V4L2_MBUS_FMT_UYVY10_1X20 = 8218,
    V4L2_MBUS_FMT_VYUY10_1X20 = 8219,
    V4L2_MBUS_FMT_YUYV10_1X20 = 8205,
    V4L2_MBUS_FMT_YVYU10_1X20 = 8206,
    V4L2_MBUS_FMT_YUV10_1X30 = 8214,
    V4L2_MBUS_FMT_AYUV8_1X32 = 8215,
    V4L2_MBUS_FMT_UYVY12_2X12 = 8220,
    V4L2_MBUS_FMT_VYUY12_2X12 = 8221,
    V4L2_MBUS_FMT_YUYV12_2X12 = 8222,
    V4L2_MBUS_FMT_YVYU12_2X12 = 8223,
    V4L2_MBUS_FMT_UYVY12_1X24 = 8224,
    V4L2_MBUS_FMT_VYUY12_1X24 = 8225,
    V4L2_MBUS_FMT_YUYV12_1X24 = 8226,
    V4L2_MBUS_FMT_YVYU12_1X24 = 8227,
    V4L2_MBUS_FMT_SBGGR8_1X8 = 12289,
    V4L2_MBUS_FMT_SGBRG8_1X8 = 12307,
    V4L2_MBUS_FMT_SGRBG8_1X8 = 12290,
    V4L2_MBUS_FMT_SRGGB8_1X8 = 12308,
    V4L2_MBUS_FMT_SBGGR10_ALAW8_1X8 = 12309,
    V4L2_MBUS_FMT_SGBRG10_ALAW8_1X8 = 12310,
    V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8 = 12311,
    V4L2_MBUS_FMT_SRGGB10_ALAW8_1X8 = 12312,
    V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8 = 12299,
    V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8 = 12300,
    V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8 = 12297,
    V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8 = 12301,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE = 12291,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE = 12292,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE = 12293,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE = 12294,
    V4L2_MBUS_FMT_SBGGR10_1X10 = 12295,
    V4L2_MBUS_FMT_SGBRG10_1X10 = 12302,
    V4L2_MBUS_FMT_SGRBG10_1X10 = 12298,
    V4L2_MBUS_FMT_SRGGB10_1X10 = 12303,
    V4L2_MBUS_FMT_SBGGR12_1X12 = 12296,
    V4L2_MBUS_FMT_SGBRG12_1X12 = 12304,
    V4L2_MBUS_FMT_SGRBG12_1X12 = 12305,
    V4L2_MBUS_FMT_SRGGB12_1X12 = 12306,
    V4L2_MBUS_FMT_JPEG_1X8 = 16385,
    V4L2_MBUS_FMT_S5C_UYVY_JPEG_1X8 = 20481,
    V4L2_MBUS_FMT_AHSV8888_1X32 = 24577
} ;
#line 177 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u32 reserved[7U] ;
};
#line 151 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 53 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_crop {
   __u32 which ;
   __u32 pad ;
   struct v4l2_rect rect ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 reserved[9U] ;
};
#line 79 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 reserved[9U] ;
};
#line 96 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 107 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 126 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 150
struct v4l2_subdev;
#line 151
struct v4l2_async_notifier;
#line 152
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 159 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_238 {
   struct device_node  const  *node ;
};
#line 159 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_239 {
   char const   *name ;
};
#line 159 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_240 {
   int adapter_id ;
   unsigned short address ;
};
#line 159 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_241 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 159 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_237 {
   struct __anonstruct_of_238 of ;
   struct __anonstruct_device_name_239 device_name ;
   struct __anonstruct_i2c_240 i2c ;
   struct __anonstruct_custom_241 custom ;
};
#line 159 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_237 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 101 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 162 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 206
struct v4l2_m2m_ctx;
#line 206 "include/media/v4l2-common.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 109 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 110
struct tuner_setup;
#line 111
struct v4l2_mbus_frame_desc;
#line 112 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 61 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 117 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 178 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 205 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 232 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 253 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 265 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*enum_framesizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*enum_frameintervals)(struct v4l2_subdev * , struct v4l2_frmivalenum * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*enum_mbus_fmt)(struct v4l2_subdev * , unsigned int  , enum v4l2_mbus_pixelcode * ) ;
   int (*enum_mbus_fsizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*g_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*try_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*s_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 359 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 399 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 414
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 418 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 466 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 485 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 529 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 541 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 562
struct regulator_bulk_data;
#line 563 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 584 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 622 "include/media/v4l2-subdev.h"
struct __anonstruct_pad_242 {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 622 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct __anonstruct_pad_242 *pad ;
};
#line 691 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct mutex ioctl_lock ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 130 "include/media/v4l2-device.h"
struct v4l2_ctrl_helper;
#line 131
struct v4l2_ctrl;
#line 133 "include/media/v4l2-device.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_34363_243 {
   u32 step ;
   u32 menu_skip_mask ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_34367_244 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_cur_245 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
union __anonunion_ldv_34378_246 {
   s32 val ;
   s64 val64 ;
   char *string ;
};
#line 58 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s32 minimum ;
   s32 maximum ;
   s32 default_value ;
   union __anonunion_ldv_34363_243 ldv_34363 ;
   union __anonunion_ldv_34367_244 ldv_34367 ;
   unsigned long flags ;
   union __anonunion_cur_245 cur ;
   union __anonunion_ldv_34378_246 ldv_34378 ;
   void *priv ;
};
#line 156 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 173 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 688
enum cx2341x_port {
    CX2341X_PORT_MEMORY = 0,
    CX2341X_PORT_STREAMING = 1,
    CX2341X_PORT_SERIAL = 2
} ;
#line 700 "include/media/v4l2-ctrls.h"
struct cx2341x_mpeg_params {
   u32 capabilities ;
   enum cx2341x_port port ;
   u16 width ;
   u16 height ;
   u16 is_50hz ;
   enum v4l2_mpeg_stream_type stream_type ;
   enum v4l2_mpeg_stream_vbi_fmt stream_vbi_fmt ;
   u16 stream_insert_nav_packets ;
   enum v4l2_mpeg_audio_sampling_freq audio_sampling_freq ;
   enum v4l2_mpeg_audio_encoding audio_encoding ;
   enum v4l2_mpeg_audio_l2_bitrate audio_l2_bitrate ;
   enum v4l2_mpeg_audio_ac3_bitrate audio_ac3_bitrate ;
   enum v4l2_mpeg_audio_mode audio_mode ;
   enum v4l2_mpeg_audio_mode_extension audio_mode_extension ;
   enum v4l2_mpeg_audio_emphasis audio_emphasis ;
   enum v4l2_mpeg_audio_crc audio_crc ;
   u32 audio_properties ;
   u16 audio_mute ;
   enum v4l2_mpeg_video_encoding video_encoding ;
   enum v4l2_mpeg_video_aspect video_aspect ;
   u16 video_b_frames ;
   u16 video_gop_size ;
   u16 video_gop_closure ;
   enum v4l2_mpeg_video_bitrate_mode video_bitrate_mode ;
   u32 video_bitrate ;
   u32 video_bitrate_peak ;
   u16 video_temporal_decimation ;
   u16 video_mute ;
   u32 video_mute_yuv ;
   enum v4l2_mpeg_cx2341x_video_spatial_filter_mode video_spatial_filter_mode ;
   u16 video_spatial_filter ;
   enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type video_luma_spatial_filter_type ;
   enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type video_chroma_spatial_filter_type ;
   enum v4l2_mpeg_cx2341x_video_temporal_filter_mode video_temporal_filter_mode ;
   u16 video_temporal_filter ;
   enum v4l2_mpeg_cx2341x_video_median_filter_type video_median_filter_type ;
   u16 video_luma_median_filter_top ;
   u16 video_luma_median_filter_bottom ;
   u16 video_chroma_median_filter_top ;
   u16 video_chroma_median_filter_bottom ;
};
#line 198 "include/media/cx2341x.h"
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 36 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_type fe_type_t;
#line 37
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 71 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_caps fe_caps_t;
#line 72 "./include/uapi/linux/dvb/frontend.h"
struct dvb_frontend_info {
   char name[128U] ;
   fe_type_t type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   fe_caps_t caps ;
};
#line 87 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6U] ;
   __u8 msg_len ;
};
#line 97 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_slave_reply {
   __u8 msg[4U] ;
   __u8 msg_len ;
   int timeout ;
};
#line 104
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 110 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_voltage fe_sec_voltage_t;
#line 111
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 116 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_tone_mode fe_sec_tone_mode_t;
#line 117
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 122 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_sec_mini_cmd fe_sec_mini_cmd_t;
#line 123
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 145 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_status fe_status_t;
#line 146
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 151 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_spectral_inversion fe_spectral_inversion_t;
#line 152
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 168 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_code_rate fe_code_rate_t;
#line 169
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 186 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_modulation fe_modulation_t;
#line 187
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 198 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_transmit_mode fe_transmit_mode_t;
#line 199
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 224 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_guard_interval fe_guard_interval_t;
#line 225
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 233 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_hierarchy fe_hierarchy_t;
#line 234
enum fe_interleaving {
    INTERLEAVING_NONE = 0,
    INTERLEAVING_AUTO = 1,
    INTERLEAVING_240 = 2,
    INTERLEAVING_720 = 3
} ;
#line 241
enum fe_pilot {
    PILOT_ON = 0,
    PILOT_OFF = 1,
    PILOT_AUTO = 2
} ;
#line 384 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_pilot fe_pilot_t;
#line 385
enum fe_rolloff {
    ROLLOFF_35 = 0,
    ROLLOFF_20 = 1,
    ROLLOFF_25 = 2,
    ROLLOFF_AUTO = 3
} ;
#line 391 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_rolloff fe_rolloff_t;
#line 392
enum fe_delivery_system {
    SYS_UNDEFINED = 0,
    SYS_DVBC_ANNEX_A = 1,
    SYS_DVBC_ANNEX_B = 2,
    SYS_DVBT = 3,
    SYS_DSS = 4,
    SYS_DVBS = 5,
    SYS_DVBS2 = 6,
    SYS_DVBH = 7,
    SYS_ISDBT = 8,
    SYS_ISDBS = 9,
    SYS_ISDBC = 10,
    SYS_ATSC = 11,
    SYS_ATSCMH = 12,
    SYS_DTMB = 13,
    SYS_CMMB = 14,
    SYS_DAB = 15,
    SYS_DVBT2 = 16,
    SYS_TURBO = 17,
    SYS_DVBC_ANNEX_C = 18
} ;
#line 413 "./include/uapi/linux/dvb/frontend.h"
typedef enum fe_delivery_system fe_delivery_system_t;
#line 471 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_ldv_34961_255 {
   __u64 uvalue ;
   __s64 svalue ;
};
#line 471 "./include/uapi/linux/dvb/frontend.h"
struct dtv_stats {
   __u8 scale ;
   union __anonunion_ldv_34961_255 ldv_34961 ;
};
#line 522 "./include/uapi/linux/dvb/frontend.h"
struct dtv_fe_stats {
   __u8 len ;
   struct dtv_stats stat[4U] ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
struct __anonstruct_buffer_257 {
   __u8 data[32U] ;
   __u32 len ;
   __u32 reserved1[3U] ;
   void *reserved2 ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_u_256 {
   __u32 data ;
   struct dtv_fe_stats st ;
   struct __anonstruct_buffer_257 buffer ;
};
#line 530 "./include/uapi/linux/dvb/frontend.h"
struct dtv_property {
   __u32 cmd ;
   __u32 reserved[3U] ;
   union __anonunion_u_256 u ;
   int result ;
};
#line 554
struct dvb_frontend;
#line 555
struct dvb_device;
#line 555 "./include/uapi/linux/dvb/frontend.h"
struct dvb_adapter {
   int num ;
   struct list_head list_head ;
   struct list_head device_list ;
   char const   *name ;
   u8 proposed_mac[6U] ;
   void *priv ;
   struct device *device ;
   struct module *module ;
   int mfe_shared ;
   struct dvb_device *mfe_dvbdev ;
   struct mutex mfe_lock ;
};
#line 75 "drivers/media/dvb-core/dvbdev.h"
struct dvb_device {
   struct list_head list_head ;
   struct file_operations  const  *fops ;
   struct dvb_adapter *adapter ;
   int type ;
   int minor ;
   u32 id ;
   int readers ;
   int writers ;
   int users ;
   wait_queue_head_t wait_queue ;
   int (*kernel_ioctl)(struct file * , unsigned int  , void * ) ;
   void *priv ;
};
#line 122 "drivers/media/dvb-core/dvbdev.h"
struct dvb_frontend_tune_settings {
   int min_delay_ms ;
   int step_size ;
   int max_drift ;
};
#line 56 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_info {
   char name[128U] ;
   u32 frequency_min ;
   u32 frequency_max ;
   u32 frequency_step ;
   u32 bandwidth_min ;
   u32 bandwidth_max ;
   u32 bandwidth_step ;
};
#line 70 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_parameters {
   unsigned int frequency ;
   unsigned int mode ;
   unsigned int audmode ;
   u64 std ;
};
#line 113
enum tuner_param {
    DVBFE_TUNER_FREQUENCY = 1,
    DVBFE_TUNER_TUNERSTEP = 2,
    DVBFE_TUNER_IFFREQ = 4,
    DVBFE_TUNER_BANDWIDTH = 8,
    DVBFE_TUNER_REFCLOCK = 16,
    DVBFE_TUNER_IQSENSE = 32,
    DVBFE_TUNER_DUMMY = (-0x7FFFFFFF-1)
} ;
#line 123
enum dvbfe_algo {
    DVBFE_ALGO_HW = 1,
    DVBFE_ALGO_SW = 2,
    DVBFE_ALGO_CUSTOM = 4,
    DVBFE_ALGO_RECOVERY = (-0x7FFFFFFF-1)
} ;
#line 130 "drivers/media/dvb-core/dvb_frontend.h"
struct tuner_state {
   u32 frequency ;
   u32 tunerstep ;
   u32 ifreq ;
   u32 bandwidth ;
   u32 iqsense ;
   u32 refclock ;
};
#line 164
enum dvbfe_search {
    DVBFE_ALGO_SEARCH_SUCCESS = 1,
    DVBFE_ALGO_SEARCH_ASLEEP = 2,
    DVBFE_ALGO_SEARCH_FAILED = 4,
    DVBFE_ALGO_SEARCH_INVALID = 8,
    DVBFE_ALGO_SEARCH_AGAIN = 16,
    DVBFE_ALGO_SEARCH_ERROR = (-0x7FFFFFFF-1)
} ;
#line 173 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_ops {
   struct dvb_tuner_info info ;
   int (*release)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*set_params)(struct dvb_frontend * ) ;
   int (*set_analog_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*calc_regs)(struct dvb_frontend * , u8 * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
   int (*get_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_bandwidth)(struct dvb_frontend * , u32 * ) ;
   int (*get_if_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_status)(struct dvb_frontend * , u32 * ) ;
   int (*get_rf_strength)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   int (*set_frequency)(struct dvb_frontend * , u32  ) ;
   int (*set_bandwidth)(struct dvb_frontend * , u32  ) ;
   int (*set_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
   int (*get_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
};
#line 237 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_info {
   char *name ;
};
#line 241 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_ops {
   struct analog_demod_info info ;
   void (*set_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*has_signal)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   void (*tuner_status)(struct dvb_frontend * ) ;
   void (*standby)(struct dvb_frontend * ) ;
   void (*release)(struct dvb_frontend * ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
};
#line 258
struct dtv_frontend_properties;
#line 259 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend_ops {
   struct dvb_frontend_info info ;
   u8 delsys[8U] ;
   void (*release)(struct dvb_frontend * ) ;
   void (*release_sec)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*write)(struct dvb_frontend * , u8 const   * , int  ) ;
   int (*tune)(struct dvb_frontend * , bool  , unsigned int  , unsigned int * , fe_status_t * ) ;
   enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend * ) ;
   int (*set_frontend)(struct dvb_frontend * ) ;
   int (*get_tune_settings)(struct dvb_frontend * , struct dvb_frontend_tune_settings * ) ;
   int (*get_frontend)(struct dvb_frontend * ) ;
   int (*read_status)(struct dvb_frontend * , fe_status_t * ) ;
   int (*read_ber)(struct dvb_frontend * , u32 * ) ;
   int (*read_signal_strength)(struct dvb_frontend * , u16 * ) ;
   int (*read_snr)(struct dvb_frontend * , u16 * ) ;
   int (*read_ucblocks)(struct dvb_frontend * , u32 * ) ;
   int (*diseqc_reset_overload)(struct dvb_frontend * ) ;
   int (*diseqc_send_master_cmd)(struct dvb_frontend * , struct dvb_diseqc_master_cmd * ) ;
   int (*diseqc_recv_slave_reply)(struct dvb_frontend * , struct dvb_diseqc_slave_reply * ) ;
   int (*diseqc_send_burst)(struct dvb_frontend * , fe_sec_mini_cmd_t  ) ;
   int (*set_tone)(struct dvb_frontend * , fe_sec_tone_mode_t  ) ;
   int (*set_voltage)(struct dvb_frontend * , fe_sec_voltage_t  ) ;
   int (*enable_high_lnb_voltage)(struct dvb_frontend * , long  ) ;
   int (*dishnetwork_send_legacy_command)(struct dvb_frontend * , unsigned long  ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*ts_bus_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_lna)(struct dvb_frontend * ) ;
   enum dvbfe_search (*search)(struct dvb_frontend * ) ;
   struct dvb_tuner_ops tuner_ops ;
   struct analog_demod_ops analog_ops ;
   int (*set_property)(struct dvb_frontend * , struct dtv_property * ) ;
   int (*get_property)(struct dvb_frontend * , struct dtv_property * ) ;
};
#line 319 "drivers/media/dvb-core/dvb_frontend.h"
struct __anonstruct_layer_258 {
   u8 segment_count ;
   fe_code_rate_t fec ;
   fe_modulation_t modulation ;
   u8 interleaving ;
};
#line 319 "drivers/media/dvb-core/dvb_frontend.h"
struct dtv_frontend_properties {
   u32 state ;
   u32 frequency ;
   fe_modulation_t modulation ;
   fe_sec_voltage_t voltage ;
   fe_sec_tone_mode_t sectone ;
   fe_spectral_inversion_t inversion ;
   fe_code_rate_t fec_inner ;
   fe_transmit_mode_t transmission_mode ;
   u32 bandwidth_hz ;
   fe_guard_interval_t guard_interval ;
   fe_hierarchy_t hierarchy ;
   u32 symbol_rate ;
   fe_code_rate_t code_rate_HP ;
   fe_code_rate_t code_rate_LP ;
   fe_pilot_t pilot ;
   fe_rolloff_t rolloff ;
   fe_delivery_system_t delivery_system ;
   enum fe_interleaving interleaving ;
   u8 isdbt_partial_reception ;
   u8 isdbt_sb_mode ;
   u8 isdbt_sb_subchannel ;
   u32 isdbt_sb_segment_idx ;
   u32 isdbt_sb_segment_count ;
   u8 isdbt_layer_enabled ;
   struct __anonstruct_layer_258 layer[3U] ;
   u32 stream_id ;
   u8 atscmh_fic_ver ;
   u8 atscmh_parade_id ;
   u8 atscmh_nog ;
   u8 atscmh_tnog ;
   u8 atscmh_sgn ;
   u8 atscmh_prc ;
   u8 atscmh_rs_frame_mode ;
   u8 atscmh_rs_frame_ensemble ;
   u8 atscmh_rs_code_mode_pri ;
   u8 atscmh_rs_code_mode_sec ;
   u8 atscmh_sccc_block_mode ;
   u8 atscmh_sccc_code_mode_a ;
   u8 atscmh_sccc_code_mode_b ;
   u8 atscmh_sccc_code_mode_c ;
   u8 atscmh_sccc_code_mode_d ;
   u32 lna ;
   struct dtv_fe_stats strength ;
   struct dtv_fe_stats cnr ;
   struct dtv_fe_stats pre_bit_error ;
   struct dtv_fe_stats pre_bit_count ;
   struct dtv_fe_stats post_bit_error ;
   struct dtv_fe_stats post_bit_count ;
   struct dtv_fe_stats block_error ;
   struct dtv_fe_stats block_count ;
};
#line 407 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend {
   struct dvb_frontend_ops ops ;
   struct dvb_adapter *dvb ;
   void *demodulator_priv ;
   void *tuner_priv ;
   void *frontend_priv ;
   void *sec_priv ;
   void *analog_demod_priv ;
   struct dtv_frontend_properties dtv_property_cache ;
   int (*callback)(void * , int  , int  , int  ) ;
   int id ;
};
#line 44 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_output_t;
#line 51 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_input_t;
#line 52
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 81 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 82 "./include/uapi/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16U] ;
   __u8 mask[16U] ;
   __u8 mode[16U] ;
};
#line 95 "./include/uapi/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 96 "./include/uapi/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 105 "./include/uapi/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 119 "./include/uapi/linux/dvb/dmx.h"
struct dmx_caps {
   __u32 caps ;
   int num_decoders ;
};
#line 134 "./include/uapi/linux/dvb/dmx.h"
typedef int dmx_source_t;
#line 141
enum dmx_success {
    DMX_OK = 0,
    DMX_LENGTH_ERROR = 1,
    DMX_OVERRUN_ERROR = 2,
    DMX_CRC_ERROR = 3,
    DMX_FRAME_ERROR = 4,
    DMX_FIFO_ERROR = 5,
    DMX_MISSED_ERROR = 6
} ;
#line 151
struct dmx_demux;
#line 151 "./include/uapi/linux/dvb/dmx.h"
struct dmx_ts_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int (*set)(struct dmx_ts_feed * , u16  , int  , enum dmx_ts_pes  , size_t  , struct timespec  ) ;
   int (*start_filtering)(struct dmx_ts_feed * ) ;
   int (*stop_filtering)(struct dmx_ts_feed * ) ;
};
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed;
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_filter {
   u8 filter_value[18U] ;
   u8 filter_mask[18U] ;
   u8 filter_mode[18U] ;
   struct dmx_section_feed *parent ;
   void *priv ;
};
#line 111 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int check_crc ;
   u32 crc_val ;
   u8 *secbuf ;
   u8 secbuf_base[4284U] ;
   u16 secbufp ;
   u16 seclen ;
   u16 tsfeedp ;
   int (*set)(struct dmx_section_feed * , u16  , size_t  , int  ) ;
   int (*allocate_filter)(struct dmx_section_feed * , struct dmx_section_filter ** ) ;
   int (*release_filter)(struct dmx_section_feed * , struct dmx_section_filter * ) ;
   int (*start_filtering)(struct dmx_section_feed * ) ;
   int (*stop_filtering)(struct dmx_section_feed * ) ;
};
#line 148
enum dmx_frontend_source {
    DMX_MEMORY_FE = 0,
    DMX_FRONTEND_0 = 1,
    DMX_FRONTEND_1 = 2,
    DMX_FRONTEND_2 = 3,
    DMX_FRONTEND_3 = 4,
    DMX_STREAM_0 = 5,
    DMX_STREAM_1 = 6,
    DMX_STREAM_2 = 7,
    DMX_STREAM_3 = 8
} ;
#line 160 "drivers/media/dvb-core/demux.h"
struct dmx_frontend {
   struct list_head connectivity_list ;
   enum dmx_frontend_source source ;
};
#line 176 "drivers/media/dvb-core/demux.h"
struct dmx_demux {
   u32 capabilities ;
   struct dmx_frontend *frontend ;
   void *priv ;
   int (*open)(struct dmx_demux * ) ;
   int (*close)(struct dmx_demux * ) ;
   int (*write)(struct dmx_demux * , char const   * , size_t  ) ;
   int (*allocate_ts_feed)(struct dmx_demux * , struct dmx_ts_feed ** , int (*)(u8 const   * ,
                                                                                size_t  ,
                                                                                u8 const   * ,
                                                                                size_t  ,
                                                                                struct dmx_ts_feed * ,
                                                                                enum dmx_success  ) ) ;
   int (*release_ts_feed)(struct dmx_demux * , struct dmx_ts_feed * ) ;
   int (*allocate_section_feed)(struct dmx_demux * , struct dmx_section_feed ** ,
                                int (*)(u8 const   * , size_t  , u8 const   * , size_t  ,
                                        struct dmx_section_filter * , enum dmx_success  ) ) ;
   int (*release_section_feed)(struct dmx_demux * , struct dmx_section_feed * ) ;
   int (*add_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*remove_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   struct list_head *(*get_frontends)(struct dmx_demux * ) ;
   int (*connect_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*disconnect_frontend)(struct dmx_demux * ) ;
   int (*get_pes_pids)(struct dmx_demux * , u16 * ) ;
   int (*get_caps)(struct dmx_demux * , struct dmx_caps * ) ;
   int (*set_source)(struct dmx_demux * , dmx_source_t const   * ) ;
   int (*get_stc)(struct dmx_demux * , unsigned int  , u64 * , unsigned int * ) ;
};
#line 239
struct dvb_demux_feed;
#line 239 "drivers/media/dvb-core/demux.h"
struct dvb_demux_filter {
   struct dmx_section_filter filter ;
   u8 maskandmode[18U] ;
   u8 maskandnotmode[18U] ;
   int doneq ;
   struct dvb_demux_filter *next ;
   struct dvb_demux_feed *feed ;
   int index ;
   int state ;
   int type ;
   u16 hw_handle ;
   struct timer_list timer ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_feed_259 {
   struct dmx_ts_feed ts ;
   struct dmx_section_feed sec ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_cb_260 {
   int (*ts)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_ts_feed * ,
             enum dmx_success  ) ;
   int (*sec)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_section_filter * ,
              enum dmx_success  ) ;
};
#line 64
struct dvb_demux;
#line 64 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux_feed {
   union __anonunion_feed_259 feed ;
   union __anonunion_cb_260 cb ;
   struct dvb_demux *demux ;
   void *priv ;
   int type ;
   int state ;
   u16 pid ;
   u8 *buffer ;
   int buffer_size ;
   struct timespec timeout ;
   struct dvb_demux_filter *filter ;
   int ts_type ;
   enum dmx_ts_pes pes_type ;
   int cc ;
   int pusi_seen ;
   u16 peslen ;
   struct list_head list_head ;
   unsigned int index ;
};
#line 100 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux {
   struct dmx_demux dmx ;
   void *priv ;
   int filternum ;
   int feednum ;
   int (*start_feed)(struct dvb_demux_feed * ) ;
   int (*stop_feed)(struct dvb_demux_feed * ) ;
   int (*write_to_decoder)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   u32 (*check_crc32)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   void (*memcopy)(struct dvb_demux_feed * , u8 * , u8 const   * , size_t  ) ;
   int users ;
   struct dvb_demux_filter *filter ;
   struct dvb_demux_feed *feed ;
   struct list_head frontend_list ;
   struct dvb_demux_feed *pesfilter[20U] ;
   u16 pids[20U] ;
   int playing ;
   int recording ;
   struct list_head feed_list ;
   u8 tsbuf[204U] ;
   int tsbufp ;
   struct mutex mutex ;
   spinlock_t lock ;
   uint8_t *cnt_storage ;
   struct timespec speed_last_time ;
   uint32_t speed_pkts_cnt ;
};
#line 84 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 48 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 53
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 59 "include/linux/pm_qos.h"
union __anonunion_data_261 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 59 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_261 data ;
   struct device *dev ;
};
#line 68
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 74 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 88 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 93 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 220 "include/linux/pm_qos.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion_ldv_35854_262 {
   struct iovec  const  *iov ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_35854_262 ldv_35854 ;
   unsigned long nr_segs ;
};
#line 38 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1153 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_264 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_264 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_265 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_265 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_266 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_266 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_267 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_267 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_268 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_268 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_269 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_269 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_270 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_270 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_271 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_271 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_272 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_273 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_272 ifr_ifrn ;
   union __anonunion_ifr_ifru_273 ifr_ifru ;
};
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 166 "include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 18 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 137 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 147 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 360 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 361 "include/linux/skbuff.h"
struct __anonstruct_ldv_39313_292 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 361 "include/linux/skbuff.h"
union __anonunion_ldv_39314_291 {
   u64 v64 ;
   struct __anonstruct_ldv_39313_292 ldv_39313 ;
};
#line 361 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_ldv_39314_291 ldv_39314 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_39333_293 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 414
struct sec_path;
#line 414 "include/linux/skbuff.h"
struct __anonstruct_ldv_39349_295 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_39350_294 {
   __wsum csum ;
   struct __anonstruct_ldv_39349_295 ldv_39349 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_39389_296 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_39395_297 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 414 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_39333_293 ldv_39333 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_39350_294 ldv_39350 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_39389_296 ldv_39389 ;
   __u32 secmark ;
   union __anonunion_ldv_39395_297 ldv_39395 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 641
struct dst_entry;
#line 3161 "include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 187 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 211 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 259 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 288 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 305 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 441 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 469 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 568 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 600 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 642 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 675 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 691 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 711 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 722 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 741 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 767 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 933 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 941 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1017 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[103U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 102
struct neighbour;
#line 102 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 35 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 35
struct rt6_info;
#line 35
struct rt6_statistics;
#line 35
struct fib6_table;
#line 35 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 80 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 86 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
#line 21
struct sctp_mib;
#line 22 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 324 "include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 24 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 29 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 43 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 48 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 53 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 64 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 72
struct ip_conntrack_stat;
#line 72
struct nf_ct_event_notifier;
#line 72
struct nf_exp_event_notifier;
#line 72 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 111
struct nft_af_info;
#line 112 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 499 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 17 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 74
struct net_generic;
#line 75
struct netns_ipvs;
#line 76 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 400 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 205 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 919 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 3161 "include/linux/security.h"
struct mnt_namespace;
#line 3162
struct ipc_namespace;
#line 3163 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 180 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 547 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 28 "include/linux/if_link.h"
struct netpoll_info;
#line 29
struct phy_device;
#line 30
struct wireless_dev;
#line 61 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 106 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 125 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 186
struct neigh_parms;
#line 207 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 212 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 241 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 292 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 336
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 384 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 385 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 522
struct Qdisc;
#line 522 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 591 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 603 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 615 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 666 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 689 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 724 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 740 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 753 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_adj_list_309 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_310 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187
struct iw_handler_def;
#line 1187
struct iw_public_data;
#line 1187
struct forwarding_accel_ops;
#line 1187
struct vlan_info;
#line 1187
struct tipc_bearer;
#line 1187
struct in_device;
#line 1187
struct dn_dev;
#line 1187
struct inet6_dev;
#line 1187
struct cpu_rmap;
#line 1187
struct pcpu_lstats;
#line 1187
struct pcpu_sw_netstats;
#line 1187
struct pcpu_dstats;
#line 1187
struct pcpu_vstats;
#line 1187 "include/linux/netdevice.h"
union __anonunion_ldv_47168_311 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1187
struct garp_port;
#line 1187
struct mrp_port;
#line 1187
struct rtnl_link_ops;
#line 1187 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_309 adj_list ;
   struct __anonstruct_all_adj_list_310 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_47168_311 ldv_47168 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1806 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 93 "include/linux/rtnetlink.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[28U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20
struct ip_mc_list;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 386 "include/linux/etherdevice.h"
struct dvb_net {
   struct dvb_device *dvbdev ;
   struct net_device *device[10U] ;
   int state[10U] ;
   unsigned char exit : 1 ;
   struct dmx_demux *demux ;
   struct mutex ioctl_mutex ;
};
#line 48 "drivers/media/dvb-core/dvb_net.h"
struct dvb_ringbuffer {
   u8 *data ;
   ssize_t size ;
   ssize_t pread ;
   ssize_t pwrite ;
   int error ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
};
#line 184 "drivers/media/dvb-core/dvb_ringbuffer.h"
enum dmxdev_type {
    DMXDEV_TYPE_NONE = 0,
    DMXDEV_TYPE_SEC = 1,
    DMXDEV_TYPE_PES = 2
} ;
#line 190
enum dmxdev_state {
    DMXDEV_STATE_FREE = 0,
    DMXDEV_STATE_ALLOCATED = 1,
    DMXDEV_STATE_SET = 2,
    DMXDEV_STATE_GO = 3,
    DMXDEV_STATE_DONE = 4,
    DMXDEV_STATE_TIMEDOUT = 5
} ;
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_filter_315 {
   struct dmx_section_filter *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_feed_316 {
   struct list_head ts ;
   struct dmx_section_feed *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_params_317 {
   struct dmx_sct_filter_params sec ;
   struct dmx_pes_filter_params pes ;
};
#line 63
struct dmxdev;
#line 63 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev_filter {
   union __anonunion_filter_315 filter ;
   union __anonunion_feed_316 feed ;
   union __anonunion_params_317 params ;
   enum dmxdev_type type ;
   enum dmxdev_state state ;
   struct dmxdev *dev ;
   struct dvb_ringbuffer buffer ;
   struct mutex mutex ;
   struct timer_list timer ;
   int todo ;
   u8 secheader[3U] ;
};
#line 92 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev {
   struct dvb_device *dvbdev ;
   struct dvb_device *dvr_dvbdev ;
   struct dmxdev_filter *filter ;
   struct dmx_demux *demux ;
   int filternum ;
   int capabilities ;
   unsigned char exit : 1 ;
   struct dmx_frontend *dvr_orig_fe ;
   struct dvb_ringbuffer dvr_buffer ;
   struct mutex mutex ;
   spinlock_t lock ;
};
#line 118
struct pvr2_context;
#line 119
struct pvr2_channel;
#line 120
struct pvr2_context_stream;
#line 122 "drivers/media/dvb-core/dmxdev.h"
struct pvr2_context_stream {
   struct pvr2_channel *user ;
   struct pvr2_stream *stream ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_context {
   struct pvr2_channel *mc_first ;
   struct pvr2_channel *mc_last ;
   struct pvr2_context *exist_next ;
   struct pvr2_context *exist_prev ;
   struct pvr2_context *notify_next ;
   struct pvr2_context *notify_prev ;
   struct pvr2_hdw *hdw ;
   struct pvr2_context_stream video_stream ;
   struct mutex mutex ;
   int notify_flag ;
   int initialized_flag ;
   int disconnect_flag ;
   void (*setup_func)(struct pvr2_context * ) ;
};
#line 56 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_channel {
   struct pvr2_context *mc_head ;
   struct pvr2_channel *mc_next ;
   struct pvr2_channel *mc_prev ;
   struct pvr2_context_stream *stream ;
   struct pvr2_hdw *hdw ;
   unsigned int input_mask ;
   void (*check_func)(struct pvr2_channel * ) ;
};
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_dvb_adapter {
   struct pvr2_channel channel ;
   struct dvb_adapter dvb_adap ;
   struct dmxdev dmxdev ;
   struct dvb_demux demux ;
   struct dvb_net dvb_net ;
   struct dvb_frontend *fe ;
   int feedcount ;
   int max_feed_count ;
   struct task_struct *thread ;
   struct mutex lock ;
   unsigned char stream_run : 1 ;
   wait_queue_head_t buffer_wait_data ;
   char *buffer_storage[32U] ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_dvb_props {
   int (*frontend_attach)(struct pvr2_dvb_adapter * ) ;
   int (*tuner_attach)(struct pvr2_dvb_adapter * ) ;
};
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_device_client_desc {
   unsigned char module_id ;
   unsigned char *i2c_address_list ;
};
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_device_client_table {
   struct pvr2_device_client_desc  const  *lst ;
   unsigned char cnt ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_string_table {
   char const   **lst ;
   unsigned int cnt ;
};
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_device_desc {
   char const   *description ;
   char const   *shortname ;
   struct pvr2_string_table client_modules ;
   struct pvr2_device_client_table client_table ;
   struct pvr2_string_table fx2_firmware ;
   struct pvr2_dvb_props  const  *dvb_props ;
   v4l2_std_id default_std_mask ;
   int default_tuner_type ;
   unsigned char signal_routing_scheme ;
   unsigned char led_scheme ;
   unsigned char digital_control_scheme ;
   unsigned char flag_skip_cx23416_firmware : 1 ;
   unsigned char flag_digital_requires_cx23416 : 1 ;
   unsigned char flag_has_hauppauge_rom : 1 ;
   unsigned char flag_no_powerup : 1 ;
   unsigned char flag_has_cx25840 : 1 ;
   unsigned char flag_has_wm8775 : 1 ;
   unsigned char ir_scheme : 3 ;
   unsigned char flag_has_fmradio : 1 ;
   unsigned char flag_has_analogtuner : 1 ;
   unsigned char flag_has_composite : 1 ;
   unsigned char flag_has_svideo : 1 ;
   unsigned char flag_fx2_16kb : 1 ;
   unsigned char flag_is_experimental : 1 ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_int_319 {
   long min_value ;
   long max_value ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_enum_320 {
   unsigned int count ;
   char const   * const  *value_names ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_bitmask_321 {
   unsigned int valid_bits ;
   char const   **bit_names ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
union __anonunion_def_318 {
   struct __anonstruct_type_int_319 type_int ;
   struct __anonstruct_type_enum_320 type_enum ;
   struct __anonstruct_type_bitmask_321 type_bitmask ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctl_info {
   char const   *name ;
   char const   *desc ;
   int (*get_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_def_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_min_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_max_value)(struct pvr2_ctrl * , int * ) ;
   int (*set_value)(struct pvr2_ctrl * , int  , int  ) ;
   int (*check_value)(struct pvr2_ctrl * , int  ) ;
   int (*val_to_sym)(struct pvr2_ctrl * , int  , int  , char * , unsigned int  , unsigned int * ) ;
   int (*sym_to_val)(struct pvr2_ctrl * , char const   * , unsigned int  , int * ,
                     int * ) ;
   int (*is_dirty)(struct pvr2_ctrl * ) ;
   void (*clear_dirty)(struct pvr2_ctrl * ) ;
   unsigned int (*get_v4lflags)(struct pvr2_ctrl * ) ;
   enum pvr2_ctl_type type ;
   int v4l_id ;
   int internal_id ;
   int skip_init ;
   int default_value ;
   union __anonunion_def_318 def ;
};
#line 127 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctld_info {
   struct pvr2_ctl_info info ;
   char desc[32U] ;
};
#line 135 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctrl {
   struct pvr2_ctl_info  const  *info ;
   struct pvr2_hdw *hdw ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
typedef int (*pvr2_i2c_func)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  );
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_hdw {
   struct usb_device *usb_dev ;
   struct usb_interface *usb_intf ;
   struct v4l2_device v4l2_dev ;
   struct pvr2_device_desc  const  *hdw_desc ;
   struct workqueue_struct *workqueue ;
   struct work_struct workpoll ;
   struct pvr2_stream *vid_stream ;
   struct mutex big_lock_mutex ;
   int big_lock_held ;
   char name[32U] ;
   char identifier[32U] ;
   struct i2c_adapter i2c_adap ;
   struct i2c_algorithm i2c_algo ;
   pvr2_i2c_func i2c_func[128U] ;
   int i2c_cx25840_hack_state ;
   int i2c_linked ;
   unsigned int ir_scheme_active ;
   struct IR_i2c_init_data ir_init_data ;
   unsigned int freqTable[500U] ;
   unsigned int freqProgSlot ;
   struct mutex ctl_lock_mutex ;
   int ctl_lock_held ;
   struct urb *ctl_write_urb ;
   struct urb *ctl_read_urb ;
   unsigned char *ctl_write_buffer ;
   unsigned char *ctl_read_buffer ;
   int ctl_write_pend_flag ;
   int ctl_read_pend_flag ;
   int ctl_timeout_flag ;
   struct completion ctl_done ;
   unsigned char cmd_buffer[64U] ;
   int cmd_debug_state ;
   unsigned char cmd_debug_code ;
   unsigned int cmd_debug_write_len ;
   unsigned int cmd_debug_read_len ;
   int state_pathway_ok ;
   int state_encoder_ok ;
   int state_encoder_run ;
   int state_encoder_config ;
   int state_encoder_waitok ;
   int state_encoder_runok ;
   int state_decoder_run ;
   int state_decoder_ready ;
   int state_usbstream_run ;
   int state_decoder_quiescent ;
   int state_pipeline_config ;
   int state_pipeline_req ;
   int state_pipeline_pause ;
   int state_pipeline_idle ;
   unsigned int master_state ;
   int led_on ;
   int state_stale ;
   void (*state_func)(void * ) ;
   void *state_data ;
   struct timer_list quiescent_timer ;
   struct timer_list decoder_stabilization_timer ;
   struct timer_list encoder_wait_timer ;
   struct timer_list encoder_run_timer ;
   wait_queue_head_t state_wait_data ;
   int force_dirty ;
   int flag_ok ;
   int flag_modulefail ;
   int flag_disconnected ;
   int flag_init_ok ;
   int fw1_state ;
   int pathway_state ;
   int flag_decoder_missed ;
   int flag_tripped ;
   unsigned int decoder_client_id ;
   char *fw_buffer ;
   unsigned int fw_size ;
   int fw_cpu_flag ;
   unsigned int tuner_type ;
   int tuner_updated ;
   unsigned int freqValTelevision ;
   unsigned int freqValRadio ;
   unsigned int freqSlotTelevision ;
   unsigned int freqSlotRadio ;
   unsigned int freqSelector ;
   int freqDirty ;
   struct v4l2_tuner tuner_signal_info ;
   int tuner_signal_stale ;
   struct v4l2_cropcap cropcap_info ;
   int cropcap_stale ;
   v4l2_std_id std_mask_eeprom ;
   v4l2_std_id std_mask_avail ;
   v4l2_std_id std_mask_cur ;
   int std_enum_cur ;
   int std_dirty ;
   struct pvr2_ctl_info std_info_enum ;
   struct pvr2_ctl_info std_info_avail ;
   struct pvr2_ctl_info std_info_cur ;
   struct pvr2_ctl_info std_info_detect ;
   char const   *std_mask_ptrs[32U] ;
   char std_mask_names[32U][16U] ;
   int unit_number ;
   unsigned long serial_number ;
   char bus_info[32U] ;
   int v4l_minor_number_video ;
   int v4l_minor_number_vbi ;
   int v4l_minor_number_radio ;
   unsigned int input_avail_mask ;
   unsigned int input_allowed_mask ;
   int eeprom_addr ;
   enum pvr2_config active_stream_type ;
   enum pvr2_config desired_stream_type ;
   struct cx2341x_mpeg_params enc_cur_state ;
   struct cx2341x_mpeg_params enc_ctl_state ;
   int enc_stale ;
   int enc_unsafe_stale ;
   int enc_cur_valid ;
   int brightness_val ;
   int brightness_dirty ;
   int contrast_val ;
   int contrast_dirty ;
   int saturation_val ;
   int saturation_dirty ;
   int hue_val ;
   int hue_dirty ;
   int volume_val ;
   int volume_dirty ;
   int balance_val ;
   int balance_dirty ;
   int bass_val ;
   int bass_dirty ;
   int treble_val ;
   int treble_dirty ;
   int mute_val ;
   int mute_dirty ;
   int cropl_val ;
   int cropl_dirty ;
   int cropt_val ;
   int cropt_dirty ;
   int cropw_val ;
   int cropw_dirty ;
   int croph_val ;
   int croph_dirty ;
   int input_val ;
   int input_dirty ;
   int audiomode_val ;
   int audiomode_dirty ;
   int res_hor_val ;
   int res_hor_dirty ;
   int res_ver_val ;
   int res_ver_dirty ;
   int srate_val ;
   int srate_dirty ;
   struct pvr2_ctld_info *mpeg_ctrl_info ;
   struct pvr2_ctrl *controls ;
   unsigned int control_cnt ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct routing_scheme {
   int const   *def ;
   unsigned int cnt ;
};
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c"
struct __va_list_tag;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c"
typedef struct __va_list_tag __va_list_tag;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 259 "include/linux/timer.h"
enum hrtimer_restart;
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_format;
#line 51
struct v4l2_audio;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 273 "include/linux/pm_runtime.h"
struct usb_driver;
#line 798 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 986 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 996 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 242 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 749 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 771 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 1428 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1681 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u16 bytesperline ;
   __u16 reserved[7U] ;
};
#line 1698 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 reserved[11U] ;
};
#line 1720 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u8 reserved[28U] ;
};
#line 1729 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_216 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1729 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_216 fmt ;
};
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct pvr2_v4l2;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-v4l2.h"
struct pvr2_sysfs;
#line 29
struct pvr2_sysfs_class;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 319 "include/linux/timer.h"
enum hrtimer_restart;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 211 "include/media/v4l2-common.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream_stats {
   unsigned int buffers_in_queue ;
   unsigned int buffers_in_idle ;
   unsigned int buffers_in_ready ;
   unsigned int buffers_processed ;
   unsigned int buffers_failed ;
   unsigned int bytes_processed ;
};
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
enum pvr2_v4l_type {
    pvr2_v4l_type_video = 0,
    pvr2_v4l_type_vbi = 1,
    pvr2_v4l_type_radio = 2
} ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef void (*pvr2_subdev_update_func)(struct pvr2_hdw * , struct v4l2_subdev * );
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_mpeg_ids {
   char const   *strid ;
   int id ;
};
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_fx2cmd_descdef {
   unsigned char id ;
   unsigned char *desc ;
};
#line 1930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_std_hack {
   v4l2_std_id pat ;
   v4l2_std_id msk ;
   v4l2_std_id std ;
};
#line 4231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef void (*led_method_func)(struct pvr2_hdw * , int  );
#line 4735 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int (*state_eval_func)(struct pvr2_hdw * );
#line 5723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 5734 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 5745 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 5756 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 5767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 5778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 5789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 5800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 5827 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 5838 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___12;
#line 5849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 5860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 5871 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___15;
#line 5882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___16;
#line 5893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___17;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 721 "include/linux/pm.h"
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
#line 1869 "include/linux/usb.h"
struct pvr2_ioread;
#line 562 "./include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 221 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 291 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 525 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 539 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 568 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 593 "include/uapi/linux/videodev2.h"
union __anonunion_m_203 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 593 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_203 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 625 "include/uapi/linux/videodev2.h"
union __anonunion_m_204 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 625 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_204 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 678 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 737 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct v4l2_pix_format fmt ;
};
#line 821 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1168 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1184 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1407 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1450 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1465 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1484 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1492 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_210 {
   __u32 data[8U] ;
};
#line 1492 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27913_209 {
   struct __anonstruct_raw_210 raw ;
};
#line 1492 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_27913_209 ldv_27913 ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_212 {
   __u64 pts ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_213 {
   __s32 speed ;
   __u32 format ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_214 {
   __u32 data[16U] ;
};
#line 1511 "include/uapi/linux/videodev2.h"
union __anonunion_ldv_27928_211 {
   struct __anonstruct_stop_212 stop ;
   struct __anonstruct_start_213 start ;
   struct __anonstruct_raw_214 raw ;
};
#line 1511 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion_ldv_27928_211 ldv_27928 ;
};
#line 1869 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 1880 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 130 "include/media/v4l2-device.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_g_priority)(struct file * , void * , enum v4l2_priority * ) ;
   int (*vidioc_s_priority)(struct file * , void * , enum v4l2_priority  ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 329 "include/media/v4l2-ioctl.h"
struct pvr2_v4l2_dev;
#line 330
struct pvr2_v4l2_fh;
#line 331 "include/media/v4l2-ioctl.h"
struct pvr2_v4l2_dev {
   struct video_device devbase ;
   struct pvr2_v4l2 *v4lp ;
   struct pvr2_context_stream *stream ;
   enum pvr2_config config ;
   int v4l_type ;
   enum pvr2_v4l_type minor_type ;
};
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
struct pvr2_v4l2_fh {
   struct pvr2_channel channel ;
   struct pvr2_v4l2_dev *pdi ;
   enum v4l2_priority prio ;
   struct pvr2_ioread *rhp ;
   struct file *file ;
   struct pvr2_v4l2 *vhead ;
   struct pvr2_v4l2_fh *vnext ;
   struct pvr2_v4l2_fh *vprev ;
   wait_queue_head_t wait_data ;
   int fw_mode_flag ;
   unsigned char *input_map ;
   unsigned int input_cnt ;
};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
struct pvr2_v4l2 {
   struct pvr2_channel channel ;
   struct pvr2_v4l2_fh *vfirst ;
   struct pvr2_v4l2_fh *vlast ;
   struct v4l2_prio_state prio ;
   struct pvr2_v4l2_dev *dev_video ;
   struct pvr2_v4l2_dev *dev_radio ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 849 "include/uapi/linux/videodev2.h"
struct v4l2_standard {
   __u32 index ;
   v4l2_std_id id ;
   __u8 name[24U] ;
   struct v4l2_fract frameperiod ;
   __u32 framelines ;
   __u32 reserved[4U] ;
};
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct std_name {
   char const   *name ;
   v4l2_std_id id ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
enum lg_chip_t {
    UNDEFINED = 0,
    LGDT3302 = 1,
    LGDT3303 = 2
} ;
#line 31 "drivers/media/dvb-frontends/lgdt330x.h"
typedef enum lg_chip_t lg_chip_type;
#line 32 "drivers/media/dvb-frontends/lgdt330x.h"
struct lgdt330x_config {
   u8 demod_address ;
   lg_chip_type demod_chip ;
   int serial_mpeg ;
   int (*pll_rf_set)(struct dvb_frontend * , int  ) ;
   int (*set_ts_params)(struct dvb_frontend * , int  ) ;
   int clock_polarity_flip ;
};
#line 57 "drivers/media/dvb-frontends/lgdt330x.h"
struct s5h1409_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 gpio ;
   u16 qam_if ;
   u8 inversion ;
   u8 status_mode ;
   u16 mpeg_timing ;
   u8 hvr1600_opt ;
};
#line 72 "drivers/media/dvb-frontends/s5h1409.h"
struct s5h1411_config {
   u8 output_mode ;
   u8 gpio ;
   u16 mpeg_timing ;
   u16 qam_if ;
   u16 vsb_if ;
   u8 inversion ;
   u8 status_mode ;
};
#line 73 "include/linux/firmware.h"
struct tda10048_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 fwbulkwritelen ;
   u8 inversion ;
   u16 dtv6_if_freq_khz ;
   u16 dtv7_if_freq_khz ;
   u16 dtv8_if_freq_khz ;
   u16 clk_freq_khz ;
   u8 disable_gate_access ;
   bool no_firmware ;
   bool set_pll ;
   u8 pll_m ;
   u8 pll_p ;
   u8 pll_n ;
};
#line 78 "drivers/media/dvb-frontends/tda10048.h"
struct tda18271_std_map_item {
   u16 if_freq ;
   unsigned char agc_mode : 2 ;
   unsigned char std : 3 ;
   unsigned char fm_rfn : 1 ;
   unsigned char if_lvl : 3 ;
   unsigned char rfagc_top : 7 ;
};
#line 41 "drivers/media/tuners/tda18271.h"
struct tda18271_std_map {
   struct tda18271_std_map_item fm_radio ;
   struct tda18271_std_map_item atv_b ;
   struct tda18271_std_map_item atv_dk ;
   struct tda18271_std_map_item atv_gh ;
   struct tda18271_std_map_item atv_i ;
   struct tda18271_std_map_item atv_l ;
   struct tda18271_std_map_item atv_lc ;
   struct tda18271_std_map_item atv_mn ;
   struct tda18271_std_map_item atsc_6 ;
   struct tda18271_std_map_item dvbt_6 ;
   struct tda18271_std_map_item dvbt_7 ;
   struct tda18271_std_map_item dvbt_8 ;
   struct tda18271_std_map_item qam_6 ;
   struct tda18271_std_map_item qam_7 ;
   struct tda18271_std_map_item qam_8 ;
};
#line 59
enum tda18271_role {
    TDA18271_MASTER = 0,
    TDA18271_SLAVE = 1
} ;
#line 64
enum tda18271_i2c_gate {
    TDA18271_GATE_AUTO = 0,
    TDA18271_GATE_ANALOG = 1,
    TDA18271_GATE_DIGITAL = 2
} ;
#line 70
enum tda18271_output_options {
    TDA18271_OUTPUT_LT_XT_ON = 0,
    TDA18271_OUTPUT_LT_OFF = 1,
    TDA18271_OUTPUT_XT_OFF = 2
} ;
#line 76
enum tda18271_small_i2c {
    TDA18271_39_BYTE_CHUNK_INIT = 0,
    TDA18271_16_BYTE_CHUNK_INIT = 16,
    TDA18271_08_BYTE_CHUNK_INIT = 8,
    TDA18271_03_BYTE_CHUNK_INIT = 3
} ;
#line 83 "drivers/media/tuners/tda18271.h"
struct tda18271_config {
   struct tda18271_std_map *std_map ;
   enum tda18271_role role ;
   enum tda18271_i2c_gate gate ;
   enum tda18271_output_options output_opt ;
   enum tda18271_small_i2c small_i2c ;
   unsigned char rf_cal_on_startup : 1 ;
   unsigned char delay_cal : 1 ;
   unsigned int config ;
};
#line 126
enum tda8290_lna {
    TDA8290_LNA_OFF = 0,
    TDA8290_LNA_GP0_HIGH_ON = 1,
    TDA8290_LNA_GP0_HIGH_OFF = 2,
    TDA8290_LNA_ON_BRIDGE = 3
} ;
#line 133 "drivers/media/tuners/tda18271.h"
struct tda829x_config {
   enum tda8290_lna lna_cfg ;
   unsigned char probe_tuner : 1 ;
   unsigned char no_i2c_gate : 1 ;
   struct tda18271_std_map *tda18271_std_map ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
enum pvr2_buffer_state {
    pvr2_buffer_state_none = 0,
    pvr2_buffer_state_idle = 1,
    pvr2_buffer_state_queued = 2,
    pvr2_buffer_state_ready = 3
} ;
#line 35
struct pvr2_buffer;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_stream {
   struct list_head queued_list ;
   unsigned int q_count ;
   unsigned int q_bcount ;
   struct list_head ready_list ;
   unsigned int r_count ;
   unsigned int r_bcount ;
   struct list_head idle_list ;
   unsigned int i_count ;
   unsigned int i_bcount ;
   struct pvr2_buffer **buffers ;
   unsigned int buffer_slot_count ;
   unsigned int buffer_total_count ;
   unsigned int buffer_target_count ;
   void (*callback_func)(void * ) ;
   void *callback_data ;
   struct usb_device *dev ;
   int endpoint ;
   spinlock_t list_lock ;
   struct mutex mutex ;
   unsigned int fail_count ;
   unsigned int fail_tolerance ;
   unsigned int buffers_processed ;
   unsigned int buffers_failed ;
   unsigned int bytes_processed ;
};
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_buffer {
   int id ;
   int signature ;
   enum pvr2_buffer_state state ;
   void *ptr ;
   unsigned int max_count ;
   unsigned int used_count ;
   int status ;
   struct pvr2_stream *stream ;
   struct list_head list_overhead ;
   struct urb *purb ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 2112 "include/linux/mm.h"
struct pvr2_ioread {
   struct pvr2_stream *stream ;
   char *buffer_storage[32U] ;
   char *sync_key_ptr ;
   unsigned int sync_key_len ;
   unsigned int sync_buf_offs ;
   unsigned int sync_state ;
   unsigned int sync_trashed_count ;
   int enabled ;
   int spigot_open ;
   int stream_running ;
   struct pvr2_buffer *c_buf ;
   char *c_data_ptr ;
   unsigned int c_data_len ;
   unsigned int c_data_offs ;
   struct mutex mutex ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
enum cx25840_video_input {
    CX25840_COMPOSITE1 = 1,
    CX25840_COMPOSITE2 = 2,
    CX25840_COMPOSITE3 = 3,
    CX25840_COMPOSITE4 = 4,
    CX25840_COMPOSITE5 = 5,
    CX25840_COMPOSITE6 = 6,
    CX25840_COMPOSITE7 = 7,
    CX25840_COMPOSITE8 = 8,
    CX25840_SVIDEO_LUMA1 = 16,
    CX25840_SVIDEO_LUMA2 = 32,
    CX25840_SVIDEO_LUMA3 = 48,
    CX25840_SVIDEO_LUMA4 = 64,
    CX25840_SVIDEO_LUMA5 = 80,
    CX25840_SVIDEO_LUMA6 = 96,
    CX25840_SVIDEO_LUMA7 = 112,
    CX25840_SVIDEO_LUMA8 = 128,
    CX25840_SVIDEO_CHROMA4 = 1024,
    CX25840_SVIDEO_CHROMA5 = 1280,
    CX25840_SVIDEO_CHROMA6 = 1536,
    CX25840_SVIDEO_CHROMA7 = 1792,
    CX25840_SVIDEO_CHROMA8 = 2048,
    CX25840_SVIDEO1 = 1296,
    CX25840_SVIDEO2 = 1568,
    CX25840_SVIDEO3 = 1840,
    CX25840_SVIDEO4 = 2112,
    CX25840_VIN1_CH1 = 2147483648U,
    CX25840_VIN2_CH1 = 2147483649U,
    CX25840_VIN3_CH1 = 2147483650U,
    CX25840_VIN4_CH1 = 2147483651U,
    CX25840_VIN5_CH1 = 2147483652U,
    CX25840_VIN6_CH1 = 2147483653U,
    CX25840_VIN7_CH1 = 2147483654U,
    CX25840_VIN8_CH1 = 2147483655U,
    CX25840_VIN4_CH2 = 2147483648U,
    CX25840_VIN5_CH2 = 2147483664U,
    CX25840_VIN6_CH2 = 2147483680U,
    CX25840_NONE_CH2 = 2147483696U,
    CX25840_VIN7_CH3 = 2147483648U,
    CX25840_VIN8_CH3 = 2147483712U,
    CX25840_NONE0_CH3 = 2147483776U,
    CX25840_NONE1_CH3 = 2147483840U,
    CX25840_SVIDEO_ON = 2147483904U,
    CX25840_COMPONENT_ON = 2147484160U,
    CX25840_DIF_ON = 2147484672U
} ;
#line 70
enum cx25840_audio_input {
    CX25840_AUDIO_SERIAL = 0,
    CX25840_AUDIO4 = 4,
    CX25840_AUDIO5 = 5,
    CX25840_AUDIO6 = 6,
    CX25840_AUDIO7 = 7,
    CX25840_AUDIO8 = 8
} ;
#line 187 "include/media/cx25840.h"
struct routing_scheme_item {
   int vid ;
   int aud ;
};
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct routing_scheme___0 {
   struct routing_scheme_item  const  *def ;
   unsigned int cnt ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
struct pvr2_sysfs_debugifc;
#line 40
struct pvr2_sysfs_ctl_item;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
struct pvr2_sysfs {
   struct pvr2_channel channel ;
   struct device *class_dev ;
   struct pvr2_sysfs_debugifc *debugifc ;
   struct pvr2_sysfs_ctl_item *item_first ;
   struct pvr2_sysfs_ctl_item *item_last ;
   struct device_attribute attr_v4l_minor_number ;
   struct device_attribute attr_v4l_radio_minor_number ;
   struct device_attribute attr_unit_number ;
   struct device_attribute attr_bus_info ;
   struct device_attribute attr_hdw_name ;
   struct device_attribute attr_hdw_desc ;
   int v4l_minor_number_created_ok ;
   int v4l_radio_minor_number_created_ok ;
   int unit_number_created_ok ;
   int bus_info_created_ok ;
   int hdw_name_created_ok ;
   int hdw_desc_created_ok ;
};
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
struct pvr2_sysfs_debugifc {
   struct device_attribute attr_debugcmd ;
   struct device_attribute attr_debuginfo ;
   int debugcmd_created_ok ;
   int debuginfo_created_ok ;
};
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
struct pvr2_sysfs_ctl_item {
   struct device_attribute attr_name ;
   struct device_attribute attr_type ;
   struct device_attribute attr_min ;
   struct device_attribute attr_max ;
   struct device_attribute attr_def ;
   struct device_attribute attr_enum ;
   struct device_attribute attr_bits ;
   struct device_attribute attr_val ;
   struct device_attribute attr_custom ;
   struct pvr2_ctrl *cptr ;
   int ctl_id ;
   struct pvr2_sysfs *chptr ;
   struct pvr2_sysfs_ctl_item *item_next ;
   struct attribute *attr_gen[8U] ;
   struct attribute_group grp ;
   int created_ok ;
   char name[80U] ;
};
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
struct pvr2_sysfs_class {
   struct class class ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14126_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 55 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 139 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 175
extern void mutex_unlock(struct mutex * ) ;
#line 316 "include/linux/slab.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_timer_state_5  =    0;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_timer_state_3  =    0;
#line 32
int ldv_state_variable_14 ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_timer_state_4  =    0;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_timer_state_1  =    0;
#line 58
struct i2c_adapter *pvr2_i2c_algo_template_group0 ;
#line 62
void ldv_initialize_i2c_algorithm_14(void) ;
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 67 "include/linux/i2c.h"
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int  ) ;
#line 302
extern struct i2c_client *i2c_new_device(struct i2c_adapter * , struct i2c_board_info  const  * ) ;
#line 454 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 456
  dev_set_drvdata(& dev->dev, data);
#line 457
  return;
}
}
#line 505
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 506
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.h"
void pvr2_i2c_core_init(struct pvr2_hdw *hdw ) ;
#line 26
void pvr2_i2c_core_done(struct pvr2_hdw *hdw ) ;
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
int pvr2_send_request(struct pvr2_hdw *hdw , void *write_data , unsigned int write_len ,
                      void *read_data , unsigned int read_len ) ;
#line 255
void pvr2_hdw_render_useless(struct pvr2_hdw *hdw ) ;
#line 756 "include/linux/skbuff.h"
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 759
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 765
extern struct sk_buff *skb_copy(struct sk_buff  const  * , gfp_t  ) ;
#line 768
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 778
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 781
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2016
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
int pvrusb2_debug ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static unsigned int i2c_scan  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int ir_mode[20U]  = 
#line 133
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int pvr2_disable_ir_video  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int pvr2_i2c_write(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *data , u16 length ) 
{ 
  int ret ;
  size_t __len ;
  void *__ret ;

  {
#line 152
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
#line 152
    length = 0U;
  } else {

  }
#line 153
  if ((unsigned int )length > 61U) {
#line 154
    if ((pvrusb2_debug & 2) != 0) {
#line 154
      printk("\016pvrusb2: Killing an I2C write to %u that is too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )length, 61U);
    } else {

    }
#line 159
    return (-524);
  } else {

  }
#line 162
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 162
  hdw->ctl_lock_held = 1;
#line 165
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 168
  hdw->cmd_buffer[0] = 8U;
#line 169
  hdw->cmd_buffer[1] = i2c_addr;
#line 170
  hdw->cmd_buffer[2] = (unsigned char )length;
#line 171
  if ((unsigned int )length != 0U) {
#line 171
    __len = (size_t )length;
#line 171
    __ret = __builtin_memcpy((void *)(& hdw->cmd_buffer) + 3U, (void const   *)data,
                             __len);
  } else {

  }
#line 174
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), (unsigned int )((int )length + 3),
                          (void *)(& hdw->cmd_buffer), 1U);
#line 179
  if (ret == 0) {
#line 180
    if ((unsigned int )hdw->cmd_buffer[0] != 8U) {
#line 181
      ret = -5;
#line 182
      if ((unsigned int )hdw->cmd_buffer[0] != 7U) {
#line 183
        if ((pvrusb2_debug & 131072) != 0) {
#line 183
          printk("\016pvrusb2: unexpected status from i2_write[%d]: %d\n", (int )i2c_addr,
                 (int )hdw->cmd_buffer[0]);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 190
  hdw->ctl_lock_held = 0;
#line 190
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 192
  return (ret);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int pvr2_i2c_read(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *data , u16 dlen ,
                         u8 *res , u16 rlen ) 
{ 
  int ret ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 206
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
#line 206
    dlen = 0U;
  } else {

  }
#line 207
  if ((unsigned int )dlen > 60U) {
#line 208
    if ((pvrusb2_debug & 2) != 0) {
#line 208
      printk("\016pvrusb2: Killing an I2C read to %u that has wlen too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )dlen, 60U);
    } else {

    }
#line 213
    return (-524);
  } else {

  }
#line 215
  if ((unsigned long )res != (unsigned long )((u8 *)0U) && (unsigned int )rlen > 63U) {
#line 216
    if ((pvrusb2_debug & 2) != 0) {
#line 216
      printk("\016pvrusb2: Killing an I2C read to %u that has rlen too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )rlen, 63U);
    } else {

    }
#line 221
    return (-524);
  } else {

  }
#line 224
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 224
  hdw->ctl_lock_held = 1;
#line 227
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 230
  hdw->cmd_buffer[0] = 9U;
#line 231
  hdw->cmd_buffer[1] = (unsigned char )dlen;
#line 232
  hdw->cmd_buffer[2] = (unsigned char )rlen;
#line 234
  hdw->cmd_buffer[3] = i2c_addr;
#line 235
  if ((unsigned int )dlen != 0U) {
#line 235
    __len = (size_t )dlen;
#line 235
    __ret = __builtin_memcpy((void *)(& hdw->cmd_buffer) + 4U, (void const   *)data,
                             __len);
  } else {

  }
#line 238
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), (unsigned int )((int )dlen + 4),
                          (void *)(& hdw->cmd_buffer), (unsigned int )((int )rlen + 1));
#line 243
  if (ret == 0) {
#line 244
    if ((unsigned int )hdw->cmd_buffer[0] != 8U) {
#line 245
      ret = -5;
#line 246
      if ((unsigned int )hdw->cmd_buffer[0] != 7U) {
#line 247
        if ((pvrusb2_debug & 131072) != 0) {
#line 247
          printk("\016pvrusb2: unexpected status from i2_read[%d]: %d\n", (int )i2c_addr,
                 (int )hdw->cmd_buffer[0]);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 255
  if ((unsigned long )res != (unsigned long )((u8 *)0U) && (unsigned int )rlen != 0U) {
#line 256
    if (ret != 0) {
#line 258
      memset((void *)res, 0, (size_t )rlen);
    } else {
#line 260
      __len___0 = (size_t )rlen;
#line 260
      __ret___0 = __builtin_memcpy((void *)res, (void const   *)(& hdw->cmd_buffer) + 1U,
                                   __len___0);
    }
  } else {

  }
#line 264
  hdw->ctl_lock_held = 0;
#line 264
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 266
  return (ret);
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int pvr2_i2c_basic_op(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                             u8 *rdata , u16 rlen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 278
  if ((unsigned long )rdata == (unsigned long )((u8 *)0U)) {
#line 278
    rlen = 0U;
  } else {

  }
#line 279
  if ((unsigned long )wdata == (unsigned long )((u8 *)0U)) {
#line 279
    wlen = 0U;
  } else {

  }
#line 280
  if ((unsigned int )rlen != 0U || (unsigned int )wlen == 0U) {
#line 281
    tmp = pvr2_i2c_read(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 281
    return (tmp);
  } else {
#line 283
    tmp___0 = pvr2_i2c_write(hdw, (int )i2c_addr, wdata, (int )wlen);
#line 283
    return (tmp___0);
  }
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int i2c_24xxx_ir(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                        u8 *rdata , u16 rlen ) 
{ 
  u8 dat[4U] ;
  unsigned int stat ;
  int tmp ;
  u16 val ;

  {
#line 300
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 302
    return (0);
  } else {

  }
#line 306
  if ((unsigned int )wlen != 0U || (unsigned int )rlen == 0U) {
#line 306
    return (-5);
  } else {

  }
#line 308
  if ((unsigned int )rlen <= 2U) {
#line 316
    if ((unsigned int )rlen != 0U) {
#line 316
      *rdata = 0U;
    } else {

    }
#line 317
    if ((unsigned int )rlen > 1U) {
#line 317
      *(rdata + 1UL) = 0U;
    } else {

    }
#line 318
    return (0);
  } else {

  }
#line 322
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 322
  hdw->ctl_lock_held = 1;
#line 323
  hdw->cmd_buffer[0] = 236U;
#line 324
  tmp = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                          4U);
#line 324
  stat = (unsigned int )tmp;
#line 327
  dat[0] = hdw->cmd_buffer[0];
#line 328
  dat[1] = hdw->cmd_buffer[1];
#line 329
  dat[2] = hdw->cmd_buffer[2];
#line 330
  dat[3] = hdw->cmd_buffer[3];
#line 331
  hdw->ctl_lock_held = 0;
#line 331
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 334
  if (stat != 0U) {
#line 334
    return ((int )stat);
  } else {

  }
#line 338
  *(rdata + 2UL) = 193U;
#line 339
  if ((unsigned int )dat[0] != 1U) {
#line 341
    *rdata = 0U;
#line 342
    *(rdata + 1UL) = 0U;
  } else {
#line 347
    val = (u16 )dat[1];
#line 348
    val = (int )val << 8U;
#line 349
    val = (int )((u16 )dat[2]) | (int )val;
#line 350
    val = (u16 )((int )val >> 1);
#line 351
    val = (unsigned int )val & 65532U;
#line 352
    val = (u16 )((unsigned int )val | 32768U);
#line 353
    *rdata = (u8 )((int )val >> 8);
#line 354
    *(rdata + 1UL) = (u8 )val;
  }
#line 357
  return (0);
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int i2c_hack_wm8775(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                           u8 *rdata , u16 rlen ) 
{ 
  int tmp ;

  {
#line 367
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 369
    return (0);
  } else {

  }
#line 371
  tmp = pvr2_i2c_basic_op(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 371
  return (tmp);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int i2c_black_hole(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                          u8 *rdata , u16 rlen ) 
{ 


  {
#line 380
  return (-5);
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int i2c_hack_cx25840(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                            u8 *rdata , u16 rlen ) 
{ 
  int ret ;
  unsigned int subaddr ;
  u8 wbuf[2U] ;
  int state ;
  int tmp ;

  {
#line 396
  state = hdw->i2c_cx25840_hack_state;
#line 398
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 402
    return (0);
  } else {

  }
#line 405
  if (state == 3) {
#line 406
    tmp = pvr2_i2c_basic_op(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 406
    return (tmp);
  } else {

  }
#line 417
  if ((unsigned int )wlen == 0U) {
#line 418
    switch (state) {
    case 1: 
#line 419
    subaddr = 256U;
#line 419
    goto ldv_49862;
    case 2: 
#line 420
    subaddr = 257U;
#line 420
    goto ldv_49862;
    default: ;
#line 421
    goto fail;
    }
    ldv_49862: ;
  } else
#line 423
  if ((unsigned int )wlen == 2U) {
#line 424
    subaddr = (unsigned int )(((int )*wdata << 8) | (int )*(wdata + 1UL));
#line 425
    switch (subaddr) {
    case 256U: 
#line 426
    state = 1;
#line 426
    goto ldv_49867;
    case 257U: 
#line 427
    state = 2;
#line 427
    goto ldv_49867;
    default: ;
#line 428
    goto fail;
    }
    ldv_49867: ;
  } else {
#line 431
    goto fail;
  }
#line 433
  if ((unsigned int )rlen == 0U) {
#line 433
    goto success;
  } else {

  }
#line 434
  state = 0;
#line 435
  if ((unsigned int )rlen != 1U) {
#line 435
    goto fail;
  } else {

  }
#line 439
  wbuf[0] = (u8 )(subaddr >> 8);
#line 440
  wbuf[1] = (u8 )subaddr;
#line 441
  ret = pvr2_i2c_basic_op(hdw, (int )i2c_addr, (u8 *)(& wbuf), 2, rdata, (int )rlen);
#line 443
  if ((ret != 0 || (unsigned int )*rdata == 4U) || (unsigned int )*rdata == 10U) {
#line 444
    if ((pvrusb2_debug & 2) != 0) {
#line 444
      printk("\016pvrusb2: WARNING: Detected a wedged cx25840 chip; the device will not work.\n");
    } else {

    }
#line 447
    if ((pvrusb2_debug & 2) != 0) {
#line 447
      printk("\016pvrusb2: WARNING: Try power cycling the pvrusb2 device.\n");
    } else {

    }
#line 449
    if ((pvrusb2_debug & 2) != 0) {
#line 449
      printk("\016pvrusb2: WARNING: Disabling further access to the device to prevent other foul-ups.\n");
    } else {

    }
#line 453
    hdw->i2c_func[68] = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ))0;
#line 454
    pvr2_hdw_render_useless(hdw);
#line 455
    goto fail;
  } else {

  }
#line 459
  if ((pvrusb2_debug & 65536) != 0) {
#line 459
    printk("\016pvrusb2: cx25840 appears to be OK.\n");
  } else {

  }
#line 460
  state = 3;
  success: 
#line 463
  hdw->i2c_cx25840_hack_state = state;
#line 464
  return (0);
  fail: 
#line 467
  hdw->i2c_cx25840_hack_state = state;
#line 468
  return (-5);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int pvr2_i2c_xfer(struct i2c_adapter *i2c_adap , struct i2c_msg *msgs , int num ) 
{ 
  int ret ;
  int (*funcp)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ) ;
  struct pvr2_hdw *hdw ;
  u16 tcnt ;
  u16 bcnt ;
  u16 offs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u16 tcnt___0 ;
  u16 bcnt___0 ;
  u16 wcnt ;
  u16 offs___0 ;
  int tmp___2 ;
  unsigned int idx ;
  unsigned int offs___1 ;
  unsigned int cnt ;

  {
#line 477
  ret = -524;
#line 478
  funcp = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ))0;
#line 479
  hdw = (struct pvr2_hdw *)i2c_adap->algo_data;
#line 481
  if (num == 0) {
#line 482
    ret = -22;
#line 483
    goto done;
  } else {

  }
#line 485
  if ((unsigned int )msgs->addr <= 127U) {
#line 486
    funcp = hdw->i2c_func[(int )msgs->addr];
  } else {

  }
#line 488
  if ((unsigned long )funcp == (unsigned long )((int (*)(struct pvr2_hdw * , u8  ,
                                                         u8 * , u16  , u8 * , u16  ))0)) {
#line 489
    ret = -5;
#line 490
    goto done;
  } else {

  }
#line 493
  if (num == 1) {
#line 494
    if ((int )msgs->flags & 1) {
#line 497
      if ((unsigned int )msgs->len == 0U) {
#line 499
        tmp = (*funcp)(hdw, (int )((u8 )msgs->addr), (u8 *)0U, 0, (u8 *)0U, 0);
#line 499
        if (tmp != 0) {
#line 500
          ret = -5;
#line 501
          goto done;
        } else {

        }
#line 503
        ret = 1;
#line 504
        goto done;
      } else {

      }
#line 509
      tcnt = msgs->len;
#line 510
      offs = 0U;
#line 511
      goto ldv_49884;
      ldv_49883: 
#line 512
      bcnt = tcnt;
#line 513
      if ((unsigned int )bcnt > 63U) {
#line 514
        bcnt = 63U;
      } else {

      }
#line 516
      tmp___0 = (*funcp)(hdw, (int )((u8 )msgs->addr), (u8 *)0U, 0, msgs->buf + (unsigned long )offs,
                         (int )bcnt);
#line 516
      if (tmp___0 != 0) {
#line 518
        ret = -5;
#line 519
        goto done;
      } else {

      }
#line 521
      offs = (int )offs + (int )bcnt;
#line 522
      tcnt = (int )tcnt - (int )bcnt;
      ldv_49884: ;
#line 511
      if ((unsigned int )tcnt != 0U) {
#line 513
        goto ldv_49883;
      } else {

      }
#line 524
      ret = 1;
#line 525
      goto done;
    } else {
#line 528
      ret = 1;
#line 529
      tmp___1 = (*funcp)(hdw, (int )((u8 )msgs->addr), msgs->buf, (int )msgs->len,
                         (u8 *)0U, 0);
#line 529
      if (tmp___1 != 0) {
#line 531
        ret = -5;
      } else {

      }
#line 533
      goto done;
    }
  } else
#line 535
  if (num == 2) {
#line 536
    if ((int )msgs->addr != (int )(msgs + 1UL)->addr) {
#line 537
      if ((pvrusb2_debug & 131072) != 0) {
#line 537
        printk("\016pvrusb2: i2c refusing 2 phase transfer with conflicting target addresses\n");
      } else {

      }
#line 539
      ret = -524;
#line 540
      goto done;
    } else {

    }
#line 542
    if (((int )msgs->flags & 1) == 0 && (int )(msgs + 1UL)->flags & 1) {
#line 549
      tcnt___0 = (msgs + 1UL)->len;
#line 550
      wcnt = msgs->len;
#line 551
      offs___0 = 0U;
#line 552
      goto ldv_49891;
      ldv_49890: 
#line 553
      bcnt___0 = tcnt___0;
#line 554
      if ((unsigned int )bcnt___0 > 63U) {
#line 555
        bcnt___0 = 63U;
      } else {

      }
#line 557
      tmp___2 = (*funcp)(hdw, (int )((u8 )msgs->addr), msgs->buf, (int )wcnt, (msgs + 1UL)->buf + (unsigned long )offs___0,
                         (int )bcnt___0);
#line 557
      if (tmp___2 != 0) {
#line 560
        ret = -5;
#line 561
        goto done;
      } else {

      }
#line 563
      offs___0 = (int )offs___0 + (int )bcnt___0;
#line 564
      tcnt___0 = (int )tcnt___0 - (int )bcnt___0;
#line 565
      wcnt = 0U;
      ldv_49891: ;
#line 552
      if ((unsigned int )tcnt___0 != 0U || (unsigned int )wcnt != 0U) {
#line 554
        goto ldv_49890;
      } else {

      }
#line 567
      ret = 2;
#line 568
      goto done;
    } else
#line 570
    if ((pvrusb2_debug & 131072) != 0) {
#line 570
      printk("\016pvrusb2: i2c refusing complex transfer read0=%d read1=%d\n", (int )msgs->flags & 1,
             (int )(msgs + 1UL)->flags & 1);
    } else {

    }
  } else
#line 576
  if ((pvrusb2_debug & 131072) != 0) {
#line 576
    printk("\016pvrusb2: i2c refusing %d phase transfer\n", num);
  } else {

  }
  done: ;
#line 580
  if ((pvrusb2_debug & 1048576) != 0) {
#line 582
    idx = 0U;
#line 582
    goto ldv_49900;
    ldv_49899: 
#line 583
    cnt = (unsigned int )(msgs + (unsigned long )idx)->len;
#line 584
    printk("\016pvrusb2 i2c xfer %u/%u: addr=0x%x len=%d %s", idx + 1U, num, (int )(msgs + (unsigned long )idx)->addr,
           cnt, (int )(msgs + (unsigned long )idx)->flags & 1 ? (char *)"read" : (char *)"write");
#line 592
    if (ret > 0 || ((int )(msgs + (unsigned long )idx)->flags & 1) == 0) {
#line 593
      if (cnt > 8U) {
#line 593
        cnt = 8U;
      } else {

      }
#line 594
      printk(" [");
#line 595
      offs___1 = 0U;
#line 595
      goto ldv_49897;
      ldv_49896: ;
#line 596
      if (offs___1 != 0U) {
#line 596
        printk(" ");
      } else {

      }
#line 597
      printk("%02x", (int )*((msgs + (unsigned long )idx)->buf + (unsigned long )offs___1));
#line 595
      offs___1 = offs___1 + 1U;
      ldv_49897: ;
#line 595
      if ((8U < cnt ? 8U : cnt) > offs___1) {
#line 597
        goto ldv_49896;
      } else {

      }

#line 599
      if (offs___1 < cnt) {
#line 599
        printk(" ...");
      } else {

      }
#line 600
      printk("]");
    } else {

    }
#line 602
    if (idx + 1U == (unsigned int )num) {
#line 603
      printk(" result=%d", ret);
    } else {

    }
#line 605
    printk("\n");
#line 582
    idx = idx + 1U;
    ldv_49900: ;
#line 582
    if ((unsigned int )num > idx) {
#line 584
      goto ldv_49899;
    } else {

    }

#line 607
    if (num == 0) {
#line 608
      printk("\016pvrusb2 i2c xfer null transfer result=%d\n", ret);
    } else {

    }
  } else {

  }
#line 613
  return (ret);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static u32 pvr2_i2c_functionality(struct i2c_adapter *adap ) 
{ 


  {
#line 618
  return (251592713U);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static struct i2c_algorithm pvr2_i2c_algo_template  =    {& pvr2_i2c_xfer, 0, & pvr2_i2c_functionality};
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static struct i2c_adapter pvr2_i2c_adap_template  = 
#line 626
     {& __this_module, 0U, 0, 0, {{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}, {0},
                                0, 0, 0, 0, 0, 0, 0}, 0, 0, {0, 0, {0, {0, 0}, 0,
                                                                    0, 0, 0, {{0}},
                                                                    {{{0L}, {0, 0},
                                                                      0, {0, {0, 0},
                                                                          0, 0, 0UL}},
                                                                     {{0, 0}, 0UL,
                                                                      0, 0, 0UL, 0,
                                                                      0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                                                      {0, {0, 0},
                                                                       0, 0, 0UL}},
                                                                     0, 0}, (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                                                             0, 0, {{0}, {{{{{0U}},
                                                                            0U, 0U,
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                    {0, 0}, 0, 0,
                                                                    0, {0, {0, 0},
                                                                        0, 0, 0UL}},
                                                             0, 0, 0, 0, {{0}, (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          {{{{{0U}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                          {0, 0},
                                                                          {0U, {{{{{{0U}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                                                                                {0,
                                                                                 0}}},
                                                                          0, (_Bool)0,
                                                                          (_Bool)0,
                                                                          {{0, 0},
                                                                           0UL, 0,
                                                                           0, 0UL,
                                                                           0, 0, 0,
                                                                           {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
                                                                           {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0UL}},
                                                                          0UL, {{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                          {{{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                           {0, 0}},
                                                                          {0}, {0},
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          0, 0, 0,
                                                                          0, 0UL,
                                                                          0UL, 0UL,
                                                                          0UL, 0,
                                                                          0, 0}, 0,
                                                             0, 0, 0, 0ULL, 0UL, 0,
                                                             {0, 0}, 0, 0, {0, 0},
                                                             0, {0}, 0U, 0U, {{{{{0U}},
                                                                                0U,
                                                                                0U,
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                             {0, 0}, {0, {0, 0}, {{0}}},
                                                             0, 0, 0, 0, (_Bool)0,
                                                             (_Bool)0}, 0, {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
    {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                      {0, 0}, 0, 0,
                                                                      0, {0, {0, 0},
                                                                          0, 0, 0UL}},
    {0, 0}, 0};
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static int do_i2c_probe(struct pvr2_hdw *hdw , int addr ) 
{ 
  struct i2c_msg msg[1U] ;
  int rc ;

  {
#line 637
  msg[0].addr = 0U;
#line 638
  msg[0].flags = 1U;
#line 639
  msg[0].len = 0U;
#line 640
  msg[0].buf = (__u8 *)0U;
#line 641
  msg[0].addr = (__u16 )addr;
#line 642
  rc = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 1);
#line 643
  return (rc == 1);
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static void do_i2c_scan(struct pvr2_hdw *hdw ) 
{ 
  int i ;
  int tmp ;

  {
#line 649
  printk("\016%s: i2c scan beginning\n", (char *)(& hdw->name));
#line 650
  i = 0;
#line 650
  goto ldv_49920;
  ldv_49919: 
#line 651
  tmp = do_i2c_probe(hdw, i);
#line 651
  if (tmp != 0) {
#line 652
    printk("\016%s: i2c scan: found device @ 0x%x\n", (char *)(& hdw->name), i);
  } else {

  }
#line 650
  i = i + 1;
  ldv_49920: ;
#line 650
  if (i <= 127) {
#line 652
    goto ldv_49919;
  } else {

  }
#line 656
  printk("\016%s: i2c scan done.\n", (char *)(& hdw->name));
#line 657
  return;
}
}
#line 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
static void pvr2_i2c_register_ir(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_board_info info ;
  struct IR_i2c_init_data *init_data ;

  {
#line 662
  init_data = & hdw->ir_init_data;
#line 663
  if (pvr2_disable_ir_video != 0) {
#line 664
    if (pvrusb2_debug & 1) {
#line 664
      printk("\016pvrusb2: Automatic binding of ir_video has been disabled.\n");
    } else {

    }
#line 666
    return;
  } else {

  }
#line 668
  memset((void *)(& info), 0, 64UL);
#line 669
  switch (hdw->ir_scheme_active) {
  case 1U: ;
  case 4U: 
#line 672
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 673
  init_data->internal_get_key_func = 2;
#line 674
  init_data->type = 8ULL;
#line 675
  init_data->name = (hdw->hdw_desc)->description;
#line 676
  init_data->polling_interval = 100U;
#line 678
  info.addr = 24U;
#line 679
  info.platform_data = (void *)init_data;
#line 680
  strlcpy((char *)(& info.type), "ir_video", 20UL);
#line 681
  if (pvrusb2_debug & 1) {
#line 681
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 683
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 684
  goto ldv_49929;
  case 2U: ;
  case 3U: 
#line 687
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 688
  init_data->internal_get_key_func = 5;
#line 689
  init_data->type = 8ULL;
#line 690
  init_data->name = (hdw->hdw_desc)->description;
#line 692
  info.addr = 113U;
#line 693
  info.platform_data = (void *)init_data;
#line 694
  strlcpy((char *)(& info.type), "ir_rx_z8f0811_haup", 20UL);
#line 695
  if (pvrusb2_debug & 1) {
#line 695
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 697
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 699
  info.addr = 112U;
#line 700
  info.platform_data = (void *)init_data;
#line 701
  strlcpy((char *)(& info.type), "ir_tx_z8f0811_haup", 20UL);
#line 702
  if (pvrusb2_debug & 1) {
#line 702
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 704
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 705
  goto ldv_49929;
  default: ;
#line 709
  goto ldv_49929;
  }
  ldv_49929: ;
#line 712
  return;
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void pvr2_i2c_core_init(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  int tmp ;

  {
#line 719
  idx = 0U;
#line 719
  goto ldv_49938;
  ldv_49937: 
#line 720
  hdw->i2c_func[idx] = & pvr2_i2c_basic_op;
#line 719
  idx = idx + 1U;
  ldv_49938: ;
#line 719
  if (idx <= 127U) {
#line 721
    goto ldv_49937;
  } else {

  }

#line 724
  if (ir_mode[hdw->unit_number] == 0) {
#line 725
    printk("\016%s: IR disabled\n", (char *)(& hdw->name));
#line 726
    hdw->i2c_func[24] = & i2c_black_hole;
  } else
#line 727
  if (ir_mode[hdw->unit_number] == 1) {
#line 728
    if (hdw->ir_scheme_active == 1U) {
#line 731
      hdw->i2c_func[24] = & i2c_24xxx_ir;
    } else {

    }
  } else {

  }
#line 734
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 735
    hdw->i2c_func[68] = & i2c_hack_cx25840;
  } else {

  }
#line 737
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 738
    hdw->i2c_func[27] = & i2c_hack_wm8775;
  } else {

  }
#line 742
  hdw->i2c_adap = pvr2_i2c_adap_template;
#line 743
  hdw->i2c_algo = pvr2_i2c_algo_template;
#line 744
  strlcpy((char *)(& hdw->i2c_adap.name), (char const   *)(& hdw->name), 48UL);
#line 745
  hdw->i2c_adap.dev.parent = & (hdw->usb_dev)->dev;
#line 746
  hdw->i2c_adap.algo = (struct i2c_algorithm  const  *)(& hdw->i2c_algo);
#line 747
  hdw->i2c_adap.algo_data = (void *)hdw;
#line 748
  hdw->i2c_linked = 1;
#line 749
  i2c_set_adapdata(& hdw->i2c_adap, (void *)(& hdw->v4l2_dev));
#line 750
  i2c_add_adapter(& hdw->i2c_adap);
#line 751
  if ((unsigned long )hdw->i2c_func[24] == (unsigned long )(& i2c_24xxx_ir)) {
#line 758
    tmp = do_i2c_probe(hdw, 113);
#line 758
    if (tmp != 0) {
#line 759
      if (pvrusb2_debug & 1) {
#line 759
        printk("\016pvrusb2: Device has newer IR hardware; disabling unneeded virtual IR device\n");
      } else {

      }
#line 762
      hdw->i2c_func[24] = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * ,
                                   u16  ))0;
#line 764
      hdw->ir_scheme_active = 3U;
    } else {

    }
  } else {

  }
#line 767
  if (i2c_scan != 0U) {
#line 767
    do_i2c_scan(hdw);
  } else {

  }
#line 769
  pvr2_i2c_register_ir(hdw);
#line 770
  return;
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void pvr2_i2c_core_done(struct pvr2_hdw *hdw ) 
{ 


  {
#line 774
  if (hdw->i2c_linked != 0) {
#line 775
    i2c_del_adapter(& hdw->i2c_adap);
#line 776
    hdw->i2c_linked = 0;
  } else {

  }
#line 778
  return;
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_initialize_i2c_algorithm_14(void) 
{ 
  void *tmp ;

  {
#line 792
  tmp = ldv_zalloc(1936UL);
#line 792
  pvr2_i2c_algo_template_group0 = (struct i2c_adapter *)tmp;
#line 793
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  struct i2c_msg *ldvarg62 ;
  void *tmp ;
  int ldvarg61 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 796
  tmp = ldv_zalloc(16UL);
#line 796
  ldvarg62 = (struct i2c_msg *)tmp;
#line 797
  tmp___0 = __VERIFIER_nondet_int();
#line 797
  ldvarg61 = tmp___0;
#line 799
  tmp___1 = __VERIFIER_nondet_int();
#line 799
  switch (tmp___1) {
  case 0: ;
#line 802
  if (ldv_state_variable_14 == 1) {
#line 804
    pvr2_i2c_xfer(pvr2_i2c_algo_template_group0, ldvarg62, ldvarg61);
#line 806
    ldv_state_variable_14 = 1;
  } else {

  }
#line 809
  goto ldv_49952;
  case 1: ;
#line 812
  if (ldv_state_variable_14 == 1) {
#line 814
    pvr2_i2c_functionality(pvr2_i2c_algo_template_group0);
#line 816
    ldv_state_variable_14 = 1;
  } else {

  }
#line 819
  goto ldv_49952;
  default: 
#line 820
  ldv_stop();
  }
  ldv_49952: ;
#line 824
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 955
  ldv_check_alloc_flags(flags);
#line 957
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 958
  return ((void *)0);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 999
  ldv_check_alloc_flags(flags);
#line 1001
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1001
  return (tmp);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1015
  ldv_check_alloc_flags(flags);
#line 1017
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1017
  return (tmp);
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1031
  ldv_check_alloc_flags(flags);
#line 1033
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1033
  return (tmp);
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1039
  ldv_check_alloc_flags(flags);
#line 1041
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1041
  return (tmp);
}
}
#line 1044 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1047
  ldv_check_alloc_flags(flags);
#line 1049
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1049
  return (tmp);
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1055
  ldv_check_alloc_flags(flags);
#line 1057
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1057
  return (tmp);
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1063
  ldv_check_alloc_flags(flags);
#line 1065
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1065
  return (tmp);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1071
  ldv_check_alloc_flags(flags);
#line 1073
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1073
  return (tmp);
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1079
  ldv_check_alloc_flags(flags);
#line 1081
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1081
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_58(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_66(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_74(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_68(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_64(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_72(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_73(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_69(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_70(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_71(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 26 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-audio.h"
void pvr2_msp3400_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
static int const   routing_scheme0[5U]  = {      0,      0,      2236960,      2236960, 
        2236961};
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
static struct routing_scheme  const  routing_def0  =    {(int const   *)(& routing_scheme0), 5U};
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
static struct routing_scheme  const  *routing_schemes[1U]  = {      & routing_def0};
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void pvr2_msp3400_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 152
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 154
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 157
    if ((pvrusb2_debug & 65536) != 0) {
#line 157
      printk("\016pvrusb2: subdev msp3400 v4l2 set_stereo\n");
    } else {

    }
#line 158
    sp = sid == 0U ? routing_schemes[sid] : (struct routing_scheme  const  *)0;
#line 161
    if (((unsigned long )sp != (unsigned long )((struct routing_scheme  const  *)0) && hdw->input_val >= 0) && (unsigned int )hdw->input_val < (unsigned int )sp->cnt) {
#line 164
      input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
    } else {
#line 166
      if ((pvrusb2_debug & 2) != 0) {
#line 166
        printk("\016pvrusb2: *** WARNING *** subdev msp3400 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 171
      return;
    }
#line 173
    (*(((sd->ops)->audio)->s_routing))(sd, input, 68U, 0U);
  } else {

  }
#line 175
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void *ldv_kmem_cache_alloc_58(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 308
  ldv_check_alloc_flags(flags);
#line 310
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 311
  return ((void *)0);
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
int ldv_pskb_expand_head_64(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 352
  ldv_check_alloc_flags(flags);
#line 354
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 354
  return (tmp);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_66(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 368
  ldv_check_alloc_flags(flags);
#line 370
  tmp = skb_clone(ldv_func_arg1, flags);
#line 370
  return (tmp);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv_skb_copy_68(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 384
  ldv_check_alloc_flags(flags);
#line 386
  tmp = skb_copy(ldv_func_arg1, flags);
#line 386
  return (tmp);
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_69(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 392
  ldv_check_alloc_flags(flags);
#line 394
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 394
  return (tmp);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_70(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 400
  ldv_check_alloc_flags(flags);
#line 402
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 402
  return (tmp);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_71(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 408
  ldv_check_alloc_flags(flags);
#line 410
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 410
  return (tmp);
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
int ldv_pskb_expand_head_72(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 418
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 418
  return (tmp);
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
int ldv_pskb_expand_head_73(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 424
  ldv_check_alloc_flags(flags);
#line 426
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 426
  return (tmp);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
struct sk_buff *ldv_skb_clone_74(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 432
  ldv_check_alloc_flags(flags);
#line 434
  tmp = skb_clone(ldv_func_arg1, flags);
#line 434
  return (tmp);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
void ldv__builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 245 "include/linux/timer.h"
extern int del_timer_sync(struct timer_list * ) ;
#line 248
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_100(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-encoder.h"
int pvr2_encoder_adjust(struct pvr2_hdw *hdw ) ;
#line 28
int pvr2_encoder_configure(struct pvr2_hdw *hdw ) ;
#line 29
int pvr2_encoder_start(struct pvr2_hdw *hdw ) ;
#line 30
int pvr2_encoder_stop(struct pvr2_hdw *hdw ) ;
#line 251 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
int pvr2_write_register(struct pvr2_hdw *hdw , u16 reg , u32 data ) ;
#line 93 "include/media/cx2341x.h"
extern int cx2341x_update(void * , int (*)(void * , u32  , int  , int  , u32 * ) ,
                          struct cx2341x_mpeg_params  const  * , struct cx2341x_mpeg_params  const  * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_108(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_116(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_110(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_106(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_115(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_111(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_112(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_113(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
static int pvr2_encoder_write_words(struct pvr2_hdw *hdw , unsigned int offs , u32 const   *data ,
                                    unsigned int dlen ) 
{ 
  unsigned int idx ;
  unsigned int addr ;
  unsigned int bAddr ;
  int ret ;
  unsigned int chunkCnt ;
  unsigned int tmp ;

  {
#line 149
  goto ldv_49790;
  ldv_49789: 
#line 150
  chunkCnt = 8U;
#line 151
  if (chunkCnt > dlen) {
#line 151
    chunkCnt = dlen;
  } else {

  }
#line 152
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 153
  bAddr = 0U;
#line 154
  tmp = bAddr;
#line 154
  bAddr = bAddr + 1U;
#line 154
  hdw->cmd_buffer[tmp] = 1U;
#line 155
  idx = 0U;
#line 155
  goto ldv_49787;
  ldv_49786: 
#line 156
  addr = idx + offs;
#line 157
  hdw->cmd_buffer[bAddr + 6U] = (unsigned char )addr;
#line 158
  hdw->cmd_buffer[bAddr + 5U] = (unsigned char )(addr >> 8);
#line 159
  hdw->cmd_buffer[bAddr + 4U] = (unsigned char )(addr >> 16);
#line 160
  hdw->cmd_buffer[bAddr] = (unsigned char )*(data + (unsigned long )idx);
#line 160
  hdw->cmd_buffer[bAddr + 1U] = (unsigned char )(*(data + (unsigned long )idx) >> 8);
#line 160
  hdw->cmd_buffer[bAddr + 2U] = (unsigned char )(*(data + (unsigned long )idx) >> 16);
#line 160
  hdw->cmd_buffer[bAddr + 3U] = (unsigned char )(*(data + (unsigned long )idx) >> 24);
#line 161
  bAddr = bAddr + 7U;
#line 155
  idx = idx + 1U;
  ldv_49787: ;
#line 155
  if (idx < chunkCnt) {
#line 157
    goto ldv_49786;
  } else {

  }
#line 163
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), chunkCnt * 7U + 1U, (void *)0,
                          0U);
#line 166
  if (ret != 0) {
#line 166
    return (ret);
  } else {

  }
#line 167
  data = data + (unsigned long )chunkCnt;
#line 168
  dlen = dlen - chunkCnt;
#line 169
  offs = offs + chunkCnt;
  ldv_49790: ;
#line 149
  if (dlen != 0U) {
#line 151
    goto ldv_49789;
  } else {

  }

#line 172
  return (0);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
static int pvr2_encoder_read_words(struct pvr2_hdw *hdw , unsigned int offs , u32 *data ,
                                   unsigned int dlen ) 
{ 
  unsigned int idx ;
  int ret ;
  unsigned int chunkCnt ;

  {
#line 194
  goto ldv_49805;
  ldv_49804: 
#line 195
  chunkCnt = 16U;
#line 196
  if (chunkCnt > dlen) {
#line 196
    chunkCnt = dlen;
  } else {

  }
#line 197
  if (chunkCnt <= 15U) {
#line 197
    chunkCnt = 1U;
  } else {

  }
#line 198
  hdw->cmd_buffer[0] = chunkCnt == 1U ? 2U : 40U;
#line 201
  hdw->cmd_buffer[1] = 0U;
#line 202
  hdw->cmd_buffer[2] = 0U;
#line 203
  hdw->cmd_buffer[3] = 0U;
#line 204
  hdw->cmd_buffer[4] = 0U;
#line 205
  hdw->cmd_buffer[5] = (unsigned char )(offs >> 16);
#line 206
  hdw->cmd_buffer[6] = (unsigned char )(offs >> 8);
#line 207
  hdw->cmd_buffer[7] = (unsigned char )offs;
#line 208
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          chunkCnt == 1U ? 4U : 64U);
#line 212
  if (ret != 0) {
#line 212
    return (ret);
  } else {

  }
#line 214
  idx = 0U;
#line 214
  goto ldv_49802;
  ldv_49801: 
#line 215
  *(data + (unsigned long )idx) = ((((unsigned int )hdw->cmd_buffer[idx * 4U + 3U] << 24) | ((unsigned int )hdw->cmd_buffer[idx * 4U + 2U] << 16)) | ((unsigned int )hdw->cmd_buffer[idx * 4U + 1U] << 8)) | (unsigned int )hdw->cmd_buffer[idx * 4U];
#line 214
  idx = idx + 1U;
  ldv_49802: ;
#line 214
  if (idx < chunkCnt) {
#line 216
    goto ldv_49801;
  } else {

  }
#line 217
  data = data + (unsigned long )chunkCnt;
#line 218
  dlen = dlen - chunkCnt;
#line 219
  offs = offs + chunkCnt;
  ldv_49805: ;
#line 194
  if (dlen != 0U) {
#line 196
    goto ldv_49804;
  } else {

  }

#line 222
  return (0);
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
static int pvr2_encoder_cmd(void *ctxt , u32 cmd , int arg_cnt_send , int arg_cnt_recv ,
                            u32 *argp ) 
{ 
  unsigned int poll_count ;
  unsigned int try_count ;
  int retry_flag ;
  int ret ;
  unsigned int idx ;
  u32 wrData[16U] ;
  u32 rdData[16U] ;
  struct pvr2_hdw *hdw ;

  {
#line 238
  try_count = 0U;
#line 240
  ret = 0;
#line 245
  hdw = (struct pvr2_hdw *)ctxt;
#line 278
  if ((unsigned int )arg_cnt_send > 12U) {
#line 279
    if ((pvrusb2_debug & 2) != 0) {
#line 279
      printk("\016pvrusb2: Failed to write cx23416 command - too many input arguments (was given %u limit %lu)\n",
             arg_cnt_send, 12UL);
    } else {

    }
#line 285
    return (-22);
  } else {

  }
#line 288
  if ((unsigned int )arg_cnt_recv > 12U) {
#line 289
    if ((pvrusb2_debug & 2) != 0) {
#line 289
      printk("\016pvrusb2: Failed to write cx23416 command - too many return arguments (was given %u limit %lu)\n",
             arg_cnt_recv, 12UL);
    } else {

    }
#line 295
    return (-22);
  } else {

  }
#line 299
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 299
  hdw->ctl_lock_held = 1;
#line 301
  if (hdw->state_encoder_ok == 0) {
#line 302
    ret = -5;
#line 303
    goto ldv_49830;
  } else {

  }
#line 306
  retry_flag = 0;
#line 307
  try_count = try_count + 1U;
#line 308
  ret = 0;
#line 309
  wrData[0] = 0U;
#line 310
  wrData[1] = cmd;
#line 311
  wrData[2] = 0U;
#line 312
  wrData[3] = 393216U;
#line 313
  idx = 0U;
#line 313
  goto ldv_49832;
  ldv_49831: 
#line 314
  wrData[idx + 4U] = *(argp + (unsigned long )idx);
#line 313
  idx = idx + 1U;
  ldv_49832: ;
#line 313
  if ((unsigned int )arg_cnt_send > idx) {
#line 315
    goto ldv_49831;
  } else {

  }

#line 316
  goto ldv_49837;
  ldv_49836: 
#line 317
  wrData[idx + 4U] = 0U;
#line 316
  idx = idx + 1U;
  ldv_49837: ;
#line 316
  if (idx <= 11U) {
#line 318
    goto ldv_49836;
  } else {

  }
#line 320
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), idx);
#line 321
  if (ret != 0) {
#line 321
    goto ldv_49830;
  } else {

  }
#line 322
  wrData[0] = 3U;
#line 323
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), 1U);
#line 324
  if (ret != 0) {
#line 324
    goto ldv_49830;
  } else {

  }
#line 325
  poll_count = 0U;
  ldv_49844: 
#line 327
  poll_count = poll_count + 1U;
#line 328
  ret = pvr2_encoder_read_words(hdw, 68U, (u32 *)(& rdData), (unsigned int )(arg_cnt_recv + 4));
#line 330
  if (ret != 0) {
#line 331
    goto ldv_49839;
  } else {

  }
#line 333
  if ((rdData[0] & 4U) != 0U) {
#line 334
    goto ldv_49839;
  } else {

  }
#line 336
  if (rdData[0] != 0U && poll_count <= 999U) {
#line 336
    goto ldv_49840;
  } else {

  }
#line 337
  if (rdData[0] == 0U) {
#line 338
    retry_flag = 1;
#line 339
    if ((pvrusb2_debug & 2) != 0) {
#line 339
      printk("\016pvrusb2: Encoder timed out waiting for us; arranging to retry\n");
    } else {

    }
  } else
#line 344
  if ((pvrusb2_debug & 2) != 0) {
#line 344
    printk("\016pvrusb2: ***WARNING*** device\'s encoder appears to be stuck (status=0x%08x)\n",
           rdData[0]);
  } else {

  }
#line 350
  if ((pvrusb2_debug & 2) != 0) {
#line 350
    printk("\016pvrusb2: Encoder command: 0x%02x\n", cmd);
  } else {

  }
#line 353
  idx = 4U;
#line 353
  goto ldv_49842;
  ldv_49841: ;
#line 354
  if ((pvrusb2_debug & 2) != 0) {
#line 354
    printk("\016pvrusb2: Encoder arg%d: 0x%08x\n", idx - 3U, wrData[idx]);
  } else {

  }
#line 353
  idx = idx + 1U;
  ldv_49842: ;
#line 353
  if ((unsigned int )arg_cnt_send > idx) {
#line 355
    goto ldv_49841;
  } else {

  }
#line 359
  ret = -16;
#line 360
  goto ldv_49839;
  ldv_49840: ;
#line 361
  goto ldv_49844;
  ldv_49839: ;
#line 362
  if (retry_flag != 0) {
#line 363
    if (try_count <= 19U) {
#line 363
      goto ldv_49845;
    } else {

    }
#line 364
    if ((pvrusb2_debug & 2) != 0) {
#line 364
      printk("\016pvrusb2: Too many retries...\n");
    } else {

    }
#line 367
    ret = -16;
  } else {

  }
#line 369
  if (ret != 0) {
#line 370
    ldv_del_timer_sync_117(& hdw->encoder_run_timer);
#line 371
    hdw->state_encoder_ok = 0;
#line 372
    if ((pvrusb2_debug & 512) != 0) {
#line 372
      printk("\016pvrusb2: State bit %s <-- %s\n", (char *)"state_encoder_ok", hdw->state_encoder_ok != 0 ? (char *)"true" : (char *)"false");
    } else {

    }
#line 376
    if (hdw->state_encoder_runok != 0) {
#line 377
      hdw->state_encoder_runok = 0;
#line 378
      if ((pvrusb2_debug & 512) != 0) {
#line 378
        printk("\016pvrusb2: State bit %s <-- %s\n", (char *)"state_encoder_runok",
               hdw->state_encoder_runok != 0 ? (char *)"true" : (char *)"false");
      } else {

      }
    } else {

    }
#line 384
    if ((pvrusb2_debug & 2) != 0) {
#line 384
      printk("\016pvrusb2: Giving up on command.  This is normally recovered via a firmware reload and re-initialization; concern is only warranted if this happens repeatedly and rapidly.\n");
    } else {

    }
#line 391
    goto ldv_49830;
  } else {

  }
#line 393
  wrData[0] = 7U;
#line 394
  idx = 0U;
#line 394
  goto ldv_49847;
  ldv_49846: 
#line 395
  *(argp + (unsigned long )idx) = rdData[idx + 4U];
#line 394
  idx = idx + 1U;
  ldv_49847: ;
#line 394
  if ((unsigned int )arg_cnt_recv > idx) {
#line 396
    goto ldv_49846;
  } else {

  }
#line 398
  wrData[0] = 0U;
#line 399
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), 1U);
#line 400
  if (ret != 0) {
#line 400
    goto ldv_49830;
  } else {

  }
  ldv_49845: ;
  ldv_49830: 
#line 402
  hdw->ctl_lock_held = 0;
#line 402
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 404
  return (ret);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
static int pvr2_encoder_vcmd(struct pvr2_hdw *hdw , int cmd , int args  , ...) 
{ 
  va_list vl ;
  unsigned int idx ;
  u32 data[12U] ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 415
  if ((unsigned int )args > 12U) {
#line 416
    if ((pvrusb2_debug & 2) != 0) {
#line 416
      printk("\016pvrusb2: Failed to write cx23416 command - too many arguments (was given %u limit %lu)\n",
             args, 12UL);
    } else {

    }
#line 422
    return (-22);
  } else {

  }
#line 425
  ldv__builtin_va_start((__va_list_tag *)(& vl));
#line 426
  idx = 0U;
#line 426
  goto ldv_49862;
  ldv_49861: 
#line 427
  ldv__builtin_va_arg(vl, sizeof(u32 ), (void *)(& tmp));
#line 427
  data[idx] = tmp;
#line 426
  idx = idx + 1U;
  ldv_49862: ;
#line 426
  if ((unsigned int )args > idx) {
#line 428
    goto ldv_49861;
  } else {

  }
#line 429
  ldv__builtin_va_end((__va_list_tag *)(& vl));
#line 431
  tmp___0 = pvr2_encoder_cmd((void *)hdw, (u32 )cmd, args, 0, (u32 *)(& data));
#line 431
  return (tmp___0);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
static int pvr2_encoder_prep_config(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  int encMisc3Arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 439
  ret = 0;
#line 440
  encMisc3Arg = 0;
#line 476
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 477
    encMisc3Arg = 1;
  } else {
#line 479
    encMisc3Arg = 0;
  }
#line 481
  tmp = pvr2_encoder_vcmd(hdw, 220, 4, 3, encMisc3Arg, 0, 0);
#line 481
  ret = tmp | ret;
#line 484
  tmp___0 = pvr2_encoder_vcmd(hdw, 220, 4, 8, 0, 0, 0);
#line 484
  ret = tmp___0 | ret;
#line 495
  tmp___1 = pvr2_encoder_vcmd(hdw, 220, 4, 0, 3, 0, 0);
#line 495
  ret = tmp___1 | ret;
#line 496
  tmp___2 = pvr2_encoder_vcmd(hdw, 220, 4, 15, 0, 0, 0);
#line 496
  ret = tmp___2 | ret;
#line 500
  tmp___3 = pvr2_encoder_vcmd(hdw, 220, 2, 4, 1);
#line 500
  ret = tmp___3 | ret;
#line 502
  return (ret);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int pvr2_encoder_adjust(struct pvr2_hdw *hdw ) 
{ 
  int ret ;

  {
#line 508
  ret = cx2341x_update((void *)hdw, & pvr2_encoder_cmd, hdw->enc_cur_valid != 0 ? (struct cx2341x_mpeg_params  const  *)(& hdw->enc_cur_state) : (struct cx2341x_mpeg_params  const  *)0,
                       (struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state));
#line 511
  if (ret != 0) {
#line 512
    if ((pvrusb2_debug & 2) != 0) {
#line 512
      printk("\016pvrusb2: Error from cx2341x module code=%d\n", ret);
    } else {

    }
  } else {
#line 515
    hdw->enc_cur_state = hdw->enc_ctl_state;
#line 516
    hdw->enc_cur_valid = 1;
  }
#line 518
  return (ret);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int pvr2_encoder_configure(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  int val ;
  int tmp ;

  {
#line 526
  if ((pvrusb2_debug & 4194304) != 0) {
#line 526
    printk("\016pvrusb2: pvr2_encoder_configure (cx2341x module)\n");
  } else {

  }
#line 528
  hdw->enc_ctl_state.port = 1;
#line 529
  hdw->enc_ctl_state.width = (u16 )hdw->res_hor_val;
#line 530
  hdw->enc_ctl_state.height = (u16 )hdw->res_ver_val;
#line 531
  hdw->enc_ctl_state.is_50hz = (hdw->std_mask_cur & 63744ULL) == 0ULL;
#line 534
  ret = 0;
#line 536
  tmp = pvr2_encoder_prep_config(hdw);
#line 536
  ret = tmp | ret;
#line 539
  val = 240;
#line 540
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 542
    val = 320;
  } else {

  }
#line 545
  if (ret == 0) {
#line 545
    ret = pvr2_encoder_vcmd(hdw, 214, 2, val, val);
  } else {

  }
#line 550
  if (ret == 0) {
#line 550
    ret = pvr2_encoder_vcmd(hdw, 213, 4, 0, 0, 268435456, 4294967295U);
  } else {

  }
#line 554
  if (ret == 0) {
#line 554
    ret = pvr2_encoder_vcmd(hdw, 183, 5, 4294967295U, 0, 0, 0, 0);
  } else {

  }
#line 558
  if (ret != 0) {
#line 559
    if ((pvrusb2_debug & 2) != 0) {
#line 559
      printk("\016pvrusb2: Failed to configure cx23416\n");
    } else {

    }
#line 561
    return (ret);
  } else {

  }
#line 564
  ret = pvr2_encoder_adjust(hdw);
#line 565
  if (ret != 0) {
#line 565
    return (ret);
  } else {

  }
#line 567
  ret = pvr2_encoder_vcmd(hdw, 205, 0);
#line 570
  if (ret != 0) {
#line 571
    if ((pvrusb2_debug & 2) != 0) {
#line 571
      printk("\016pvrusb2: Failed to initialize cx23416 video input\n");
    } else {

    }
#line 573
    return (ret);
  } else {

  }
#line 576
  return (0);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int pvr2_encoder_start(struct pvr2_hdw *hdw ) 
{ 
  int status ;

  {
#line 585
  pvr2_write_register(hdw, 72, 3221225471U);
#line 587
  pvr2_encoder_vcmd(hdw, 217, 1, hdw->input_val == 4);
#line 590
  switch ((unsigned int )hdw->active_stream_type) {
  case 2U: 
#line 592
  status = pvr2_encoder_vcmd(hdw, 129, 2, 1, 20);
#line 594
  goto ldv_49883;
  case 1U: 
#line 596
  status = pvr2_encoder_vcmd(hdw, 129, 2, 0, 19);
#line 598
  goto ldv_49883;
  default: 
#line 600
  status = pvr2_encoder_vcmd(hdw, 129, 2, 0, 19);
#line 602
  goto ldv_49883;
  }
  ldv_49883: ;
#line 604
  return (status);
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int pvr2_encoder_stop(struct pvr2_hdw *hdw ) 
{ 
  int status ;

  {
#line 612
  pvr2_write_register(hdw, 72, 4294967295U);
#line 614
  switch ((unsigned int )hdw->active_stream_type) {
  case 2U: 
#line 616
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 1, 20);
#line 618
  goto ldv_49891;
  case 1U: 
#line 620
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 0, 19);
#line 622
  goto ldv_49891;
  default: 
#line 624
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 0, 19);
#line 626
  goto ldv_49891;
  }
  ldv_49891: ;
#line 629
  return (status);
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void *ldv_kmem_cache_alloc_100(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 762
  ldv_check_alloc_flags(flags);
#line 764
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 765
  return ((void *)0);
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_pskb_expand_head_106(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 806
  ldv_check_alloc_flags(flags);
#line 808
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 808
  return (tmp);
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv_skb_clone_108(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 822
  ldv_check_alloc_flags(flags);
#line 824
  tmp = skb_clone(ldv_func_arg1, flags);
#line 824
  return (tmp);
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv_skb_copy_110(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 838
  ldv_check_alloc_flags(flags);
#line 840
  tmp = skb_copy(ldv_func_arg1, flags);
#line 840
  return (tmp);
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_111(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 846
  ldv_check_alloc_flags(flags);
#line 848
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 848
  return (tmp);
}
}
#line 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_112(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 854
  ldv_check_alloc_flags(flags);
#line 856
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 856
  return (tmp);
}
}
#line 859 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_113(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 862
  ldv_check_alloc_flags(flags);
#line 864
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 864
  return (tmp);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_pskb_expand_head_114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 870
  ldv_check_alloc_flags(flags);
#line 872
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 872
  return (tmp);
}
}
#line 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_pskb_expand_head_115(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 878
  ldv_check_alloc_flags(flags);
#line 880
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 880
  return (tmp);
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
struct sk_buff *ldv_skb_clone_116(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 886
  ldv_check_alloc_flags(flags);
#line 888
  tmp = skb_clone(ldv_func_arg1, flags);
#line 888
  return (tmp);
}
}
#line 891 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 895
  tmp = del_timer_sync(ldv_func_arg1);
#line 895
  ldv_func_res = tmp;
#line 897
  disable_suitable_timer_3(ldv_func_arg1);
#line 899
  return (ldv_func_res);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_144(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_152(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_160(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_154(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_150(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_158(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_159(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_155(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_156(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_157(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.h"
void pvr2_saa7115_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
static int const   routing_scheme0___0[5U]  = {      4,      0,      5,      8, 
        5};
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
static struct routing_scheme  const  routing_def0___0  =    {(int const   *)(& routing_scheme0___0), 5U};
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
static int const   routing_scheme1[5U]  = {      4,      0,      3,      8, 
        5};
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
static struct routing_scheme  const  routing_def1  =    {(int const   *)(& routing_scheme1), 5U};
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
static struct routing_scheme  const  *routing_schemes___0[3U]  = {      & routing_def0___0,      0,      & routing_def1};
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void pvr2_saa7115_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 170
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 172
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 175
    if ((pvrusb2_debug & 65536) != 0) {
#line 175
      printk("\016pvrusb2: subdev v4l2 set_input(%d)\n", hdw->input_val);
    } else {

    }
#line 178
    sp = sid <= 2U ? routing_schemes___0[sid] : (struct routing_scheme  const  *)0;
#line 180
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 183
      if ((pvrusb2_debug & 2) != 0) {
#line 183
        printk("\016pvrusb2: *** WARNING *** subdev v4l2 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 188
      return;
    } else {

    }
#line 190
    input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
#line 191
    (*(((sd->ops)->video)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 193
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void *ldv_kmem_cache_alloc_144(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 325
  ldv_check_alloc_flags(flags);
#line 327
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 328
  return ((void *)0);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
int ldv_pskb_expand_head_150(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 369
  ldv_check_alloc_flags(flags);
#line 371
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 371
  return (tmp);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv_skb_clone_152(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 385
  ldv_check_alloc_flags(flags);
#line 387
  tmp = skb_clone(ldv_func_arg1, flags);
#line 387
  return (tmp);
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv_skb_copy_154(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 401
  ldv_check_alloc_flags(flags);
#line 403
  tmp = skb_copy(ldv_func_arg1, flags);
#line 403
  return (tmp);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_155(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 409
  ldv_check_alloc_flags(flags);
#line 411
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 411
  return (tmp);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_156(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 417
  ldv_check_alloc_flags(flags);
#line 419
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 419
  return (tmp);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_157(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 425
  ldv_check_alloc_flags(flags);
#line 427
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 427
  return (tmp);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
int ldv_pskb_expand_head_158(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 433
  ldv_check_alloc_flags(flags);
#line 435
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 435
  return (tmp);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
int ldv_pskb_expand_head_159(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 441
  ldv_check_alloc_flags(flags);
#line 443
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 443
  return (tmp);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
struct sk_buff *ldv_skb_clone_160(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 449
  ldv_check_alloc_flags(flags);
#line 451
  tmp = skb_clone(ldv_func_arg1, flags);
#line 451
  return (tmp);
}
}
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 315
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_186(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445 "include/linux/slab.h"
__inline static void *ldv_kmalloc_182(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 462
  tmp___2 = __kmalloc(size, flags);
#line 462
  return (tmp___2);
}
}
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-eeprom.h"
int pvr2_eeprom_analyze(struct pvr2_hdw *hdw ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_194(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_202(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_196(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_192(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_200(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_201(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_197(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_198(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_199(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
static u8 *pvr2_eeprom_fetch(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_msg msg[2U] ;
  u8 *eeprom ;
  u8 iadd[2U] ;
  u8 addr ;
  u16 eepromSize ;
  unsigned int offs ;
  int ret ;
  int mode16 ;
  unsigned int pcnt ;
  unsigned int tcnt ;
  void *tmp ;

  {
#line 144
  mode16 = 0;
#line 146
  tmp = kmalloc(128UL, 208U);
#line 146
  eeprom = (u8 *)tmp;
#line 147
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 148
    if ((pvrusb2_debug & 2) != 0) {
#line 148
      printk("\016pvrusb2: Failed to allocate memory required to read eeprom\n");
    } else {

    }
#line 151
    return ((u8 *)0U);
  } else {

  }
#line 154
  if ((pvrusb2_debug & 1024) != 0) {
#line 154
    printk("\016pvrusb2: Value for eeprom addr from controller was 0x%x\n", hdw->eeprom_addr);
  } else {

  }
#line 156
  addr = (u8 )hdw->eeprom_addr;
#line 160
  if ((int )((signed char )addr) < 0) {
#line 160
    addr = (u8 )((int )addr >> 1);
  } else {

  }
#line 165
  mode16 = (int )addr & 1;
#line 166
  eepromSize = mode16 != 0 ? 4096U : 256U;
#line 167
  if ((pvrusb2_debug & 1024) != 0) {
#line 167
    printk("\016pvrusb2: Examining %d byte eeprom at location 0x%x using %d bit addressing\n",
           (int )eepromSize, (int )addr, mode16 != 0 ? 16 : 8);
  } else {

  }
#line 171
  msg[0].addr = (__u16 )addr;
#line 172
  msg[0].flags = 0U;
#line 173
  msg[0].len = mode16 != 0 ? 2U : 1U;
#line 174
  msg[0].buf = (__u8 *)(& iadd);
#line 175
  msg[1].addr = (__u16 )addr;
#line 176
  msg[1].flags = 1U;
#line 182
  memset((void *)eeprom, 0, 128UL);
#line 183
  tcnt = 0U;
#line 183
  goto ldv_49784;
  ldv_49783: 
#line 184
  pcnt = 16U;
#line 185
  if (pcnt + tcnt > 128U) {
#line 185
    pcnt = 128U - tcnt;
  } else {

  }
#line 186
  offs = ((unsigned int )eepromSize + tcnt) + 4294967168U;
#line 187
  if (mode16 != 0) {
#line 188
    iadd[0] = (u8 )(offs >> 8);
#line 189
    iadd[1] = (u8 )offs;
  } else {
#line 191
    iadd[0] = (u8 )offs;
  }
#line 193
  msg[1].len = (__u16 )pcnt;
#line 194
  msg[1].buf = eeprom + (unsigned long )tcnt;
#line 195
  ret = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 2);
#line 195
  if (ret != 2) {
#line 197
    if ((pvrusb2_debug & 2) != 0) {
#line 197
      printk("\016pvrusb2: eeprom fetch set offs err=%d\n", ret);
    } else {

    }
#line 199
    kfree((void const   *)eeprom);
#line 200
    return ((u8 *)0U);
  } else {

  }
#line 183
  tcnt = tcnt + pcnt;
  ldv_49784: ;
#line 183
  if (tcnt <= 127U) {
#line 185
    goto ldv_49783;
  } else {

  }

#line 203
  return (eeprom);
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
int pvr2_eeprom_analyze(struct pvr2_hdw *hdw ) 
{ 
  u8 *eeprom ;
  struct tveeprom tvdata ;
  struct i2c_client fake_client ;

  {
#line 213
  memset((void *)(& tvdata), 0, 76UL);
#line 215
  eeprom = pvr2_eeprom_fetch(hdw);
#line 216
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 216
    return (-22);
  } else {

  }
#line 221
  fake_client.addr = (unsigned short )hdw->eeprom_addr;
#line 222
  fake_client.adapter = & hdw->i2c_adap;
#line 223
  tveeprom_hauppauge_analog(& fake_client, & tvdata, eeprom);
#line 226
  if ((pvrusb2_debug & 1024) != 0) {
#line 226
    printk("\016pvrusb2: eeprom assumed v4l tveeprom module\n");
  } else {

  }
#line 227
  if ((pvrusb2_debug & 1024) != 0) {
#line 227
    printk("\016pvrusb2: eeprom direct call results:\n");
  } else {

  }
#line 228
  if ((pvrusb2_debug & 1024) != 0) {
#line 228
    printk("\016pvrusb2: has_radio=%d\n", tvdata.has_radio);
  } else {

  }
#line 229
  if ((pvrusb2_debug & 1024) != 0) {
#line 229
    printk("\016pvrusb2: tuner_type=%d\n", tvdata.tuner_type);
  } else {

  }
#line 230
  if ((pvrusb2_debug & 1024) != 0) {
#line 230
    printk("\016pvrusb2: tuner_formats=0x%x\n", tvdata.tuner_formats);
  } else {

  }
#line 231
  if ((pvrusb2_debug & 1024) != 0) {
#line 231
    printk("\016pvrusb2: audio_processor=%d\n", tvdata.audio_processor);
  } else {

  }
#line 232
  if ((pvrusb2_debug & 1024) != 0) {
#line 232
    printk("\016pvrusb2: model=%d\n", tvdata.model);
  } else {

  }
#line 233
  if ((pvrusb2_debug & 1024) != 0) {
#line 233
    printk("\016pvrusb2: revision=%d\n", tvdata.revision);
  } else {

  }
#line 234
  if ((pvrusb2_debug & 1024) != 0) {
#line 234
    printk("\016pvrusb2: serial_number=%d\n", tvdata.serial_number);
  } else {

  }
#line 235
  if ((pvrusb2_debug & 1024) != 0) {
#line 235
    printk("\016pvrusb2: rev_str=%s\n", (char *)(& tvdata.rev_str));
  } else {

  }
#line 236
  hdw->tuner_type = tvdata.tuner_type;
#line 237
  hdw->tuner_updated = 1;
#line 238
  hdw->serial_number = (unsigned long )tvdata.serial_number;
#line 239
  hdw->std_mask_eeprom = (v4l2_std_id )tvdata.tuner_formats;
#line 241
  kfree((void const   *)eeprom);
#line 243
  return (0);
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 346
  ldv_check_alloc_flags(flags);
#line 348
  ldv_kmalloc_182(size, flags);
#line 349
  return ((void *)0);
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void *ldv_kmem_cache_alloc_186(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 376
  ldv_check_alloc_flags(flags);
#line 378
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 379
  return ((void *)0);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
int ldv_pskb_expand_head_192(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 420
  ldv_check_alloc_flags(flags);
#line 422
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 422
  return (tmp);
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv_skb_clone_194(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 436
  ldv_check_alloc_flags(flags);
#line 438
  tmp = skb_clone(ldv_func_arg1, flags);
#line 438
  return (tmp);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv_skb_copy_196(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 454
  tmp = skb_copy(ldv_func_arg1, flags);
#line 454
  return (tmp);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_197(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 460
  ldv_check_alloc_flags(flags);
#line 462
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 462
  return (tmp);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_198(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 468
  ldv_check_alloc_flags(flags);
#line 470
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 470
  return (tmp);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_199(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 476
  ldv_check_alloc_flags(flags);
#line 478
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 478
  return (tmp);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
int ldv_pskb_expand_head_200(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 484
  ldv_check_alloc_flags(flags);
#line 486
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 486
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
int ldv_pskb_expand_head_201(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 492
  ldv_check_alloc_flags(flags);
#line 494
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 494
  return (tmp);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
struct sk_buff *ldv_skb_clone_202(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 500
  ldv_check_alloc_flags(flags);
#line 502
  tmp = skb_clone(ldv_func_arg1, flags);
#line 502
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_228(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_8  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_5  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_4  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct usb_interface *pvr_driver_group1  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_3  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_5  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_13  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_12  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_73xxx_dvb_props_group0  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_14  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_onair_usb2_fe_props_group0  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_9  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_format *pvr2_ioctl_ops_group0  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_onair_creator_fe_props_group0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ref_cnt  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_1  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_7  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_1  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct file *vdev_fops_group0  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_ext_controls *pvr2_ioctl_ops_group4  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_10  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_751xx_dvb_props_group0  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_6  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_2  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int usb_counter  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_control *pvr2_ioctl_ops_group2  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_11  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_audio *pvr2_ioctl_ops_group3  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_3  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct file *pvr2_ioctl_ops_group1  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct i2c_adapter *pvr2_i2c_algo_template_group0  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_750xx_dvb_props_group0  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_4  ;
#line 62
void ldv_initialize_pvr2_dvb_props_10(void) ;
#line 64
void ldv_initialize_pvr2_dvb_props_7(void) ;
#line 73
void ldv_usb_driver_13(void) ;
#line 75
void ldv_initialize_pvr2_dvb_props_9(void) ;
#line 85
void ldv_initialize_pvr2_dvb_props_8(void) ;
#line 88
void ldv_initialize_v4l2_ioctl_ops_12(void) ;
#line 90
void ldv_initialize_v4l2_file_operations_11(void) ;
#line 91
void ldv_initialize_pvr2_dvb_props_6(void) ;
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 194 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 196
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 196
  return (tmp);
}
}
#line 199 "include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
#line 201
  dev_set_drvdata(& intf->dev, data);
#line 202
  return;
}
}
#line 1148
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1152
int ldv_usb_register_driver_245(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) ;
#line 1159
extern void usb_deregister(struct usb_driver * ) ;
#line 1162
void ldv_usb_deregister_246(struct usb_driver *arg ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_236(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_244(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_238(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_242(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_243(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_239(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_240(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_241(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_context *pvr2_context_create(struct usb_interface *intf , struct usb_device_id  const  *devid ,
                                         void (*setup_func)(struct pvr2_context * ) ) ;
#line 71
void pvr2_context_disconnect(struct pvr2_context *mp ) ;
#line 82
int pvr2_context_global_init(void) ;
#line 83
void pvr2_context_global_done(void) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr ) ;
#line 187 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct usb_device_id pvr2_device_table[12U] ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-v4l2.h"
struct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp ) ;
#line 30
struct pvr2_sysfs_class *pvr2_sysfs_class_create(void) ;
#line 31
void pvr2_sysfs_class_destroy(struct pvr2_sysfs_class *clp ) ;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-sysfs.h"
struct pvr2_sysfs *pvr2_sysfs_create(struct pvr2_context *mp , struct pvr2_sysfs_class *class_ptr___0 ) ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int pvrusb2_debug  =    31;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static struct pvr2_sysfs_class *class_ptr  =    (struct pvr2_sysfs_class *)0;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static void pvr_setup_attach(struct pvr2_context *pvr ) 
{ 


  {
#line 151
  pvr2_v4l2_create(pvr);
#line 154
  pvr2_dvb_create(pvr);
#line 157
  pvr2_sysfs_create(pvr, class_ptr);
#line 158
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static int pvr_probe(struct usb_interface *intf , struct usb_device_id  const  *devid ) 
{ 
  struct pvr2_context *pvr ;

  {
#line 167
  pvr = pvr2_context_create(intf, devid, & pvr_setup_attach);
#line 168
  if ((unsigned long )pvr == (unsigned long )((struct pvr2_context *)0)) {
#line 169
    if ((pvrusb2_debug & 2) != 0) {
#line 169
      printk("\016pvrusb2: Failed to create hdw handler\n");
    } else {

    }
#line 171
    return (-12);
  } else {

  }
#line 174
  if ((pvrusb2_debug & 32) != 0) {
#line 174
    printk("\016pvrusb2: pvr_probe(pvr=%p)\n", pvr);
  } else {

  }
#line 176
  usb_set_intfdata(intf, (void *)pvr);
#line 178
  return (0);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static void pvr_disconnect(struct usb_interface *intf ) 
{ 
  struct pvr2_context *pvr ;
  void *tmp ;

  {
#line 187
  tmp = usb_get_intfdata(intf);
#line 187
  pvr = (struct pvr2_context *)tmp;
#line 189
  if ((pvrusb2_debug & 32) != 0) {
#line 189
    printk("\016pvrusb2: pvr_disconnect(pvr=%p) BEGIN\n", pvr);
  } else {

  }
#line 191
  usb_set_intfdata(intf, (void *)0);
#line 192
  pvr2_context_disconnect(pvr);
#line 194
  if ((pvrusb2_debug & 32) != 0) {
#line 194
    printk("\016pvrusb2: pvr_disconnect(pvr=%p) DONE\n", pvr);
  } else {

  }
#line 195
  return;
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static struct usb_driver pvr_driver  = 
#line 198
     {"pvrusb2", & pvr_probe, & pvr_disconnect, 0, 0, 0, 0, 0, 0, (struct usb_device_id  const  *)(& pvr2_device_table),
    {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {{0, 0, 0, 0, (_Bool)0,
                                                                 0, 0, 0, 0, 0, 0,
                                                                 0, 0, 0, 0}, 0},
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static int pvr_init(void) 
{ 
  int ret ;

  {
#line 215
  if ((pvrusb2_debug & 32) != 0) {
#line 215
    printk("\016pvrusb2: pvr_init\n");
  } else {

  }
#line 217
  ret = pvr2_context_global_init();
#line 218
  if (ret != 0) {
#line 219
    if ((pvrusb2_debug & 32) != 0) {
#line 219
      printk("\016pvrusb2: pvr_init failure code=%d\n", ret);
    } else {

    }
#line 220
    return (ret);
  } else {

  }
#line 224
  class_ptr = pvr2_sysfs_class_create();
#line 227
  ret = ldv_usb_register_driver_245(& pvr_driver, & __this_module, "pvrusb2");
#line 229
  if (ret == 0) {
#line 230
    printk("\016pvrusb2: V4L in-tree version:Hauppauge WinTV-PVR-USB2 MPEG2 Encoder/Tuner\n");
  } else {

  }
#line 232
  if (pvrusb2_debug != 0) {
#line 233
    printk("\016pvrusb2: Debug mask is %d (0x%x)\n", pvrusb2_debug, pvrusb2_debug);
  } else {

  }
#line 236
  if ((pvrusb2_debug & 32) != 0) {
#line 236
    printk("\016pvrusb2: pvr_init complete\n");
  } else {

  }
#line 238
  return (ret);
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
static void pvr_exit(void) 
{ 


  {
#line 243
  if ((pvrusb2_debug & 32) != 0) {
#line 243
    printk("\016pvrusb2: pvr_exit\n");
  } else {

  }
#line 245
  ldv_usb_deregister_246(& pvr_driver);
#line 247
  pvr2_context_global_done();
#line 250
  pvr2_sysfs_class_destroy(class_ptr);
#line 253
  if ((pvrusb2_debug & 32) != 0) {
#line 253
    printk("\016pvrusb2: pvr_exit complete\n");
  } else {

  }
#line 254
  return;
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_retval_1  ;
#line 276
extern void ldv_initialize(void) ;
#line 277
extern void ldv_check_final_state(void) ;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_retval_2  ;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_usb_driver_13(void) 
{ 
  void *tmp ;

  {
#line 282
  tmp = ldv_zalloc(1560UL);
#line 282
  pvr_driver_group1 = (struct usb_interface *)tmp;
#line 283
  return;
}
}
#line 290
void ldv_main_exported_8(void) ;
#line 291
void ldv_main_exported_6(void) ;
#line 292
void ldv_main_exported_7(void) ;
#line 293
void ldv_main_exported_10(void) ;
#line 294
void ldv_main_exported_9(void) ;
#line 296
void ldv_main_exported_11(void) ;
#line 297
void ldv_main_exported_12(void) ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int main(void) 
{ 
  struct usb_device_id *ldvarg63 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 304
  tmp = ldv_zalloc(32UL);
#line 304
  ldvarg63 = (struct usb_device_id *)tmp;
#line 302
  ldv_initialize();
#line 306
  ldv_state_variable_6 = 0;
#line 307
  ldv_state_variable_11 = 0;
#line 309
  ldv_state_variable_3 = 1;
#line 310
  ldv_state_variable_7 = 0;
#line 311
  ldv_state_variable_9 = 0;
#line 312
  ldv_state_variable_12 = 0;
#line 314
  ldv_state_variable_2 = 1;
#line 315
  ldv_state_variable_14 = 0;
#line 316
  ldv_state_variable_8 = 0;
#line 318
  ldv_state_variable_1 = 1;
#line 320
  ldv_state_variable_4 = 1;
#line 321
  ref_cnt = 0;
#line 322
  ldv_state_variable_0 = 1;
#line 323
  ldv_state_variable_13 = 0;
#line 324
  ldv_state_variable_10 = 0;
#line 326
  ldv_state_variable_5 = 1;
  ldv_47169: 
#line 328
  tmp___0 = __VERIFIER_nondet_int();
#line 328
  switch (tmp___0) {
  case 0: ;
#line 332
  if (ldv_state_variable_6 != 0) {
#line 333
    ldv_main_exported_6();
  } else {

  }
#line 336
  goto ldv_47144;
  case 1: ;
#line 340
  if (ldv_state_variable_11 != 0) {
#line 341
    ldv_main_exported_11();
  } else {

  }
#line 344
  goto ldv_47144;
  case 2: ;
#line 351
  goto ldv_47144;
  case 3: ;
#line 355
  if (ldv_state_variable_7 != 0) {
#line 356
    ldv_main_exported_7();
  } else {

  }
#line 359
  goto ldv_47144;
  case 4: ;
#line 363
  if (ldv_state_variable_9 != 0) {
#line 364
    ldv_main_exported_9();
  } else {

  }
#line 367
  goto ldv_47144;
  case 5: ;
#line 371
  if (ldv_state_variable_12 != 0) {
#line 372
    ldv_main_exported_12();
  } else {

  }
#line 375
  goto ldv_47144;
  case 6: ;
#line 382
  goto ldv_47144;
  case 7: ;
#line 386
  if (ldv_state_variable_14 != 0) {
#line 387
    ldv_main_exported_14();
  } else {

  }
#line 390
  goto ldv_47144;
  case 8: ;
#line 394
  if (ldv_state_variable_8 != 0) {
#line 395
    ldv_main_exported_8();
  } else {

  }
#line 398
  goto ldv_47144;
  case 9: ;
#line 405
  goto ldv_47144;
  case 10: ;
#line 412
  goto ldv_47144;
  case 11: ;
#line 416
  if (ldv_state_variable_0 != 0) {
#line 417
    tmp___1 = __VERIFIER_nondet_int();
#line 417
    switch (tmp___1) {
    case 0: ;
#line 420
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 422
      pvr_exit();
#line 423
      ldv_state_variable_0 = 2;
#line 424
      goto ldv_final;
    } else {

    }
#line 427
    goto ldv_47158;
    case 1: ;
#line 430
    if (ldv_state_variable_0 == 1) {
#line 432
      ldv_retval_1 = pvr_init();
#line 434
      if (ldv_retval_1 == 0) {
#line 435
        ldv_state_variable_0 = 3;
#line 436
        ldv_state_variable_14 = 1;
#line 437
        ldv_initialize_i2c_algorithm_14();
#line 438
        ldv_state_variable_12 = 1;
#line 439
        ldv_initialize_v4l2_ioctl_ops_12();
#line 440
        ldv_state_variable_9 = 1;
#line 441
        ldv_initialize_pvr2_dvb_props_9();
#line 442
        ldv_state_variable_10 = 1;
#line 443
        ldv_initialize_pvr2_dvb_props_10();
#line 444
        ldv_state_variable_7 = 1;
#line 445
        ldv_initialize_pvr2_dvb_props_7();
#line 446
        ldv_state_variable_11 = 1;
#line 447
        ldv_initialize_v4l2_file_operations_11();
#line 448
        ldv_state_variable_6 = 1;
#line 449
        ldv_initialize_pvr2_dvb_props_6();
#line 450
        ldv_state_variable_8 = 1;
#line 451
        ldv_initialize_pvr2_dvb_props_8();
      } else {

      }
#line 453
      if (ldv_retval_1 != 0) {
#line 454
        ldv_state_variable_0 = 2;
#line 455
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 459
    goto ldv_47158;
    default: 
#line 460
    ldv_stop();
    }
    ldv_47158: ;
  } else {

  }
#line 464
  goto ldv_47144;
  case 12: ;
#line 468
  if (ldv_state_variable_13 != 0) {
#line 469
    tmp___2 = __VERIFIER_nondet_int();
#line 469
    switch (tmp___2) {
    case 0: ;
#line 472
    if (ldv_state_variable_13 == 1) {
#line 474
      ldv_retval_2 = pvr_probe(pvr_driver_group1, (struct usb_device_id  const  *)ldvarg63);
#line 475
      if (ldv_retval_2 == 0) {
#line 476
        ldv_state_variable_13 = 2;
#line 477
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 481
    goto ldv_47163;
    case 1: ;
#line 484
    if (ldv_state_variable_13 == 2 && usb_counter == 0) {
#line 486
      pvr_disconnect(pvr_driver_group1);
#line 487
      ldv_state_variable_13 = 1;
#line 488
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 491
    goto ldv_47163;
    default: 
#line 492
    ldv_stop();
    }
    ldv_47163: ;
  } else {

  }
#line 496
  goto ldv_47144;
  case 13: ;
#line 500
  if (ldv_state_variable_10 != 0) {
#line 501
    ldv_main_exported_10();
  } else {

  }
#line 504
  goto ldv_47144;
  case 14: ;
#line 511
  goto ldv_47144;
  default: 
#line 512
  ldv_stop();
  }
  ldv_47144: ;
#line 514
  goto ldv_47169;
  ldv_final: 
#line 516
  ldv_check_final_state();
#line 517
  return 0;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void *ldv_kmem_cache_alloc_228(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 650
  ldv_check_alloc_flags(flags);
#line 652
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 653
  return ((void *)0);
}
}
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 694
  ldv_check_alloc_flags(flags);
#line 696
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 696
  return (tmp);
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv_skb_clone_236(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 710
  ldv_check_alloc_flags(flags);
#line 712
  tmp = skb_clone(ldv_func_arg1, flags);
#line 712
  return (tmp);
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv_skb_copy_238(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 726
  ldv_check_alloc_flags(flags);
#line 728
  tmp = skb_copy(ldv_func_arg1, flags);
#line 728
  return (tmp);
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_239(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 734
  ldv_check_alloc_flags(flags);
#line 736
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 736
  return (tmp);
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_240(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 742
  ldv_check_alloc_flags(flags);
#line 744
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 744
  return (tmp);
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_241(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 750
  ldv_check_alloc_flags(flags);
#line 752
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 752
  return (tmp);
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_pskb_expand_head_242(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 758
  ldv_check_alloc_flags(flags);
#line 760
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 760
  return (tmp);
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_pskb_expand_head_243(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 766
  ldv_check_alloc_flags(flags);
#line 768
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 768
  return (tmp);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct sk_buff *ldv_skb_clone_244(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 774
  ldv_check_alloc_flags(flags);
#line 776
  tmp = skb_clone(ldv_func_arg1, flags);
#line 776
  return (tmp);
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_usb_register_driver_245(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 783
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 783
  ldv_func_res = tmp;
#line 785
  ldv_state_variable_13 = 1;
#line 786
  usb_counter = 0;
#line 787
  ldv_usb_driver_13();
#line 790
  return (ldv_func_res);
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_usb_deregister_246(struct usb_driver *arg ) 
{ 


  {
#line 796
  usb_deregister(arg);
#line 798
  ldv_state_variable_13 = 0;
#line 799
  return;
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 391 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 395
extern int scnprintf(char * , size_t  , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 68 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 144
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 823
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 824
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 120 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 91
extern void wait_for_completion(struct completion * ) ;
#line 106
extern void complete(struct completion * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 169 "include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 171
  return ((unsigned long )timer->entry.next != (unsigned long )((struct list_head */* const  */)0));
}
}
#line 240
extern void add_timer(struct timer_list * ) ;
#line 248
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_296(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_297(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_299(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_301(struct timer_list *ldv_func_arg1 ) ;
#line 284
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 ) ;
#line 288
int ldv_del_timer_sync_305(struct timer_list *ldv_func_arg1 ) ;
#line 292
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 ) ;
#line 296
int ldv_del_timer_sync_307(struct timer_list *ldv_func_arg1 ) ;
#line 300
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 ) ;
#line 304
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 ) ;
#line 308
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 ) ;
#line 180 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 364
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 424
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 431
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 438
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 471 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 474
  tmp = queue_work_on(8192, wq, work);
#line 474
  return (tmp);
}
}
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_274(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 563 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 565
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 566
    return ((void *)0);
  } else {

  }
#line 567
  tmp = __kmalloc(n * size, flags);
#line 567
  return (tmp);
}
}
#line 576 "include/linux/slab.h"
__inline static void *ldv_kcalloc_272(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 578
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 578
  return (tmp);
}
}
#line 576
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) ;
#line 65
int reg_timer_2(struct timer_list *timer ) ;
#line 66
void choose_timer_5(struct timer_list *timer ) ;
#line 67
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 68
void choose_timer_3(struct timer_list *timer ) ;
#line 69
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 70
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 71
void choose_timer_4(struct timer_list *timer ) ;
#line 75
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 76
int reg_timer_1(struct timer_list *timer ) ;
#line 77
int reg_timer_4(struct timer_list *timer ) ;
#line 78
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 79
void disable_suitable_timer_1(struct timer_list *timer ) ;
#line 80
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 82
int reg_timer_3(struct timer_list *timer ) ;
#line 83
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 85
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 86
void choose_timer_1(struct timer_list *timer ) ;
#line 88
int reg_timer_5(struct timer_list *timer ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 906 "include/linux/device.h"
__inline static void device_unlock(struct device *dev ) 
{ 


  {
#line 908
  mutex_unlock(& dev->mutex);
#line 909
  return;
}
}
#line 117 "include/media/v4l2-common.h"
extern struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device * , struct i2c_adapter * ,
                                               char const   * , u8  , unsigned short const   * ) ;
#line 381 "include/linux/sched.h"
extern void schedule(void) ;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-std.h"
int pvr2_std_str_to_id(v4l2_std_id *idPtr , char const   *bufPtr , unsigned int bufSize ) ;
#line 37
unsigned int pvr2_std_id_to_str(char *bufPtr , unsigned int bufSize , v4l2_std_id id ) ;
#line 47
v4l2_std_id pvr2_std_get_usable(void) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 595 "include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 597
  __mptr = (struct device  const  *)intf->dev.parent;
#line 597
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 621
extern int usb_lock_device_for_reset(struct usb_device * , struct usb_interface  const  * ) ;
#line 625
extern int usb_reset_device(struct usb_device * ) ;
#line 791 "include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
#line 794
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
#line 796
  return ((int )size > actual ? actual : -1);
}
}
#line 1511 "include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 


  {
#line 1519
  urb->dev = dev;
#line 1520
  urb->pipe = pipe;
#line 1521
  urb->transfer_buffer = transfer_buffer;
#line 1522
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1523
  urb->complete = complete_fn;
#line 1524
  urb->context = context;
#line 1525
  return;
}
}
#line 1581
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
#line 1584
struct urb *ldv_usb_alloc_urb_292(int ldv_func_arg1 , gfp_t flags ) ;
#line 1588
struct urb *ldv_usb_alloc_urb_293(int ldv_func_arg1 , gfp_t flags ) ;
#line 1590
extern void usb_free_urb(struct urb * ) ;
#line 1593
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
#line 1596
int ldv_usb_submit_urb_302(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1600
int ldv_usb_submit_urb_303(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1602
extern int usb_unlink_urb(struct urb * ) ;
#line 1603
extern void usb_kill_urb(struct urb * ) ;
#line 1656
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1661
extern int usb_bulk_msg(struct usb_device * , unsigned int  , void * , int  , int * ,
                        int  ) ;
#line 1674
extern int usb_clear_halt(struct usb_device * , int  ) ;
#line 1676
extern int usb_set_interface(struct usb_device * , int  , int  ) ;
#line 1784 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1787
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream *pvr2_stream_create(void) ;
#line 49
void pvr2_stream_destroy(struct pvr2_stream *sp ) ;
#line 50
void pvr2_stream_setup(struct pvr2_stream *sp , struct usb_device *dev , int endpoint ,
                       unsigned int tolerance___0 ) ;
#line 56
void pvr2_stream_get_stats(struct pvr2_stream *sp , struct pvr2_stream_stats *stats ,
                           int zero_counts ) ;
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr , int mask , int val ,
                                    char *buf , unsigned int maxlen , unsigned int *len ) ;
#line 102 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
char const   *pvr2_config_get_name(enum pvr2_config cfg ) ;
#line 108
struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf , struct usb_device_id  const  *devid ) ;
#line 113
int pvr2_hdw_initialize(struct pvr2_hdw *hdw , void (*callback_func)(void * ) , void *callback_data ) ;
#line 118
void pvr2_hdw_destroy(struct pvr2_hdw *hdw ) ;
#line 121
int pvr2_hdw_dev_ok(struct pvr2_hdw *hdw ) ;
#line 125
int pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw ) ;
#line 128
struct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw ) ;
#line 131
unsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw ) ;
#line 134
char const   *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw ) ;
#line 137
char const   *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw ) ;
#line 140
void pvr2_hdw_disconnect(struct pvr2_hdw *hdw ) ;
#line 143
void pvr2_hdw_set_v4l2_dev(struct pvr2_hdw *hdw , struct video_device *vdev ) ;
#line 146
unsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw ) ;
#line 149
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw , unsigned int idx ) ;
#line 152
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 155
struct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 158
struct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 162
int pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw ) ;
#line 166
unsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw ) ;
#line 170
unsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw ) ;
#line 177
int pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw , unsigned int change_mask , unsigned int change_val ) ;
#line 182
char const   *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw ) ;
#line 185
void pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw ) ;
#line 188
int pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw , struct v4l2_tuner *vtp ) ;
#line 191
int pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw , struct v4l2_cropcap *pp ) ;
#line 194
int pvr2_hdw_is_hsm(struct pvr2_hdw *hdw ) ;
#line 197
char const   *pvr2_hdw_get_type(struct pvr2_hdw *hdw ) ;
#line 200
char const   *pvr2_hdw_get_desc(struct pvr2_hdw *hdw ) ;
#line 203
int pvr2_hdw_set_streaming(struct pvr2_hdw *hdw , int enable_flag ) ;
#line 206
int pvr2_hdw_get_streaming(struct pvr2_hdw *hdw ) ;
#line 209
int pvr2_hdw_get_state(struct pvr2_hdw *hdw ) ;
#line 212
int pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw , enum pvr2_config config ) ;
#line 215
struct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp ) ;
#line 221
void pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw , int mode , int enable_flag ) ;
#line 226
int pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw ) ;
#line 231
int pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw , unsigned int offs , char *buf , unsigned int cnt ) ;
#line 235
int pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ) ;
#line 238
void pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ,
                                     int v ) ;
#line 258
void pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw , int val ) ;
#line 261
void pvr2_hdw_device_reset(struct pvr2_hdw *hdw ) ;
#line 264
int pvr2_hdw_untrip(struct pvr2_hdw *hdw ) ;
#line 269
int pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw ) ;
#line 272
int pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw ) ;
#line 275
int pvr2_hdw_cmd_powerdown(struct pvr2_hdw *hdw ) ;
#line 278
int pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw ) ;
#line 281
int pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 282
int pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 283
int pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 284
int pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw , u32 msk , u32 val ) ;
#line 285
int pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw , u32 msk , u32 val ) ;
#line 334
unsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 338
void pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw ) ;
#line 343
int pvr2_upload_firmware2(struct pvr2_hdw *hdw ) ;
#line 668 "include/media/v4l2-subdev.h"
__inline static void *v4l2_get_subdevdata(struct v4l2_subdev  const  *sd ) 
{ 


  {
#line 670
  return ((void *)sd->dev_priv);
}
}
#line 79 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 103
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 106
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 96 "include/media/cx2341x.h"
extern int cx2341x_ctrl_query(struct cx2341x_mpeg_params  const  * , struct v4l2_queryctrl * ) ;
#line 98
extern char const   * const  *cx2341x_ctrl_get_menu(struct cx2341x_mpeg_params  const  * ,
                                                    u32  ) ;
#line 99
extern int cx2341x_ext_ctrls(struct cx2341x_mpeg_params * , int  , struct v4l2_ext_controls * ,
                             unsigned int  ) ;
#line 101
extern void cx2341x_fill_defaults(struct cx2341x_mpeg_params * ) ;
#line 102
extern void cx2341x_log_status(struct cx2341x_mpeg_params  const  * , char const   * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_282(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_290(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_284(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_288(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_289(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_285(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_286(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_287(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
unsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw ) ;
#line 394
void pvr2_hdw_status_poll(struct pvr2_hdw *hdw ) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-wm8775.h"
void pvr2_wm8775_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.h"
void pvr2_cx25840_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.h"
void pvr2_cs53l32a_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct pvr2_hdw *unit_pointers[20U]  = 
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
  {      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0};
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct mutex pvr2_unit_mtx  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_unit_mtx.wait_lock",
                                                           0, 0UL}}}}, {& pvr2_unit_mtx.wait_list,
                                                                        & pvr2_unit_mtx.wait_list},
    0, 0, (void *)(& pvr2_unit_mtx), {0, {0, 0}, "pvr2_unit_mtx", 0, 0UL}};
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int procreload  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int tuner[20U]  = 
#line 162
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int tolerance[20U]  = 
#line 163
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int video_std[20U]  = 
#line 164
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int init_pause_msec  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int default_tv_freq  =    61250000;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int default_radio_freq  =    104300000;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static pvr2_subdev_update_func pvr2_module_update_functions[7U]  = {      0,      & pvr2_msp3400_subdev_update,      & pvr2_cx25840_subdev_update,      & pvr2_saa7115_subdev_update, 
        0,      & pvr2_cs53l32a_subdev_update,      & pvr2_wm8775_subdev_update};
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *module_names[8U]  = 
#line 216
  {      0,      "msp3400",      "cx25840",      "saa7115", 
        "tuner",      "cs53l32a",      "wm8775",      "tuner"};
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned char const   *module_i2c_addresses[8U]  = 
#line 227
  {      0,      (unsigned char const   *)"@",      (unsigned char const   *)"D",      (unsigned char const   *)"!", 
        (unsigned char const   *)"`abc",      (unsigned char const   *)"\021",      (unsigned char const   *)"\033",      (unsigned char const   *)"C"};
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *ir_scheme_names[5U]  = {      "none",      "24xxx (29xxx emulation)",      "Zilog",      "24xxx (MCE device)", 
        "29xxx"};
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct pvr2_mpeg_ids  const  mpeg_ids[26U]  = 
#line 253
  {      {"audio_layer", 10029413}, 
        {"audio_bitrate", 10029415}, 
        {"mpeg_audio_mode", 10029417}, 
        {"mpeg_audio_mode_extension", 10029418}, 
        {"audio_emphasis", 10029419}, 
        {"audio_crc", 10029420}, 
        {"video_aspect", 10029513}, 
        {"video_b_frames", 10029514}, 
        {"video_gop_size", 10029515}, 
        {"video_gop_closure", 10029516}, 
        {"video_bitrate_mode", 10029518}, 
        {"video_bitrate", 10029519}, 
        {"video_bitrate_peak", 10029520}, 
        {"video_temporal_decimation", 10029521}, 
        {"stream_type", 10029312}, 
        {"video_spatial_filter_mode", 10031104}, 
        {"video_spatial_filter", 10031105}, 
        {"video_luma_spatial_filter_type", 10031106}, 
        {"video_chroma_spatial_filter_type", 10031107}, 
        {"video_temporal_filter_mode", 10031108}, 
        {"video_temporal_filter", 10031109}, 
        {"video_median_filter_type", 10031110}, 
        {"video_luma_median_filter_top", 10031112}, 
        {"video_luma_median_filter_bottom", 10031111}, 
        {"video_chroma_median_filter_top", 10031114}, 
        {"video_chroma_median_filter_bottom", 10031113}};
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *control_values_srate[3U]  = {      "44.1 kHz",      "48 kHz",      "32 kHz"};
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *control_values_input[5U]  = {      "television",      "dtv",      "composite",      "s-video", 
        "radio"};
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *control_values_audiomode[5U]  = {      "Mono",      "Stereo",      "Lang2",      "Lang1", 
        "Lang1+Lang2"};
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *control_values_hsm[3U]  = {      "Fail",      "Full",      "High"};
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *pvr2_state_names[7U]  = {      "none",      "dead",      "cold",      "warm", 
        "error",      "ready",      "run"};
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct pvr2_fx2cmd_descdef  const  pvr2_fx2cmd_desc[25U]  = 
#line 387
  {      {1U, (unsigned char *)"write encoder dword"}, 
        {2U, (unsigned char *)"read encoder dword"}, 
        {16U, (unsigned char *)"zilog IR reset control"}, 
        {40U, (unsigned char *)"read encoder 64bytes"}, 
        {4U, (unsigned char *)"write encoder register"}, 
        {5U, (unsigned char *)"read encoder register"}, 
        {6U, (unsigned char *)"encoder memsel"}, 
        {8U, (unsigned char *)"i2c write"}, 
        {9U, (unsigned char *)"i2c read"}, 
        {11U, (unsigned char *)"get USB speed"}, 
        {54U, (unsigned char *)"stream on"}, 
        {55U, (unsigned char *)"stream off"}, 
        {82U, (unsigned char *)"fwpost1"}, 
        {220U, (unsigned char *)"power off"}, 
        {222U, (unsigned char *)"power on"}, 
        {221U, (unsigned char *)"deep reset"}, 
        {235U, (unsigned char *)"get rom addr"}, 
        {236U, (unsigned char *)"get IR code"}, 
        {240U, (unsigned char *)"hcw demod resetin"}, 
        {241U, (unsigned char *)"hcw dtv stream on"}, 
        {242U, (unsigned char *)"hcw dtv stream off"}, 
        {160U, (unsigned char *)"onair dtv stream on"}, 
        {161U, (unsigned char *)"onair dtv stream off"}, 
        {162U, (unsigned char *)"onair dtv power on"}, 
        {163U, (unsigned char *)"onair dtv power off"}};
#line 416
static int pvr2_hdw_set_input(struct pvr2_hdw *hdw , int v ) ;
#line 417
static void pvr2_hdw_state_sched(struct pvr2_hdw *hdw ) ;
#line 418
static int pvr2_hdw_state_eval(struct pvr2_hdw *hdw ) ;
#line 419
static void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw , unsigned long val ) ;
#line 420
static void pvr2_hdw_worker_poll(struct work_struct *work ) ;
#line 421
static int pvr2_hdw_wait(struct pvr2_hdw *hdw , int state ) ;
#line 422
static int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw ) ;
#line 423
static void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw ) ;
#line 424
static int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw , int runFl ) ;
#line 425
static int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw ) ;
#line 426
static int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw ) ;
#line 427
static void pvr2_hdw_quiescent_timeout(unsigned long data ) ;
#line 428
static void pvr2_hdw_decoder_stabilization_timeout(unsigned long data ) ;
#line 429
static void pvr2_hdw_encoder_wait_timeout(unsigned long data ) ;
#line 430
static void pvr2_hdw_encoder_run_timeout(unsigned long data ) ;
#line 431
static int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw , u32 cmdcode ) ;
#line 432
static int pvr2_send_request_ex(struct pvr2_hdw *hdw , unsigned int timeout , int probe_fl ,
                                void *write_data , unsigned int write_len , void *read_data ,
                                unsigned int read_len ) ;
#line 436
static int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw ) ;
#line 437
static v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw ) ;
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void trace_stbit(char const   *name , int val ) 
{ 


  {
#line 441
  if ((pvrusb2_debug & 512) != 0) {
#line 441
    printk("\016pvrusb2: State bit %s <-- %s\n", name, val != 0 ? (char *)"true" : (char *)"false");
  } else {

  }
#line 442
  return;
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channelfreq_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 448
  hdw = cptr->hdw;
#line 449
  if (hdw->freqProgSlot != 0U && hdw->freqProgSlot <= 500U) {
#line 450
    *vp = (int )hdw->freqTable[hdw->freqProgSlot - 1U];
  } else {
#line 452
    *vp = 0;
  }
#line 454
  return (0);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channelfreq_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  unsigned int slotId ;

  {
#line 459
  hdw = cptr->hdw;
#line 460
  slotId = hdw->freqProgSlot;
#line 461
  if (slotId != 0U && slotId <= 500U) {
#line 462
    hdw->freqTable[slotId - 1U] = (unsigned int )v;
#line 466
    if (hdw->freqSelector != 0U) {
#line 467
      if (hdw->freqSlotRadio == slotId) {
#line 468
        hdw->freqSlotRadio = 0U;
      } else {

      }
    } else
#line 471
    if (hdw->freqSlotTelevision == slotId) {
#line 472
      hdw->freqSlotTelevision = 0U;
    } else {

    }
  } else {

  }
#line 476
  return (0);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channelprog_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 481
  *vp = (int )(cptr->hdw)->freqProgSlot;
#line 482
  return (0);
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channelprog_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 487
  hdw = cptr->hdw;
#line 488
  if (v >= 0 && v <= 500) {
#line 489
    hdw->freqProgSlot = (unsigned int )v;
  } else {

  }
#line 491
  return (0);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channel_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 496
  hdw = cptr->hdw;
#line 497
  *vp = (int )(hdw->freqSelector != 0U ? hdw->freqSlotRadio : hdw->freqSlotTelevision);
#line 498
  return (0);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_channel_set(struct pvr2_ctrl *cptr , int m , int slotId ) 
{ 
  unsigned int freq ;
  struct pvr2_hdw *hdw ;

  {
#line 503
  freq = 0U;
#line 504
  hdw = cptr->hdw;
#line 505
  if (slotId < 0 || slotId > 500) {
#line 505
    return (0);
  } else {

  }
#line 506
  if (slotId > 0) {
#line 507
    freq = hdw->freqTable[slotId + -1];
#line 508
    if (freq == 0U) {
#line 508
      return (0);
    } else {

    }
#line 509
    pvr2_hdw_set_cur_freq(hdw, (unsigned long )freq);
  } else {

  }
#line 511
  if (hdw->freqSelector != 0U) {
#line 512
    hdw->freqSlotRadio = (unsigned int )slotId;
  } else {
#line 514
    hdw->freqSlotTelevision = (unsigned int )slotId;
  }
#line 516
  return (0);
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_freq_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long tmp ;

  {
#line 521
  tmp = pvr2_hdw_get_cur_freq(cptr->hdw);
#line 521
  *vp = (int )tmp;
#line 522
  return (0);
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_freq_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 527
  return ((cptr->hdw)->freqDirty != 0);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_freq_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 532
  (cptr->hdw)->freqDirty = 0;
#line 533
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_freq_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 537
  pvr2_hdw_set_cur_freq(cptr->hdw, (unsigned long )v);
#line 538
  return (0);
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cropl_min_get(struct pvr2_ctrl *cptr , int *left ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 543
  cap = & (cptr->hdw)->cropcap_info;
#line 544
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 544
  stat = tmp;
#line 545
  if (stat != 0) {
#line 546
    return (stat);
  } else {

  }
#line 548
  *left = cap->bounds.left;
#line 549
  return (0);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cropl_max_get(struct pvr2_ctrl *cptr , int *left ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 554
  cap = & (cptr->hdw)->cropcap_info;
#line 555
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 555
  stat = tmp;
#line 556
  if (stat != 0) {
#line 557
    return (stat);
  } else {

  }
#line 559
  *left = cap->bounds.left;
#line 560
  if (cap->bounds.width > (__u32 )(cptr->hdw)->cropw_val) {
#line 561
    *left = (int )((__u32 )*left + (cap->bounds.width - (__u32 )(cptr->hdw)->cropw_val));
  } else {

  }
#line 563
  return (0);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cropt_min_get(struct pvr2_ctrl *cptr , int *top ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 568
  cap = & (cptr->hdw)->cropcap_info;
#line 569
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 569
  stat = tmp;
#line 570
  if (stat != 0) {
#line 571
    return (stat);
  } else {

  }
#line 573
  *top = cap->bounds.top;
#line 574
  return (0);
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cropt_max_get(struct pvr2_ctrl *cptr , int *top ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 579
  cap = & (cptr->hdw)->cropcap_info;
#line 580
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 580
  stat = tmp;
#line 581
  if (stat != 0) {
#line 582
    return (stat);
  } else {

  }
#line 584
  *top = cap->bounds.top;
#line 585
  if (cap->bounds.height > (__u32 )(cptr->hdw)->croph_val) {
#line 586
    *top = (int )((__u32 )*top + (cap->bounds.height - (__u32 )(cptr->hdw)->croph_val));
  } else {

  }
#line 588
  return (0);
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cropw_max_get(struct pvr2_ctrl *cptr , int *width ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int bleftend ;
  int cleft ;

  {
#line 593
  cap = & (cptr->hdw)->cropcap_info;
#line 596
  stat = pvr2_hdw_check_cropcap(cptr->hdw);
#line 597
  if (stat != 0) {
#line 598
    return (stat);
  } else {

  }
#line 600
  bleftend = (int )((__u32 )cap->bounds.left + cap->bounds.width);
#line 601
  cleft = (cptr->hdw)->cropl_val;
#line 603
  *width = cleft < bleftend ? bleftend - cleft : 0;
#line 604
  return (0);
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_croph_max_get(struct pvr2_ctrl *cptr , int *height ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int btopend ;
  int ctop ;

  {
#line 609
  cap = & (cptr->hdw)->cropcap_info;
#line 612
  stat = pvr2_hdw_check_cropcap(cptr->hdw);
#line 613
  if (stat != 0) {
#line 614
    return (stat);
  } else {

  }
#line 616
  btopend = (int )((__u32 )cap->bounds.top + cap->bounds.height);
#line 617
  ctop = (cptr->hdw)->cropt_val;
#line 619
  *height = ctop < btopend ? btopend - ctop : 0;
#line 620
  return (0);
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapbl(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 625
  cap = & (cptr->hdw)->cropcap_info;
#line 626
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 626
  stat = tmp;
#line 627
  if (stat != 0) {
#line 628
    return (stat);
  } else {

  }
#line 630
  *val = cap->bounds.left;
#line 631
  return (0);
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapbt(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 636
  cap = & (cptr->hdw)->cropcap_info;
#line 637
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 637
  stat = tmp;
#line 638
  if (stat != 0) {
#line 639
    return (stat);
  } else {

  }
#line 641
  *val = cap->bounds.top;
#line 642
  return (0);
}
}
#line 645 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapbw(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 647
  cap = & (cptr->hdw)->cropcap_info;
#line 648
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 648
  stat = tmp;
#line 649
  if (stat != 0) {
#line 650
    return (stat);
  } else {

  }
#line 652
  *val = (int )cap->bounds.width;
#line 653
  return (0);
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapbh(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 658
  cap = & (cptr->hdw)->cropcap_info;
#line 659
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 659
  stat = tmp;
#line 660
  if (stat != 0) {
#line 661
    return (stat);
  } else {

  }
#line 663
  *val = (int )cap->bounds.height;
#line 664
  return (0);
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapdl(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 669
  cap = & (cptr->hdw)->cropcap_info;
#line 670
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 670
  stat = tmp;
#line 671
  if (stat != 0) {
#line 672
    return (stat);
  } else {

  }
#line 674
  *val = cap->defrect.left;
#line 675
  return (0);
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapdt(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 680
  cap = & (cptr->hdw)->cropcap_info;
#line 681
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 681
  stat = tmp;
#line 682
  if (stat != 0) {
#line 683
    return (stat);
  } else {

  }
#line 685
  *val = cap->defrect.top;
#line 686
  return (0);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapdw(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 691
  cap = & (cptr->hdw)->cropcap_info;
#line 692
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 692
  stat = tmp;
#line 693
  if (stat != 0) {
#line 694
    return (stat);
  } else {

  }
#line 696
  *val = (int )cap->defrect.width;
#line 697
  return (0);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcapdh(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 702
  cap = & (cptr->hdw)->cropcap_info;
#line 703
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 703
  stat = tmp;
#line 704
  if (stat != 0) {
#line 705
    return (stat);
  } else {

  }
#line 707
  *val = (int )cap->defrect.height;
#line 708
  return (0);
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcappan(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 713
  cap = & (cptr->hdw)->cropcap_info;
#line 714
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 714
  stat = tmp;
#line 715
  if (stat != 0) {
#line 716
    return (stat);
  } else {

  }
#line 718
  *val = (int )cap->pixelaspect.numerator;
#line 719
  return (0);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropcappad(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 724
  cap = & (cptr->hdw)->cropcap_info;
#line 725
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 725
  stat = tmp;
#line 726
  if (stat != 0) {
#line 727
    return (stat);
  } else {

  }
#line 729
  *val = (int )cap->pixelaspect.denominator;
#line 730
  return (0);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_vres_max_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 736
  if (((cptr->hdw)->std_mask_cur & 63744ULL) != 0ULL) {
#line 737
    *vp = 480;
  } else {
#line 739
    *vp = 576;
  }
#line 741
  return (0);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_vres_min_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 747
  if ((unsigned int )*((unsigned char *)(cptr->hdw)->hdw_desc + 87UL) != 0U) {
#line 748
    *vp = 75;
  } else {
#line 750
    *vp = 17;
  }
#line 752
  return (0);
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_input(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 757
  *vp = (cptr->hdw)->input_val;
#line 758
  return (0);
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_check_input(struct pvr2_ctrl *cptr , int v ) 
{ 


  {
#line 763
  return (((unsigned int )(1 << v) & (cptr->hdw)->input_allowed_mask) != 0U);
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_input(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  int tmp ;

  {
#line 768
  tmp = pvr2_hdw_set_input(cptr->hdw, v);
#line 768
  return (tmp);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_input(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 773
  return ((cptr->hdw)->input_dirty != 0);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_input(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 778
  (cptr->hdw)->input_dirty = 0;
#line 779
  return;
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_freq_max_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long fv ;
  struct pvr2_hdw *hdw ;

  {
#line 785
  hdw = cptr->hdw;
#line 786
  if (hdw->tuner_signal_stale != 0) {
#line 787
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 789
  fv = (unsigned long )hdw->tuner_signal_info.rangehigh;
#line 790
  if (fv == 0UL) {
#line 792
    *vp = 850000000;
#line 793
    return (0);
  } else {

  }
#line 795
  if ((int )hdw->tuner_signal_info.capability & 1) {
#line 796
    fv = (fv * 125UL) / 2UL;
  } else {
#line 798
    fv = fv * 62500UL;
  }
#line 800
  *vp = (int )fv;
#line 801
  return (0);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_freq_min_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long fv ;
  struct pvr2_hdw *hdw ;

  {
#line 807
  hdw = cptr->hdw;
#line 808
  if (hdw->tuner_signal_stale != 0) {
#line 809
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 811
  fv = (unsigned long )hdw->tuner_signal_info.rangelow;
#line 812
  if (fv == 0UL) {
#line 814
    *vp = 55250000;
#line 815
    return (0);
  } else {

  }
#line 817
  if ((int )hdw->tuner_signal_info.capability & 1) {
#line 818
    fv = (fv * 125UL) / 2UL;
  } else {
#line 820
    fv = fv * 62500UL;
  }
#line 822
  *vp = (int )fv;
#line 823
  return (0);
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cx2341x_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 828
  return ((cptr->hdw)->enc_stale != 0);
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cx2341x_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 833
  (cptr->hdw)->enc_stale = 0;
#line 834
  (cptr->hdw)->enc_unsafe_stale = 0;
#line 835
  return;
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cx2341x_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int ret ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;

  {
#line 842
  memset((void *)(& cs), 0, 32UL);
#line 843
  memset((void *)(& c1), 0, 20UL);
#line 844
  cs.controls = & c1;
#line 845
  cs.count = 1U;
#line 846
  c1.id = (__u32 )(cptr->info)->v4l_id;
#line 847
  ret = cx2341x_ext_ctrls(& (cptr->hdw)->enc_ctl_state, 0, & cs, 3223344711U);
#line 849
  if (ret != 0) {
#line 849
    return (ret);
  } else {

  }
#line 850
  *vp = c1.ldv_29295.value;
#line 851
  return (0);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_cx2341x_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  int ret ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;

  {
#line 857
  hdw = cptr->hdw;
#line 860
  memset((void *)(& cs), 0, 32UL);
#line 861
  memset((void *)(& c1), 0, 20UL);
#line 862
  cs.controls = & c1;
#line 863
  cs.count = 1U;
#line 864
  c1.id = (__u32 )(cptr->info)->v4l_id;
#line 865
  c1.ldv_29295.value = v;
#line 866
  ret = cx2341x_ext_ctrls(& hdw->enc_ctl_state, hdw->state_encoder_run, & cs, 3223344712U);
#line 869
  if (ret == -16) {
#line 875
    ret = cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs, 3223344712U);
#line 878
    if (ret == 0) {
#line 878
      hdw->enc_unsafe_stale = 1;
    } else {

    }
  } else {

  }
#line 880
  if (ret != 0) {
#line 880
    return (ret);
  } else {

  }
#line 881
  hdw->enc_stale = 1;
#line 882
  return (0);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int ctrl_cx2341x_getv4lflags(struct pvr2_ctrl *cptr ) 
{ 
  struct v4l2_queryctrl qctrl ;
  struct pvr2_ctl_info *info ;

  {
#line 889
  qctrl.id = (__u32 )(cptr->info)->v4l_id;
#line 890
  cx2341x_ctrl_query((struct cx2341x_mpeg_params  const  *)(& (cptr->hdw)->enc_ctl_state),
                     & qctrl);
#line 897
  info = (struct pvr2_ctl_info *)cptr->info;
#line 898
  if ((qctrl.flags & 4U) != 0U) {
#line 899
    if ((unsigned long )info->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                     int  , int  ))0)) {
#line 900
      info->set_value = (int (*)(struct pvr2_ctrl * , int  , int  ))0;
    } else {

    }
  } else
#line 903
  if ((unsigned long )info->set_value == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                   int  , int  ))0)) {
#line 904
    info->set_value = & ctrl_cx2341x_set;
  } else {

  }
#line 907
  return (qctrl.flags);
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_streamingenabled_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 912
  *vp = (cptr->hdw)->state_pipeline_req;
#line 913
  return (0);
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_masterstate_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 918
  *vp = (int )(cptr->hdw)->master_state;
#line 919
  return (0);
}
}
#line 922 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_hsm_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int result ;
  int tmp ;

  {
#line 924
  tmp = pvr2_hdw_is_hsm(cptr->hdw);
#line 924
  result = tmp;
#line 925
  *vp = 1;
#line 926
  if (result < 0) {
#line 926
    *vp = 0;
  } else {

  }
#line 927
  if (result != 0) {
#line 927
    *vp = 2;
  } else {

  }
#line 928
  return (0);
}
}
#line 931 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stddetect_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  v4l2_std_id tmp ;

  {
#line 933
  tmp = pvr2_hdw_get_detected_std(cptr->hdw);
#line 933
  *vp = (int )tmp;
#line 934
  return (0);
}
}
#line 937 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stdavail_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 939
  *vp = (int )(cptr->hdw)->std_mask_avail;
#line 940
  return (0);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stdavail_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  v4l2_std_id ns ;

  {
#line 945
  hdw = cptr->hdw;
#line 947
  ns = hdw->std_mask_avail;
#line 948
  ns = ((v4l2_std_id )(~ m) & ns) | (v4l2_std_id )(v & m);
#line 949
  if (hdw->std_mask_avail == ns) {
#line 949
    return (0);
  } else {

  }
#line 950
  hdw->std_mask_avail = ns;
#line 951
  hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )hdw->std_mask_avail;
#line 952
  return (0);
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_std_val_to_sym(struct pvr2_ctrl *cptr , int msk , int val , char *bufPtr ,
                               unsigned int bufSize , unsigned int *len ) 
{ 


  {
#line 959
  *len = pvr2_std_id_to_str(bufPtr, bufSize, (v4l2_std_id )(msk & val));
#line 960
  return (0);
}
}
#line 963 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_std_sym_to_val(struct pvr2_ctrl *cptr , char const   *bufPtr , unsigned int bufSize ,
                               int *mskp , int *valp ) 
{ 
  int ret ;
  v4l2_std_id id ;

  {
#line 969
  ret = pvr2_std_str_to_id(& id, bufPtr, bufSize);
#line 970
  if (ret < 0) {
#line 970
    return (ret);
  } else {

  }
#line 971
  if ((unsigned long )mskp != (unsigned long )((int *)0)) {
#line 971
    *mskp = (int )id;
  } else {

  }
#line 972
  if ((unsigned long )valp != (unsigned long )((int *)0)) {
#line 972
    *valp = (int )id;
  } else {

  }
#line 973
  return (0);
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stdcur_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 978
  *vp = (int )(cptr->hdw)->std_mask_cur;
#line 979
  return (0);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stdcur_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  v4l2_std_id ns ;

  {
#line 984
  hdw = cptr->hdw;
#line 986
  ns = hdw->std_mask_cur;
#line 987
  ns = ((v4l2_std_id )(~ m) & ns) | (v4l2_std_id )(v & m);
#line 988
  if (hdw->std_mask_cur == ns) {
#line 988
    return (0);
  } else {

  }
#line 989
  hdw->std_mask_cur = ns;
#line 990
  hdw->std_dirty = 1;
#line 991
  return (0);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_stdcur_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 996
  return ((cptr->hdw)->std_dirty != 0);
}
}
#line 999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_stdcur_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1001
  (cptr->hdw)->std_dirty = 0;
#line 1002
  return;
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_signal_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 1006
  hdw = cptr->hdw;
#line 1007
  pvr2_hdw_status_poll(hdw);
#line 1008
  *vp = hdw->tuner_signal_info.signal;
#line 1009
  return (0);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_audio_modes_present_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int val ;
  unsigned int subchan ;
  struct pvr2_hdw *hdw ;

  {
#line 1014
  val = 0;
#line 1016
  hdw = cptr->hdw;
#line 1017
  pvr2_hdw_status_poll(hdw);
#line 1018
  subchan = hdw->tuner_signal_info.rxsubchans;
#line 1019
  if ((int )subchan & 1) {
#line 1020
    val = val | 1;
  } else {

  }
#line 1022
  if ((subchan & 2U) != 0U) {
#line 1023
    val = val | 2;
  } else {

  }
#line 1025
  if ((subchan & 8U) != 0U) {
#line 1026
    val = val | 8;
  } else {

  }
#line 1028
  if ((subchan & 4U) != 0U) {
#line 1029
    val = val | 4;
  } else {

  }
#line 1031
  *vp = val;
#line 1032
  return (0);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_brightness(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1071
  *vp = (cptr->hdw)->brightness_val;
#line 1071
  return (0);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_brightness(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1071
  (cptr->hdw)->brightness_val = v;
#line 1071
  (cptr->hdw)->brightness_dirty = 1;
#line 1071
  return (0);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_brightness(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1071
  return ((cptr->hdw)->brightness_dirty != 0);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_brightness(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1071
  (cptr->hdw)->brightness_dirty = 0;
#line 1072
  return;
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_contrast(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1072
  *vp = (cptr->hdw)->contrast_val;
#line 1072
  return (0);
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_contrast(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1072
  (cptr->hdw)->contrast_val = v;
#line 1072
  (cptr->hdw)->contrast_dirty = 1;
#line 1072
  return (0);
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_contrast(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1072
  return ((cptr->hdw)->contrast_dirty != 0);
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_contrast(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1072
  (cptr->hdw)->contrast_dirty = 0;
#line 1073
  return;
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_saturation(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1073
  *vp = (cptr->hdw)->saturation_val;
#line 1073
  return (0);
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_saturation(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1073
  (cptr->hdw)->saturation_val = v;
#line 1073
  (cptr->hdw)->saturation_dirty = 1;
#line 1073
  return (0);
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_saturation(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1073
  return ((cptr->hdw)->saturation_dirty != 0);
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_saturation(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1073
  (cptr->hdw)->saturation_dirty = 0;
#line 1074
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_hue(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1074
  *vp = (cptr->hdw)->hue_val;
#line 1074
  return (0);
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_hue(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1074
  (cptr->hdw)->hue_val = v;
#line 1074
  (cptr->hdw)->hue_dirty = 1;
#line 1074
  return (0);
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_hue(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1074
  return ((cptr->hdw)->hue_dirty != 0);
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_hue(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1074
  (cptr->hdw)->hue_dirty = 0;
#line 1075
  return;
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_volume(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1075
  *vp = (cptr->hdw)->volume_val;
#line 1075
  return (0);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_volume(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1075
  (cptr->hdw)->volume_val = v;
#line 1075
  (cptr->hdw)->volume_dirty = 1;
#line 1075
  return (0);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_volume(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1075
  return ((cptr->hdw)->volume_dirty != 0);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_volume(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1075
  (cptr->hdw)->volume_dirty = 0;
#line 1076
  return;
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_balance(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1076
  *vp = (cptr->hdw)->balance_val;
#line 1076
  return (0);
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_balance(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1076
  (cptr->hdw)->balance_val = v;
#line 1076
  (cptr->hdw)->balance_dirty = 1;
#line 1076
  return (0);
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_balance(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1076
  return ((cptr->hdw)->balance_dirty != 0);
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_balance(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1076
  (cptr->hdw)->balance_dirty = 0;
#line 1077
  return;
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_bass(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1077
  *vp = (cptr->hdw)->bass_val;
#line 1077
  return (0);
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_bass(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1077
  (cptr->hdw)->bass_val = v;
#line 1077
  (cptr->hdw)->bass_dirty = 1;
#line 1077
  return (0);
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_bass(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1077
  return ((cptr->hdw)->bass_dirty != 0);
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_bass(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1077
  (cptr->hdw)->bass_dirty = 0;
#line 1078
  return;
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_treble(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1078
  *vp = (cptr->hdw)->treble_val;
#line 1078
  return (0);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_treble(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1078
  (cptr->hdw)->treble_val = v;
#line 1078
  (cptr->hdw)->treble_dirty = 1;
#line 1078
  return (0);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_treble(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1078
  return ((cptr->hdw)->treble_dirty != 0);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_treble(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1078
  (cptr->hdw)->treble_dirty = 0;
#line 1079
  return;
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_mute(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1079
  *vp = (cptr->hdw)->mute_val;
#line 1079
  return (0);
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_mute(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1079
  (cptr->hdw)->mute_val = v;
#line 1079
  (cptr->hdw)->mute_dirty = 1;
#line 1079
  return (0);
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_mute(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1079
  return ((cptr->hdw)->mute_dirty != 0);
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_mute(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1079
  (cptr->hdw)->mute_dirty = 0;
#line 1080
  return;
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropl(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1080
  *vp = (cptr->hdw)->cropl_val;
#line 1080
  return (0);
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_cropl(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1080
  (cptr->hdw)->cropl_val = v;
#line 1080
  (cptr->hdw)->cropl_dirty = 1;
#line 1080
  return (0);
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_cropl(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1080
  return ((cptr->hdw)->cropl_dirty != 0);
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_cropl(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1080
  (cptr->hdw)->cropl_dirty = 0;
#line 1081
  return;
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropt(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1081
  *vp = (cptr->hdw)->cropt_val;
#line 1081
  return (0);
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_cropt(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1081
  (cptr->hdw)->cropt_val = v;
#line 1081
  (cptr->hdw)->cropt_dirty = 1;
#line 1081
  return (0);
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_cropt(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1081
  return ((cptr->hdw)->cropt_dirty != 0);
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_cropt(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1081
  (cptr->hdw)->cropt_dirty = 0;
#line 1082
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_cropw(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1082
  *vp = (cptr->hdw)->cropw_val;
#line 1082
  return (0);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_cropw(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1082
  (cptr->hdw)->cropw_val = v;
#line 1082
  (cptr->hdw)->cropw_dirty = 1;
#line 1082
  return (0);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_cropw(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1082
  return ((cptr->hdw)->cropw_dirty != 0);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_cropw(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1082
  (cptr->hdw)->cropw_dirty = 0;
#line 1083
  return;
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_croph(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1083
  *vp = (cptr->hdw)->croph_val;
#line 1083
  return (0);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_croph(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1083
  (cptr->hdw)->croph_val = v;
#line 1083
  (cptr->hdw)->croph_dirty = 1;
#line 1083
  return (0);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_croph(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1083
  return ((cptr->hdw)->croph_dirty != 0);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_croph(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1083
  (cptr->hdw)->croph_dirty = 0;
#line 1084
  return;
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_audiomode(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1084
  *vp = (cptr->hdw)->audiomode_val;
#line 1084
  return (0);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_audiomode(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1084
  (cptr->hdw)->audiomode_val = v;
#line 1084
  (cptr->hdw)->audiomode_dirty = 1;
#line 1084
  return (0);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_audiomode(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1084
  return ((cptr->hdw)->audiomode_dirty != 0);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_audiomode(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1084
  (cptr->hdw)->audiomode_dirty = 0;
#line 1085
  return;
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_res_hor(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1085
  *vp = (cptr->hdw)->res_hor_val;
#line 1085
  return (0);
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_res_hor(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1085
  (cptr->hdw)->res_hor_val = v;
#line 1085
  (cptr->hdw)->res_hor_dirty = 1;
#line 1085
  return (0);
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_res_hor(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1085
  return ((cptr->hdw)->res_hor_dirty != 0);
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_res_hor(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1085
  (cptr->hdw)->res_hor_dirty = 0;
#line 1086
  return;
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_res_ver(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1086
  *vp = (cptr->hdw)->res_ver_val;
#line 1086
  return (0);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_res_ver(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1086
  (cptr->hdw)->res_ver_val = v;
#line 1086
  (cptr->hdw)->res_ver_dirty = 1;
#line 1086
  return (0);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_res_ver(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1086
  return ((cptr->hdw)->res_ver_dirty != 0);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_res_ver(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1086
  (cptr->hdw)->res_ver_dirty = 0;
#line 1087
  return;
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_get_srate(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 1087
  *vp = (cptr->hdw)->srate_val;
#line 1087
  return (0);
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_set_srate(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 1087
  (cptr->hdw)->srate_val = v;
#line 1087
  (cptr->hdw)->srate_dirty = 1;
#line 1087
  return (0);
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int ctrl_isdirty_srate(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1087
  return ((cptr->hdw)->srate_dirty != 0);
}
}
#line 1087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void ctrl_cleardirty_srate(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 1087
  (cptr->hdw)->srate_dirty = 0;
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct pvr2_ctl_info  const  control_defs[36U]  = 
#line 1090
  {      {"brightness", "Brightness", & ctrl_get_brightness, 0, 0, 0, & ctrl_set_brightness,
      0, 0, 0, & ctrl_isdirty_brightness, & ctrl_cleardirty_brightness, 0, 0, 9963776,
      0, 0, 128, {{0L, 255L}}}, 
        {"contrast", "Contrast", & ctrl_get_contrast, 0, 0, 0, & ctrl_set_contrast, 0,
      0, 0, & ctrl_isdirty_contrast, & ctrl_cleardirty_contrast, 0, 0, 9963777, 0,
      0, 68, {{0L, 127L}}}, 
        {"saturation", "Saturation", & ctrl_get_saturation, 0, 0, 0, & ctrl_set_saturation,
      0, 0, 0, & ctrl_isdirty_saturation, & ctrl_cleardirty_saturation, 0, 0, 9963778,
      0, 0, 64, {{0L, 127L}}}, 
        {"hue", "Hue", & ctrl_get_hue, 0, 0, 0, & ctrl_set_hue, 0, 0, 0, & ctrl_isdirty_hue,
      & ctrl_cleardirty_hue, 0, 0, 9963779, 0, 0, 0, {{-128L, 127L}}}, 
        {"volume", "Volume", & ctrl_get_volume, 0, 0, 0, & ctrl_set_volume, 0, 0, 0,
      & ctrl_isdirty_volume, & ctrl_cleardirty_volume, 0, 0, 9963781, 0, 0, 62000,
      {{0L, 65535L}}}, 
        {"balance", "Balance", & ctrl_get_balance, 0, 0, 0, & ctrl_set_balance, 0, 0,
      0, & ctrl_isdirty_balance, & ctrl_cleardirty_balance, 0, 0, 9963782, 0, 0, 0,
      {{-32768L, 32767L}}}, 
        {"bass", "Bass", & ctrl_get_bass, 0, 0, 0, & ctrl_set_bass, 0, 0, 0, & ctrl_isdirty_bass,
      & ctrl_cleardirty_bass, 0, 0, 9963783, 0, 0, 0, {{-32768L, 32767L}}}, 
        {"treble", "Treble", & ctrl_get_treble, 0, 0, 0, & ctrl_set_treble, 0, 0, 0,
      & ctrl_isdirty_treble, & ctrl_cleardirty_treble, 0, 0, 9963784, 0, 0, 0, {{-32768L,
                                                                                 32767L}}}, 
        {"mute",
      "Mute", & ctrl_get_mute, 0, 0, 0, & ctrl_set_mute, 0, 0, 0, & ctrl_isdirty_mute,
      & ctrl_cleardirty_mute, 0, 3, 9963785, 0, 0, 0, {{0L, 0L}}}, 
        {"crop_left", "Capture crop left margin", & ctrl_get_cropl, & ctrl_get_cropcapdl,
      & ctrl_cropl_min_get, & ctrl_cropl_max_get, & ctrl_set_cropl, 0, 0, 0, & ctrl_isdirty_cropl,
      & ctrl_cleardirty_cropl, 0, 0, 0, 9, 0, 0, {{-129L, 340L}}}, 
        {"crop_top", "Capture crop top margin", & ctrl_get_cropt, & ctrl_get_cropcapdt,
      & ctrl_cropt_min_get, & ctrl_cropt_max_get, & ctrl_set_cropt, 0, 0, 0, & ctrl_isdirty_cropt,
      & ctrl_cleardirty_cropt, 0, 0, 0, 10, 0, 0, {{-35L, 544L}}}, 
        {"crop_width", "Capture crop width", & ctrl_get_cropw, & ctrl_get_cropcapdw,
      0, & ctrl_cropw_max_get, & ctrl_set_cropw, 0, 0, 0, & ctrl_isdirty_cropw, & ctrl_cleardirty_cropw,
      0, 0, 0, 11, 0, 720, {{0L, 864L}}}, 
        {"crop_height", "Capture crop height", & ctrl_get_croph, & ctrl_get_cropcapdh,
      0, & ctrl_croph_max_get, & ctrl_set_croph, 0, 0, 0, & ctrl_isdirty_croph, & ctrl_cleardirty_croph,
      0, 0, 0, 12, 0, 480, {{0L, 576L}}}, 
        {"cropcap_pixel_numerator", "Capture capability pixel aspect numerator", & ctrl_get_cropcappan,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, {{0L, 0L}}}, 
        {"cropcap_pixel_denominator", "Capture capability pixel aspect denominator",
      & ctrl_get_cropcappad, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_top",
      "Capture capability bounds top", & ctrl_get_cropcapbt, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 16, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_left", "Capture capability bounds left", & ctrl_get_cropcapbl,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_width", "Capture capability bounds width", & ctrl_get_cropcapbw,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_height", "Capture capability bounds height", & ctrl_get_cropcapbh,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, {{0L, 0L}}}, 
        {"input", "Video Source", & ctrl_get_input, 0, 0, 0, & ctrl_set_input, & ctrl_check_input,
      0, 0, & ctrl_isdirty_input, & ctrl_cleardirty_input, 0, 1, 0, 4, 0, 0, {.type_enum = {5U,
                                                                                            (char const   * const  *)(& control_values_input)}}}, 
        {"audio_mode",
      "Audio Mode", & ctrl_get_audiomode, 0, 0, 0, & ctrl_set_audiomode, 0, 0, 0,
      & ctrl_isdirty_audiomode, & ctrl_cleardirty_audiomode, 0, 1, 0, 5, 0, 1, {.type_enum = {5U,
                                                                                              (char const   * const  *)(& control_values_audiomode)}}}, 
        {"resolution_hor",
      "Horizontal capture resolution", & ctrl_get_res_hor, 0, 0, 0, & ctrl_set_res_hor,
      0, 0, 0, & ctrl_isdirty_res_hor, & ctrl_cleardirty_res_hor, 0, 0, 0, 7, 0, 720,
      {{19L, 720L}}}, 
        {"resolution_ver", "Vertical capture resolution", & ctrl_get_res_ver, 0, & ctrl_vres_min_get,
      & ctrl_vres_max_get, & ctrl_set_res_ver, 0, 0, 0, & ctrl_isdirty_res_ver, & ctrl_cleardirty_res_ver,
      0, 0, 0, 8, 0, 480, {{17L, 576L}}}, 
        {"srate", "Audio Sampling Frequency", & ctrl_get_srate, 0, 0, 0, & ctrl_set_srate,
      0, 0, 0, & ctrl_isdirty_srate, & ctrl_cleardirty_srate, 0, 1, 10029412, 0, 0,
      1, {.type_enum = {3U, (char const   * const  *)(& control_values_srate)}}}, 
        {"frequency", "Tuner Frequency (Hz)", & ctrl_freq_get, 0, & ctrl_freq_min_get,
      & ctrl_freq_max_get, & ctrl_freq_set, 0, 0, 0, & ctrl_freq_is_dirty, & ctrl_freq_clear_dirty,
      0, 0, 0, 6, 0, 0, {{0L, 0L}}}, 
        {"channel", "Channel", & ctrl_channel_get, 0, 0, 0, & ctrl_channel_set, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, {{0L, 500L}}}, 
        {"freq_table_value", "Channel Program Frequency", & ctrl_channelfreq_get, 0,
      & ctrl_freq_min_get, & ctrl_freq_max_get, & ctrl_channelfreq_set, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, {{0L, 0L}}}, 
        {"freq_table_channel", "Channel Program ID", & ctrl_channelprog_get, 0, 0, 0,
      & ctrl_channelprog_set, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {{0L, 500L}}}, 
        {"streaming_enabled", "Streaming Enabled", & ctrl_streamingenabled_get, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, {{0L, 0L}}}, 
        {"usb_speed", "USB Speed", & ctrl_hsm_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
      0, 0, 0, {.type_enum = {3U, (char const   * const  *)(& control_values_hsm)}}}, 
        {"master_state",
      "Master State", & ctrl_masterstate_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
      0, 0, 0, {.type_enum = {7U, (char const   * const  *)(& pvr2_state_names)}}}, 
        {"signal_present",
      "Signal Present", & ctrl_signal_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, {{0L, 65535L}}}, 
        {"audio_modes_present", "Audio Modes Present", & ctrl_audio_modes_present_get,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, {.type_bitmask = {15U, (char const   **)(& control_values_audiomode)}}}, 
        {"video_standard_mask_available",
      "Video Standards Available Mask", & ctrl_stdavail_get, 0, 0, 0, & ctrl_stdavail_set,
      0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, 0, 0, 0, 2, 0, 3, 1, 0, {{0L,
                                                                                 0L}}}, 
        {"video_standard_mask_active",
      "Video Standards In Use Mask", & ctrl_stdcur_get, 0, 0, 0, & ctrl_stdcur_set,
      0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, & ctrl_stdcur_is_dirty, & ctrl_stdcur_clear_dirty,
      0, 2, 0, 2, 1, 0, {{0L, 0L}}}, 
        {"video_standard_mask_detected", "Video Standards Detected Mask", & ctrl_stddetect_get,
      0, 0, 0, 0, 0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, 0, 0, 0, 2, 0,
      19, 1, 0, {{0L, 0L}}}};
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_config_get_name(enum pvr2_config cfg ) 
{ 


  {
#line 1370
  switch ((unsigned int )cfg) {
  case 0U: ;
#line 1371
  return ("empty");
  case 1U: ;
#line 1372
  return ("mpeg");
  case 2U: ;
#line 1373
  return ("vbi");
  case 3U: ;
#line 1374
  return ("pcm");
  case 4U: ;
#line 1375
  return ("raw video");
  }
#line 1377
  return ("<unknown>");
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1383
  return (hdw->usb_dev);
}
}
#line 1387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1389
  return (hdw->serial_number);
}
}
#line 1393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1395
  return ((char const   *)(& hdw->bus_info));
}
}
#line 1399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1401
  return ((char const   *)(& hdw->identifier));
}
}
#line 1405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1407
  return ((unsigned long )(hdw->freqSelector != 0U ? hdw->freqValTelevision : hdw->freqValRadio));
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw , unsigned long val ) 
{ 


  {
#line 1414
  if (hdw->input_val == 4) {
#line 1415
    if (hdw->freqSelector != 0U) {
#line 1417
      hdw->freqSelector = 0U;
#line 1418
      hdw->freqDirty = 1;
    } else {

    }
#line 1420
    if ((unsigned long )hdw->freqValRadio != val) {
#line 1421
      hdw->freqValRadio = (unsigned int )val;
#line 1422
      hdw->freqSlotRadio = 0U;
#line 1423
      hdw->freqDirty = 1;
    } else {

    }
  } else {
#line 1426
    if (hdw->freqSelector == 0U) {
#line 1428
      hdw->freqSelector = 1U;
#line 1429
      hdw->freqDirty = 1;
    } else {

    }
#line 1431
    if ((unsigned long )hdw->freqValTelevision != val) {
#line 1432
      hdw->freqValTelevision = (unsigned int )val;
#line 1433
      hdw->freqSlotTelevision = 0U;
#line 1434
      hdw->freqDirty = 1;
    } else {

    }
  }
#line 1437
  return;
}
}
#line 1439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1441
  return (hdw->unit_number);
}
}
#line 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_locate_firmware(struct pvr2_hdw *hdw , struct firmware  const  **fw_entry ,
                                char const   *fwtypename , unsigned int fwcount ,
                                char const   **fwnames ) 
{ 
  unsigned int idx ;
  int ret ;

  {
#line 1458
  ret = -22;
#line 1459
  idx = 0U;
#line 1459
  goto ldv_50714;
  ldv_50713: 
#line 1460
  ret = request_firmware(fw_entry, *(fwnames + (unsigned long )idx), & (hdw->usb_dev)->dev);
#line 1463
  if (ret == 0) {
#line 1464
    if ((pvrusb2_debug & 32768) != 0) {
#line 1464
      printk("\016pvrusb2: Located %s firmware: %s; uploading...\n", fwtypename, *(fwnames + (unsigned long )idx));
    } else {

    }
#line 1468
    return ((int )idx);
  } else {

  }
#line 1470
  if (ret == -2) {
#line 1470
    goto ldv_50712;
  } else {

  }
#line 1471
  if ((pvrusb2_debug & 2) != 0) {
#line 1471
    printk("\016pvrusb2: request_firmware fatal error with code=%d\n", ret);
  } else {

  }
#line 1473
  return (ret);
  ldv_50712: 
#line 1459
  idx = idx + 1U;
  ldv_50714: ;
#line 1459
  if (idx < fwcount) {
#line 1461
    goto ldv_50713;
  } else {

  }

#line 1475
  if ((pvrusb2_debug & 2) != 0) {
#line 1475
    printk("\016pvrusb2: ***WARNING*** Device %s firmware seems to be missing.\n",
           fwtypename);
  } else {

  }
#line 1480
  if ((pvrusb2_debug & 2) != 0) {
#line 1480
    printk("\016pvrusb2: Did you install the pvrusb2 firmware files in their proper location?\n");
  } else {

  }
#line 1483
  if (fwcount == 1U) {
#line 1484
    if ((pvrusb2_debug & 2) != 0) {
#line 1484
      printk("\016pvrusb2: request_firmware unable to locate %s file %s\n", fwtypename,
             *fwnames);
    } else {

    }
  } else {
#line 1488
    if ((pvrusb2_debug & 2) != 0) {
#line 1488
      printk("\016pvrusb2: request_firmware unable to locate one of the following %s files:\n",
             fwtypename);
    } else {

    }
#line 1492
    idx = 0U;
#line 1492
    goto ldv_50717;
    ldv_50716: ;
#line 1493
    if ((pvrusb2_debug & 2) != 0) {
#line 1493
      printk("\016pvrusb2: request_firmware: Failed to find %s\n", *(fwnames + (unsigned long )idx));
    } else {

    }
#line 1492
    idx = idx + 1U;
    ldv_50717: ;
#line 1492
    if (idx < fwcount) {
#line 1494
      goto ldv_50716;
    } else {

    }

  }
#line 1498
  return (ret);
}
}
#line 1512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_upload_firmware1(struct pvr2_hdw *hdw ) 
{ 
  struct firmware  const  *fw_entry ;
  void *fw_ptr ;
  unsigned int pipe ;
  unsigned int fwsize ;
  int ret ;
  u16 address ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 1514
  fw_entry = (struct firmware  const  *)0;
#line 1521
  if ((unsigned int )(hdw->hdw_desc)->fx2_firmware.cnt == 0U) {
#line 1522
    hdw->fw1_state = 4;
#line 1523
    if ((pvrusb2_debug & 2) != 0) {
#line 1523
      printk("\016pvrusb2: Connected device type defines no firmware to upload; ignoring firmware\n");
    } else {

    }
#line 1526
    return (-25);
  } else {

  }
#line 1529
  hdw->fw1_state = 2;
#line 1531
  if ((pvrusb2_debug & 32768) != 0) {
#line 1531
    printk("\016pvrusb2: pvr2_upload_firmware1\n");
  } else {

  }
#line 1533
  ret = pvr2_locate_firmware(hdw, & fw_entry, "fx2 controller", (hdw->hdw_desc)->fx2_firmware.cnt,
                             (hdw->hdw_desc)->fx2_firmware.lst);
#line 1536
  if (ret < 0) {
#line 1537
    if (ret == -2) {
#line 1537
      hdw->fw1_state = 1;
    } else {

    }
#line 1538
    return (ret);
  } else {

  }
#line 1541
  tmp = __create_pipe(hdw->usb_dev, 0U);
#line 1541
  usb_clear_halt(hdw->usb_dev, (int )(tmp | 3221225472U));
#line 1543
  tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 1543
  pipe = tmp___0 | 2147483648U;
#line 1544
  fwsize = (unsigned int )fw_entry->size;
#line 1546
  if (fwsize != 8192U && ((unsigned int )*((unsigned char *)hdw->hdw_desc + 88UL) == 0U || fwsize != 16384U)) {
#line 1548
    if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 88UL) != 0U) {
#line 1549
      if ((pvrusb2_debug & 2) != 0) {
#line 1549
        printk("\016pvrusb2: Wrong fx2 firmware size (expected 8192 or 16384, got %u)\n",
               fwsize);
      } else {

      }
    } else
#line 1554
    if ((pvrusb2_debug & 2) != 0) {
#line 1554
      printk("\016pvrusb2: Wrong fx2 firmware size (expected 8192, got %u)\n", fwsize);
    } else {

    }
#line 1559
    release_firmware(fw_entry);
#line 1560
    return (-12);
  } else {

  }
#line 1563
  fw_ptr = kmalloc(2048UL, 208U);
#line 1564
  if ((unsigned long )fw_ptr == (unsigned long )((void *)0)) {
#line 1565
    release_firmware(fw_entry);
#line 1566
    return (-12);
  } else {

  }
#line 1570
  pvr2_hdw_cpureset_assert(hdw, 1);
#line 1575
  ret = 0;
#line 1576
  address = 0U;
#line 1576
  goto ldv_50732;
  ldv_50731: 
#line 1577
  __len = 2048UL;
#line 1577
  if (__len > 63UL) {
#line 1577
    __ret = __memcpy(fw_ptr, (void const   *)fw_entry->data + (unsigned long )address,
                     __len);
  } else {
#line 1577
    __ret = __builtin_memcpy(fw_ptr, (void const   *)fw_entry->data + (unsigned long )address,
                             __len);
  }
#line 1578
  tmp___1 = usb_control_msg(hdw->usb_dev, pipe, 160, 64, (int )address, 0, fw_ptr,
                            2048, 250);
#line 1578
  ret = tmp___1 + ret;
#line 1576
  address = (unsigned int )address + 2048U;
  ldv_50732: ;
#line 1576
  if ((unsigned int )address < fwsize) {
#line 1578
    goto ldv_50731;
  } else {

  }

#line 1582
  if ((pvrusb2_debug & 32768) != 0) {
#line 1582
    printk("\016pvrusb2: Upload done, releasing device\'s CPU\n");
  } else {

  }
#line 1585
  pvr2_hdw_cpureset_assert(hdw, 0);
#line 1587
  kfree((void const   *)fw_ptr);
#line 1588
  release_firmware(fw_entry);
#line 1590
  if ((pvrusb2_debug & 32768) != 0) {
#line 1590
    printk("\016pvrusb2: Upload done (%d bytes sent)\n", ret);
  } else {

  }
#line 1593
  if ((unsigned int )ret == fwsize) {
#line 1594
    hdw->fw1_state = 3;
#line 1595
    return (0);
  } else {

  }
#line 1598
  return (-5);
}
}
#line 1609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_upload_firmware2(struct pvr2_hdw *hdw ) 
{ 
  struct firmware  const  *fw_entry ;
  void *fw_ptr ;
  unsigned int pipe ;
  unsigned int fw_len ;
  unsigned int fw_done ;
  unsigned int bcnt ;
  unsigned int icnt ;
  int actual_length ;
  int ret ;
  int fwidx ;
  char const   *fw_files[1U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 1611
  fw_entry = (struct firmware  const  *)0;
#line 1615
  ret = 0;
#line 1617
  fw_files[0] = "v4l-cx2341x-enc.fw";
#line 1621
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 1622
    return (0);
  } else {

  }
#line 1625
  if ((pvrusb2_debug & 32768) != 0) {
#line 1625
    printk("\016pvrusb2: pvr2_upload_firmware2\n");
  } else {

  }
#line 1627
  ret = pvr2_locate_firmware(hdw, & fw_entry, "encoder", 1U, (char const   **)(& fw_files));
#line 1629
  if (ret < 0) {
#line 1629
    return (ret);
  } else {

  }
#line 1630
  fwidx = ret;
#line 1631
  ret = 0;
#line 1635
  hdw->enc_cur_valid = 0;
#line 1639
  ldv_del_timer_sync_291(& hdw->encoder_run_timer);
#line 1640
  if (hdw->state_encoder_runok != 0) {
#line 1641
    hdw->state_encoder_runok = 0;
#line 1642
    trace_stbit("state_encoder_runok", hdw->state_encoder_runok);
  } else {

  }
#line 1646
  tmp = pvr2_write_register(hdw, 72, 4294967295U);
#line 1646
  ret = tmp | ret;
#line 1647
  tmp___0 = pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 136U);
#line 1647
  ret = tmp___0 | ret;
#line 1648
  tmp___1 = pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 8U);
#line 1648
  ret = tmp___1 | ret;
#line 1649
  tmp___2 = pvr2_hdw_cmd_deep_reset(hdw);
#line 1649
  ret = tmp___2 | ret;
#line 1650
  tmp___3 = pvr2_write_register(hdw, 41060, 0U);
#line 1650
  ret = tmp___3 | ret;
#line 1651
  tmp___4 = pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1032U);
#line 1651
  ret = tmp___4 | ret;
#line 1652
  tmp___5 = pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 8U);
#line 1652
  ret = tmp___5 | ret;
#line 1653
  tmp___6 = pvr2_write_register(hdw, 36952, 4294967277U);
#line 1653
  ret = tmp___6 | ret;
#line 1654
  tmp___7 = pvr2_write_register(hdw, 36948, 4294967293U);
#line 1654
  ret = tmp___7 | ret;
#line 1655
  tmp___8 = pvr2_write_register(hdw, 2040, 2147485696U);
#line 1655
  ret = tmp___8 | ret;
#line 1656
  tmp___9 = pvr2_write_register(hdw, 2044, 26U);
#line 1656
  ret = tmp___9 | ret;
#line 1657
  tmp___10 = pvr2_write_register(hdw, 1792, 0U);
#line 1657
  ret = tmp___10 | ret;
#line 1658
  tmp___11 = pvr2_write_register(hdw, 43520, 0U);
#line 1658
  ret = tmp___11 | ret;
#line 1659
  tmp___12 = pvr2_write_register(hdw, 43524, 358416U);
#line 1659
  ret = tmp___12 | ret;
#line 1660
  tmp___13 = pvr2_write_register(hdw, 43536, 1344768U);
#line 1660
  ret = tmp___13 | ret;
#line 1661
  tmp___14 = pvr2_write_register(hdw, 43544, 8650752U);
#line 1661
  ret = tmp___14 | ret;
#line 1662
  tmp___15 = pvr2_issue_simple_cmd(hdw, 82U);
#line 1662
  ret = tmp___15 | ret;
#line 1663
  tmp___16 = pvr2_issue_simple_cmd(hdw, 262U);
#line 1663
  ret = tmp___16 | ret;
#line 1665
  if (ret != 0) {
#line 1666
    if ((pvrusb2_debug & 2) != 0) {
#line 1666
      printk("\016pvrusb2: firmware2 upload prep failed, ret=%d\n", ret);
    } else {

    }
#line 1668
    release_firmware(fw_entry);
#line 1669
    goto done;
  } else {

  }
#line 1674
  fw_len = (unsigned int )fw_entry->size;
#line 1676
  if ((fw_len & 3U) != 0U) {
#line 1677
    if ((pvrusb2_debug & 2) != 0) {
#line 1677
      printk("\016pvrusb2: size of %s firmware must be a multiple of %zu bytes\n",
             fw_files[fwidx], 4UL);
    } else {

    }
#line 1681
    release_firmware(fw_entry);
#line 1682
    ret = -22;
#line 1683
    goto done;
  } else {

  }
#line 1686
  fw_ptr = kmalloc(8192UL, 208U);
#line 1687
  if ((unsigned long )fw_ptr == (unsigned long )((void *)0)) {
#line 1688
    release_firmware(fw_entry);
#line 1689
    if ((pvrusb2_debug & 2) != 0) {
#line 1689
      printk("\016pvrusb2: failed to allocate memory for firmware2 upload\n");
    } else {

    }
#line 1691
    ret = -12;
#line 1692
    goto done;
  } else {

  }
#line 1695
  tmp___17 = __create_pipe(hdw->usb_dev, 2U);
#line 1695
  pipe = tmp___17 | 3221225472U;
#line 1697
  fw_done = 0U;
#line 1698
  fw_done = 0U;
#line 1698
  goto ldv_50759;
  ldv_50758: 
#line 1699
  bcnt = fw_len - fw_done;
#line 1700
  if (bcnt > 8192U) {
#line 1700
    bcnt = 8192U;
  } else {

  }
#line 1701
  __len = (size_t )bcnt;
#line 1701
  __ret = __builtin_memcpy(fw_ptr, (void const   *)fw_entry->data + (unsigned long )fw_done,
                           __len);
#line 1714
  icnt = 0U;
#line 1714
  goto ldv_50755;
  ldv_50754: 
#line 1715
  tmp___18 = __fswab32(*((u32 *)fw_ptr + (unsigned long )icnt));
#line 1715
  *((u32 *)fw_ptr + (unsigned long )icnt) = tmp___18;
#line 1714
  icnt = icnt + 1U;
  ldv_50755: ;
#line 1714
  if (bcnt / 4U > icnt) {
#line 1716
    goto ldv_50754;
  } else {

  }
#line 1717
  tmp___19 = usb_bulk_msg(hdw->usb_dev, pipe, fw_ptr, (int )bcnt, & actual_length,
                          250);
#line 1717
  ret = tmp___19 | ret;
#line 1719
  ret = ((unsigned int )actual_length != bcnt) | ret;
#line 1720
  if (ret != 0) {
#line 1720
    goto ldv_50757;
  } else {

  }
#line 1721
  fw_done = fw_done + bcnt;
  ldv_50759: ;
#line 1698
  if (fw_done < fw_len) {
#line 1700
    goto ldv_50758;
  } else {

  }
  ldv_50757: ;
#line 1724
  if ((pvrusb2_debug & 32768) != 0) {
#line 1724
    printk("\016pvrusb2: upload of %s : %i / %i \n", fw_files[fwidx], fw_done, fw_len);
  } else {

  }
#line 1727
  kfree((void const   *)fw_ptr);
#line 1728
  release_firmware(fw_entry);
#line 1730
  if (ret != 0) {
#line 1731
    if ((pvrusb2_debug & 2) != 0) {
#line 1731
      printk("\016pvrusb2: firmware2 upload transfer failure\n");
    } else {

    }
#line 1733
    goto done;
  } else {

  }
#line 1738
  tmp___20 = pvr2_write_register(hdw, 36948, 4294967295U);
#line 1738
  ret = tmp___20 | ret;
#line 1739
  tmp___21 = pvr2_write_register(hdw, 36952, 4294967272U);
#line 1739
  ret = tmp___21 | ret;
#line 1740
  tmp___22 = pvr2_issue_simple_cmd(hdw, 262U);
#line 1740
  ret = tmp___22 | ret;
#line 1742
  if (ret != 0) {
#line 1743
    if ((pvrusb2_debug & 2) != 0) {
#line 1743
      printk("\016pvrusb2: firmware2 upload post-proc failure\n");
    } else {

    }
  } else {

  }
  done: ;
#line 1748
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 1752
    pvr2_hdw_gpio_chg_dir(hdw, 2048U, 4294967295U);
  } else {

  }
#line 1754
  return (ret);
}
}
#line 1758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *pvr2_get_state_name(unsigned int st ) 
{ 


  {
#line 1760
  if (st <= 6U) {
#line 1761
    return (pvr2_state_names[st]);
  } else {

  }
#line 1763
  return ("???");
}
}
#line 1766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_decoder_enable(struct pvr2_hdw *hdw , int enablefl ) 
{ 
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 1772
  if ((pvrusb2_debug & 65536) != 0) {
#line 1772
    printk("\016pvrusb2: subdev v4l2 stream=%s\n", enablefl != 0 ? (char *)"on" : (char *)"off");
  } else {

  }
#line 1774
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 1774
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 1774
  goto ldv_50775;
  ldv_50774: ;
#line 1774
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                               int  ))0)) {
#line 1774
    (*(((__sd->ops)->video)->s_stream))(__sd, enablefl);
  } else {

  }
#line 1774
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1774
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_50775: ;
#line 1774
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 1776
    goto ldv_50774;
  } else {

  }
#line 1775
  __mptr___1 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 1775
  __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff80UL;
#line 1775
  goto ldv_50783;
  ldv_50782: ;
#line 1775
  if ((unsigned long )(__sd___0->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->audio)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                       int  ))0)) {
#line 1775
    (*(((__sd___0->ops)->audio)->s_stream))(__sd___0, enablefl);
  } else {

  }
#line 1775
  __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1775
  __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff80UL;
  ldv_50783: ;
#line 1775
  if ((unsigned long )(& __sd___0->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 1777
    goto ldv_50782;
  } else {

  }

#line 1776
  if (hdw->decoder_client_id != 0U) {
#line 1780
    return (0);
  } else {

  }
#line 1782
  if (hdw->flag_decoder_missed == 0) {
#line 1783
    if ((pvrusb2_debug & 2) != 0) {
#line 1783
      printk("\016pvrusb2: WARNING: No decoder present\n");
    } else {

    }
#line 1785
    hdw->flag_decoder_missed = 1;
#line 1786
    trace_stbit("flag_decoder_missed", hdw->flag_decoder_missed);
  } else {

  }
#line 1789
  return (-5);
}
}
#line 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_get_state(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1795
  return ((int )hdw->master_state);
}
}
#line 1799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1801
  if (hdw->flag_tripped == 0) {
#line 1801
    return (0);
  } else {

  }
#line 1802
  hdw->flag_tripped = 0;
#line 1803
  if ((pvrusb2_debug & 2) != 0) {
#line 1803
    printk("\016pvrusb2: Clearing driver error statuss\n");
  } else {

  }
#line 1805
  return (1);
}
}
#line 1809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_untrip(struct pvr2_hdw *hdw ) 
{ 
  int fl ;

  {
#line 1812
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 1812
  hdw->big_lock_held = 1;
#line 1813
  fl = pvr2_hdw_untrip_unlocked(hdw);
#line 1814
  hdw->big_lock_held = 0;
#line 1814
  mutex_unlock(& hdw->big_lock_mutex);
#line 1815
  if (fl != 0) {
#line 1815
    pvr2_hdw_state_sched(hdw);
  } else {

  }
#line 1816
  return (0);
}
}
#line 1822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_get_streaming(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1824
  return (hdw->state_pipeline_req != 0);
}
}
#line 1828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_set_streaming(struct pvr2_hdw *hdw , int enable_flag ) 
{ 
  int ret ;
  int st ;

  {
#line 1831
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 1831
  hdw->big_lock_held = 1;
#line 1832
  pvr2_hdw_untrip_unlocked(hdw);
#line 1833
  if ((enable_flag == 0) ^ (hdw->state_pipeline_req == 0)) {
#line 1834
    hdw->state_pipeline_req = enable_flag != 0;
#line 1835
    if ((pvrusb2_debug & 64) != 0) {
#line 1835
      printk("\016pvrusb2: /*--TRACE_STREAM--*/ %s\n", enable_flag != 0 ? (char *)"enable" : (char *)"disable");
    } else {

    }
  } else {

  }
#line 1839
  pvr2_hdw_state_sched(hdw);
#line 1840
  hdw->big_lock_held = 0;
#line 1840
  mutex_unlock(& hdw->big_lock_mutex);
#line 1841
  ret = pvr2_hdw_wait(hdw, 0);
#line 1841
  if (ret < 0) {
#line 1841
    return (ret);
  } else {

  }
#line 1842
  if (enable_flag != 0) {
#line 1843
    goto ldv_50805;
    ldv_50804: ;
#line 1844
    if (st != 5) {
#line 1844
      return (-5);
    } else {

    }
#line 1845
    ret = pvr2_hdw_wait(hdw, st);
#line 1845
    if (ret < 0) {
#line 1845
      return (ret);
    } else {

    }
    ldv_50805: 
#line 1843
    st = (int )hdw->master_state;
#line 1843
    if (st != 6) {
#line 1845
      goto ldv_50804;
    } else {

    }

  } else {

  }
#line 1848
  return (0);
}
}
#line 1852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw , enum pvr2_config config ) 
{ 
  int fl ;
  int tmp ;

  {
#line 1855
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 1855
  hdw->big_lock_held = 1;
#line 1856
  fl = (unsigned int )hdw->desired_stream_type != (unsigned int )config;
#line 1856
  if (fl != 0) {
#line 1857
    hdw->desired_stream_type = config;
#line 1858
    hdw->state_pipeline_config = 0;
#line 1859
    trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 1861
    pvr2_hdw_state_sched(hdw);
  } else {

  }
#line 1863
  hdw->big_lock_held = 0;
#line 1863
  mutex_unlock(& hdw->big_lock_mutex);
#line 1864
  if (fl != 0) {
#line 1864
    return (0);
  } else {

  }
#line 1865
  tmp = pvr2_hdw_wait(hdw, 0);
#line 1865
  return (tmp);
}
}
#line 1869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int get_default_tuner_type(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1871
  unit_number = hdw->unit_number;
#line 1872
  tp = -1;
#line 1873
  if (unit_number >= 0 && unit_number <= 19) {
#line 1874
    tp = tuner[unit_number];
  } else {

  }
#line 1876
  if (tp < 0) {
#line 1876
    return (-22);
  } else {

  }
#line 1877
  hdw->tuner_type = (unsigned int )tp;
#line 1878
  hdw->tuner_updated = 1;
#line 1879
  return (0);
}
}
#line 1883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static v4l2_std_id get_default_standard(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1885
  unit_number = hdw->unit_number;
#line 1886
  tp = 0;
#line 1887
  if (unit_number >= 0 && unit_number <= 19) {
#line 1888
    tp = video_std[unit_number];
#line 1889
    if (tp != 0) {
#line 1889
      return ((v4l2_std_id )tp);
    } else {

    }
  } else {

  }
#line 1891
  return (0ULL);
}
}
#line 1895 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int get_default_error_tolerance(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1897
  unit_number = hdw->unit_number;
#line 1898
  tp = 0;
#line 1899
  if (unit_number >= 0 && unit_number <= 19) {
#line 1900
    tp = tolerance[unit_number];
  } else {

  }
#line 1902
  return ((unsigned int )tp);
}
}
#line 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_check_firmware(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 1913
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 1913
  hdw->ctl_lock_held = 1;
#line 1914
  hdw->cmd_buffer[0] = 235U;
#line 1915
  result = pvr2_send_request_ex(hdw, 250U, 1, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                                1U);
#line 1918
  if (result < 0) {

  } else {

  }
#line 1919
  hdw->ctl_lock_held = 0;
#line 1919
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 1920
  if (result != 0) {
#line 1921
    if ((pvrusb2_debug & 32) != 0) {
#line 1921
      printk("\016pvrusb2: Probe of device endpoint 1 result status %d\n", result);
    } else {

    }
  } else
#line 1925
  if ((pvrusb2_debug & 32) != 0) {
#line 1925
    printk("\016pvrusb2: Probe of device endpoint 1 succeeded\n");
  } else {

  }
#line 1928
  return (result == 0);
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static struct pvr2_std_hack  const  std_eeprom_maps[5U]  = {      {851983ULL, 0ULL, 7ULL}, 
        {46848ULL, 0ULL, 4096ULL}, 
        {16ULL, 0ULL, 16ULL}, 
        {12582912ULL, 0ULL, 12582912ULL}, 
        {3277024ULL, 0ULL, 224ULL}};
#line 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_setup_std(struct pvr2_hdw *hdw ) 
{ 
  char buf[40U] ;
  unsigned int bcnt ;
  v4l2_std_id std1 ;
  v4l2_std_id std2 ;
  v4l2_std_id std3 ;
  unsigned int idx ;

  {
#line 1975
  std1 = get_default_standard(hdw);
#line 1976
  std3 = std1 == 0ULL ? (hdw->hdw_desc)->default_std_mask : 0ULL;
#line 1978
  bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, hdw->std_mask_eeprom);
#line 1979
  if ((pvrusb2_debug & 16) != 0) {
#line 1979
    printk("\016pvrusb2: Supported video standard(s) reported available in hardware: %.*s\n",
           bcnt, (char *)(& buf));
  } else {

  }
#line 1984
  hdw->std_mask_avail = hdw->std_mask_eeprom;
#line 1986
  std2 = (std1 | std3) & ~ hdw->std_mask_avail;
#line 1987
  if (std2 != 0ULL) {
#line 1988
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std2);
#line 1989
    if ((pvrusb2_debug & 16) != 0) {
#line 1989
      printk("\016pvrusb2: Expanding supported video standards to include: %.*s\n",
             bcnt, (char *)(& buf));
    } else {

    }
#line 1993
    hdw->std_mask_avail = hdw->std_mask_avail | std2;
  } else {

  }
#line 1996
  hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )hdw->std_mask_avail;
#line 1998
  if (std1 != 0ULL) {
#line 1999
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std1);
#line 2000
    if ((pvrusb2_debug & 16) != 0) {
#line 2000
      printk("\016pvrusb2: Initial video standard forced to %.*s\n", bcnt, (char *)(& buf));
    } else {

    }
#line 2003
    hdw->std_mask_cur = std1;
#line 2004
    hdw->std_dirty = 1;
#line 2005
    return;
  } else {

  }
#line 2007
  if (std3 != 0ULL) {
#line 2008
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std3);
#line 2009
    if ((pvrusb2_debug & 16) != 0) {
#line 2009
      printk("\016pvrusb2: Initial video standard (determined by device type): %.*s\n",
             bcnt, (char *)(& buf));
    } else {

    }
#line 2012
    hdw->std_mask_cur = std3;
#line 2013
    hdw->std_dirty = 1;
#line 2014
    return;
  } else {

  }
#line 2019
  idx = 0U;
#line 2019
  goto ldv_50850;
  ldv_50849: ;
#line 2020
  if ((unsigned long long )std_eeprom_maps[idx].msk != 0ULL ? (((unsigned long long )std_eeprom_maps[idx].pat ^ hdw->std_mask_eeprom) & (unsigned long long )std_eeprom_maps[idx].msk) != 0ULL : (unsigned long long )std_eeprom_maps[idx].pat != hdw->std_mask_eeprom) {
#line 2025
    goto ldv_50848;
  } else {

  }
#line 2026
  bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std_eeprom_maps[idx].std);
#line 2028
  if ((pvrusb2_debug & 16) != 0) {
#line 2028
    printk("\016pvrusb2: Initial video standard guessed as %.*s\n", bcnt, (char *)(& buf));
  } else {

  }
#line 2031
  hdw->std_mask_cur = std_eeprom_maps[idx].std;
#line 2032
  hdw->std_dirty = 1;
#line 2033
  return;
  ldv_50848: 
#line 2019
  idx = idx + 1U;
  ldv_50850: ;
#line 2019
  if (idx <= 4U) {
#line 2021
    goto ldv_50849;
  } else {

  }

#line 2027
  return;
}
}
#line 2040 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int pvr2_copy_i2c_addr_list(unsigned short *dst , unsigned char const   *src ,
                                            unsigned int dst_max ) 
{ 
  unsigned int cnt ;

  {
#line 2044
  cnt = 0U;
#line 2045
  if ((unsigned long )src == (unsigned long )((unsigned char const   *)0U)) {
#line 2045
    return (0U);
  } else {

  }
#line 2046
  goto ldv_50859;
  ldv_50858: 
#line 2047
  *(dst + (unsigned long )cnt) = (unsigned short )*(src + (unsigned long )cnt);
#line 2048
  cnt = cnt + 1U;
  ldv_50859: ;
#line 2046
  if ((unsigned int )((unsigned char )*(src + (unsigned long )cnt)) != 0U && cnt + 1U < dst_max) {
#line 2048
    goto ldv_50858;
  } else {

  }
#line 2050
  *(dst + (unsigned long )cnt) = 65534U;
#line 2051
  return (cnt);
}
}
#line 2055 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_cx25840_vbi_hack(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_format fmt ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2067
  if (hdw->decoder_client_id != 2U) {
#line 2069
    return;
  } else {

  }
#line 2072
  if ((pvrusb2_debug & 32) != 0) {
#line 2072
    printk("\016pvrusb2: Module ID %u: Executing cx25840 VBI hack\n", hdw->decoder_client_id);
  } else {

  }
#line 2076
  memset((void *)(& fmt), 0, 208UL);
#line 2077
  fmt.type = 6U;
#line 2078
  fmt.fmt.sliced.service_lines[0][21] = 4096U;
#line 2079
  fmt.fmt.sliced.service_lines[1][21] = 4096U;
#line 2080
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2080
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 2080
  goto ldv_50871;
  ldv_50870: ;
#line 2080
  if (((hdw->decoder_client_id == 0U || __sd->grp_id == hdw->decoder_client_id) && (unsigned long )(__sd->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                           struct v4l2_sliced_vbi_format * ))0)) {
#line 2080
    (*(((__sd->ops)->vbi)->s_sliced_fmt))(__sd, & fmt.fmt.sliced);
  } else {

  }
#line 2080
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2080
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_50871: ;
#line 2080
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2082
    goto ldv_50870;
  } else {

  }

#line 2088
  return;
}
}
#line 2085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_load_subdev(struct pvr2_hdw *hdw , struct pvr2_device_client_desc  const  *cd ) 
{ 
  char const   *fname ;
  unsigned char mid ;
  struct v4l2_subdev *sd ;
  unsigned int i2ccnt ;
  unsigned char const   *p ;
  unsigned short i2caddr[25U] ;

  {
#line 2096
  mid = cd->module_id;
#line 2097
  fname = (unsigned int )mid <= 7U ? module_names[(int )mid] : (char const   *)0;
#line 2098
  if ((unsigned long )fname == (unsigned long )((char const   *)0)) {
#line 2099
    if ((pvrusb2_debug & 2) != 0) {
#line 2099
      printk("\016pvrusb2: Module ID %u for device %s has no name?  The driver might have a configuration problem.\n",
             (int )mid, (hdw->hdw_desc)->description);
    } else {

    }
#line 2104
    return (-22);
  } else {

  }
#line 2106
  if ((pvrusb2_debug & 32) != 0) {
#line 2106
    printk("\016pvrusb2: Module ID %u (%s) for device %s being loaded...\n", (int )mid,
           fname, (hdw->hdw_desc)->description);
  } else {

  }
#line 2111
  i2ccnt = pvr2_copy_i2c_addr_list((unsigned short *)(& i2caddr), (unsigned char const   *)cd->i2c_address_list,
                                   25U);
#line 2113
  if (i2ccnt == 0U) {
#line 2113
    p = (unsigned int )mid <= 7U ? module_i2c_addresses[(int )mid] : (unsigned char const   *)0U;
#line 2113
    if ((unsigned long )p != (unsigned long )((unsigned char const   *)0U)) {
#line 2116
      i2ccnt = pvr2_copy_i2c_addr_list((unsigned short *)(& i2caddr), p, 25U);
#line 2118
      if (i2ccnt != 0U) {
#line 2119
        if ((pvrusb2_debug & 32) != 0) {
#line 2119
          printk("\016pvrusb2: Module ID %u: Using default i2c address list\n", (int )mid);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 2126
  if (i2ccnt == 0U) {
#line 2127
    if ((pvrusb2_debug & 2) != 0) {
#line 2127
      printk("\016pvrusb2: Module ID %u (%s) for device %s: No i2c addresses.  The driver might have a configuration problem.\n",
             (int )mid, fname, (hdw->hdw_desc)->description);
    } else {

    }
#line 2132
    return (-22);
  } else {

  }
#line 2135
  if (i2ccnt == 1U) {
#line 2136
    if ((pvrusb2_debug & 32) != 0) {
#line 2136
      printk("\016pvrusb2: Module ID %u: Setting up with specified i2c address 0x%x\n",
             (int )mid, (int )i2caddr[0]);
    } else {

    }
#line 2140
    sd = v4l2_i2c_new_subdev(& hdw->v4l2_dev, & hdw->i2c_adap, fname, (int )((u8 )i2caddr[0]),
                             (unsigned short const   *)0U);
  } else {
#line 2143
    if ((pvrusb2_debug & 32) != 0) {
#line 2143
      printk("\016pvrusb2: Module ID %u: Setting up with address probe list\n", (int )mid);
    } else {

    }
#line 2147
    sd = v4l2_i2c_new_subdev(& hdw->v4l2_dev, & hdw->i2c_adap, fname, 0, (unsigned short const   *)(& i2caddr));
  }
#line 2151
  if ((unsigned long )sd == (unsigned long )((struct v4l2_subdev *)0)) {
#line 2152
    if ((pvrusb2_debug & 2) != 0) {
#line 2152
      printk("\016pvrusb2: Module ID %u (%s) for device %s failed to load.  Possible missing sub-device kernel module or initialization failure within module.\n",
             (int )mid, fname, (hdw->hdw_desc)->description);
    } else {

    }
#line 2157
    return (-5);
  } else {

  }
#line 2163
  sd->grp_id = (u32 )mid;
#line 2165
  if (pvrusb2_debug & 1) {
#line 2165
    printk("\016pvrusb2: Attached sub-driver %s\n", fname);
  } else {

  }
#line 2169
  switch ((int )mid) {
  case 2: ;
  case 3: 
#line 2172
  hdw->decoder_client_id = (unsigned int )mid;
#line 2173
  goto ldv_50893;
  default: ;
#line 2174
  goto ldv_50893;
  }
  ldv_50893: ;
#line 2177
  return (0);
}
}
#line 2181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_load_modules(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_string_table  const  *cm ;
  struct pvr2_device_client_table  const  *ct ;
  int okFl ;
  int tmp ;

  {
#line 2186
  okFl = 1;
#line 2188
  cm = & (hdw->hdw_desc)->client_modules;
#line 2189
  idx = 0U;
#line 2189
  goto ldv_50903;
  ldv_50902: 
#line 2190
  __request_module(1, *(cm->lst + (unsigned long )idx));
#line 2189
  idx = idx + 1U;
  ldv_50903: ;
#line 2189
  if ((unsigned int )cm->cnt > idx) {
#line 2191
    goto ldv_50902;
  } else {

  }
#line 2193
  ct = & (hdw->hdw_desc)->client_table;
#line 2194
  idx = 0U;
#line 2194
  goto ldv_50906;
  ldv_50905: 
#line 2195
  tmp = pvr2_hdw_load_subdev(hdw, ct->lst + (unsigned long )idx);
#line 2195
  if (tmp < 0) {
#line 2195
    okFl = 0;
  } else {

  }
#line 2194
  idx = idx + 1U;
  ldv_50906: ;
#line 2194
  if ((unsigned int )ct->cnt > idx) {
#line 2196
    goto ldv_50905;
  } else {

  }

#line 2197
  if (okFl == 0) {
#line 2198
    hdw->flag_modulefail = 1;
#line 2199
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 2201
  return;
}
}
#line 2204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_setup_low(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int reloadFl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2209
  reloadFl = 0;
#line 2210
  if ((unsigned int )(hdw->hdw_desc)->fx2_firmware.cnt != 0U) {
#line 2211
    if (reloadFl == 0) {
#line 2212
      reloadFl = (unsigned int )((hdw->usb_intf)->cur_altsetting)->desc.bNumEndpoints == 0U;
#line 2215
      if (reloadFl != 0) {
#line 2216
        if ((pvrusb2_debug & 32) != 0) {
#line 2216
          printk("\016pvrusb2: USB endpoint config looks strange; possibly firmware needs to be loaded\n");
        } else {

        }
      } else {

      }
    } else {

    }
#line 2222
    if (reloadFl == 0) {
#line 2223
      tmp = pvr2_hdw_check_firmware(hdw);
#line 2223
      reloadFl = tmp == 0;
#line 2224
      if (reloadFl != 0) {
#line 2225
        if ((pvrusb2_debug & 32) != 0) {
#line 2225
          printk("\016pvrusb2: Check for FX2 firmware failed; possibly firmware needs to be loaded\n");
        } else {

        }
      } else {

      }
    } else {

    }
#line 2231
    if (reloadFl != 0) {
#line 2232
      tmp___0 = pvr2_upload_firmware1(hdw);
#line 2232
      if (tmp___0 != 0) {
#line 2233
        if ((pvrusb2_debug & 2) != 0) {
#line 2233
          printk("\016pvrusb2: Failure uploading firmware1\n");
        } else {

        }
      } else {

      }
#line 2236
      return;
    } else {

    }
  } else {

  }
#line 2239
  hdw->fw1_state = 4;
#line 2241
  tmp___1 = pvr2_hdw_dev_ok(hdw);
#line 2241
  if (tmp___1 == 0) {
#line 2241
    return;
  } else {

  }
#line 2243
  hdw->force_dirty = 1;
#line 2245
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) == 0U) {
#line 2246
    pvr2_hdw_cmd_powerup(hdw);
#line 2247
    tmp___2 = pvr2_hdw_dev_ok(hdw);
#line 2247
    if (tmp___2 == 0) {
#line 2247
      return;
    } else {

    }
  } else {

  }
#line 2251
  if (hdw->ir_scheme_active == 2U) {
#line 2252
    pvr2_issue_simple_cmd(hdw, 272U);
  } else {

  }
#line 2259
  pvr2_i2c_core_init(hdw);
#line 2260
  tmp___3 = pvr2_hdw_dev_ok(hdw);
#line 2260
  if (tmp___3 == 0) {
#line 2260
    return;
  } else {

  }
#line 2262
  pvr2_hdw_load_modules(hdw);
#line 2263
  tmp___4 = pvr2_hdw_dev_ok(hdw);
#line 2263
  if (tmp___4 == 0) {
#line 2263
    return;
  } else {

  }
#line 2265
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2265
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 2265
  goto ldv_50921;
  ldv_50920: ;
#line 2265
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->load_fw != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 2265
    (*(((__sd->ops)->core)->load_fw))(__sd);
  } else {

  }
#line 2265
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2265
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_50921: ;
#line 2265
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2267
    goto ldv_50920;
  } else {

  }
#line 2267
  idx = 0U;
#line 2267
  goto ldv_50927;
  ldv_50926: 
#line 2268
  cptr = hdw->controls + (unsigned long )idx;
#line 2269
  if ((int )(cptr->info)->skip_init != 0) {
#line 2269
    goto ldv_50925;
  } else {

  }
#line 2270
  if ((unsigned long )(cptr->info)->set_value == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 2270
    goto ldv_50925;
  } else {

  }
#line 2271
  (*((cptr->info)->set_value))(cptr, -1, (cptr->info)->default_value);
  ldv_50925: 
#line 2267
  idx = idx + 1U;
  ldv_50927: ;
#line 2267
  if (idx <= 35U) {
#line 2269
    goto ldv_50926;
  } else {

  }
#line 2274
  pvr2_hdw_cx25840_vbi_hack(hdw);
#line 2281
  hdw->freqValTelevision = (unsigned int )default_tv_freq;
#line 2282
  hdw->freqValRadio = (unsigned int )default_radio_freq;
#line 2288
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 2289
    ret = pvr2_hdw_get_eeprom_addr(hdw);
#line 2290
    tmp___5 = pvr2_hdw_dev_ok(hdw);
#line 2290
    if (tmp___5 == 0) {
#line 2290
      return;
    } else {

    }
#line 2291
    if (ret < 0) {
#line 2292
      if ((pvrusb2_debug & 2) != 0) {
#line 2292
        printk("\016pvrusb2: Unable to determine location of eeprom, skipping\n");
      } else {

      }
    } else {
#line 2296
      hdw->eeprom_addr = ret;
#line 2297
      pvr2_eeprom_analyze(hdw);
#line 2298
      tmp___6 = pvr2_hdw_dev_ok(hdw);
#line 2298
      if (tmp___6 == 0) {
#line 2298
        return;
      } else {

      }
    }
  } else {
#line 2301
    hdw->tuner_type = (unsigned int )(hdw->hdw_desc)->default_tuner_type;
#line 2302
    hdw->tuner_updated = 1;
#line 2303
    hdw->std_mask_eeprom = 16777215ULL;
  }
#line 2306
  if (hdw->serial_number != 0UL) {
#line 2307
    tmp___7 = scnprintf((char *)(& hdw->identifier), 31UL, "sn-%lu", hdw->serial_number);
#line 2307
    idx = (unsigned int )tmp___7;
  } else
#line 2309
  if (hdw->unit_number >= 0) {
#line 2310
    tmp___8 = scnprintf((char *)(& hdw->identifier), 31UL, "unit-%c", hdw->unit_number + 97);
#line 2310
    idx = (unsigned int )tmp___8;
  } else {
#line 2314
    tmp___9 = scnprintf((char *)(& hdw->identifier), 31UL, "unit-??");
#line 2314
    idx = (unsigned int )tmp___9;
  }
#line 2317
  hdw->identifier[idx] = 0;
#line 2319
  pvr2_hdw_setup_std(hdw);
#line 2321
  tmp___10 = get_default_tuner_type(hdw);
#line 2321
  if (tmp___10 == 0) {
#line 2322
    if ((pvrusb2_debug & 32) != 0) {
#line 2322
      printk("\016pvrusb2: pvr2_hdw_setup: Tuner type overridden to %d\n", hdw->tuner_type);
    } else {

    }
  } else {

  }
#line 2328
  tmp___11 = pvr2_hdw_dev_ok(hdw);
#line 2328
  if (tmp___11 == 0) {
#line 2328
    return;
  } else {

  }
#line 2330
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 2334
    pvr2_hdw_gpio_chg_dir(hdw, 2048U, 4294967295U);
  } else {

  }
#line 2337
  pvr2_hdw_commit_setup(hdw);
#line 2339
  hdw->vid_stream = pvr2_stream_create();
#line 2340
  tmp___12 = pvr2_hdw_dev_ok(hdw);
#line 2340
  if (tmp___12 == 0) {
#line 2340
    return;
  } else {

  }
#line 2341
  if ((pvrusb2_debug & 32) != 0) {
#line 2341
    printk("\016pvrusb2: pvr2_hdw_setup: video stream is %p\n", hdw->vid_stream);
  } else {

  }
#line 2343
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 2344
    idx = get_default_error_tolerance(hdw);
#line 2345
    if (idx != 0U) {
#line 2346
      if ((pvrusb2_debug & 32) != 0) {
#line 2346
        printk("\016pvrusb2: pvr2_hdw_setup: video stream %p setting tolerance %u\n",
               hdw->vid_stream, idx);
      } else {

      }
    } else {

    }
#line 2351
    pvr2_stream_setup(hdw->vid_stream, hdw->usb_dev, 132, idx);
  } else {

  }
#line 2355
  tmp___13 = pvr2_hdw_dev_ok(hdw);
#line 2355
  if (tmp___13 == 0) {
#line 2355
    return;
  } else {

  }
#line 2357
  hdw->flag_init_ok = 1;
#line 2359
  pvr2_hdw_state_sched(hdw);
#line 2360
  return;
}
}
#line 2366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_setup(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2368
  if ((pvrusb2_debug & 32) != 0) {
#line 2368
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) begin\n", hdw);
  } else {

  }
#line 2370
  pvr2_hdw_setup_low(hdw);
#line 2371
  if ((pvrusb2_debug & 32) != 0) {
#line 2371
    tmp = pvr2_hdw_dev_ok(hdw);
#line 2371
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) done, ok=%d init_ok=%d\n", hdw, tmp,
           hdw->flag_init_ok);
  } else {

  }
#line 2374
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 2374
  if (tmp___0 != 0) {
#line 2375
    if (hdw->flag_init_ok != 0) {
#line 2376
      if (pvrusb2_debug & 1) {
#line 2376
        printk("\016pvrusb2: Device initialization completed successfully.\n");
      } else {

      }
#line 2380
      goto ldv_50932;
    } else {

    }
#line 2382
    if (hdw->fw1_state == 3) {
#line 2383
      if (pvrusb2_debug & 1) {
#line 2383
        printk("\016pvrusb2: Device microcontroller firmware (re)loaded; it should now reset and reconnect.\n");
      } else {

      }
#line 2388
      goto ldv_50932;
    } else {

    }
#line 2390
    if ((pvrusb2_debug & 2) != 0) {
#line 2390
      printk("\016pvrusb2: Device initialization was not successful.\n");
    } else {

    }
#line 2393
    if (hdw->fw1_state == 1) {
#line 2394
      if ((pvrusb2_debug & 2) != 0) {
#line 2394
        printk("\016pvrusb2: Giving up since device microcontroller firmware appears to be missing.\n");
      } else {

      }
#line 2399
      goto ldv_50932;
    } else {

    }
  } else {

  }
#line 2402
  if (hdw->flag_modulefail != 0) {
#line 2403
    if ((pvrusb2_debug & 2) != 0) {
#line 2403
      printk("\016pvrusb2: ***WARNING*** pvrusb2 driver initialization failed due to the failure of one or more sub-device kernel modules.\n");
    } else {

    }
#line 2408
    if ((pvrusb2_debug & 2) != 0) {
#line 2408
      printk("\016pvrusb2: You need to resolve the failing condition before this driver can function.  There should be some earlier messages giving more information about the problem.\n");
    } else {

    }
#line 2414
    goto ldv_50932;
  } else {

  }
#line 2416
  if (procreload != 0) {
#line 2417
    if ((pvrusb2_debug & 2) != 0) {
#line 2417
      printk("\016pvrusb2: Attempting pvrusb2 recovery by reloading primary firmware.\n");
    } else {

    }
#line 2421
    if ((pvrusb2_debug & 2) != 0) {
#line 2421
      printk("\016pvrusb2: If this works, device should disconnect and reconnect in a sane state.\n");
    } else {

    }
#line 2425
    hdw->fw1_state = 0;
#line 2426
    pvr2_upload_firmware1(hdw);
  } else {
#line 2428
    if ((pvrusb2_debug & 2) != 0) {
#line 2428
      printk("\016pvrusb2: ***WARNING*** pvrusb2 device hardware appears to be jammed and I can\'t clear it.\n");
    } else {

    }
#line 2433
    if ((pvrusb2_debug & 2) != 0) {
#line 2433
      printk("\016pvrusb2: You might need to power cycle the pvrusb2 device in order to recover.\n");
    } else {

    }
  }
  ldv_50932: ;
#line 2440
  if ((pvrusb2_debug & 32) != 0) {
#line 2440
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) end\n", hdw);
  } else {

  }
#line 2441
  return;
}
}
#line 2447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_initialize(struct pvr2_hdw *hdw , void (*callback_func)(void * ) , void *callback_data ) 
{ 


  {
#line 2451
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 2451
  hdw->big_lock_held = 1;
#line 2452
  if (hdw->flag_disconnected != 0) {
#line 2459
    goto ldv_50939;
  } else {

  }
#line 2461
  hdw->state_data = callback_data;
#line 2462
  hdw->state_func = callback_func;
#line 2463
  pvr2_hdw_setup(hdw);
  ldv_50939: 
#line 2464
  hdw->big_lock_held = 0;
#line 2464
  mutex_unlock(& hdw->big_lock_mutex);
#line 2465
  return (hdw->flag_init_ok);
}
}
#line 2471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf , struct usb_device_id  const  *devid ) 
{ 
  unsigned int idx ;
  unsigned int cnt1 ;
  unsigned int cnt2 ;
  unsigned int m ;
  struct pvr2_hdw *hdw ;
  int valid_std_mask ;
  struct pvr2_ctrl *cptr ;
  struct usb_device *usb_dev ;
  struct pvr2_device_desc  const  *hdw_desc ;
  __u8 ifnum ;
  struct v4l2_queryctrl qctrl ;
  struct pvr2_ctl_info *ciptr ;
  void *tmp ;
  struct lock_class_key __key ;
  void *tmp___0 ;
  void *tmp___1 ;
  v4l2_std_id tmp___2 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___8 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;

  {
#line 2475
  hdw = (struct pvr2_hdw *)0;
#line 2484
  usb_dev = interface_to_usbdev(intf);
#line 2486
  hdw_desc = (struct pvr2_device_desc  const  *)devid->driver_info;
#line 2488
  if ((unsigned long )hdw_desc == (unsigned long )((struct pvr2_device_desc  const  *)0)) {
#line 2489
    if ((pvrusb2_debug & 32) != 0) {
#line 2489
      printk("\016pvrusb2: pvr2_hdw_create: No device description pointer, unable to continue.\n");
    } else {

    }
#line 2492
    if ((pvrusb2_debug & 32) != 0) {
#line 2492
      printk("\016pvrusb2: If you have a new device type, please contact Mike Isely <isely@pobox.com> to get it included in the driver\n\n");
    } else {

    }
#line 2495
    goto fail;
  } else {

  }
#line 2498
  tmp = kzalloc(9016UL, 208U);
#line 2498
  hdw = (struct pvr2_hdw *)tmp;
#line 2499
  if ((pvrusb2_debug & 32) != 0) {
#line 2499
    printk("\016pvrusb2: pvr2_hdw_create: hdw=%p, type \"%s\"\n", hdw, hdw_desc->description);
  } else {

  }
#line 2501
  if (pvrusb2_debug & 1) {
#line 2501
    printk("\016pvrusb2: Hardware description: %s\n", hdw_desc->description);
  } else {

  }
#line 2503
  if ((unsigned int )*((unsigned char *)hdw_desc + 89UL) != 0U) {
#line 2504
    if (pvrusb2_debug & 1) {
#line 2504
      printk("\016pvrusb2: **********\n");
    } else {

    }
#line 2505
    if (pvrusb2_debug & 1) {
#line 2505
      printk("\016pvrusb2: WARNING: Support for this device (%s) is experimental.\n",
             hdw_desc->description);
    } else {

    }
#line 2508
    if (pvrusb2_debug & 1) {
#line 2508
      printk("\016pvrusb2: Important functionality might not be entirely working.\n");
    } else {

    }
#line 2511
    if (pvrusb2_debug & 1) {
#line 2511
      printk("\016pvrusb2: Please consider contacting the driver author to help with further stabilization of the driver.\n");
    } else {

    }
#line 2514
    if (pvrusb2_debug & 1) {
#line 2514
      printk("\016pvrusb2: **********\n");
    } else {

    }
  } else {

  }
#line 2516
  if ((unsigned long )hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 2516
    goto fail;
  } else {

  }
#line 2518
  reg_timer_3(& hdw->quiescent_timer);
#line 2519
  hdw->quiescent_timer.data = (unsigned long )hdw;
#line 2520
  hdw->quiescent_timer.function = & pvr2_hdw_quiescent_timeout;
#line 2522
  reg_timer_3(& hdw->decoder_stabilization_timer);
#line 2523
  hdw->decoder_stabilization_timer.data = (unsigned long )hdw;
#line 2524
  hdw->decoder_stabilization_timer.function = & pvr2_hdw_decoder_stabilization_timeout;
#line 2527
  reg_timer_3(& hdw->encoder_wait_timer);
#line 2528
  hdw->encoder_wait_timer.data = (unsigned long )hdw;
#line 2529
  hdw->encoder_wait_timer.function = & pvr2_hdw_encoder_wait_timeout;
#line 2531
  reg_timer_3(& hdw->encoder_run_timer);
#line 2532
  hdw->encoder_run_timer.data = (unsigned long )hdw;
#line 2533
  hdw->encoder_run_timer.function = & pvr2_hdw_encoder_run_timeout;
#line 2535
  hdw->master_state = 1U;
#line 2537
  __init_waitqueue_head(& hdw->state_wait_data, "&hdw->state_wait_data", & __key);
#line 2539
  hdw->tuner_signal_stale = 1;
#line 2540
  cx2341x_fill_defaults(& hdw->enc_ctl_state);
#line 2543
  m = 0U;
#line 2544
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2544
    m = m | 1U;
  } else {

  }
#line 2545
  if ((unsigned int )((unsigned char )hdw_desc->digital_control_scheme) != 0U) {
#line 2546
    m = m | 2U;
  } else {

  }
#line 2548
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2548
    m = m | 8U;
  } else {

  }
#line 2549
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2549
    m = m | 4U;
  } else {

  }
#line 2550
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2550
    m = m | 16U;
  } else {

  }
#line 2551
  hdw->input_avail_mask = m;
#line 2552
  hdw->input_allowed_mask = hdw->input_avail_mask;
#line 2556
  if ((hdw->input_avail_mask & 2U) == 0U) {
#line 2557
    hdw->pathway_state = 1;
  } else
#line 2558
  if ((hdw->input_avail_mask & 1U) == 0U) {
#line 2559
    hdw->pathway_state = 2;
  } else {

  }
#line 2562
  hdw->control_cnt = 36U;
#line 2563
  hdw->control_cnt = hdw->control_cnt + 26U;
#line 2564
  tmp___0 = kzalloc((unsigned long )hdw->control_cnt * 16UL, 208U);
#line 2564
  hdw->controls = (struct pvr2_ctrl *)tmp___0;
#line 2566
  if ((unsigned long )hdw->controls == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2566
    goto fail;
  } else {

  }
#line 2567
  hdw->hdw_desc = hdw_desc;
#line 2568
  hdw->ir_scheme_active = (unsigned int )(hdw->hdw_desc)->ir_scheme;
#line 2569
  idx = 0U;
#line 2569
  goto ldv_50963;
  ldv_50962: 
#line 2570
  cptr = hdw->controls + (unsigned long )idx;
#line 2571
  cptr->hdw = hdw;
#line 2569
  idx = idx + 1U;
  ldv_50963: ;
#line 2569
  if (hdw->control_cnt > idx) {
#line 2571
    goto ldv_50962;
  } else {

  }
#line 2573
  idx = 0U;
#line 2573
  goto ldv_50966;
  ldv_50965: 
#line 2574
  hdw->std_mask_ptrs[idx] = (char const   *)(& hdw->std_mask_names) + (unsigned long )idx;
#line 2573
  idx = idx + 1U;
  ldv_50966: ;
#line 2573
  if (idx <= 31U) {
#line 2575
    goto ldv_50965;
  } else {

  }
#line 2576
  idx = 0U;
#line 2576
  goto ldv_50971;
  ldv_50970: 
#line 2577
  cptr = hdw->controls + (unsigned long )idx;
#line 2578
  cptr->info = (struct pvr2_ctl_info  const  *)(& control_defs) + (unsigned long )idx;
#line 2576
  idx = idx + 1U;
  ldv_50971: ;
#line 2576
  if (idx <= 35U) {
#line 2578
    goto ldv_50970;
  } else {

  }
#line 2582
  m = hdw->input_avail_mask;
#line 2583
  if (m != 0U) {
#line 2583
    idx = 0U;
#line 2583
    goto ldv_50976;
    ldv_50975: ;
#line 2584
    if (((unsigned int )(1 << (int )idx) & m) == 0U) {
#line 2584
      goto ldv_50973;
    } else {

    }
#line 2585
    hdw->input_val = (int )idx;
#line 2586
    goto ldv_50974;
    ldv_50973: 
#line 2583
    idx = idx + 1U;
    ldv_50976: ;
#line 2583
    if (idx <= 31U) {
#line 2585
      goto ldv_50975;
    } else {

    }
    ldv_50974: ;
  } else {

  }
#line 2590
  tmp___1 = kcalloc(26UL, 176UL, 208U);
#line 2590
  hdw->mpeg_ctrl_info = (struct pvr2_ctld_info *)tmp___1;
#line 2593
  if ((unsigned long )hdw->mpeg_ctrl_info == (unsigned long )((struct pvr2_ctld_info *)0)) {
#line 2593
    goto fail;
  } else {

  }
#line 2594
  idx = 0U;
#line 2594
  goto ldv_50992;
  ldv_50991: 
#line 2595
  cptr = hdw->controls + ((unsigned long )idx + 36UL);
#line 2596
  ciptr = & (hdw->mpeg_ctrl_info + (unsigned long )idx)->info;
#line 2597
  ciptr->desc = (char const   *)(& (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc);
#line 2598
  ciptr->name = mpeg_ids[idx].strid;
#line 2599
  ciptr->v4l_id = mpeg_ids[idx].id;
#line 2600
  ciptr->skip_init = 1;
#line 2601
  ciptr->get_value = & ctrl_cx2341x_get;
#line 2602
  ciptr->get_v4lflags = & ctrl_cx2341x_getv4lflags;
#line 2603
  ciptr->is_dirty = & ctrl_cx2341x_is_dirty;
#line 2604
  if (idx == 0U) {
#line 2604
    ciptr->clear_dirty = & ctrl_cx2341x_clear_dirty;
  } else {

  }
#line 2605
  qctrl.id = (__u32 )ciptr->v4l_id;
#line 2606
  cx2341x_ctrl_query((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                     & qctrl);
#line 2607
  if ((qctrl.flags & 4U) == 0U) {
#line 2608
    ciptr->set_value = & ctrl_cx2341x_set;
  } else {

  }
#line 2610
  strncpy((char *)(& (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc), (char const   *)(& qctrl.name),
          32UL);
#line 2612
  (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc[31] = 0;
#line 2613
  ciptr->default_value = qctrl.default_value;
#line 2614
  switch (qctrl.type) {
  default: ;
  case 1U: 
#line 2617
  ciptr->type = 0;
#line 2618
  ciptr->def.type_int.min_value = (long )qctrl.minimum;
#line 2619
  ciptr->def.type_int.max_value = (long )qctrl.maximum;
#line 2620
  goto ldv_50985;
  case 2U: 
#line 2622
  ciptr->type = 3;
#line 2623
  goto ldv_50985;
  case 3U: 
#line 2625
  ciptr->type = 1;
#line 2626
  ciptr->def.type_enum.value_names = cx2341x_ctrl_get_menu((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                                                           (u32 )ciptr->v4l_id);
#line 2629
  cnt1 = 0U;
#line 2629
  goto ldv_50989;
  ldv_50988: 
#line 2631
  cnt1 = cnt1 + 1U;
  ldv_50989: ;
#line 2629
  if ((unsigned long )*(ciptr->def.type_enum.value_names + (unsigned long )cnt1) != (unsigned long )((char const   */* const  */)0)) {
#line 2632
    goto ldv_50988;
  } else {

  }
#line 2632
  ciptr->def.type_enum.count = cnt1;
#line 2633
  goto ldv_50985;
  }
  ldv_50985: 
#line 2635
  cptr->info = (struct pvr2_ctl_info  const  *)ciptr;
#line 2594
  idx = idx + 1U;
  ldv_50992: ;
#line 2594
  if (idx <= 25U) {
#line 2596
    goto ldv_50991;
  } else {

  }
#line 2639
  tmp___2 = pvr2_std_get_usable();
#line 2639
  valid_std_mask = (int )tmp___2;
#line 2640
  idx = 0U;
#line 2640
  goto ldv_50996;
  ldv_50995: ;
#line 2641
  if (((valid_std_mask >> (int )idx) & 1) == 0) {
#line 2641
    goto ldv_50994;
  } else {

  }
#line 2642
  cnt1 = pvr2_std_id_to_str((char *)(& hdw->std_mask_names) + (unsigned long )idx,
                            15U, (v4l2_std_id )(1 << (int )idx));
#line 2646
  hdw->std_mask_names[idx][cnt1] = 0;
  ldv_50994: 
#line 2640
  idx = idx + 1U;
  ldv_50996: ;
#line 2640
  if (idx <= 31U) {
#line 2642
    goto ldv_50995;
  } else {

  }
#line 2648
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 3U);
#line 2649
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2650
    __len = 144UL;
#line 2650
    if (__len > 63UL) {
#line 2650
      __ret = __memcpy((void *)(& hdw->std_info_avail), (void const   *)cptr->info,
                       __len);
    } else {
#line 2650
      __ret = __builtin_memcpy((void *)(& hdw->std_info_avail), (void const   *)cptr->info,
                               __len);
    }
#line 2652
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_avail);
#line 2653
    hdw->std_info_avail.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2655
    hdw->std_info_avail.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2658
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 2659
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2660
    __len___0 = 144UL;
#line 2660
    if (__len___0 > 63UL) {
#line 2660
      __ret___0 = __memcpy((void *)(& hdw->std_info_cur), (void const   *)cptr->info,
                           __len___0);
    } else {
#line 2660
      __ret___0 = __builtin_memcpy((void *)(& hdw->std_info_cur), (void const   *)cptr->info,
                                   __len___0);
    }
#line 2662
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_cur);
#line 2663
    hdw->std_info_cur.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2665
    hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2668
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 19U);
#line 2669
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2670
    __len___1 = 144UL;
#line 2670
    if (__len___1 > 63UL) {
#line 2670
      __ret___1 = __memcpy((void *)(& hdw->std_info_detect), (void const   *)cptr->info,
                           __len___1);
    } else {
#line 2670
      __ret___1 = __builtin_memcpy((void *)(& hdw->std_info_detect), (void const   *)cptr->info,
                                   __len___1);
    }
#line 2672
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_detect);
#line 2673
    hdw->std_info_detect.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2675
    hdw->std_info_detect.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2679
  hdw->cropcap_stale = 1;
#line 2680
  hdw->eeprom_addr = -1;
#line 2681
  hdw->unit_number = -1;
#line 2682
  hdw->v4l_minor_number_video = -1;
#line 2683
  hdw->v4l_minor_number_vbi = -1;
#line 2684
  hdw->v4l_minor_number_radio = -1;
#line 2685
  tmp___3 = kmalloc(64UL, 208U);
#line 2685
  hdw->ctl_write_buffer = (unsigned char *)tmp___3;
#line 2686
  if ((unsigned long )hdw->ctl_write_buffer == (unsigned long )((unsigned char *)0U)) {
#line 2686
    goto fail;
  } else {

  }
#line 2687
  tmp___4 = kmalloc(64UL, 208U);
#line 2687
  hdw->ctl_read_buffer = (unsigned char *)tmp___4;
#line 2688
  if ((unsigned long )hdw->ctl_read_buffer == (unsigned long )((unsigned char *)0U)) {
#line 2688
    goto fail;
  } else {

  }
#line 2689
  hdw->ctl_write_urb = ldv_usb_alloc_urb_292(0, 208U);
#line 2690
  if ((unsigned long )hdw->ctl_write_urb == (unsigned long )((struct urb *)0)) {
#line 2690
    goto fail;
  } else {

  }
#line 2691
  hdw->ctl_read_urb = ldv_usb_alloc_urb_293(0, 208U);
#line 2692
  if ((unsigned long )hdw->ctl_read_urb == (unsigned long )((struct urb *)0)) {
#line 2692
    goto fail;
  } else {

  }
#line 2694
  tmp___5 = v4l2_device_register(& intf->dev, & hdw->v4l2_dev);
#line 2694
  if (tmp___5 != 0) {
#line 2695
    if ((pvrusb2_debug & 2) != 0) {
#line 2695
      printk("\016pvrusb2: Error registering with v4l core, giving up\n");
    } else {

    }
#line 2697
    goto fail;
  } else {

  }
#line 2699
  mutex_lock_nested(& pvr2_unit_mtx, 0U);
#line 2700
  idx = 0U;
#line 2700
  goto ldv_51010;
  ldv_51009: ;
#line 2701
  if ((unsigned long )unit_pointers[idx] != (unsigned long )((struct pvr2_hdw *)0)) {
#line 2701
    goto ldv_51007;
  } else {

  }
#line 2702
  hdw->unit_number = (int )idx;
#line 2703
  unit_pointers[idx] = hdw;
#line 2704
  goto ldv_51008;
  ldv_51007: 
#line 2700
  idx = idx + 1U;
  ldv_51010: ;
#line 2700
  if (idx <= 19U) {
#line 2702
    goto ldv_51009;
  } else {

  }
  ldv_51008: 
#line 2706
  mutex_unlock(& pvr2_unit_mtx);
#line 2708
  cnt1 = 0U;
#line 2709
  tmp___6 = scnprintf((char *)(& hdw->name) + (unsigned long )cnt1, 32UL - (unsigned long )cnt1,
                      "pvrusb2");
#line 2709
  cnt2 = (unsigned int )tmp___6;
#line 2710
  cnt1 = cnt1 + cnt2;
#line 2711
  if (hdw->unit_number >= 0) {
#line 2712
    tmp___7 = scnprintf((char *)(& hdw->name) + (unsigned long )cnt1, 32UL - (unsigned long )cnt1,
                        "_%c", hdw->unit_number + 97);
#line 2712
    cnt2 = (unsigned int )tmp___7;
#line 2714
    cnt1 = cnt1 + cnt2;
  } else {

  }
#line 2716
  if (cnt1 > 31U) {
#line 2716
    cnt1 = 31U;
  } else {

  }
#line 2717
  hdw->name[cnt1] = 0;
#line 2719
  __lock_name = "\"%s\"(hdw->name)";
#line 2719
  tmp___8 = __alloc_workqueue_key("%s", 10U, 1, & __key___0, __lock_name, (char *)(& hdw->name));
#line 2719
  hdw->workqueue = tmp___8;
#line 2720
  __init_work(& hdw->workpoll, 0);
#line 2720
  __constr_expr_0.counter = 137438953408L;
#line 2720
  hdw->workpoll.data = __constr_expr_0;
#line 2720
  lockdep_init_map(& hdw->workpoll.lockdep_map, "(&hdw->workpoll)", & __key___1, 0);
#line 2720
  INIT_LIST_HEAD(& hdw->workpoll.entry);
#line 2720
  hdw->workpoll.func = & pvr2_hdw_worker_poll;
#line 2722
  if ((pvrusb2_debug & 32) != 0) {
#line 2722
    printk("\016pvrusb2: Driver unit number is %d, name is %s\n", hdw->unit_number,
           (char *)(& hdw->name));
  } else {

  }
#line 2725
  hdw->tuner_type = 4294967295U;
#line 2726
  hdw->flag_ok = 1;
#line 2728
  hdw->usb_intf = intf;
#line 2729
  hdw->usb_dev = usb_dev;
#line 2731
  usb_make_path(hdw->usb_dev, (char *)(& hdw->bus_info), 32UL);
#line 2733
  ifnum = ((hdw->usb_intf)->cur_altsetting)->desc.bInterfaceNumber;
#line 2734
  usb_set_interface(hdw->usb_dev, (int )ifnum, 0);
#line 2736
  __mutex_init(& hdw->ctl_lock_mutex, "&hdw->ctl_lock_mutex", & __key___2);
#line 2737
  __mutex_init(& hdw->big_lock_mutex, "&hdw->big_lock_mutex", & __key___3);
#line 2739
  return (hdw);
  fail: ;
#line 2741
  if ((unsigned long )hdw != (unsigned long )((struct pvr2_hdw *)0)) {
#line 2742
    ldv_del_timer_sync_294(& hdw->quiescent_timer);
#line 2743
    ldv_del_timer_sync_295(& hdw->decoder_stabilization_timer);
#line 2744
    ldv_del_timer_sync_296(& hdw->encoder_run_timer);
#line 2745
    ldv_del_timer_sync_297(& hdw->encoder_wait_timer);
#line 2746
    if ((unsigned long )hdw->workqueue != (unsigned long )((struct workqueue_struct *)0)) {
#line 2747
      flush_workqueue(hdw->workqueue);
#line 2748
      destroy_workqueue(hdw->workqueue);
#line 2749
      hdw->workqueue = (struct workqueue_struct *)0;
    } else {

    }
#line 2751
    usb_free_urb(hdw->ctl_read_urb);
#line 2752
    usb_free_urb(hdw->ctl_write_urb);
#line 2753
    kfree((void const   *)hdw->ctl_read_buffer);
#line 2754
    kfree((void const   *)hdw->ctl_write_buffer);
#line 2755
    kfree((void const   *)hdw->controls);
#line 2756
    kfree((void const   *)hdw->mpeg_ctrl_info);
#line 2757
    kfree((void const   *)hdw);
  } else {

  }
#line 2759
  return ((struct pvr2_hdw *)0);
}
}
#line 2765 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_remove_usb_stuff(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2767
  if (hdw->flag_disconnected != 0) {
#line 2767
    return;
  } else {

  }
#line 2768
  if ((pvrusb2_debug & 32) != 0) {
#line 2768
    printk("\016pvrusb2: pvr2_hdw_remove_usb_stuff: hdw=%p\n", hdw);
  } else {

  }
#line 2769
  if ((unsigned long )hdw->ctl_read_urb != (unsigned long )((struct urb *)0)) {
#line 2770
    usb_kill_urb(hdw->ctl_read_urb);
#line 2771
    usb_free_urb(hdw->ctl_read_urb);
#line 2772
    hdw->ctl_read_urb = (struct urb *)0;
  } else {

  }
#line 2774
  if ((unsigned long )hdw->ctl_write_urb != (unsigned long )((struct urb *)0)) {
#line 2775
    usb_kill_urb(hdw->ctl_write_urb);
#line 2776
    usb_free_urb(hdw->ctl_write_urb);
#line 2777
    hdw->ctl_write_urb = (struct urb *)0;
  } else {

  }
#line 2779
  if ((unsigned long )hdw->ctl_read_buffer != (unsigned long )((unsigned char *)0U)) {
#line 2780
    kfree((void const   *)hdw->ctl_read_buffer);
#line 2781
    hdw->ctl_read_buffer = (unsigned char *)0U;
  } else {

  }
#line 2783
  if ((unsigned long )hdw->ctl_write_buffer != (unsigned long )((unsigned char *)0U)) {
#line 2784
    kfree((void const   *)hdw->ctl_write_buffer);
#line 2785
    hdw->ctl_write_buffer = (unsigned char *)0U;
  } else {

  }
#line 2787
  hdw->flag_disconnected = 1;
#line 2791
  v4l2_device_disconnect(& hdw->v4l2_dev);
#line 2792
  hdw->usb_dev = (struct usb_device *)0;
#line 2793
  hdw->usb_intf = (struct usb_interface *)0;
#line 2794
  pvr2_hdw_render_useless(hdw);
#line 2795
  return;
}
}
#line 2797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_set_v4l2_dev(struct pvr2_hdw *hdw , struct video_device *vdev ) 
{ 


  {
#line 2799
  vdev->v4l2_dev = & hdw->v4l2_dev;
#line 2800
  return;
}
}
#line 2803 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_destroy(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2805
  if ((unsigned long )hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 2805
    return;
  } else {

  }
#line 2806
  if ((pvrusb2_debug & 32) != 0) {
#line 2806
    printk("\016pvrusb2: pvr2_hdw_destroy: hdw=%p\n", hdw);
  } else {

  }
#line 2807
  if ((unsigned long )hdw->workqueue != (unsigned long )((struct workqueue_struct *)0)) {
#line 2808
    flush_workqueue(hdw->workqueue);
#line 2809
    destroy_workqueue(hdw->workqueue);
#line 2810
    hdw->workqueue = (struct workqueue_struct *)0;
  } else {

  }
#line 2812
  ldv_del_timer_sync_298(& hdw->quiescent_timer);
#line 2813
  ldv_del_timer_sync_299(& hdw->decoder_stabilization_timer);
#line 2814
  ldv_del_timer_sync_300(& hdw->encoder_run_timer);
#line 2815
  ldv_del_timer_sync_301(& hdw->encoder_wait_timer);
#line 2816
  if ((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0)) {
#line 2817
    kfree((void const   *)hdw->fw_buffer);
#line 2818
    hdw->fw_buffer = (char *)0;
  } else {

  }
#line 2820
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 2821
    pvr2_stream_destroy(hdw->vid_stream);
#line 2822
    hdw->vid_stream = (struct pvr2_stream *)0;
  } else {

  }
#line 2824
  pvr2_i2c_core_done(hdw);
#line 2825
  v4l2_device_unregister(& hdw->v4l2_dev);
#line 2826
  pvr2_hdw_remove_usb_stuff(hdw);
#line 2827
  mutex_lock_nested(& pvr2_unit_mtx, 0U);
#line 2828
  if ((hdw->unit_number >= 0 && hdw->unit_number <= 19) && (unsigned long )unit_pointers[hdw->unit_number] == (unsigned long )hdw) {
#line 2831
    unit_pointers[hdw->unit_number] = (struct pvr2_hdw *)0;
  } else {

  }
#line 2833
  mutex_unlock(& pvr2_unit_mtx);
#line 2834
  kfree((void const   *)hdw->controls);
#line 2835
  kfree((void const   *)hdw->mpeg_ctrl_info);
#line 2836
  kfree((void const   *)hdw);
#line 2837
  return;
}
}
#line 2840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_dev_ok(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2842
  return ((unsigned long )hdw != (unsigned long )((struct pvr2_hdw *)0) && hdw->flag_ok != 0);
}
}
#line 2847 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_disconnect(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2849
  if ((pvrusb2_debug & 32) != 0) {
#line 2849
    printk("\016pvrusb2: pvr2_hdw_disconnect(hdw=%p)\n", hdw);
  } else {

  }
#line 2850
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 2850
  hdw->big_lock_held = 1;
#line 2851
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 2851
  hdw->ctl_lock_held = 1;
#line 2852
  pvr2_hdw_remove_usb_stuff(hdw);
#line 2853
  hdw->ctl_lock_held = 0;
#line 2853
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 2854
  hdw->big_lock_held = 0;
#line 2854
  mutex_unlock(& hdw->big_lock_mutex);
#line 2855
  return;
}
}
#line 2859 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2861
  return (hdw->control_cnt);
}
}
#line 2866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw , unsigned int idx ) 
{ 


  {
#line 2869
  if (hdw->control_cnt <= idx) {
#line 2869
    return ((struct pvr2_ctrl *)0);
  } else {

  }
#line 2870
  return (hdw->controls + (unsigned long )idx);
}
}
#line 2875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  unsigned int idx ;
  int i ;

  {
#line 2883
  idx = 0U;
#line 2883
  goto ldv_51049;
  ldv_51048: 
#line 2884
  cptr = hdw->controls + (unsigned long )idx;
#line 2885
  i = (cptr->info)->internal_id;
#line 2886
  if (i != 0 && (unsigned int )i == ctl_id) {
#line 2886
    return (cptr);
  } else {

  }
#line 2883
  idx = idx + 1U;
  ldv_51049: ;
#line 2883
  if (hdw->control_cnt > idx) {
#line 2885
    goto ldv_51048;
  } else {

  }

#line 2888
  return ((struct pvr2_ctrl *)0);
}
}
#line 2893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  unsigned int idx ;
  int i ;

  {
#line 2900
  idx = 0U;
#line 2900
  goto ldv_51059;
  ldv_51058: 
#line 2901
  cptr = hdw->controls + (unsigned long )idx;
#line 2902
  i = (cptr->info)->v4l_id;
#line 2903
  if (i != 0 && (unsigned int )i == ctl_id) {
#line 2903
    return (cptr);
  } else {

  }
#line 2900
  idx = idx + 1U;
  ldv_51059: ;
#line 2900
  if (hdw->control_cnt > idx) {
#line 2902
    goto ldv_51058;
  } else {

  }

#line 2905
  return ((struct pvr2_ctrl *)0);
}
}
#line 2911 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  struct pvr2_ctrl *cp2 ;
  unsigned int idx ;
  int i ;

  {
#line 2919
  cp2 = (struct pvr2_ctrl *)0;
#line 2920
  idx = 0U;
#line 2920
  goto ldv_51071;
  ldv_51070: 
#line 2921
  cptr = hdw->controls + (unsigned long )idx;
#line 2922
  i = (cptr->info)->v4l_id;
#line 2923
  if (i == 0) {
#line 2923
    goto ldv_51069;
  } else {

  }
#line 2924
  if ((unsigned int )i <= ctl_id) {
#line 2924
    goto ldv_51069;
  } else {

  }
#line 2925
  if ((unsigned long )cp2 != (unsigned long )((struct pvr2_ctrl *)0) && (int )(cp2->info)->v4l_id < i) {
#line 2925
    goto ldv_51069;
  } else {

  }
#line 2926
  cp2 = cptr;
  ldv_51069: 
#line 2920
  idx = idx + 1U;
  ldv_51071: ;
#line 2920
  if (hdw->control_cnt > idx) {
#line 2922
    goto ldv_51070;
  } else {

  }

#line 2928
  return (cp2);
#line 2929
  return ((struct pvr2_ctrl *)0);
}
}
#line 2933 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *get_ctrl_typename(enum pvr2_ctl_type tp ) 
{ 


  {
#line 2935
  switch ((unsigned int )tp) {
  case 0U: ;
#line 2936
  return ("integer");
  case 1U: ;
#line 2937
  return ("enum");
  case 3U: ;
#line 2938
  return ("boolean");
  case 2U: ;
#line 2939
  return ("bitmask");
  }
#line 2941
  return ("");
}
}
#line 2945 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_subdev_set_control(struct pvr2_hdw *hdw , int id , char const   *name ,
                                    int val ) 
{ 
  struct v4l2_control ctrl ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2949
  if ((pvrusb2_debug & 65536) != 0) {
#line 2949
    printk("\016pvrusb2: subdev v4l2 %s=%d\n", name, val);
  } else {

  }
#line 2950
  memset((void *)(& ctrl), 0, 8UL);
#line 2951
  ctrl.id = (__u32 )id;
#line 2952
  ctrl.value = val;
#line 2953
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2953
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 2953
  goto ldv_51093;
  ldv_51092: ;
#line 2953
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->s_ctrl != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                          struct v4l2_control * ))0)) {
#line 2953
    (*(((__sd->ops)->core)->s_ctrl))(__sd, & ctrl);
  } else {

  }
#line 2953
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2953
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51093: ;
#line 2953
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2955
    goto ldv_51092;
  } else {

  }

#line 2961
  return;
}
}
#line 2961 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw ) 
{ 
  v4l2_std_id std ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2964
  std = hdw->std_mask_avail;
#line 2965
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2965
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 2965
  goto ldv_51105;
  ldv_51104: ;
#line 2965
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->querystd != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                               v4l2_std_id * ))0)) {
#line 2965
    (*(((__sd->ops)->video)->querystd))(__sd, & std);
  } else {

  }
#line 2965
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2965
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51105: ;
#line 2965
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2967
    goto ldv_51104;
  } else {

  }

#line 2967
  return (std);
}
}
#line 2972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_subdev_update(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_subdev *sd ;
  unsigned int id ;
  void (*fp)(struct pvr2_hdw * , struct v4l2_subdev * ) ;
  struct tuner_setup setup ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  v4l2_std_id vs ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct v4l2_tuner vt ;
  struct v4l2_subdev *__sd___2 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  unsigned long fv ;
  struct v4l2_frequency freq ;
  struct v4l2_subdev *__sd___3 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  struct v4l2_mbus_framefmt fmt ;
  struct v4l2_subdev *__sd___4 ;
  struct list_head  const  *__mptr___9 ;
  struct list_head  const  *__mptr___10 ;
  u32 val ;
  struct v4l2_subdev *__sd___5 ;
  struct list_head  const  *__mptr___11 ;
  struct list_head  const  *__mptr___12 ;
  struct list_head  const  *__mptr___13 ;
  struct list_head  const  *__mptr___14 ;

  {
#line 2978
  if ((pvrusb2_debug & 65536) != 0) {
#line 2978
    printk("\016pvrusb2: subdev update...\n");
  } else {

  }
#line 2980
  if (hdw->tuner_updated != 0 || hdw->force_dirty != 0) {
#line 2982
    if ((pvrusb2_debug & 65536) != 0) {
#line 2982
      printk("\016pvrusb2: subdev tuner set_type(%d)\n", hdw->tuner_type);
    } else {

    }
#line 2984
    if ((int )hdw->tuner_type >= 0) {
#line 2985
      memset((void *)(& setup), 0, 32UL);
#line 2986
      setup.addr = 255U;
#line 2987
      setup.type = hdw->tuner_type;
#line 2988
      setup.mode_mask = 6U;
#line 2989
      __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2989
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 2989
      goto ldv_51120;
      ldv_51119: ;
#line 2989
      if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_type_addr != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                      struct tuner_setup * ))0)) {
#line 2989
        (*(((__sd->ops)->tuner)->s_type_addr))(__sd, & setup);
      } else {

      }
#line 2989
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2989
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
      ldv_51120: ;
#line 2989
      if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2991
        goto ldv_51119;
      } else {

      }

    } else {

    }
  } else {

  }
#line 2994
  if ((hdw->input_dirty != 0 || hdw->std_dirty != 0) || hdw->force_dirty != 0) {
#line 2995
    if ((pvrusb2_debug & 65536) != 0) {
#line 2995
      printk("\016pvrusb2: subdev v4l2 set_standard\n");
    } else {

    }
#line 2996
    if (hdw->input_val == 4) {
#line 2997
      __mptr___1 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2997
      __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff80UL;
#line 2997
      goto ldv_51128;
      ldv_51127: ;
#line 2997
      if ((unsigned long )(__sd___0->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->tuner)->s_radio != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 2997
        (*(((__sd___0->ops)->tuner)->s_radio))(__sd___0);
      } else {

      }
#line 2997
      __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 2997
      __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff80UL;
      ldv_51128: ;
#line 2997
      if ((unsigned long )(& __sd___0->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2999
        goto ldv_51127;
      } else {

      }

    } else {
#line 3001
      vs = hdw->std_mask_cur;
#line 3002
      __mptr___3 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3002
      __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff80UL;
#line 3002
      goto ldv_51137;
      ldv_51136: ;
#line 3002
      if ((unsigned long )(__sd___1->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd___1->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        v4l2_std_id  ))0)) {
#line 3002
        (*(((__sd___1->ops)->video)->s_std))(__sd___1, vs);
      } else {

      }
#line 3002
      __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 3002
      __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff80UL;
      ldv_51137: ;
#line 3002
      if ((unsigned long )(& __sd___1->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3004
        goto ldv_51136;
      } else {

      }
#line 3004
      pvr2_hdw_cx25840_vbi_hack(hdw);
    }
#line 3006
    hdw->tuner_signal_stale = 1;
#line 3007
    hdw->cropcap_stale = 1;
  } else {

  }
#line 3010
  if (hdw->brightness_dirty != 0 || hdw->force_dirty != 0) {
#line 3010
    pvr2_subdev_set_control(hdw, 9963776, "brightness", hdw->brightness_val);
  } else {

  }
#line 3011
  if (hdw->contrast_dirty != 0 || hdw->force_dirty != 0) {
#line 3011
    pvr2_subdev_set_control(hdw, 9963777, "contrast", hdw->contrast_val);
  } else {

  }
#line 3012
  if (hdw->saturation_dirty != 0 || hdw->force_dirty != 0) {
#line 3012
    pvr2_subdev_set_control(hdw, 9963778, "saturation", hdw->saturation_val);
  } else {

  }
#line 3013
  if (hdw->hue_dirty != 0 || hdw->force_dirty != 0) {
#line 3013
    pvr2_subdev_set_control(hdw, 9963779, "hue", hdw->hue_val);
  } else {

  }
#line 3014
  if (hdw->mute_dirty != 0 || hdw->force_dirty != 0) {
#line 3014
    pvr2_subdev_set_control(hdw, 9963785, "mute", hdw->mute_val);
  } else {

  }
#line 3015
  if (hdw->volume_dirty != 0 || hdw->force_dirty != 0) {
#line 3015
    pvr2_subdev_set_control(hdw, 9963781, "volume", hdw->volume_val);
  } else {

  }
#line 3016
  if (hdw->balance_dirty != 0 || hdw->force_dirty != 0) {
#line 3016
    pvr2_subdev_set_control(hdw, 9963782, "balance", hdw->balance_val);
  } else {

  }
#line 3017
  if (hdw->bass_dirty != 0 || hdw->force_dirty != 0) {
#line 3017
    pvr2_subdev_set_control(hdw, 9963783, "bass", hdw->bass_val);
  } else {

  }
#line 3018
  if (hdw->treble_dirty != 0 || hdw->force_dirty != 0) {
#line 3018
    pvr2_subdev_set_control(hdw, 9963784, "treble", hdw->treble_val);
  } else {

  }
#line 3020
  if ((hdw->input_dirty != 0 || hdw->audiomode_dirty != 0) || hdw->force_dirty != 0) {
#line 3022
    memset((void *)(& vt), 0, 84UL);
#line 3023
    vt.type = hdw->input_val == 4 ? 1U : 2U;
#line 3025
    vt.audmode = (__u32 )hdw->audiomode_val;
#line 3026
    __mptr___5 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3026
    __sd___2 = (struct v4l2_subdev *)__mptr___5 + 0xffffffffffffff80UL;
#line 3026
    goto ldv_51146;
    ldv_51145: ;
#line 3026
    if ((unsigned long )(__sd___2->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___2->ops)->tuner)->s_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        struct v4l2_tuner  const  * ))0)) {
#line 3026
      (*(((__sd___2->ops)->tuner)->s_tuner))(__sd___2, (struct v4l2_tuner  const  *)(& vt));
    } else {

    }
#line 3026
    __mptr___6 = (struct list_head  const  *)__sd___2->list.next;
#line 3026
    __sd___2 = (struct v4l2_subdev *)__mptr___6 + 0xffffffffffffff80UL;
    ldv_51146: ;
#line 3026
    if ((unsigned long )(& __sd___2->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3028
      goto ldv_51145;
    } else {

    }

  } else {

  }
#line 3029
  if (hdw->freqDirty != 0 || hdw->force_dirty != 0) {
#line 3032
    fv = pvr2_hdw_get_cur_freq(hdw);
#line 3033
    if ((pvrusb2_debug & 65536) != 0) {
#line 3033
      printk("\016pvrusb2: subdev v4l2 set_freq(%lu)\n", fv);
    } else {

    }
#line 3034
    if (hdw->tuner_signal_stale != 0) {
#line 3034
      pvr2_hdw_status_poll(hdw);
    } else {

    }
#line 3035
    memset((void *)(& freq), 0, 44UL);
#line 3036
    if ((int )hdw->tuner_signal_info.capability & 1) {
#line 3038
      freq.frequency = (__u32 )((fv * 2UL) / 125UL);
    } else {
#line 3040
      freq.frequency = (__u32 )(fv / 62500UL);
    }
#line 3044
    if (hdw->input_val == 4) {
#line 3045
      freq.type = 1U;
    } else {
#line 3047
      freq.type = 2U;
    }
#line 3049
    freq.tuner = 0U;
#line 3050
    __mptr___7 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3050
    __sd___3 = (struct v4l2_subdev *)__mptr___7 + 0xffffffffffffff80UL;
#line 3050
    goto ldv_51156;
    ldv_51155: ;
#line 3050
    if ((unsigned long )(__sd___3->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___3->ops)->tuner)->s_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct v4l2_frequency  const  * ))0)) {
#line 3050
      (*(((__sd___3->ops)->tuner)->s_frequency))(__sd___3, (struct v4l2_frequency  const  *)(& freq));
    } else {

    }
#line 3050
    __mptr___8 = (struct list_head  const  *)__sd___3->list.next;
#line 3050
    __sd___3 = (struct v4l2_subdev *)__mptr___8 + 0xffffffffffffff80UL;
    ldv_51156: ;
#line 3050
    if ((unsigned long )(& __sd___3->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3052
      goto ldv_51155;
    } else {

    }

  } else {

  }
#line 3054
  if ((hdw->res_hor_dirty != 0 || hdw->res_ver_dirty != 0) || hdw->force_dirty != 0) {
#line 3056
    memset((void *)(& fmt), 0, 48UL);
#line 3057
    fmt.width = (__u32 )hdw->res_hor_val;
#line 3058
    fmt.height = (__u32 )hdw->res_ver_val;
#line 3059
    fmt.code = 1U;
#line 3060
    if ((pvrusb2_debug & 65536) != 0) {
#line 3060
      printk("\016pvrusb2: subdev v4l2 set_size(%dx%d)\n", fmt.width, fmt.height);
    } else {

    }
#line 3062
    __mptr___9 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3062
    __sd___4 = (struct v4l2_subdev *)__mptr___9 + 0xffffffffffffff80UL;
#line 3062
    goto ldv_51165;
    ldv_51164: ;
#line 3062
    if ((unsigned long )(__sd___4->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd___4->ops)->video)->s_mbus_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_mbus_framefmt * ))0)) {
#line 3062
      (*(((__sd___4->ops)->video)->s_mbus_fmt))(__sd___4, & fmt);
    } else {

    }
#line 3062
    __mptr___10 = (struct list_head  const  *)__sd___4->list.next;
#line 3062
    __sd___4 = (struct v4l2_subdev *)__mptr___10 + 0xffffffffffffff80UL;
    ldv_51165: ;
#line 3062
    if ((unsigned long )(& __sd___4->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3064
      goto ldv_51164;
    } else {

    }

  } else {

  }
#line 3065
  if (hdw->srate_dirty != 0 || hdw->force_dirty != 0) {
#line 3067
    if ((pvrusb2_debug & 65536) != 0) {
#line 3067
      printk("\016pvrusb2: subdev v4l2 set_audio %d\n", hdw->srate_val);
    } else {

    }
#line 3069
    switch (hdw->srate_val) {
    default: ;
    case 1: 
#line 3072
    val = 48000U;
#line 3073
    goto ldv_51170;
    case 0: 
#line 3075
    val = 44100U;
#line 3076
    goto ldv_51170;
    case 2: 
#line 3078
    val = 32000U;
#line 3079
    goto ldv_51170;
    }
    ldv_51170: 
#line 3081
    __mptr___11 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3081
    __sd___5 = (struct v4l2_subdev *)__mptr___11 + 0xffffffffffffff80UL;
#line 3081
    goto ldv_51179;
    ldv_51178: ;
#line 3081
    if ((unsigned long )(__sd___5->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd___5->ops)->audio)->s_clock_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             u32  ))0)) {
#line 3081
      (*(((__sd___5->ops)->audio)->s_clock_freq))(__sd___5, val);
    } else {

    }
#line 3081
    __mptr___12 = (struct list_head  const  *)__sd___5->list.next;
#line 3081
    __sd___5 = (struct v4l2_subdev *)__mptr___12 + 0xffffffffffffff80UL;
    ldv_51179: ;
#line 3081
    if ((unsigned long )(& __sd___5->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3083
      goto ldv_51178;
    } else {

    }

  } else {

  }
#line 3088
  __mptr___13 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3088
  sd = (struct v4l2_subdev *)__mptr___13 + 0xffffffffffffff80UL;
#line 3088
  goto ldv_51189;
  ldv_51188: 
#line 3089
  id = sd->grp_id;
#line 3090
  if (id > 6U) {
#line 3090
    goto ldv_51187;
  } else {

  }
#line 3091
  fp = pvr2_module_update_functions[id];
#line 3092
  if ((unsigned long )fp == (unsigned long )((void (*)(struct pvr2_hdw * , struct v4l2_subdev * ))0)) {
#line 3092
    goto ldv_51187;
  } else {

  }
#line 3093
  (*fp)(hdw, sd);
  ldv_51187: 
#line 3088
  __mptr___14 = (struct list_head  const  *)sd->list.next;
#line 3088
  sd = (struct v4l2_subdev *)__mptr___14 + 0xffffffffffffff80UL;
  ldv_51189: ;
#line 3088
  if ((unsigned long )(& sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3090
    goto ldv_51188;
  } else {

  }

#line 3096
  if (hdw->tuner_signal_stale != 0 || hdw->cropcap_stale != 0) {
#line 3097
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 3098
  return;
}
}
#line 3105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int value ;
  int commit_flag ;
  char buf[100U] ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 3110
  commit_flag = hdw->force_dirty;
#line 3114
  idx = 0U;
#line 3114
  goto ldv_51203;
  ldv_51202: 
#line 3115
  cptr = hdw->controls + (unsigned long )idx;
#line 3116
  if ((unsigned long )(cptr->info)->is_dirty == (unsigned long )((int (*)(struct pvr2_ctrl * ))0)) {
#line 3116
    goto ldv_51201;
  } else {

  }
#line 3117
  tmp = (*((cptr->info)->is_dirty))(cptr);
#line 3117
  if (tmp == 0) {
#line 3117
    goto ldv_51201;
  } else {

  }
#line 3118
  commit_flag = 1;
#line 3120
  if ((pvrusb2_debug & 128) == 0) {
#line 3120
    goto ldv_51201;
  } else {

  }
#line 3121
  tmp___0 = scnprintf((char *)(& buf), 100UL, "\"%s\" <-- ", (cptr->info)->name);
#line 3121
  bcnt = (unsigned int )tmp___0;
#line 3123
  value = 0;
#line 3124
  (*((cptr->info)->get_value))(cptr, & value);
#line 3125
  pvr2_ctrl_value_to_sym_internal(cptr, -1, value, (char *)(& buf) + (unsigned long )bcnt,
                                  100U - bcnt, & ccnt);
#line 3128
  bcnt = bcnt + ccnt;
#line 3129
  tmp___1 = get_ctrl_typename((cptr->info)->type);
#line 3129
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )bcnt, 100UL - (unsigned long )bcnt,
                      " <%s>", tmp___1);
#line 3129
  bcnt = (unsigned int )tmp___2 + bcnt;
#line 3131
  if ((pvrusb2_debug & 128) != 0) {
#line 3131
    printk("\016pvrusb2: /*--TRACE_COMMIT--*/ %.*s\n", bcnt, (char *)(& buf));
  } else {

  }
  ldv_51201: 
#line 3114
  idx = idx + 1U;
  ldv_51203: ;
#line 3114
  if (hdw->control_cnt > idx) {
#line 3116
    goto ldv_51202;
  } else {

  }

#line 3136
  if (commit_flag == 0) {
#line 3138
    return (0);
  } else {

  }
#line 3141
  hdw->state_pipeline_config = 0;
#line 3142
  trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 3143
  pvr2_hdw_state_sched(hdw);
#line 3145
  return (1);
}
}
#line 3154 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_commit_execute(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int disruptive_change ;
  int nvres ;
  int gop_size ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;
  int _min1 ;
  int _min2 ;
  int nvres___0 ;
  int _min1___0 ;
  int _min2___0 ;
  struct v4l2_ext_controls cs___0 ;
  struct v4l2_ext_control c1___0 ;
  u32 b ;
  int tmp ;

  {
#line 3160
  if ((hdw->input_dirty != 0 && hdw->state_pathway_ok != 0) && (hdw->input_val == 1 ? 2 : 1) != hdw->pathway_state) {
#line 3165
    hdw->state_pathway_ok = 0;
#line 3166
    trace_stbit("state_pathway_ok", hdw->state_pathway_ok);
  } else {

  }
#line 3168
  if (hdw->state_pathway_ok == 0) {
#line 3170
    return (0);
  } else {

  }
#line 3175
  if (hdw->std_dirty != 0) {
#line 3178
    if ((hdw->std_mask_cur & 63744ULL) != 0ULL) {
#line 3179
      nvres = 480;
#line 3180
      gop_size = 15;
    } else {
#line 3182
      nvres = 576;
#line 3183
      gop_size = 12;
    }
#line 3187
    if (hdw->res_ver_val != nvres) {
#line 3188
      hdw->res_ver_val = nvres;
#line 3189
      hdw->res_ver_dirty = 1;
    } else {

    }
#line 3193
    if ((int )hdw->enc_ctl_state.video_gop_size != gop_size) {
#line 3196
      memset((void *)(& cs), 0, 32UL);
#line 3197
      memset((void *)(& c1), 0, 20UL);
#line 3198
      cs.controls = & c1;
#line 3199
      cs.count = 1U;
#line 3200
      c1.id = 10029515U;
#line 3201
      c1.ldv_29295.value = gop_size;
#line 3202
      cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs, 3223344712U);
    } else {

    }
  } else {

  }
#line 3213
  if (hdw->res_hor_dirty != 0 && hdw->cropw_val < hdw->res_hor_val) {
#line 3214
    hdw->cropw_val = hdw->res_hor_val;
#line 3215
    hdw->cropw_dirty = 1;
  } else
#line 3216
  if (hdw->cropw_dirty != 0) {
#line 3217
    hdw->res_hor_dirty = 1;
#line 3218
    _min1 = 720;
#line 3218
    _min2 = hdw->cropw_val;
#line 3218
    hdw->res_hor_val = _min1 < _min2 ? _min1 : _min2;
  } else {

  }
#line 3220
  if (hdw->res_ver_dirty != 0 && hdw->croph_val < hdw->res_ver_val) {
#line 3221
    hdw->croph_val = hdw->res_ver_val;
#line 3222
    hdw->croph_dirty = 1;
  } else
#line 3223
  if (hdw->croph_dirty != 0) {
#line 3224
    nvres___0 = (hdw->std_mask_cur & 63744ULL) != 0ULL ? 480 : 576;
#line 3225
    hdw->res_ver_dirty = 1;
#line 3226
    _min1___0 = nvres___0;
#line 3226
    _min2___0 = hdw->croph_val;
#line 3226
    hdw->res_ver_val = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
  } else {

  }
#line 3233
  disruptive_change = (((((((hdw->std_dirty != 0 || hdw->enc_unsafe_stale != 0) || hdw->srate_dirty != 0) || hdw->res_ver_dirty != 0) || hdw->res_hor_dirty != 0) || hdw->cropw_dirty != 0) || hdw->croph_dirty != 0) || hdw->input_dirty != 0) || (unsigned int )hdw->active_stream_type != (unsigned int )hdw->desired_stream_type;
#line 3243
  if (disruptive_change != 0 && hdw->state_pipeline_idle == 0) {
#line 3247
    hdw->state_pipeline_pause = 1;
#line 3248
    return (0);
  } else {

  }
#line 3251
  if (hdw->srate_dirty != 0) {
#line 3258
    memset((void *)(& cs___0), 0, 32UL);
#line 3259
    memset((void *)(& c1___0), 0, 20UL);
#line 3260
    cs___0.controls = & c1___0;
#line 3261
    cs___0.count = 1U;
#line 3262
    c1___0.id = 10029412U;
#line 3263
    c1___0.ldv_29295.value = hdw->srate_val;
#line 3264
    cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs___0, 3223344712U);
  } else {

  }
#line 3267
  if ((unsigned int )hdw->active_stream_type != (unsigned int )hdw->desired_stream_type) {
#line 3269
    hdw->active_stream_type = hdw->desired_stream_type;
  } else {

  }
#line 3272
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 3276
    pvr2_hdw_gpio_get_out(hdw, & b);
#line 3277
    if (hdw->input_val == 4) {
#line 3279
      pvr2_hdw_gpio_chg_out(hdw, 2048U, 4294967295U);
    } else {
#line 3282
      pvr2_hdw_gpio_chg_out(hdw, 2048U, 0U);
    }
  } else {

  }
#line 3287
  pvr2_subdev_update(hdw);
#line 3289
  hdw->tuner_updated = 0;
#line 3290
  hdw->force_dirty = 0;
#line 3291
  idx = 0U;
#line 3291
  goto ldv_51227;
  ldv_51226: 
#line 3292
  cptr = hdw->controls + (unsigned long )idx;
#line 3293
  if ((unsigned long )(cptr->info)->clear_dirty == (unsigned long )((void (*)(struct pvr2_ctrl * ))0)) {
#line 3293
    goto ldv_51225;
  } else {

  }
#line 3294
  (*((cptr->info)->clear_dirty))(cptr);
  ldv_51225: 
#line 3291
  idx = idx + 1U;
  ldv_51227: ;
#line 3291
  if (hdw->control_cnt > idx) {
#line 3293
    goto ldv_51226;
  } else {

  }

#line 3297
  if (hdw->pathway_state == 1 && hdw->state_encoder_run != 0) {
#line 3302
    tmp = pvr2_encoder_adjust(hdw);
#line 3302
    if (tmp < 0) {
#line 3302
      return (1);
    } else {

    }
  } else {

  }
#line 3305
  hdw->state_pipeline_config = 1;
#line 3309
  trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 3310
  return (1);
}
}
#line 3314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw ) 
{ 
  int fl ;
  int tmp ;

  {
#line 3317
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3317
  hdw->big_lock_held = 1;
#line 3318
  fl = pvr2_hdw_commit_setup(hdw);
#line 3319
  hdw->big_lock_held = 0;
#line 3319
  mutex_unlock(& hdw->big_lock_mutex);
#line 3320
  if (fl == 0) {
#line 3320
    return (0);
  } else {

  }
#line 3321
  tmp = pvr2_hdw_wait(hdw, 0);
#line 3321
  return (tmp);
}
}
#line 3325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_worker_poll(struct work_struct *work ) 
{ 
  int fl ;
  struct pvr2_hdw *hdw ;
  struct work_struct  const  *__mptr ;

  {
#line 3327
  fl = 0;
#line 3328
  __mptr = (struct work_struct  const  *)work;
#line 3328
  hdw = (struct pvr2_hdw *)__mptr + 0xfffffffffffffe78UL;
#line 3329
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3329
  hdw->big_lock_held = 1;
#line 3330
  fl = pvr2_hdw_state_eval(hdw);
#line 3331
  hdw->big_lock_held = 0;
#line 3331
  mutex_unlock(& hdw->big_lock_mutex);
#line 3332
  if (fl != 0 && (unsigned long )hdw->state_func != (unsigned long )((void (*)(void * ))0)) {
#line 3333
    (*(hdw->state_func))(hdw->state_data);
  } else {

  }
#line 3334
  return;
}
}
#line 3338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_wait(struct pvr2_hdw *hdw , int state ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;

  {
#line 3340
  __ret = 0;
#line 3340
  if (hdw->state_stale != 0 || (state != 0 && hdw->master_state == (unsigned int )state)) {
#line 3340
    __ret___0 = 0L;
#line 3340
    INIT_LIST_HEAD(& __wait.task_list);
#line 3340
    __wait.flags = 0U;
    ldv_51250: 
#line 3340
    tmp = prepare_to_wait_event(& hdw->state_wait_data, & __wait, 1);
#line 3340
    __int = tmp;
#line 3340
    if (hdw->state_stale == 0 && (state == 0 || hdw->master_state != (unsigned int )state)) {
#line 3340
      goto ldv_51249;
    } else {

    }
#line 3340
    if (__int != 0L) {
#line 3340
      __ret___0 = __int;
#line 3340
      goto ldv_51249;
    } else {

    }
#line 3340
    schedule();
#line 3340
    goto ldv_51250;
    ldv_51249: 
#line 3340
    finish_wait(& hdw->state_wait_data, & __wait);
#line 3340
    __ret = (int )__ret___0;
  } else {

  }
#line 3340
  return (__ret);
}
}
#line 3348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3350
  return ((char const   *)(& hdw->name));
}
}
#line 3354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_hdw_get_desc(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3356
  return ((char const   *)(hdw->hdw_desc)->description);
}
}
#line 3360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
char const   *pvr2_hdw_get_type(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3362
  return ((char const   *)(hdw->hdw_desc)->shortname);
}
}
#line 3366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_is_hsm(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 3369
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 3369
  hdw->ctl_lock_held = 1;
#line 3370
  hdw->cmd_buffer[0] = 11U;
#line 3371
  result = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                             1U);
#line 3374
  if (result < 0) {
#line 3374
    goto ldv_51266;
  } else {

  }
#line 3375
  result = (unsigned int )hdw->cmd_buffer[0] != 0U;
  ldv_51266: 
#line 3376
  hdw->ctl_lock_held = 0;
#line 3376
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 3377
  return (result);
}
}
#line 3382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3384
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3384
  hdw->big_lock_held = 1;
#line 3385
  pvr2_hdw_status_poll(hdw);
#line 3386
  hdw->big_lock_held = 0;
#line 3386
  mutex_unlock(& hdw->big_lock_mutex);
#line 3387
  return;
}
}
#line 3390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3392
  if (hdw->cropcap_stale == 0) {
#line 3393
    return (0);
  } else {

  }
#line 3395
  pvr2_hdw_status_poll(hdw);
#line 3396
  if (hdw->cropcap_stale != 0) {
#line 3397
    return (-5);
  } else {

  }
#line 3399
  return (0);
}
}
#line 3404 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw , struct v4l2_cropcap *pp ) 
{ 
  int stat ;
  size_t __len ;
  void *__ret ;

  {
#line 3406
  stat = 0;
#line 3407
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3407
  hdw->big_lock_held = 1;
#line 3408
  stat = pvr2_hdw_check_cropcap(hdw);
#line 3409
  if (stat == 0) {
#line 3410
    __len = 44UL;
#line 3410
    if (__len > 63UL) {
#line 3410
      __ret = __memcpy((void *)pp, (void const   *)(& hdw->cropcap_info), __len);
    } else {
#line 3410
      __ret = __builtin_memcpy((void *)pp, (void const   *)(& hdw->cropcap_info),
                               __len);
    }
  } else {

  }
#line 3412
  hdw->big_lock_held = 0;
#line 3412
  mutex_unlock(& hdw->big_lock_mutex);
#line 3413
  return (stat);
}
}
#line 3418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw , struct v4l2_tuner *vtp ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 3420
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3420
  hdw->big_lock_held = 1;
#line 3421
  if (hdw->tuner_signal_stale != 0) {
#line 3422
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 3424
  __len = 84UL;
#line 3424
  if (__len > 63UL) {
#line 3424
    __ret = __memcpy((void *)vtp, (void const   *)(& hdw->tuner_signal_info), __len);
  } else {
#line 3424
    __ret = __builtin_memcpy((void *)vtp, (void const   *)(& hdw->tuner_signal_info),
                             __len);
  }
#line 3425
  hdw->big_lock_held = 0;
#line 3425
  mutex_unlock(& hdw->big_lock_mutex);
#line 3426
  return (0);
}
}
#line 3431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp ) 
{ 


  {
#line 3433
  return (hp->vid_stream);
}
}
#line 3437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw ) 
{ 
  int nr ;
  int tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3439
  tmp = pvr2_hdw_get_unit_number(hdw);
#line 3439
  nr = tmp;
#line 3440
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3440
  hdw->big_lock_held = 1;
#line 3441
  printk("\016pvrusb2: =================  START STATUS CARD #%d  =================\n",
         nr);
#line 3442
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3442
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 3442
  goto ldv_51301;
  ldv_51300: ;
#line 3442
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->log_status != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 3442
    (*(((__sd->ops)->core)->log_status))(__sd);
  } else {

  }
#line 3442
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 3442
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51301: ;
#line 3442
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3444
    goto ldv_51300;
  } else {

  }

#line 3443
  if (pvrusb2_debug & 1) {
#line 3443
    printk("\016pvrusb2: cx2341x config:\n");
  } else {

  }
#line 3444
  cx2341x_log_status((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                     "pvrusb2");
#line 3445
  pvr2_hdw_state_log_state(hdw);
#line 3446
  printk("\016pvrusb2: ==================  END STATUS CARD #%d  ==================\n",
         nr);
#line 3447
  hdw->big_lock_held = 0;
#line 3447
  mutex_unlock(& hdw->big_lock_mutex);
#line 3448
  return;
}
}
#line 3454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static u8 *pvr2_full_eeprom_fetch(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_msg msg[2U] ;
  u8 *eeprom ;
  u8 iadd[2U] ;
  u8 addr ;
  u16 eepromSize ;
  unsigned int offs ;
  int ret ;
  int mode16 ;
  unsigned int pcnt ;
  unsigned int tcnt ;
  void *tmp ;

  {
#line 3463
  mode16 = 0;
#line 3465
  tmp = kmalloc(8192UL, 208U);
#line 3465
  eeprom = (u8 *)tmp;
#line 3466
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 3467
    if ((pvrusb2_debug & 2) != 0) {
#line 3467
      printk("\016pvrusb2: Failed to allocate memory required to read eeprom\n");
    } else {

    }
#line 3470
    return ((u8 *)0U);
  } else {

  }
#line 3473
  if ((pvrusb2_debug & 1024) != 0) {
#line 3473
    printk("\016pvrusb2: Value for eeprom addr from controller was 0x%x\n", hdw->eeprom_addr);
  } else {

  }
#line 3475
  addr = (u8 )hdw->eeprom_addr;
#line 3479
  if ((int )((signed char )addr) < 0) {
#line 3479
    addr = (u8 )((int )addr >> 1);
  } else {

  }
#line 3484
  mode16 = (int )addr & 1;
#line 3485
  eepromSize = mode16 != 0 ? 8192U : 256U;
#line 3486
  if ((pvrusb2_debug & 1024) != 0) {
#line 3486
    printk("\016pvrusb2: Examining %d byte eeprom at location 0x%x using %d bit addressing\n",
           (int )eepromSize, (int )addr, mode16 != 0 ? 16 : 8);
  } else {

  }
#line 3490
  msg[0].addr = (__u16 )addr;
#line 3491
  msg[0].flags = 0U;
#line 3492
  msg[0].len = mode16 != 0 ? 2U : 1U;
#line 3493
  msg[0].buf = (__u8 *)(& iadd);
#line 3494
  msg[1].addr = (__u16 )addr;
#line 3495
  msg[1].flags = 1U;
#line 3501
  memset((void *)eeprom, 0, 8192UL);
#line 3502
  tcnt = 0U;
#line 3502
  goto ldv_51319;
  ldv_51318: 
#line 3503
  pcnt = 16U;
#line 3504
  if (pcnt + tcnt > 8192U) {
#line 3504
    pcnt = 8192U - tcnt;
  } else {

  }
#line 3505
  offs = ((unsigned int )eepromSize + tcnt) + 4294959104U;
#line 3506
  if (mode16 != 0) {
#line 3507
    iadd[0] = (u8 )(offs >> 8);
#line 3508
    iadd[1] = (u8 )offs;
  } else {
#line 3510
    iadd[0] = (u8 )offs;
  }
#line 3512
  msg[1].len = (__u16 )pcnt;
#line 3513
  msg[1].buf = eeprom + (unsigned long )tcnt;
#line 3514
  ret = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 2);
#line 3514
  if (ret != 2) {
#line 3516
    if ((pvrusb2_debug & 2) != 0) {
#line 3516
      printk("\016pvrusb2: eeprom fetch set offs err=%d\n", ret);
    } else {

    }
#line 3518
    kfree((void const   *)eeprom);
#line 3519
    return ((u8 *)0U);
  } else {

  }
#line 3502
  tcnt = tcnt + pcnt;
  ldv_51319: ;
#line 3502
  if (tcnt <= 8191U) {
#line 3504
    goto ldv_51318;
  } else {

  }

#line 3522
  return (eeprom);
}
}
#line 3526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw , int mode , int enable_flag ) 
{ 
  int ret ;
  u16 address ;
  unsigned int pipe ;
  void *tmp ;
  unsigned int tmp___0 ;
  u8 *tmp___1 ;

  {
#line 3533
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3533
  hdw->big_lock_held = 1;
#line 3534
  if (((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0)) ^ (enable_flag == 0)) {
#line 3534
    goto ldv_51329;
  } else {

  }
#line 3536
  if (enable_flag == 0) {
#line 3537
    if ((pvrusb2_debug & 32768) != 0) {
#line 3537
      printk("\016pvrusb2: Cleaning up after CPU firmware fetch\n");
    } else {

    }
#line 3539
    kfree((void const   *)hdw->fw_buffer);
#line 3540
    hdw->fw_buffer = (char *)0;
#line 3541
    hdw->fw_size = 0U;
#line 3542
    if (hdw->fw_cpu_flag != 0) {
#line 3545
      pvr2_hdw_cpureset_assert(hdw, 0);
    } else {

    }
#line 3547
    goto ldv_51329;
  } else {

  }
#line 3550
  hdw->fw_cpu_flag = mode != 2;
#line 3551
  if (hdw->fw_cpu_flag != 0) {
#line 3552
    hdw->fw_size = mode == 1 ? 16384U : 8192U;
#line 3553
    if ((pvrusb2_debug & 32768) != 0) {
#line 3553
      printk("\016pvrusb2: Preparing to suck out CPU firmware (size=%u)\n", hdw->fw_size);
    } else {

    }
#line 3556
    tmp = kzalloc((size_t )hdw->fw_size, 208U);
#line 3556
    hdw->fw_buffer = (char *)tmp;
#line 3557
    if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3558
      hdw->fw_size = 0U;
#line 3559
      goto ldv_51329;
    } else {

    }
#line 3563
    pvr2_hdw_cpureset_assert(hdw, 1);
#line 3568
    if ((pvrusb2_debug & 32768) != 0) {
#line 3568
      printk("\016pvrusb2: Grabbing CPU firmware\n");
    } else {

    }
#line 3570
    tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 3570
    pipe = tmp___0 | 2147483776U;
#line 3571
    address = 0U;
#line 3571
    goto ldv_51332;
    ldv_51331: 
#line 3573
    ret = usb_control_msg(hdw->usb_dev, pipe, 160, 192, (int )address, 0, (void *)hdw->fw_buffer + (unsigned long )address,
                          2048, 250);
#line 3578
    if (ret < 0) {
#line 3578
      goto ldv_51330;
    } else {

    }
#line 3572
    address = (unsigned int )address + 2048U;
    ldv_51332: ;
#line 3571
    if ((unsigned int )address < hdw->fw_size) {
#line 3573
      goto ldv_51331;
    } else {

    }
    ldv_51330: ;
#line 3581
    if ((pvrusb2_debug & 32768) != 0) {
#line 3581
      printk("\016pvrusb2: Done grabbing CPU firmware\n");
    } else {

    }
  } else {
#line 3584
    if ((pvrusb2_debug & 32768) != 0) {
#line 3584
      printk("\016pvrusb2: Sucking down EEPROM contents\n");
    } else {

    }
#line 3586
    tmp___1 = pvr2_full_eeprom_fetch(hdw);
#line 3586
    hdw->fw_buffer = (char *)tmp___1;
#line 3587
    if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3588
      if ((pvrusb2_debug & 32768) != 0) {
#line 3588
        printk("\016pvrusb2: EEPROM content suck failed.\n");
      } else {

      }
#line 3590
      goto ldv_51329;
    } else {

    }
#line 3592
    hdw->fw_size = 8192U;
#line 3593
    if ((pvrusb2_debug & 32768) != 0) {
#line 3593
      printk("\016pvrusb2: Done sucking down EEPROM contents\n");
    } else {

    }
  }
  ldv_51329: 
#line 3597
  hdw->big_lock_held = 0;
#line 3597
  mutex_unlock(& hdw->big_lock_mutex);
#line 3598
  return;
}
}
#line 3602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3604
  return ((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0));
}
}
#line 3608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw , unsigned int offs , char *buf , unsigned int cnt ) 
{ 
  int ret ;
  size_t __len ;
  void *__ret ;

  {
#line 3611
  ret = -22;
#line 3612
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 3612
  hdw->big_lock_held = 1;
#line 3613
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 3613
    goto ldv_51343;
  } else {

  }
#line 3614
  if (cnt == 0U) {
#line 3614
    goto ldv_51343;
  } else {

  }
#line 3616
  if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3617
    ret = -5;
#line 3618
    goto ldv_51343;
  } else {

  }
#line 3621
  if (hdw->fw_size <= offs) {
#line 3622
    if ((pvrusb2_debug & 32768) != 0) {
#line 3622
      printk("\016pvrusb2: Read firmware data offs=%d EOF\n", offs);
    } else {

    }
#line 3625
    ret = 0;
#line 3626
    goto ldv_51343;
  } else {

  }
#line 3629
  if (offs + cnt > hdw->fw_size) {
#line 3629
    cnt = hdw->fw_size - offs;
  } else {

  }
#line 3631
  __len = (size_t )cnt;
#line 3631
  __ret = __builtin_memcpy((void *)buf, (void const   *)hdw->fw_buffer + (unsigned long )offs,
                           __len);
#line 3633
  if ((pvrusb2_debug & 32768) != 0) {
#line 3633
    printk("\016pvrusb2: Read firmware data offs=%d cnt=%d\n", offs, cnt);
  } else {

  }
#line 3636
  ret = (int )cnt;
  ldv_51343: 
#line 3637
  hdw->big_lock_held = 0;
#line 3637
  mutex_unlock(& hdw->big_lock_mutex);
#line 3639
  return (ret);
}
}
#line 3643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ) 
{ 


  {
#line 3646
  switch ((unsigned int )index) {
  case 0U: ;
#line 3647
  return (hdw->v4l_minor_number_video);
  case 1U: ;
#line 3648
  return (hdw->v4l_minor_number_vbi);
  case 2U: ;
#line 3649
  return (hdw->v4l_minor_number_radio);
  default: ;
#line 3650
  return (-1);
  }
}
}
#line 3656 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ,
                                     int v ) 
{ 


  {
#line 3659
  switch ((unsigned int )index) {
  case 0U: 
#line 3660
  hdw->v4l_minor_number_video = v;
#line 3660
  goto ldv_51361;
  case 1U: 
#line 3661
  hdw->v4l_minor_number_vbi = v;
#line 3661
  goto ldv_51361;
  case 2U: 
#line 3662
  hdw->v4l_minor_number_radio = v;
#line 3662
  goto ldv_51361;
  default: ;
#line 3663
  goto ldv_51361;
  }
  ldv_51361: ;
#line 3666
  return;
}
}
#line 3668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_ctl_write_complete(struct urb *urb ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3670
  hdw = (struct pvr2_hdw *)urb->context;
#line 3671
  hdw->ctl_write_pend_flag = 0;
#line 3672
  if (hdw->ctl_read_pend_flag != 0) {
#line 3672
    return;
  } else {

  }
#line 3673
  complete(& hdw->ctl_done);
#line 3674
  return;
}
}
#line 3677 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_ctl_read_complete(struct urb *urb ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3679
  hdw = (struct pvr2_hdw *)urb->context;
#line 3680
  hdw->ctl_read_pend_flag = 0;
#line 3681
  if (hdw->ctl_write_pend_flag != 0) {
#line 3681
    return;
  } else {

  }
#line 3682
  complete(& hdw->ctl_done);
#line 3683
  return;
}
}
#line 3686 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_ctl_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3688
  hdw = (struct pvr2_hdw *)data;
#line 3689
  if (hdw->ctl_write_pend_flag != 0 || hdw->ctl_read_pend_flag != 0) {
#line 3690
    hdw->ctl_timeout_flag = 1;
#line 3691
    if (hdw->ctl_write_pend_flag != 0) {
#line 3692
      usb_unlink_urb(hdw->ctl_write_urb);
    } else {

    }
#line 3693
    if (hdw->ctl_read_pend_flag != 0) {
#line 3694
      usb_unlink_urb(hdw->ctl_read_urb);
    } else {

    }
  } else {

  }
#line 3696
  return;
}
}
#line 3703 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_send_request_ex(struct pvr2_hdw *hdw , unsigned int timeout , int probe_fl ,
                                void *write_data , unsigned int write_len , void *read_data ,
                                unsigned int read_len ) 
{ 
  unsigned int idx ;
  int status ;
  struct timer_list timer ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 3709
  status = 0;
#line 3711
  if (hdw->ctl_lock_held == 0) {
#line 3712
    if ((pvrusb2_debug & 2) != 0) {
#line 3712
      printk("\016pvrusb2: Attempted to execute control transfer without lock!!\n");
    } else {

    }
#line 3715
    return (-35);
  } else {

  }
#line 3717
  if (hdw->flag_ok == 0 && probe_fl == 0) {
#line 3718
    if ((pvrusb2_debug & 2) != 0) {
#line 3718
      printk("\016pvrusb2: Attempted to execute control transfer when device not ok\n");
    } else {

    }
#line 3721
    return (-5);
  } else {

  }
#line 3723
  if ((unsigned long )hdw->ctl_read_urb == (unsigned long )((struct urb *)0) || (unsigned long )hdw->ctl_write_urb == (unsigned long )((struct urb *)0)) {
#line 3724
    if (probe_fl == 0) {
#line 3725
      if ((pvrusb2_debug & 2) != 0) {
#line 3725
        printk("\016pvrusb2: Attempted to execute control transfer when USB is disconnected\n");
      } else {

      }
    } else {

    }
#line 3729
    return (-25);
  } else {

  }
#line 3733
  if ((unsigned long )write_data == (unsigned long )((void *)0)) {
#line 3733
    write_len = 0U;
  } else {

  }
#line 3734
  if ((unsigned long )read_data == (unsigned long )((void *)0)) {
#line 3734
    read_len = 0U;
  } else {

  }
#line 3735
  if (write_len > 64U) {
#line 3736
    if ((pvrusb2_debug & 2) != 0) {
#line 3736
      printk("\016pvrusb2: Attempted to execute %d byte control-write transfer (limit=%d)\n",
             write_len, 64);
    } else {

    }
#line 3741
    return (-22);
  } else {

  }
#line 3743
  if (read_len > 64U) {
#line 3744
    if ((pvrusb2_debug & 2) != 0) {
#line 3744
      printk("\016pvrusb2: Attempted to execute %d byte control-read transfer (limit=%d)\n",
             write_len, 64);
    } else {

    }
#line 3749
    return (-22);
  } else {

  }
#line 3751
  if (write_len == 0U && read_len == 0U) {
#line 3752
    if ((pvrusb2_debug & 2) != 0) {
#line 3752
      printk("\016pvrusb2: Attempted to execute null control transfer?\n");
    } else {

    }
#line 3755
    return (-22);
  } else {

  }
#line 3759
  hdw->cmd_debug_state = 1;
#line 3760
  if (write_len != 0U) {
#line 3761
    hdw->cmd_debug_code = *((unsigned char *)write_data);
  } else {
#line 3763
    hdw->cmd_debug_code = 0U;
  }
#line 3765
  hdw->cmd_debug_write_len = write_len;
#line 3766
  hdw->cmd_debug_read_len = read_len;
#line 3769
  init_completion(& hdw->ctl_done);
#line 3770
  hdw->ctl_timeout_flag = 0;
#line 3771
  hdw->ctl_write_pend_flag = 0;
#line 3772
  hdw->ctl_read_pend_flag = 0;
#line 3773
  reg_timer_3(& timer);
#line 3774
  timer.expires = (unsigned long )timeout + (unsigned long )jiffies;
#line 3775
  timer.data = (unsigned long )hdw;
#line 3776
  timer.function = & pvr2_ctl_timeout;
#line 3778
  if (write_len != 0U) {
#line 3779
    hdw->cmd_debug_state = 2;
#line 3781
    idx = 0U;
#line 3781
    goto ldv_51390;
    ldv_51389: 
#line 3782
    *(hdw->ctl_write_buffer + (unsigned long )idx) = *((unsigned char *)write_data + (unsigned long )idx);
#line 3781
    idx = idx + 1U;
    ldv_51390: ;
#line 3781
    if (idx < write_len) {
#line 3783
      goto ldv_51389;
    } else {

    }
#line 3786
    tmp = __create_pipe(hdw->usb_dev, 1U);
#line 3786
    usb_fill_bulk_urb(hdw->ctl_write_urb, hdw->usb_dev, tmp | 3221225472U, (void *)hdw->ctl_write_buffer,
                      (int )write_len, & pvr2_ctl_write_complete, (void *)hdw);
#line 3794
    (hdw->ctl_write_urb)->actual_length = 0U;
#line 3795
    hdw->ctl_write_pend_flag = 1;
#line 3796
    status = ldv_usb_submit_urb_302(hdw->ctl_write_urb, 208U);
#line 3797
    if (status < 0) {
#line 3798
      if ((pvrusb2_debug & 2) != 0) {
#line 3798
        printk("\016pvrusb2: Failed to submit write-control URB status=%d\n", status);
      } else {

      }
#line 3801
      hdw->ctl_write_pend_flag = 0;
#line 3802
      goto done;
    } else {

    }
  } else {

  }
#line 3806
  if (read_len != 0U) {
#line 3807
    hdw->cmd_debug_state = 3;
#line 3808
    memset((void *)hdw->ctl_read_buffer, 67, (size_t )read_len);
#line 3810
    tmp___0 = __create_pipe(hdw->usb_dev, 129U);
#line 3810
    usb_fill_bulk_urb(hdw->ctl_read_urb, hdw->usb_dev, tmp___0 | 3221225600U, (void *)hdw->ctl_read_buffer,
                      (int )read_len, & pvr2_ctl_read_complete, (void *)hdw);
#line 3818
    (hdw->ctl_read_urb)->actual_length = 0U;
#line 3819
    hdw->ctl_read_pend_flag = 1;
#line 3820
    status = ldv_usb_submit_urb_303(hdw->ctl_read_urb, 208U);
#line 3821
    if (status < 0) {
#line 3822
      if ((pvrusb2_debug & 2) != 0) {
#line 3822
        printk("\016pvrusb2: Failed to submit read-control URB status=%d\n", status);
      } else {

      }
#line 3825
      hdw->ctl_read_pend_flag = 0;
#line 3826
      goto done;
    } else {

    }
  } else {

  }
#line 3831
  add_timer(& timer);
#line 3834
  hdw->cmd_debug_state = 4;
#line 3835
  goto ldv_51394;
  ldv_51393: 
#line 3836
  wait_for_completion(& hdw->ctl_done);
  ldv_51394: ;
#line 3835
  if (hdw->ctl_write_pend_flag != 0 || hdw->ctl_read_pend_flag != 0) {
#line 3837
    goto ldv_51393;
  } else {

  }
#line 3838
  hdw->cmd_debug_state = 5;
#line 3841
  ldv_del_timer_sync_304(& timer);
#line 3843
  hdw->cmd_debug_state = 6;
#line 3844
  status = 0;
#line 3846
  if (hdw->ctl_timeout_flag != 0) {
#line 3847
    status = -110;
#line 3848
    if (probe_fl == 0) {
#line 3849
      if ((pvrusb2_debug & 2) != 0) {
#line 3849
        printk("\016pvrusb2: Timed out control-write\n");
      } else {

      }
    } else {

    }
#line 3852
    goto done;
  } else {

  }
#line 3855
  if (write_len != 0U) {
#line 3857
    if ((((hdw->ctl_write_urb)->status != 0 && (hdw->ctl_write_urb)->status != -2) && (hdw->ctl_write_urb)->status != -108) && (hdw->ctl_write_urb)->status != -104) {
#line 3863
      status = (hdw->ctl_write_urb)->status;
#line 3864
      if (probe_fl == 0) {
#line 3865
        if ((pvrusb2_debug & 2) != 0) {
#line 3865
          printk("\016pvrusb2: control-write URB failure, status=%d\n", status);
        } else {

        }
      } else {

      }
#line 3870
      goto done;
    } else {

    }
#line 3872
    if ((hdw->ctl_write_urb)->actual_length < write_len) {
#line 3874
      status = -5;
#line 3875
      if (probe_fl == 0) {
#line 3876
        if ((pvrusb2_debug & 2) != 0) {
#line 3876
          printk("\016pvrusb2: control-write URB short, expected=%d got=%d\n", write_len,
                 (hdw->ctl_write_urb)->actual_length);
        } else {

        }
      } else {

      }
#line 3882
      goto done;
    } else {

    }
  } else {

  }
#line 3885
  if (read_len != 0U) {
#line 3887
    if ((((hdw->ctl_read_urb)->status != 0 && (hdw->ctl_read_urb)->status != -2) && (hdw->ctl_read_urb)->status != -108) && (hdw->ctl_read_urb)->status != -104) {
#line 3893
      status = (hdw->ctl_read_urb)->status;
#line 3894
      if (probe_fl == 0) {
#line 3895
        if ((pvrusb2_debug & 2) != 0) {
#line 3895
          printk("\016pvrusb2: control-read URB failure, status=%d\n", status);
        } else {

        }
      } else {

      }
#line 3900
      goto done;
    } else {

    }
#line 3902
    if ((hdw->ctl_read_urb)->actual_length < read_len) {
#line 3904
      status = -5;
#line 3905
      if (probe_fl == 0) {
#line 3906
        if ((pvrusb2_debug & 2) != 0) {
#line 3906
          printk("\016pvrusb2: control-read URB short, expected=%d got=%d\n", read_len,
                 (hdw->ctl_read_urb)->actual_length);
        } else {

        }
      } else {

      }
#line 3912
      goto done;
    } else {

    }
#line 3915
    idx = 0U;
#line 3915
    goto ldv_51397;
    ldv_51396: 
#line 3916
    *((unsigned char *)read_data + (unsigned long )idx) = *(hdw->ctl_read_buffer + (unsigned long )idx);
#line 3915
    idx = idx + 1U;
    ldv_51397: ;
#line 3915
    if (idx < read_len) {
#line 3917
      goto ldv_51396;
    } else {

    }

  } else {

  }
  done: 
#line 3923
  hdw->cmd_debug_state = 0;
#line 3924
  if (status < 0 && probe_fl == 0) {
#line 3925
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 3927
  return (status);
}
}
#line 3931 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_send_request(struct pvr2_hdw *hdw , void *write_data , unsigned int write_len ,
                      void *read_data , unsigned int read_len ) 
{ 
  int tmp ;

  {
#line 3935
  tmp = pvr2_send_request_ex(hdw, 1000U, 0, write_data, write_len, read_data, read_len);
#line 3935
  return (tmp);
}
}
#line 3941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw , u32 cmdcode ) 
{ 
  int ret ;
  unsigned int cnt ;
  unsigned int args ;
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int bcnt ;
  char tbuf[50U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3944
  cnt = 1U;
#line 3945
  args = 0U;
#line 3946
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 3946
  hdw->ctl_lock_held = 1;
#line 3947
  hdw->cmd_buffer[0] = (unsigned char )cmdcode;
#line 3948
  args = (cmdcode >> 8) & 255U;
#line 3949
  args = 2U < args ? 2U : args;
#line 3950
  if (args != 0U) {
#line 3951
    cnt = cnt + args;
#line 3952
    hdw->cmd_buffer[1] = (unsigned char )(cmdcode >> 16);
#line 3953
    if (args > 1U) {
#line 3954
      hdw->cmd_buffer[2] = (unsigned char )(cmdcode >> 24);
    } else {

    }
  } else {

  }
#line 3957
  if ((pvrusb2_debug & 32) != 0) {
#line 3961
    cmdcode = cmdcode & 255U;
#line 3962
    bcnt = 0U;
#line 3963
    tmp = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                    "Sending FX2 command 0x%x", cmdcode);
#line 3963
    ccnt = (unsigned int )tmp;
#line 3966
    bcnt = bcnt + ccnt;
#line 3967
    idx = 0U;
#line 3967
    goto ldv_51421;
    ldv_51420: ;
#line 3968
    if ((u32 )pvr2_fx2cmd_desc[idx].id == cmdcode) {
#line 3969
      tmp___0 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          " \"%s\"", pvr2_fx2cmd_desc[idx].desc);
#line 3969
      ccnt = (unsigned int )tmp___0;
#line 3973
      bcnt = bcnt + ccnt;
#line 3974
      goto ldv_51419;
    } else {

    }
#line 3967
    idx = idx + 1U;
    ldv_51421: ;
#line 3967
    if (idx <= 24U) {
#line 3969
      goto ldv_51420;
    } else {

    }
    ldv_51419: ;
#line 3977
    if (args != 0U) {
#line 3978
      tmp___1 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          " (%u", (int )hdw->cmd_buffer[1]);
#line 3978
      ccnt = (unsigned int )tmp___1;
#line 3981
      bcnt = bcnt + ccnt;
#line 3982
      if (args > 1U) {
#line 3983
        tmp___2 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                            ",%u", (int )hdw->cmd_buffer[2]);
#line 3983
        ccnt = (unsigned int )tmp___2;
#line 3986
        bcnt = bcnt + ccnt;
      } else {

      }
#line 3988
      tmp___3 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          ")");
#line 3988
      ccnt = (unsigned int )tmp___3;
#line 3991
      bcnt = bcnt + ccnt;
    } else {

    }
#line 3993
    if ((pvrusb2_debug & 32) != 0) {
#line 3993
      printk("\016pvrusb2: %.*s\n", bcnt, (char *)(& tbuf));
    } else {

    }
  } else {

  }
#line 3995
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), cnt, (void *)0, 0U);
#line 3996
  hdw->ctl_lock_held = 0;
#line 3996
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 3997
  return (ret);
}
}
#line 4001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_write_register(struct pvr2_hdw *hdw , u16 reg , u32 data ) 
{ 
  int ret ;

  {
#line 4005
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 4005
  hdw->ctl_lock_held = 1;
#line 4007
  hdw->cmd_buffer[0] = 4U;
#line 4008
  hdw->cmd_buffer[1] = (unsigned char )data;
#line 4008
  hdw->cmd_buffer[2] = (unsigned char )(data >> 8);
#line 4008
  hdw->cmd_buffer[3] = (unsigned char )(data >> 16);
#line 4008
  hdw->cmd_buffer[4] = (unsigned char )(data >> 24);
#line 4009
  hdw->cmd_buffer[5] = 0U;
#line 4010
  hdw->cmd_buffer[6] = (unsigned char )((int )reg >> 8);
#line 4011
  hdw->cmd_buffer[7] = (unsigned char )reg;
#line 4014
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          0U);
#line 4016
  hdw->ctl_lock_held = 0;
#line 4016
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 4018
  return (ret);
}
}
#line 4022 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_read_register(struct pvr2_hdw *hdw , u16 reg , u32 *data ) 
{ 
  int ret ;
  int tmp ;

  {
#line 4024
  ret = 0;
#line 4026
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 4026
  hdw->ctl_lock_held = 1;
#line 4028
  hdw->cmd_buffer[0] = 5U;
#line 4029
  hdw->cmd_buffer[1] = 0U;
#line 4030
  hdw->cmd_buffer[2] = 0U;
#line 4031
  hdw->cmd_buffer[3] = 0U;
#line 4032
  hdw->cmd_buffer[4] = 0U;
#line 4033
  hdw->cmd_buffer[5] = 0U;
#line 4034
  hdw->cmd_buffer[6] = (unsigned char )((int )reg >> 8);
#line 4035
  hdw->cmd_buffer[7] = (unsigned char )reg;
#line 4037
  tmp = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          4U);
#line 4037
  ret = tmp | ret;
#line 4038
  *data = ((((unsigned int )hdw->cmd_buffer[3] << 24) | ((unsigned int )hdw->cmd_buffer[2] << 16)) | ((unsigned int )hdw->cmd_buffer[1] << 8)) | (unsigned int )hdw->cmd_buffer[0];
#line 4040
  hdw->ctl_lock_held = 0;
#line 4040
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 4042
  return (ret);
}
}
#line 4046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_render_useless(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4048
  if (hdw->flag_ok == 0) {
#line 4048
    return;
  } else {

  }
#line 4049
  if ((pvrusb2_debug & 2) != 0) {
#line 4049
    printk("\016pvrusb2: Device being rendered inoperable\n");
  } else {

  }
#line 4051
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 4052
    pvr2_stream_setup(hdw->vid_stream, (struct usb_device *)0, 0, 0U);
  } else {

  }
#line 4054
  hdw->flag_ok = 0;
#line 4055
  trace_stbit("flag_ok", hdw->flag_ok);
#line 4056
  pvr2_hdw_state_sched(hdw);
#line 4057
  return;
}
}
#line 4060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_device_reset(struct pvr2_hdw *hdw ) 
{ 
  int ret ;

  {
#line 4063
  if ((pvrusb2_debug & 32) != 0) {
#line 4063
    printk("\016pvrusb2: Performing a device reset...\n");
  } else {

  }
#line 4064
  ret = usb_lock_device_for_reset(hdw->usb_dev, (struct usb_interface  const  *)0);
#line 4065
  if (ret == 0) {
#line 4066
    ret = usb_reset_device(hdw->usb_dev);
#line 4067
    device_unlock(& (hdw->usb_dev)->dev);
  } else
#line 4069
  if ((pvrusb2_debug & 2) != 0) {
#line 4069
    printk("\016pvrusb2: Failed to lock USB device ret=%d\n", ret);
  } else {

  }
#line 4072
  if (init_pause_msec != 0) {
#line 4073
    if (pvrusb2_debug & 1) {
#line 4073
      printk("\016pvrusb2: Waiting %u msec for hardware to settle\n", init_pause_msec);
    } else {

    }
#line 4076
    msleep((unsigned int )init_pause_msec);
  } else {

  }
#line 4078
  return;
}
}
#line 4082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw , int val ) 
{ 
  char *da ;
  unsigned int pipe ;
  int ret ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 4088
  if ((unsigned long )hdw->usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 4088
    return;
  } else {

  }
#line 4090
  tmp = kmalloc(16UL, 208U);
#line 4090
  da = (char *)tmp;
#line 4092
  if ((unsigned long )da == (unsigned long )((char *)0)) {
#line 4093
    if ((pvrusb2_debug & 2) != 0) {
#line 4093
      printk("\016pvrusb2: Unable to allocate memory to control CPU reset\n");
    } else {

    }
#line 4095
    return;
  } else {

  }
#line 4098
  if ((pvrusb2_debug & 32) != 0) {
#line 4098
    printk("\016pvrusb2: cpureset_assert(%d)\n", val);
  } else {

  }
#line 4100
  *da = val != 0;
#line 4104
  tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 4104
  pipe = tmp___0 | 2147483648U;
#line 4105
  ret = usb_control_msg(hdw->usb_dev, pipe, 160, 64, 58880, 0, (void *)da, 1, 250);
#line 4106
  if (ret < 0) {
#line 4107
    if ((pvrusb2_debug & 2) != 0) {
#line 4107
      printk("\016pvrusb2: cpureset_assert(%d) error=%d\n", val, ret);
    } else {

    }
#line 4109
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 4112
  kfree((void const   *)da);
#line 4113
  return;
}
}
#line 4116 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4118
  tmp = pvr2_issue_simple_cmd(hdw, 221U);
#line 4118
  return (tmp);
}
}
#line 4122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4124
  tmp = pvr2_issue_simple_cmd(hdw, 222U);
#line 4124
  return (tmp);
}
}
#line 4128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cmd_powerdown(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4130
  tmp = pvr2_issue_simple_cmd(hdw, 220U);
#line 4130
  return (tmp);
}
}
#line 4134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4136
  if ((pvrusb2_debug & 32) != 0) {
#line 4136
    printk("\016pvrusb2: Requesting decoder reset\n");
  } else {

  }
#line 4138
  if (hdw->decoder_client_id != 0U) {
#line 4139
    __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 4139
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 4139
    goto ldv_51466;
    ldv_51465: ;
#line 4139
    if (((hdw->decoder_client_id == 0U || __sd->grp_id == hdw->decoder_client_id) && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                         u32  ))0)) {
#line 4139
      (*(((__sd->ops)->core)->reset))(__sd, 0U);
    } else {

    }
#line 4139
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 4139
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
    ldv_51466: ;
#line 4139
    if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 4141
      goto ldv_51465;
    } else {

    }
#line 4141
    pvr2_hdw_cx25840_vbi_hack(hdw);
#line 4142
    return (0);
  } else {

  }
#line 4144
  if ((pvrusb2_debug & 32) != 0) {
#line 4144
    printk("\016pvrusb2: Unable to reset decoder: nothing attached\n");
  } else {

  }
#line 4146
  return (-25);
}
}
#line 4150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_cmd_hcw_demod_reset(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4152
  hdw->flag_ok = 1;
#line 4153
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 66032U : 496U);
#line 4153
  return (tmp);
}
}
#line 4160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_cmd_onair_fe_power_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4162
  hdw->flag_ok = 1;
#line 4163
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 162U : 163U);
#line 4163
  return (tmp);
}
}
#line 4169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_cmd_onair_digital_path_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4172
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 160U : 161U);
#line 4172
  return (tmp);
}
}
#line 4178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_cmd_modeswitch(struct pvr2_hdw *hdw , int digitalFl ) 
{ 
  int cmode ;

  {
#line 4183
  cmode = digitalFl != 0 ? 2 : 1;
#line 4184
  if (hdw->pathway_state == cmode) {
#line 4186
    return;
  } else {

  }
#line 4189
  switch ((int )(hdw->hdw_desc)->digital_control_scheme) {
  case 1: 
#line 4191
  pvr2_hdw_cmd_hcw_demod_reset(hdw, digitalFl);
#line 4192
  if (cmode == 1) {
#line 4197
    pvr2_hdw_cmd_decoder_reset(hdw);
  } else {

  }
#line 4199
  goto ldv_51486;
  case 2: 
#line 4204
  pvr2_hdw_cmd_onair_fe_power_ctrl(hdw, digitalFl);
#line 4205
  goto ldv_51486;
  default: ;
#line 4206
  goto ldv_51486;
  }
  ldv_51486: 
#line 4209
  pvr2_hdw_untrip_unlocked(hdw);
#line 4210
  hdw->pathway_state = cmode;
#line 4211
  return;
}
}
#line 4214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_led_ctrl_hauppauge(struct pvr2_hdw *hdw , int onoff ) 
{ 


  {
#line 4222
  if (onoff != 0) {
#line 4223
    pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1153U);
  } else {
#line 4225
    pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1025U);
  }
#line 4227
  pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 0U);
#line 4228
  return;
}
}
#line 4233 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static led_method_func led_methods[2U]  = {      0,      & pvr2_led_ctrl_hauppauge};
#line 4239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_led_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  unsigned int scheme_id ;
  void (*fp)(struct pvr2_hdw * , int  ) ;

  {
#line 4244
  if ((onoff != 0) ^ (hdw->led_on == 0)) {
#line 4244
    return;
  } else {

  }
#line 4246
  hdw->led_on = onoff != 0;
#line 4248
  scheme_id = (unsigned int )(hdw->hdw_desc)->led_scheme;
#line 4249
  if (scheme_id <= 1U) {
#line 4250
    fp = led_methods[scheme_id];
  } else {
#line 4252
    fp = (void (*)(struct pvr2_hdw * , int  ))0;
  }
#line 4255
  if ((unsigned long )fp != (unsigned long )((void (*)(struct pvr2_hdw * , int  ))0)) {
#line 4255
    (*fp)(hdw, onoff);
  } else {

  }
#line 4256
  return;
}
}
#line 4260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw , int runFl ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4266
  if (hdw->pathway_state == 1) {
#line 4267
    tmp = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 54U : 55U);
#line 4267
    return (tmp);
  } else {

  }
#line 4274
  if (hdw->pathway_state != 2) {
#line 4276
    return (-22);
  } else {

  }
#line 4283
  switch ((int )(hdw->hdw_desc)->digital_control_scheme) {
  case 1: 
#line 4285
  tmp___0 = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 241U : 242U);
#line 4285
  return (tmp___0);
  case 2: 
#line 4290
  ret = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 54U : 55U);
#line 4294
  if (ret != 0) {
#line 4294
    return (ret);
  } else {

  }
#line 4295
  tmp___1 = pvr2_hdw_cmd_onair_digital_path_ctrl(hdw, runFl);
#line 4295
  return (tmp___1);
  default: ;
#line 4297
  return (-22);
  }
}
}
#line 4303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_pathway_ok(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4305
  if (hdw->state_pathway_ok != 0) {
#line 4307
    return (0);
  } else {

  }
#line 4309
  if (hdw->state_pipeline_idle == 0) {
#line 4311
    return (0);
  } else {

  }
#line 4313
  pvr2_hdw_cmd_modeswitch(hdw, hdw->input_val == 1);
#line 4314
  hdw->state_pathway_ok = 1;
#line 4315
  trace_stbit("state_pathway_ok", hdw->state_pathway_ok);
#line 4316
  return (1);
}
}
#line 4321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_encoder_ok(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4323
  if (hdw->state_encoder_ok != 0) {
#line 4323
    return (0);
  } else {

  }
#line 4324
  if (hdw->flag_tripped != 0) {
#line 4324
    return (0);
  } else {

  }
#line 4325
  if (hdw->state_encoder_run != 0) {
#line 4325
    return (0);
  } else {

  }
#line 4326
  if (hdw->state_encoder_config != 0) {
#line 4326
    return (0);
  } else {

  }
#line 4327
  if (hdw->state_decoder_run != 0) {
#line 4327
    return (0);
  } else {

  }
#line 4328
  if (hdw->state_usbstream_run != 0) {
#line 4328
    return (0);
  } else {

  }
#line 4329
  if (hdw->pathway_state == 2) {
#line 4330
    if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) == 0U) {
#line 4330
      return (0);
    } else {

    }
  } else
#line 4331
  if (hdw->pathway_state != 1) {
#line 4332
    return (0);
  } else {

  }
#line 4335
  tmp = pvr2_upload_firmware2(hdw);
#line 4335
  if (tmp < 0) {
#line 4336
    hdw->flag_tripped = 1;
#line 4337
    trace_stbit("flag_tripped", hdw->flag_tripped);
#line 4338
    return (1);
  } else {

  }
#line 4340
  hdw->state_encoder_ok = 1;
#line 4341
  trace_stbit("state_encoder_ok", hdw->state_encoder_ok);
#line 4342
  return (1);
}
}
#line 4347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_encoder_config(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 4349
  if (hdw->state_encoder_config != 0) {
#line 4350
    if (hdw->state_encoder_ok != 0) {
#line 4351
      if (hdw->state_pipeline_req != 0 && hdw->state_pipeline_pause == 0) {
#line 4352
        return (0);
      } else {

      }
    } else {

    }
#line 4354
    hdw->state_encoder_config = 0;
#line 4355
    hdw->state_encoder_waitok = 0;
#line 4356
    trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4358
    ldv_del_timer_sync_305(& hdw->encoder_wait_timer);
  } else {
#line 4360
    if ((((((hdw->state_pathway_ok == 0 || hdw->pathway_state != 1) || hdw->state_encoder_ok == 0) || hdw->state_pipeline_idle == 0) || hdw->state_pipeline_pause != 0) || hdw->state_pipeline_req == 0) || hdw->state_pipeline_config == 0) {
#line 4370
      tmp = timer_pending((struct timer_list  const  *)(& hdw->encoder_wait_timer));
#line 4370
      if (tmp != 0) {
#line 4371
        ldv_del_timer_sync_306(& hdw->encoder_wait_timer);
      } else {

      }
#line 4373
      if (hdw->state_encoder_waitok != 0) {
#line 4377
        hdw->state_encoder_waitok = 0;
#line 4378
        trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4380
        return (1);
      } else {

      }
#line 4382
      return (0);
    } else {

    }
#line 4384
    if (hdw->state_encoder_waitok == 0) {
#line 4385
      tmp___0 = timer_pending((struct timer_list  const  *)(& hdw->encoder_wait_timer));
#line 4385
      if (tmp___0 == 0) {
#line 4392
        if (hdw->state_encoder_waitok == 0) {
#line 4393
          hdw->encoder_wait_timer.expires = (unsigned long )jiffies + 12UL;
#line 4397
          add_timer(& hdw->encoder_wait_timer);
        } else {

        }
      } else {

      }
#line 4403
      return (0);
    } else {

    }
#line 4405
    pvr2_encoder_configure(hdw);
#line 4406
    if (hdw->state_encoder_ok != 0) {
#line 4406
      hdw->state_encoder_config = 1;
    } else {

    }
  }
#line 4408
  trace_stbit("state_encoder_config", hdw->state_encoder_config);
#line 4409
  return (1);
}
}
#line 4414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_check_disable_encoder_run(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4416
  if (hdw->state_encoder_ok == 0) {
#line 4418
    return (1);
  } else {

  }
#line 4420
  if (hdw->state_pathway_ok == 0) {
#line 4423
    return (1);
  } else {

  }
#line 4426
  switch (hdw->pathway_state) {
  case 1: ;
#line 4428
  if (hdw->state_decoder_run == 0) {
#line 4432
    return (1);
  } else {

  }
#line 4434
  goto ldv_51526;
  case 2: ;
#line 4436
  if (hdw->state_encoder_runok != 0) {
#line 4444
    return (1);
  } else {

  }
#line 4446
  goto ldv_51526;
  default: ;
#line 4449
  return (1);
  }
  ldv_51526: ;
#line 4454
  return (0);
}
}
#line 4459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_check_enable_encoder_run(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4461
  if (hdw->state_encoder_ok == 0) {
#line 4463
    return (0);
  } else {

  }
#line 4465
  if (hdw->state_pathway_ok == 0) {
#line 4468
    return (0);
  } else {

  }
#line 4471
  switch (hdw->pathway_state) {
  case 1: ;
#line 4473
  if (hdw->state_decoder_run != 0 && hdw->state_decoder_ready != 0) {
#line 4476
    return (1);
  } else {

  }
#line 4478
  goto ldv_51533;
  case 2: ;
#line 4480
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->digital_control_scheme) == 2U && hdw->state_encoder_runok == 0) {
#line 4491
    return (1);
  } else {

  }
#line 4493
  goto ldv_51533;
  default: ;
#line 4496
  goto ldv_51533;
  }
  ldv_51533: ;
#line 4500
  return (0);
}
}
#line 4505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_encoder_run(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4507
  if (hdw->state_encoder_run != 0) {
#line 4508
    tmp = state_check_disable_encoder_run(hdw);
#line 4508
    if (tmp == 0) {
#line 4508
      return (0);
    } else {

    }
#line 4509
    if (hdw->state_encoder_ok != 0) {
#line 4510
      ldv_del_timer_sync_307(& hdw->encoder_run_timer);
#line 4511
      tmp___0 = pvr2_encoder_stop(hdw);
#line 4511
      if (tmp___0 < 0) {
#line 4511
        return (1);
      } else {

      }
    } else {

    }
#line 4513
    hdw->state_encoder_run = 0;
  } else {
#line 4515
    tmp___1 = state_check_enable_encoder_run(hdw);
#line 4515
    if (tmp___1 == 0) {
#line 4515
      return (0);
    } else {

    }
#line 4516
    tmp___2 = pvr2_encoder_start(hdw);
#line 4516
    if (tmp___2 < 0) {
#line 4516
      return (1);
    } else {

    }
#line 4517
    hdw->state_encoder_run = 1;
#line 4518
    if (hdw->state_encoder_runok == 0) {
#line 4519
      hdw->encoder_run_timer.expires = (unsigned long )jiffies + 62UL;
#line 4521
      add_timer(& hdw->encoder_run_timer);
    } else {

    }
  }
#line 4524
  trace_stbit("state_encoder_run", hdw->state_encoder_run);
#line 4525
  return (1);
}
}
#line 4530 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_quiescent_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4532
  hdw = (struct pvr2_hdw *)data;
#line 4533
  hdw->state_decoder_quiescent = 1;
#line 4534
  trace_stbit("state_decoder_quiescent", hdw->state_decoder_quiescent);
#line 4535
  hdw->state_stale = 1;
#line 4536
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4537
  return;
}
}
#line 4541 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_decoder_stabilization_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4543
  hdw = (struct pvr2_hdw *)data;
#line 4544
  hdw->state_decoder_ready = 1;
#line 4545
  trace_stbit("state_decoder_ready", hdw->state_decoder_ready);
#line 4546
  hdw->state_stale = 1;
#line 4547
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4548
  return;
}
}
#line 4552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_encoder_wait_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4554
  hdw = (struct pvr2_hdw *)data;
#line 4555
  hdw->state_encoder_waitok = 1;
#line 4556
  trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4557
  hdw->state_stale = 1;
#line 4558
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4559
  return;
}
}
#line 4563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_encoder_run_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4565
  hdw = (struct pvr2_hdw *)data;
#line 4566
  if (hdw->state_encoder_runok == 0) {
#line 4567
    hdw->state_encoder_runok = 1;
#line 4568
    trace_stbit("state_encoder_runok", hdw->state_encoder_runok);
#line 4569
    hdw->state_stale = 1;
#line 4570
    queue_work(hdw->workqueue, & hdw->workpoll);
  } else {

  }
#line 4572
  return;
}
}
#line 4576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_decoder_run(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 4578
  if (hdw->state_decoder_run != 0) {
#line 4579
    if (hdw->state_encoder_ok != 0) {
#line 4580
      if ((hdw->state_pipeline_req != 0 && hdw->state_pipeline_pause == 0) && hdw->state_pathway_ok != 0) {
#line 4582
        return (0);
      } else {

      }
    } else {

    }
#line 4584
    if (hdw->flag_decoder_missed == 0) {
#line 4585
      pvr2_decoder_enable(hdw, 0);
    } else {

    }
#line 4587
    hdw->state_decoder_quiescent = 0;
#line 4588
    hdw->state_decoder_run = 0;
#line 4590
    ldv_del_timer_sync_308(& hdw->quiescent_timer);
#line 4594
    ldv_del_timer_sync_309(& hdw->decoder_stabilization_timer);
#line 4595
    hdw->state_decoder_ready = 0;
  } else {
#line 4597
    if (hdw->state_decoder_quiescent == 0) {
#line 4598
      tmp = timer_pending((struct timer_list  const  *)(& hdw->quiescent_timer));
#line 4598
      if (tmp == 0) {
#line 4609
        if (hdw->state_decoder_quiescent == 0) {
#line 4610
          hdw->quiescent_timer.expires = (unsigned long )jiffies + 12UL;
#line 4614
          add_timer(& hdw->quiescent_timer);
        } else {

        }
      } else {

      }
#line 4620
      return (0);
    } else {

    }
#line 4622
    if ((((((hdw->state_pathway_ok == 0 || hdw->pathway_state != 1) || hdw->state_pipeline_req == 0) || hdw->state_pipeline_pause != 0) || hdw->state_pipeline_config == 0) || hdw->state_encoder_config == 0) || hdw->state_encoder_ok == 0) {
#line 4628
      return (0);
    } else {

    }
#line 4629
    ldv_del_timer_sync_310(& hdw->quiescent_timer);
#line 4630
    if (hdw->flag_decoder_missed != 0) {
#line 4630
      return (0);
    } else {

    }
#line 4631
    tmp___0 = pvr2_decoder_enable(hdw, 1);
#line 4631
    if (tmp___0 < 0) {
#line 4631
      return (0);
    } else {

    }
#line 4632
    hdw->state_decoder_quiescent = 0;
#line 4633
    hdw->state_decoder_ready = 0;
#line 4634
    hdw->state_decoder_run = 1;
#line 4635
    if (hdw->decoder_client_id == 3U) {
#line 4636
      hdw->decoder_stabilization_timer.expires = (unsigned long )jiffies + 75UL;
#line 4640
      add_timer(& hdw->decoder_stabilization_timer);
    } else {
#line 4642
      hdw->state_decoder_ready = 1;
    }
  }
#line 4645
  trace_stbit("state_decoder_quiescent", hdw->state_decoder_quiescent);
#line 4646
  trace_stbit("state_decoder_run", hdw->state_decoder_run);
#line 4647
  trace_stbit("state_decoder_ready", hdw->state_decoder_ready);
#line 4648
  return (1);
}
}
#line 4653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_usbstream_run(struct pvr2_hdw *hdw ) 
{ 
  int fl ;
  int tmp ;

  {
#line 4655
  if (hdw->state_usbstream_run != 0) {
#line 4656
    fl = 1;
#line 4657
    if (hdw->pathway_state == 1) {
#line 4658
      fl = hdw->state_encoder_ok != 0 && hdw->state_encoder_run != 0;
    } else
#line 4660
    if (hdw->pathway_state == 2 && (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 4662
      fl = hdw->state_encoder_ok;
    } else {

    }
#line 4664
    if (((fl != 0 && hdw->state_pipeline_req != 0) && hdw->state_pipeline_pause == 0) && hdw->state_pathway_ok != 0) {
#line 4668
      return (0);
    } else {

    }
#line 4670
    pvr2_hdw_cmd_usbstream(hdw, 0);
#line 4671
    hdw->state_usbstream_run = 0;
  } else {
#line 4673
    if ((hdw->state_pipeline_req == 0 || hdw->state_pipeline_pause != 0) || hdw->state_pathway_ok == 0) {
#line 4675
      return (0);
    } else {

    }
#line 4676
    if (hdw->pathway_state == 1) {
#line 4677
      if (hdw->state_encoder_ok == 0 || hdw->state_encoder_run == 0) {
#line 4678
        return (0);
      } else {

      }
    } else
#line 4679
    if (hdw->pathway_state == 2 && (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 4681
      if (hdw->state_encoder_ok == 0) {
#line 4681
        return (0);
      } else {

      }
#line 4682
      if (hdw->state_encoder_run != 0) {
#line 4682
        return (0);
      } else {

      }
#line 4683
      if ((unsigned int )((unsigned char )(hdw->hdw_desc)->digital_control_scheme) == 2U) {
#line 4690
        if (hdw->state_encoder_runok == 0) {
#line 4690
          return (0);
        } else {

        }
      } else {

      }
    } else {

    }
#line 4693
    tmp = pvr2_hdw_cmd_usbstream(hdw, 1);
#line 4693
    if (tmp < 0) {
#line 4693
      return (0);
    } else {

    }
#line 4694
    hdw->state_usbstream_run = 1;
  }
#line 4696
  trace_stbit("state_usbstream_run", hdw->state_usbstream_run);
#line 4697
  return (1);
}
}
#line 4702 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_eval_pipeline_config(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4704
  if (hdw->state_pipeline_config != 0 || hdw->state_pipeline_pause != 0) {
#line 4705
    return (0);
  } else {

  }
#line 4706
  pvr2_hdw_commit_execute(hdw);
#line 4707
  return (1);
}
}
#line 4714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int state_update_pipeline_state(struct pvr2_hdw *hdw ) 
{ 
  unsigned int st ;
  int updatedFl ;

  {
#line 4717
  updatedFl = 0;
#line 4719
  st = (unsigned int )(((hdw->state_encoder_run == 0 && hdw->state_decoder_run == 0) && hdw->state_usbstream_run == 0) && hdw->state_decoder_quiescent != 0);
#line 4723
  if ((st == 0U) ^ (hdw->state_pipeline_idle == 0)) {
#line 4724
    hdw->state_pipeline_idle = (int )st;
#line 4725
    updatedFl = 1;
  } else {

  }
#line 4727
  if (hdw->state_pipeline_idle != 0 && hdw->state_pipeline_pause != 0) {
#line 4728
    hdw->state_pipeline_pause = 0;
#line 4729
    updatedFl = 1;
  } else {

  }
#line 4731
  return (updatedFl);
}
}
#line 4738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static state_eval_func eval_funcs[7U]  = {      & state_eval_pathway_ok,      & state_eval_pipeline_config,      & state_eval_encoder_ok,      & state_eval_encoder_config, 
        & state_eval_decoder_run,      & state_eval_encoder_run,      & state_eval_usbstream_run};
#line 4750 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_state_update(struct pvr2_hdw *hdw ) 
{ 
  unsigned int i ;
  int state_updated ;
  int check_flag ;
  int tmp ;

  {
#line 4753
  state_updated = 0;
#line 4756
  if (hdw->state_stale == 0) {
#line 4756
    return (0);
  } else {

  }
#line 4757
  if (hdw->fw1_state != 4 || hdw->flag_ok == 0) {
#line 4759
    hdw->state_stale = 0;
#line 4760
    return (1);
  } else {

  }
  ldv_51584: 
#line 4770
  check_flag = 0;
#line 4771
  state_update_pipeline_state(hdw);
#line 4773
  i = 0U;
#line 4773
  goto ldv_51582;
  ldv_51581: 
#line 4774
  tmp = (*(eval_funcs[i]))(hdw);
#line 4774
  if (tmp != 0) {
#line 4775
    check_flag = 1;
#line 4776
    state_updated = 1;
#line 4777
    state_update_pipeline_state(hdw);
  } else {

  }
#line 4773
  i = i + 1U;
  ldv_51582: ;
#line 4773
  if (i <= 6U && hdw->flag_ok != 0) {
#line 4775
    goto ldv_51581;
  } else {

  }

#line 4780
  if (check_flag != 0 && hdw->flag_ok != 0) {
#line 4782
    goto ldv_51584;
  } else {

  }
#line 4781
  hdw->state_stale = 0;
#line 4782
  trace_stbit("state_stale", hdw->state_stale);
#line 4783
  return (state_updated);
}
}
#line 4787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int print_input_mask(unsigned int msk , char *buf , unsigned int acnt ) 
{ 
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int tcnt ;
  int tmp ;

  {
#line 4791
  tcnt = 0U;
#line 4792
  idx = 0U;
#line 4792
  goto ldv_51598;
  ldv_51597: ;
#line 4793
  if (((unsigned int )(1 << (int )idx) & msk) == 0U) {
#line 4793
    goto ldv_51596;
  } else {

  }
#line 4794
  tmp = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "%s%s", tcnt != 0U ? (char *)", " : (char *)"",
                  control_values_input[idx]);
#line 4794
  ccnt = (unsigned int )tmp;
#line 4799
  tcnt = tcnt + ccnt;
  ldv_51596: 
#line 4792
  idx = idx + 1U;
  ldv_51598: ;
#line 4792
  if (idx <= 4U) {
#line 4794
    goto ldv_51597;
  } else {

  }

#line 4801
  return (tcnt);
}
}
#line 4805 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static char const   *pvr2_pathway_state_name(int id ) 
{ 


  {
#line 4807
  switch (id) {
  case 1: ;
#line 4808
  return ("analog");
  case 2: ;
#line 4809
  return ("digital");
  default: ;
#line 4810
  return ("unknown");
  }
}
}
#line 4815 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int pvr2_hdw_report_unlocked(struct pvr2_hdw *hdw , int which , char *buf ,
                                             unsigned int acnt ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  unsigned int tcnt ;
  unsigned int ccnt ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  struct pvr2_stream_stats stats ;
  int tmp___9 ;
  unsigned int id ;
  int tmp___10 ;

  {
#line 4818
  switch (which) {
  case 0: 
#line 4820
  tmp = pvr2_pathway_state_name(hdw->pathway_state);
#line 4820
  tmp___0 = scnprintf(buf, (size_t )acnt, "driver:%s%s%s%s%s <mode=%s>", hdw->flag_ok != 0 ? (char *)" <ok>" : (char *)" <fail>",
                      hdw->flag_init_ok != 0 ? (char *)" <init>" : (char *)" <uninitialized>",
                      hdw->flag_disconnected != 0 ? (char *)" <disconnected>" : (char *)" <connected>",
                      hdw->flag_tripped != 0 ? (char *)" <tripped>" : (char *)"",
                      hdw->flag_decoder_missed != 0 ? (char *)" <no decoder>" : (char *)"",
                      tmp);
#line 4820
  return ((unsigned int )tmp___0);
  case 1: 
#line 4832
  tmp___1 = scnprintf(buf, (size_t )acnt, "pipeline:%s%s%s%s", hdw->state_pipeline_idle != 0 ? (char *)" <idle>" : (char *)"",
                      hdw->state_pipeline_config != 0 ? (char *)" <configok>" : (char *)" <stale>",
                      hdw->state_pipeline_req != 0 ? (char *)" <req>" : (char *)"",
                      hdw->state_pipeline_pause != 0 ? (char *)" <pause>" : (char *)"");
#line 4832
  return ((unsigned int )tmp___1);
  case 2: 
#line 4841
  tmp___2 = scnprintf(buf, (size_t )acnt, "worker:%s%s%s%s%s%s%s", hdw->state_decoder_run != 0 ? (hdw->state_decoder_ready != 0 ? (char *)"<decode:run>" : (char *)" <decode:start>") : (hdw->state_decoder_quiescent != 0 ? (char *)"" : (char *)" <decode:stop>"),
                      hdw->state_decoder_quiescent != 0 ? (char *)" <decode:quiescent>" : (char *)"",
                      hdw->state_encoder_ok != 0 ? (char *)"" : (char *)" <encode:init>",
                      hdw->state_encoder_run != 0 ? (hdw->state_encoder_runok != 0 ? (char *)" <encode:run>" : (char *)" <encode:firstrun>") : (hdw->state_encoder_runok != 0 ? (char *)" <encode:stop>" : (char *)" <encode:virgin>"),
                      hdw->state_encoder_config == 0 ? (hdw->state_encoder_waitok != 0 ? (char *)"" : (char *)" <encode:waitok>") : (char *)" <encode:configok>",
                      hdw->state_usbstream_run != 0 ? (char *)" <usb:run>" : (char *)" <usb:stop>",
                      hdw->state_pathway_ok != 0 ? (char *)" <pathway:ok>" : (char *)"");
#line 4841
  return ((unsigned int )tmp___2);
  case 3: 
#line 4869
  tmp___3 = pvr2_get_state_name(hdw->master_state);
#line 4869
  tmp___4 = scnprintf(buf, (size_t )acnt, "state: %s", tmp___3);
#line 4869
  return ((unsigned int )tmp___4);
  case 4: 
#line 4874
  tcnt = 0U;
#line 4877
  tmp___5 = scnprintf(buf, (size_t )acnt, "Hardware supported inputs: ");
#line 4877
  ccnt = (unsigned int )tmp___5;
#line 4880
  tcnt = tcnt + ccnt;
#line 4881
  tmp___6 = print_input_mask(hdw->input_avail_mask, buf + (unsigned long )tcnt, acnt - tcnt);
#line 4881
  tcnt = tmp___6 + tcnt;
#line 4884
  if (hdw->input_avail_mask != hdw->input_allowed_mask) {
#line 4885
    tmp___7 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "; allowed inputs: ");
#line 4885
    ccnt = (unsigned int )tmp___7;
#line 4888
    tcnt = tcnt + ccnt;
#line 4889
    tmp___8 = print_input_mask(hdw->input_allowed_mask, buf + (unsigned long )tcnt,
                               acnt - tcnt);
#line 4889
    tcnt = tmp___8 + tcnt;
  } else {

  }
#line 4893
  return (tcnt);
  case 5: ;
#line 4897
  if ((unsigned long )hdw->vid_stream == (unsigned long )((struct pvr2_stream *)0)) {
#line 4897
    goto ldv_51621;
  } else {

  }
#line 4898
  pvr2_stream_get_stats(hdw->vid_stream, & stats, 0);
#line 4901
  tmp___9 = scnprintf(buf, (size_t )acnt, "Bytes streamed=%u URBs: queued=%u idle=%u ready=%u processed=%u failed=%u",
                      stats.bytes_processed, stats.buffers_in_queue, stats.buffers_in_idle,
                      stats.buffers_in_ready, stats.buffers_processed, stats.buffers_failed);
#line 4901
  return ((unsigned int )tmp___9);
  case 6: 
#line 4914
  id = hdw->ir_scheme_active;
#line 4915
  tmp___10 = scnprintf(buf, (size_t )acnt, "ir scheme: id=%d %s", id, id <= 4U ? ir_scheme_names[id] : "?");
#line 4915
  return ((unsigned int )tmp___10);
  default: ;
#line 4919
  goto ldv_51621;
  }
  ldv_51621: ;
#line 4921
  return (0U);
}
}
#line 4928 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static unsigned int pvr2_hdw_report_clients(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  struct v4l2_subdev *sd ;
  unsigned int tcnt ;
  unsigned int ccnt ;
  struct i2c_client *client ;
  char const   *p ;
  unsigned int id ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4932
  tcnt = 0U;
#line 4938
  tmp = scnprintf(buf, (size_t )acnt, "Associated v4l2-subdev drivers and I2C clients:\n");
#line 4938
  ccnt = (unsigned int )tmp;
#line 4939
  tcnt = tcnt + ccnt;
#line 4940
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 4940
  sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 4940
  goto ldv_51645;
  ldv_51644: 
#line 4941
  id = sd->grp_id;
#line 4942
  p = (char const   *)0;
#line 4943
  if (id <= 7U) {
#line 4943
    p = module_names[id];
  } else {

  }
#line 4944
  if ((unsigned long )p != (unsigned long )((char const   *)0)) {
#line 4945
    tmp___0 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "  %s:",
                        p);
#line 4945
    ccnt = (unsigned int )tmp___0;
#line 4946
    tcnt = tcnt + ccnt;
  } else {
#line 4948
    tmp___1 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "  (unknown id=%u):",
                        id);
#line 4948
    ccnt = (unsigned int )tmp___1;
#line 4950
    tcnt = tcnt + ccnt;
  }
#line 4952
  tmp___2 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 4952
  client = (struct i2c_client *)tmp___2;
#line 4953
  if ((unsigned long )client != (unsigned long )((struct i2c_client *)0)) {
#line 4954
    tmp___3 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), " %s @ %02x\n",
                        (char *)(& client->name), (int )client->addr);
#line 4954
    ccnt = (unsigned int )tmp___3;
#line 4957
    tcnt = tcnt + ccnt;
  } else {
#line 4959
    tmp___4 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), " no i2c client\n");
#line 4959
    ccnt = (unsigned int )tmp___4;
#line 4961
    tcnt = tcnt + ccnt;
  }
#line 4940
  __mptr___0 = (struct list_head  const  *)sd->list.next;
#line 4940
  sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51645: ;
#line 4940
  if ((unsigned long )(& sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 4942
    goto ldv_51644;
  } else {

  }

#line 4964
  return (tcnt);
}
}
#line 4968 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  unsigned int bcnt ;
  unsigned int ccnt ;
  unsigned int idx ;

  {
#line 4972
  bcnt = 0U;
#line 4973
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 4973
  hdw->big_lock_held = 1;
#line 4974
  idx = 0U;
  ldv_51656: 
#line 4975
  ccnt = pvr2_hdw_report_unlocked(hdw, (int )idx, buf, acnt);
#line 4976
  if (ccnt == 0U) {
#line 4976
    goto ldv_51655;
  } else {

  }
#line 4977
  bcnt = bcnt + ccnt;
#line 4977
  acnt = acnt - ccnt;
#line 4977
  buf = buf + (unsigned long )ccnt;
#line 4978
  if (acnt == 0U) {
#line 4978
    goto ldv_51655;
  } else {

  }
#line 4979
  *buf = 10;
#line 4979
  ccnt = 1U;
#line 4980
  bcnt = bcnt + ccnt;
#line 4980
  acnt = acnt - ccnt;
#line 4980
  buf = buf + (unsigned long )ccnt;
#line 4974
  idx = idx + 1U;
#line 4981
  goto ldv_51656;
  ldv_51655: 
#line 4982
  ccnt = pvr2_hdw_report_clients(hdw, buf, acnt);
#line 4983
  bcnt = bcnt + ccnt;
#line 4983
  acnt = acnt - ccnt;
#line 4983
  buf = buf + (unsigned long )ccnt;
#line 4984
  hdw->big_lock_held = 0;
#line 4984
  mutex_unlock(& hdw->big_lock_mutex);
#line 4985
  return (bcnt);
}
}
#line 4989 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw ) 
{ 
  char buf[256U] ;
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int lcnt ;
  unsigned int ucnt ;

  {
#line 4995
  idx = 0U;
  ldv_51666: 
#line 4996
  ccnt = pvr2_hdw_report_unlocked(hdw, (int )idx, (char *)(& buf), 256U);
#line 4997
  if (ccnt == 0U) {
#line 4997
    goto ldv_51665;
  } else {

  }
#line 4998
  printk("\016%s %.*s\n", (char *)(& hdw->name), ccnt, (char *)(& buf));
#line 4995
  idx = idx + 1U;
#line 4999
  goto ldv_51666;
  ldv_51665: 
#line 5000
  ccnt = pvr2_hdw_report_clients(hdw, (char *)(& buf), 256U);
#line 5001
  ucnt = 0U;
#line 5002
  goto ldv_51671;
  ldv_51670: 
#line 5003
  lcnt = 0U;
#line 5004
  goto ldv_51668;
  ldv_51667: 
#line 5005
  lcnt = lcnt + 1U;
  ldv_51668: ;
#line 5004
  if (lcnt + ucnt < ccnt && (int )((signed char )buf[lcnt + ucnt]) != 10) {
#line 5006
    goto ldv_51667;
  } else {

  }
#line 5007
  printk("\016%s %.*s\n", (char *)(& hdw->name), lcnt, (char *)(& buf) + (unsigned long )ucnt);
#line 5008
  ucnt = (lcnt + ucnt) + 1U;
  ldv_51671: ;
#line 5002
  if (ucnt < ccnt) {
#line 5004
    goto ldv_51670;
  } else {

  }

#line 5009
  return;
}
}
#line 5015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_state_eval(struct pvr2_hdw *hdw ) 
{ 
  unsigned int st ;
  int state_updated ;
  int callback_flag ;
  int analog_mode ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 5018
  state_updated = 0;
#line 5019
  callback_flag = 0;
#line 5022
  if ((pvrusb2_debug & 512) != 0) {
#line 5022
    printk("\016pvrusb2: Drive state check START\n");
  } else {

  }
#line 5024
  if ((pvrusb2_debug & 512) != 0) {
#line 5025
    pvr2_hdw_state_log_state(hdw);
  } else {

  }
#line 5029
  state_updated = pvr2_hdw_state_update(hdw);
#line 5031
  analog_mode = hdw->pathway_state != 2;
#line 5034
  if (hdw->flag_ok == 0) {
#line 5035
    st = 1U;
  } else
#line 5036
  if (hdw->fw1_state != 4) {
#line 5037
    st = 2U;
  } else
#line 5038
  if ((analog_mode != 0 || (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) && hdw->state_encoder_ok == 0) {
#line 5041
    st = 3U;
  } else
#line 5042
  if (hdw->flag_tripped != 0 || (analog_mode != 0 && hdw->flag_decoder_missed != 0)) {
#line 5044
    st = 4U;
  } else
#line 5045
  if (hdw->state_usbstream_run != 0 && (analog_mode == 0 || (hdw->state_encoder_run != 0 && hdw->state_decoder_run != 0))) {
#line 5048
    st = 6U;
  } else {
#line 5050
    st = 5U;
  }
#line 5052
  if (hdw->master_state != st) {
#line 5053
    if ((pvrusb2_debug & 256) != 0) {
#line 5053
      tmp = pvr2_get_state_name(st);
#line 5053
      tmp___0 = pvr2_get_state_name(hdw->master_state);
#line 5053
      printk("\016pvrusb2: Device state change from %s to %s\n", tmp___0, tmp);
    } else {

    }
#line 5057
    pvr2_led_ctrl(hdw, st == 6U);
#line 5058
    hdw->master_state = st;
#line 5059
    state_updated = 1;
#line 5060
    callback_flag = 1;
  } else {

  }
#line 5062
  if (state_updated != 0) {
#line 5064
    __wake_up(& hdw->state_wait_data, 3U, 1, (void *)0);
  } else {

  }
#line 5067
  if ((pvrusb2_debug & 512) != 0) {
#line 5068
    pvr2_hdw_state_log_state(hdw);
  } else {

  }
#line 5070
  if ((pvrusb2_debug & 512) != 0) {
#line 5070
    printk("\016pvrusb2: Drive state check DONE callback=%d\n", callback_flag);
  } else {

  }
#line 5073
  return (callback_flag);
}
}
#line 5078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static void pvr2_hdw_state_sched(struct pvr2_hdw *hdw ) 
{ 


  {
#line 5080
  if (hdw->state_stale != 0) {
#line 5080
    return;
  } else {

  }
#line 5081
  hdw->state_stale = 1;
#line 5082
  trace_stbit("state_stale", hdw->state_stale);
#line 5083
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 5084
  return;
}
}
#line 5087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 5089
  tmp = pvr2_read_register(hdw, 36896, dp);
#line 5089
  return (tmp);
}
}
#line 5093 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 5095
  tmp = pvr2_read_register(hdw, 36876, dp);
#line 5095
  return (tmp);
}
}
#line 5099 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 5101
  tmp = pvr2_read_register(hdw, 36872, dp);
#line 5101
  return (tmp);
}
}
#line 5105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw , u32 msk , u32 val ) 
{ 
  u32 cval ;
  u32 nval ;
  int ret ;
  int tmp ;

  {
#line 5109
  if (msk != 4294967295U) {
#line 5110
    ret = pvr2_read_register(hdw, 36896, & cval);
#line 5111
    if (ret != 0) {
#line 5111
      return (ret);
    } else {

    }
#line 5112
    nval = (~ msk & cval) | (val & msk);
#line 5113
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5113
      printk("\016pvrusb2: GPIO direction changing 0x%x:0x%x from 0x%x to 0x%x\n",
             msk, val, cval, nval);
    } else {

    }
  } else {
#line 5118
    nval = val;
#line 5119
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5119
      printk("\016pvrusb2: GPIO direction changing to 0x%x\n", nval);
    } else {

    }
  }
#line 5122
  tmp = pvr2_write_register(hdw, 36896, nval);
#line 5122
  return (tmp);
}
}
#line 5126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw , u32 msk , u32 val ) 
{ 
  u32 cval ;
  u32 nval ;
  int ret ;
  int tmp ;

  {
#line 5130
  if (msk != 4294967295U) {
#line 5131
    ret = pvr2_read_register(hdw, 36876, & cval);
#line 5132
    if (ret != 0) {
#line 5132
      return (ret);
    } else {

    }
#line 5133
    nval = (~ msk & cval) | (val & msk);
#line 5134
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5134
      printk("\016pvrusb2: GPIO output changing 0x%x:0x%x from 0x%x to 0x%x\n", msk,
             val, cval, nval);
    } else {

    }
  } else {
#line 5138
    nval = val;
#line 5139
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5139
      printk("\016pvrusb2: GPIO output changing to 0x%x\n", nval);
    } else {

    }
  }
#line 5142
  tmp = pvr2_write_register(hdw, 36876, nval);
#line 5142
  return (tmp);
}
}
#line 5146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void pvr2_hdw_status_poll(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_tuner *vtp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 5148
  vtp = & hdw->tuner_signal_info;
#line 5149
  memset((void *)vtp, 0, 84UL);
#line 5150
  vtp->type = hdw->input_val == 4 ? 1U : 2U;
#line 5152
  hdw->tuner_signal_stale = 0;
#line 5157
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 5157
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff80UL;
#line 5157
  goto ldv_51721;
  ldv_51720: ;
#line 5157
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 5157
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, vtp);
  } else {

  }
#line 5157
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 5157
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff80UL;
  ldv_51721: ;
#line 5157
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 5159
    goto ldv_51720;
  } else {

  }

#line 5158
  if ((pvrusb2_debug & 65536) != 0) {
#line 5158
    printk("\016pvrusb2: subdev status poll type=%u strength=%u audio=0x%x cap=0x%x low=%u hi=%u\n",
           vtp->type, vtp->signal, vtp->rxsubchans, vtp->capability, vtp->rangelow,
           vtp->rangehigh);
  } else {

  }
#line 5167
  hdw->cropcap_stale = 0;
#line 5168
  return;
}
}
#line 5171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw ) 
{ 


  {
#line 5173
  return (hdw->input_avail_mask);
}
}
#line 5177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
unsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw ) 
{ 


  {
#line 5179
  return (hdw->input_allowed_mask);
}
}
#line 5183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_set_input(struct pvr2_hdw *hdw , int v ) 
{ 


  {
#line 5185
  if (hdw->input_val != v) {
#line 5186
    hdw->input_val = v;
#line 5187
    hdw->input_dirty = 1;
  } else {

  }
#line 5193
  if (hdw->input_val == 4) {
#line 5194
    hdw->freqSelector = 0U;
#line 5195
    hdw->freqDirty = 1;
  } else
#line 5196
  if (hdw->input_val == 0 || hdw->input_val == 1) {
#line 5198
    hdw->freqSelector = 1U;
#line 5199
    hdw->freqDirty = 1;
  } else {

  }
#line 5201
  return (0);
}
}
#line 5205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw , unsigned int change_mask , unsigned int change_val ) 
{ 
  int ret ;
  unsigned int nv ;
  unsigned int m ;
  unsigned int idx ;

  {
#line 5209
  ret = 0;
#line 5211
  mutex_lock_nested(& hdw->big_lock_mutex, 0U);
#line 5211
  hdw->big_lock_held = 1;
#line 5213
  nv = hdw->input_allowed_mask & ~ change_mask;
#line 5214
  nv = (change_val & change_mask) | nv;
#line 5215
  nv = hdw->input_avail_mask & nv;
#line 5216
  if (nv == 0U) {
#line 5218
    ret = -1;
#line 5219
    goto ldv_51742;
  } else {

  }
#line 5221
  hdw->input_allowed_mask = nv;
#line 5222
  if (((unsigned int )(1 << hdw->input_val) & hdw->input_allowed_mask) != 0U) {
#line 5225
    goto ldv_51742;
  } else {

  }
#line 5229
  if (hdw->input_allowed_mask == 0U) {
#line 5231
    goto ldv_51742;
  } else {

  }
#line 5233
  m = hdw->input_allowed_mask;
#line 5234
  idx = 0U;
#line 5234
  goto ldv_51746;
  ldv_51745: ;
#line 5235
  if (((unsigned int )(1 << (int )idx) & m) == 0U) {
#line 5235
    goto ldv_51743;
  } else {

  }
#line 5236
  pvr2_hdw_set_input(hdw, (int )idx);
#line 5237
  goto ldv_51744;
  ldv_51743: 
#line 5234
  idx = idx + 1U;
  ldv_51746: ;
#line 5234
  if (idx <= 31U) {
#line 5236
    goto ldv_51745;
  } else {

  }
  ldv_51744: ;
  ldv_51742: 
#line 5240
  hdw->big_lock_held = 0;
#line 5240
  mutex_unlock(& hdw->big_lock_mutex);
#line 5241
  return (ret);
}
}
#line 5246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
static int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 5249
  mutex_lock_nested(& hdw->ctl_lock_mutex, 0U);
#line 5249
  hdw->ctl_lock_held = 1;
#line 5250
  hdw->cmd_buffer[0] = 235U;
#line 5251
  result = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                             1U);
#line 5254
  if (result < 0) {
#line 5254
    goto ldv_51751;
  } else {

  }
#line 5255
  result = (int )hdw->cmd_buffer[0];
  ldv_51751: 
#line 5256
  hdw->ctl_lock_held = 0;
#line 5256
  mutex_unlock(& hdw->ctl_lock_mutex);
#line 5257
  return (result);
}
}
#line 5261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 5262
  LDV_IN_INTERRUPT = 2;
#line 5263
  (*(timer->function))(timer->data);
#line 5264
  LDV_IN_INTERRUPT = 1;
#line 5265
  ldv_timer_state_2 = 2;
#line 5266
  return;
}
}
#line 5269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 5270
  ldv_timer_list_2 = timer;
#line 5271
  ldv_timer_state_2 = 1;
#line 5272
  return (0);
}
}
#line 5275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_5(struct timer_list *timer ) 
{ 


  {
#line 5276
  LDV_IN_INTERRUPT = 2;
#line 5277
  (*(timer->function))(timer->data);
#line 5278
  LDV_IN_INTERRUPT = 1;
#line 5279
  ldv_timer_state_5 = 2;
#line 5280
  return;
}
}
#line 5283 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5283
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 5284
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 5285
      ldv_timer_list_2 = timer;
#line 5286
      ldv_timer_list_2->data = data;
#line 5287
      ldv_timer_state_2 = 1;
    } else {

    }
#line 5289
    return;
  } else {

  }
#line 5291
  reg_timer_2(timer);
#line 5292
  ldv_timer_list_2->data = data;
#line 5293
  return;
}
}
#line 5296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_3(struct timer_list *timer ) 
{ 


  {
#line 5297
  LDV_IN_INTERRUPT = 2;
#line 5298
  (*(timer->function))(timer->data);
#line 5299
  LDV_IN_INTERRUPT = 1;
#line 5300
  ldv_timer_state_3 = 2;
#line 5301
  return;
}
}
#line 5304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5304
  if ((unsigned long )ldv_timer_list_4 == (unsigned long )timer) {
#line 5305
    if (ldv_timer_state_4 == 2 || pending_flag != 0) {
#line 5306
      ldv_timer_list_4 = timer;
#line 5307
      ldv_timer_list_4->data = data;
#line 5308
      ldv_timer_state_4 = 1;
    } else {

    }
#line 5310
    return;
  } else {

  }
#line 5312
  reg_timer_4(timer);
#line 5313
  ldv_timer_list_4->data = data;
#line 5314
  return;
}
}
#line 5317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5317
  if ((unsigned long )ldv_timer_list_1 == (unsigned long )timer) {
#line 5318
    if (ldv_timer_state_1 == 2 || pending_flag != 0) {
#line 5319
      ldv_timer_list_1 = timer;
#line 5320
      ldv_timer_list_1->data = data;
#line 5321
      ldv_timer_state_1 = 1;
    } else {

    }
#line 5323
    return;
  } else {

  }
#line 5325
  reg_timer_1(timer);
#line 5326
  ldv_timer_list_1->data = data;
#line 5327
  return;
}
}
#line 5330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5331
  LDV_IN_INTERRUPT = 2;
#line 5332
  (*(timer->function))(timer->data);
#line 5333
  LDV_IN_INTERRUPT = 1;
#line 5334
  ldv_timer_state_4 = 2;
#line 5335
  return;
}
}
#line 5338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) 
{ 


  {
#line 5339
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_3) {
#line 5340
    ldv_timer_state_3 = 0;
#line 5341
    return;
  } else {

  }
#line 5343
  return;
}
}
#line 5346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5347
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_4) {
#line 5348
    ldv_timer_state_4 = 0;
#line 5349
    return;
  } else {

  }
#line 5351
  return;
}
}
#line 5354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_1(struct timer_list *timer ) 
{ 


  {
#line 5355
  ldv_timer_list_1 = timer;
#line 5356
  ldv_timer_state_1 = 1;
#line 5357
  return (0);
}
}
#line 5360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5361
  ldv_timer_list_4 = timer;
#line 5362
  ldv_timer_state_4 = 1;
#line 5363
  return (0);
}
}
#line 5366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 5367
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 5368
    ldv_timer_state_2 = 0;
#line 5369
    return;
  } else {

  }
#line 5371
  return;
}
}
#line 5374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_1(struct timer_list *timer ) 
{ 


  {
#line 5375
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_1) {
#line 5376
    ldv_timer_state_1 = 0;
#line 5377
    return;
  } else {

  }
#line 5379
  return;
}
}
#line 5382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5382
  if ((unsigned long )ldv_timer_list_3 == (unsigned long )timer) {
#line 5383
    if (ldv_timer_state_3 == 2 || pending_flag != 0) {
#line 5384
      ldv_timer_list_3 = timer;
#line 5385
      ldv_timer_list_3->data = data;
#line 5386
      ldv_timer_state_3 = 1;
    } else {

    }
#line 5388
    return;
  } else {

  }
#line 5390
  reg_timer_3(timer);
#line 5391
  ldv_timer_list_3->data = data;
#line 5392
  return;
}
}
#line 5395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_3(struct timer_list *timer ) 
{ 


  {
#line 5396
  ldv_timer_list_3 = timer;
#line 5397
  ldv_timer_state_3 = 1;
#line 5398
  return (0);
}
}
#line 5401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5401
  if ((unsigned long )ldv_timer_list_5 == (unsigned long )timer) {
#line 5402
    if (ldv_timer_state_5 == 2 || pending_flag != 0) {
#line 5403
      ldv_timer_list_5 = timer;
#line 5404
      ldv_timer_list_5->data = data;
#line 5405
      ldv_timer_state_5 = 1;
    } else {

    }
#line 5407
    return;
  } else {

  }
#line 5409
  reg_timer_5(timer);
#line 5410
  ldv_timer_list_5->data = data;
#line 5411
  return;
}
}
#line 5414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 5415
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_5) {
#line 5416
    ldv_timer_state_5 = 0;
#line 5417
    return;
  } else {

  }
#line 5419
  return;
}
}
#line 5422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_1(struct timer_list *timer ) 
{ 


  {
#line 5423
  LDV_IN_INTERRUPT = 2;
#line 5424
  (*(timer->function))(timer->data);
#line 5425
  LDV_IN_INTERRUPT = 1;
#line 5426
  ldv_timer_state_1 = 2;
#line 5427
  return;
}
}
#line 5430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_5(struct timer_list *timer ) 
{ 


  {
#line 5431
  ldv_timer_list_5 = timer;
#line 5432
  ldv_timer_state_5 = 1;
#line 5433
  return (0);
}
}
#line 5548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 


  {
#line 5551
  ldv_check_alloc_flags(flags);
#line 5553
  ldv_kcalloc_272(n, size, flags);
#line 5554
  return ((void *)0);
}
}
#line 5562 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void *ldv_kmem_cache_alloc_274(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 5565
  ldv_check_alloc_flags(flags);
#line 5567
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 5568
  return ((void *)0);
}
}
#line 5570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 5573
  ldv_check_alloc_flags(flags);
#line 5574
  return ((void *)0);
}
}
#line 5606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 5609
  ldv_check_alloc_flags(flags);
#line 5611
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 5611
  return (tmp);
}
}
#line 5622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv_skb_clone_282(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5625
  ldv_check_alloc_flags(flags);
#line 5627
  tmp = skb_clone(ldv_func_arg1, flags);
#line 5627
  return (tmp);
}
}
#line 5638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv_skb_copy_284(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5641
  ldv_check_alloc_flags(flags);
#line 5643
  tmp = skb_copy(ldv_func_arg1, flags);
#line 5643
  return (tmp);
}
}
#line 5646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_285(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5649
  ldv_check_alloc_flags(flags);
#line 5651
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 5651
  return (tmp);
}
}
#line 5654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_286(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5657
  ldv_check_alloc_flags(flags);
#line 5659
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 5659
  return (tmp);
}
}
#line 5662 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_287(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5665
  ldv_check_alloc_flags(flags);
#line 5667
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 5667
  return (tmp);
}
}
#line 5670 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_pskb_expand_head_288(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 5673
  ldv_check_alloc_flags(flags);
#line 5675
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 5675
  return (tmp);
}
}
#line 5678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_pskb_expand_head_289(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 5681
  ldv_check_alloc_flags(flags);
#line 5683
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 5683
  return (tmp);
}
}
#line 5686 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct sk_buff *ldv_skb_clone_290(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 5689
  ldv_check_alloc_flags(flags);
#line 5691
  tmp = skb_clone(ldv_func_arg1, flags);
#line 5691
  return (tmp);
}
}
#line 5694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 5698
  tmp = del_timer_sync(ldv_func_arg1);
#line 5698
  ldv_func_res = tmp;
#line 5700
  disable_suitable_timer_3(ldv_func_arg1);
#line 5702
  return (ldv_func_res);
}
}
#line 5705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct urb *ldv_usb_alloc_urb_292(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 5708
  ldv_check_alloc_flags(flags);
#line 5710
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 5710
  return (tmp);
}
}
#line 5713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
struct urb *ldv_usb_alloc_urb_293(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 5716
  ldv_check_alloc_flags(flags);
#line 5718
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 5718
  return (tmp);
}
}
#line 5721 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 5725
  tmp = del_timer_sync(ldv_func_arg1);
#line 5725
  ldv_func_res = tmp;
#line 5727
  disable_suitable_timer_3(ldv_func_arg1);
#line 5729
  return (ldv_func_res);
}
}
#line 5732 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 5736
  tmp = del_timer_sync(ldv_func_arg1);
#line 5736
  ldv_func_res = tmp;
#line 5738
  disable_suitable_timer_3(ldv_func_arg1);
#line 5740
  return (ldv_func_res);
}
}
#line 5743 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_296(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 5747
  tmp = del_timer_sync(ldv_func_arg1);
#line 5747
  ldv_func_res = tmp;
#line 5749
  disable_suitable_timer_3(ldv_func_arg1);
#line 5751
  return (ldv_func_res);
}
}
#line 5754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_297(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 5758
  tmp = del_timer_sync(ldv_func_arg1);
#line 5758
  ldv_func_res = tmp;
#line 5760
  disable_suitable_timer_3(ldv_func_arg1);
#line 5762
  return (ldv_func_res);
}
}
#line 5765 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 5769
  tmp = del_timer_sync(ldv_func_arg1);
#line 5769
  ldv_func_res = tmp;
#line 5771
  disable_suitable_timer_3(ldv_func_arg1);
#line 5773
  return (ldv_func_res);
}
}
#line 5776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_299(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 5780
  tmp = del_timer_sync(ldv_func_arg1);
#line 5780
  ldv_func_res = tmp;
#line 5782
  disable_suitable_timer_3(ldv_func_arg1);
#line 5784
  return (ldv_func_res);
}
}
#line 5787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 5791
  tmp = del_timer_sync(ldv_func_arg1);
#line 5791
  ldv_func_res = tmp;
#line 5793
  disable_suitable_timer_3(ldv_func_arg1);
#line 5795
  return (ldv_func_res);
}
}
#line 5798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_301(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 5802
  tmp = del_timer_sync(ldv_func_arg1);
#line 5802
  ldv_func_res = tmp;
#line 5804
  disable_suitable_timer_3(ldv_func_arg1);
#line 5806
  return (ldv_func_res);
}
}
#line 5809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_usb_submit_urb_302(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 5812
  ldv_check_alloc_flags(flags);
#line 5814
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 5814
  return (tmp);
}
}
#line 5817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_usb_submit_urb_303(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 5820
  ldv_check_alloc_flags(flags);
#line 5822
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 5822
  return (tmp);
}
}
#line 5825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 5829
  tmp = del_timer_sync(ldv_func_arg1);
#line 5829
  ldv_func_res = tmp;
#line 5831
  disable_suitable_timer_3(ldv_func_arg1);
#line 5833
  return (ldv_func_res);
}
}
#line 5836 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_305(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 5840
  tmp = del_timer_sync(ldv_func_arg1);
#line 5840
  ldv_func_res = tmp;
#line 5842
  disable_suitable_timer_3(ldv_func_arg1);
#line 5844
  return (ldv_func_res);
}
}
#line 5847 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 5851
  tmp = del_timer_sync(ldv_func_arg1);
#line 5851
  ldv_func_res = tmp;
#line 5853
  disable_suitable_timer_3(ldv_func_arg1);
#line 5855
  return (ldv_func_res);
}
}
#line 5858 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_307(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 5862
  tmp = del_timer_sync(ldv_func_arg1);
#line 5862
  ldv_func_res = tmp;
#line 5864
  disable_suitable_timer_3(ldv_func_arg1);
#line 5866
  return (ldv_func_res);
}
}
#line 5869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 5873
  tmp = del_timer_sync(ldv_func_arg1);
#line 5873
  ldv_func_res = tmp;
#line 5875
  disable_suitable_timer_3(ldv_func_arg1);
#line 5877
  return (ldv_func_res);
}
}
#line 5880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 5884
  tmp = del_timer_sync(ldv_func_arg1);
#line 5884
  ldv_func_res = tmp;
#line 5886
  disable_suitable_timer_3(ldv_func_arg1);
#line 5888
  return (ldv_func_res);
}
}
#line 5891 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 5895
  tmp = del_timer_sync(ldv_func_arg1);
#line 5895
  ldv_func_res = tmp;
#line 5897
  disable_suitable_timer_3(ldv_func_arg1);
#line 5899
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
#line 230 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_356(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 19 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern size_t __VERIFIER_nondet_size_t(void) ;
#line 25
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 647 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 723 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 725
  tmp = __builtin_object_size(from, 0);
#line 725
  sz = (int )tmp;
#line 727
  might_fault();
#line 730
  tmp___0 = ldv__builtin_expect(sz < 0, 1L);
#line 730
  if (tmp___0 != 0L) {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 730
    tmp___1 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 730
    if (tmp___1 != 0L) {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
    } else {
#line 735
      __copy_to_user_overflow();
    }
  }
#line 737
  return (n);
}
}
#line 806 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 809
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 810
    return ((char const   *)dev->init_name);
  } else {

  }
#line 812
  tmp = kobject_name(& dev->kobj);
#line 812
  return (tmp);
}
}
#line 926
extern int device_move(struct device * , struct device * , enum dpm_order  ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
void pvr2_channel_init(struct pvr2_channel *cp , struct pvr2_context *mp ) ;
#line 74
void pvr2_channel_done(struct pvr2_channel *cp ) ;
#line 75
int pvr2_channel_limit_inputs(struct pvr2_channel *cp , unsigned int cmsk ) ;
#line 77
int pvr2_channel_claim_stream(struct pvr2_channel *cp , struct pvr2_context_stream *sp ) ;
#line 79
struct pvr2_ioread *pvr2_channel_create_mpeg_stream(struct pvr2_context_stream *sp ) ;
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 57 "include/media/v4l2-dev.h"
extern int v4l2_prio_change(struct v4l2_prio_state * , enum v4l2_priority * , enum v4l2_priority  ) ;
#line 59
extern void v4l2_prio_open(struct v4l2_prio_state * , enum v4l2_priority * ) ;
#line 60
extern void v4l2_prio_close(struct v4l2_prio_state * , enum v4l2_priority  ) ;
#line 61
extern enum v4l2_priority v4l2_prio_max(struct v4l2_prio_state * ) ;
#line 62
extern int v4l2_prio_check(struct v4l2_prio_state * , enum v4l2_priority  ) ;
#line 151
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 158 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 161
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 161
  return (tmp);
}
}
#line 174
extern void video_unregister_device(struct video_device * ) ;
#line 219
extern struct video_device *video_devdata(struct file * ) ;
#line 228 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 230
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 230
  return (tmp);
}
}
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
void pvr2_stream_set_callback(struct pvr2_stream *sp , void (*func)(void * ) , void *data ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_set_value(struct pvr2_ctrl *cptr , int val ) ;
#line 40
int pvr2_ctrl_get_value(struct pvr2_ctrl *cptr , int *valptr ) ;
#line 43
enum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr ) ;
#line 46
int pvr2_ctrl_get_max(struct pvr2_ctrl *cptr ) ;
#line 49
int pvr2_ctrl_get_min(struct pvr2_ctrl *cptr ) ;
#line 52
int pvr2_ctrl_get_def(struct pvr2_ctrl *cptr , int *valptr ) ;
#line 55
int pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr ) ;
#line 61
char const   *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr ) ;
#line 64
char const   *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr ) ;
#line 67
int pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr , int val , char *bptr , unsigned int bmax ,
                          unsigned int *blen ) ;
#line 75
unsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr ) ;
#line 78
int pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ioread.h"
void pvr2_ioread_destroy(struct pvr2_ioread *cp ) ;
#line 30
struct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp ) ;
#line 34
int pvr2_ioread_set_enabled(struct pvr2_ioread *cp , int fl ) ;
#line 35
int pvr2_ioread_read(struct pvr2_ioread *cp , void *buf , unsigned int cnt ) ;
#line 36
int pvr2_ioread_avail(struct pvr2_ioread *cp ) ;
#line 303 "include/media/v4l2-ioctl.h"
extern void v4l_printk_ioctl(char const   * , unsigned int  ) ;
#line 328
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int video_nr[20U]  = 
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int radio_nr[20U]  = 
#line 175
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int vbi_nr[20U]  = 
#line 178
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct v4l2_capability pvr_capability  =    {{'p', 'v', 'r', 'u', 's', 'b', '2', '\000'}, {'H', 'a', 'u', 'p', 'p', 'a', 'u',
                                                  'g', 'e', ' ', 'W', 'i', 'n', 'T',
                                                  'V', ' ', 'p', 'v', 'r', '-', 'u',
                                                  's', 'b', '2', '\000'}, {'u', 's',
                                                                           'b', '\000'},
    200704U, 17235969U, 0U, {0U, 0U, 0U}};
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct v4l2_fmtdesc pvr_fmtdesc[1U]  = {      {0U, 1U, 1U, {'M', 'P', 'E', 'G', '1', '/', '2', '\000'}, 0U, {0U, 0U, 0U, 0U}}};
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct v4l2_format pvr_format[2U]  = {      {1U, {{720U, 576U, 0U, 4U, 0U, 32768U, 0U, 0U}}}, 
        {4U, {.vbi = {27000000U, 248U, 1443U, 1497715271U, {0, 0}, {0U, 0U}, 0U, {0U,
                                                                               0U}}}}};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_querycap(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  size_t __len ;
  void *__ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 250
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 251
  hdw = (fh->channel.mc_head)->hdw;
#line 253
  __len = 104UL;
#line 253
  if (__len > 63UL) {
#line 253
    __ret = __memcpy((void *)cap, (void const   *)(& pvr_capability), __len);
  } else {
#line 253
    __ret = __builtin_memcpy((void *)cap, (void const   *)(& pvr_capability), __len);
  }
#line 254
  tmp = pvr2_hdw_get_bus_info(hdw);
#line 254
  strlcpy((char *)(& cap->bus_info), tmp, 32UL);
#line 256
  tmp___0 = pvr2_hdw_get_desc(hdw);
#line 256
  strlcpy((char *)(& cap->card), tmp___0, 32UL);
#line 257
  return (0);
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_priority(struct file *file , void *priv , enum v4l2_priority *p ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_v4l2 *vp ;

  {
#line 262
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 263
  vp = fh->vhead;
#line 265
  *p = v4l2_prio_max(& vp->prio);
#line 266
  return (0);
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_priority(struct file *file , void *priv , enum v4l2_priority prio ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_v4l2 *vp ;
  int tmp ;

  {
#line 271
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 272
  vp = fh->vhead;
#line 274
  tmp = v4l2_prio_change(& vp->prio, & fh->prio, prio);
#line 274
  return (tmp);
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_std(struct file *file , void *priv , v4l2_std_id *std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 279
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 280
  hdw = (fh->channel.mc_head)->hdw;
#line 281
  val = 0;
#line 284
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 284
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 286
  *std = (v4l2_std_id )val;
#line 287
  return (ret);
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_std(struct file *file , void *priv , v4l2_std_id std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 292
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 293
  hdw = (fh->channel.mc_head)->hdw;
#line 295
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 295
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )std);
#line 295
  return (tmp___0);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_querystd(struct file *file , void *priv , v4l2_std_id *std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 301
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 302
  hdw = (fh->channel.mc_head)->hdw;
#line 303
  val = 0;
#line 306
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 19U);
#line 306
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 308
  *std = (v4l2_std_id )val;
#line 309
  return (ret);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_enum_input(struct file *file , void *priv , struct v4l2_input *vi ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *cptr ;
  struct v4l2_input tmp ;
  unsigned int cnt ;
  int val ;

  {
#line 314
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 315
  hdw = (fh->channel.mc_head)->hdw;
#line 321
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 323
  memset((void *)(& tmp), 0, 80UL);
#line 324
  tmp.index = vi->index;
#line 325
  if (vi->index >= fh->input_cnt) {
#line 326
    return (-22);
  } else {

  }
#line 327
  val = (int )*(fh->input_map + (unsigned long )vi->index);
#line 328
  switch (val) {
  case 0: ;
  case 1: ;
  case 4: 
#line 332
  tmp.type = 1U;
#line 333
  goto ldv_33683;
  case 3: ;
  case 2: 
#line 336
  tmp.type = 2U;
#line 337
  goto ldv_33683;
  default: ;
#line 339
  return (-22);
  }
  ldv_33683: 
#line 342
  cnt = 0U;
#line 343
  pvr2_ctrl_get_valname(cptr, val, (char *)(& tmp.name), 31U, & cnt);
#line 345
  tmp.name[cnt] = 0U;
#line 356
  *vi = tmp;
#line 357
  return (0);
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_input(struct file *file , void *priv , unsigned int *i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int val ;
  int ret ;

  {
#line 362
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 363
  hdw = (fh->channel.mc_head)->hdw;
#line 369
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 370
  val = 0;
#line 371
  ret = pvr2_ctrl_get_value(cptr, & val);
#line 372
  *i = 0U;
#line 373
  idx = 0U;
#line 373
  goto ldv_33700;
  ldv_33699: ;
#line 374
  if ((int )*(fh->input_map + (unsigned long )idx) == val) {
#line 375
    *i = idx;
#line 376
    goto ldv_33698;
  } else {

  }
#line 373
  idx = idx + 1U;
  ldv_33700: ;
#line 373
  if (fh->input_cnt > idx) {
#line 375
    goto ldv_33699;
  } else {

  }
  ldv_33698: ;
#line 379
  return (ret);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_input(struct file *file , void *priv , unsigned int inp ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 384
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 385
  hdw = (fh->channel.mc_head)->hdw;
#line 387
  if (fh->input_cnt <= inp) {
#line 388
    return (-22);
  } else {

  }
#line 389
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 389
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )*(fh->input_map + (unsigned long )inp));
#line 389
  return (tmp___0);
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_enumaudio(struct file *file , void *priv , struct v4l2_audio *vin ) 
{ 


  {
#line 411
  if (vin->index != 0U) {
#line 412
    return (-22);
  } else {

  }
#line 413
  strncpy((char *)(& vin->name), "PVRUSB2 Audio", 14UL);
#line 414
  vin->capability = 1U;
#line 415
  return (0);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_audio(struct file *file , void *priv , struct v4l2_audio *vin ) 
{ 


  {
#line 421
  vin->index = 0U;
#line 422
  strncpy((char *)(& vin->name), "PVRUSB2 Audio", 14UL);
#line 423
  vin->capability = 1U;
#line 424
  return (0);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_audio(struct file *file , void *priv , struct v4l2_audio  const  *vout ) 
{ 


  {
#line 429
  if ((unsigned int )vout->index != 0U) {
#line 430
    return (-22);
  } else {

  }
#line 431
  return (0);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_tuner(struct file *file , void *priv , struct v4l2_tuner *vt ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 436
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 437
  hdw = (fh->channel.mc_head)->hdw;
#line 439
  if (vt->index != 0U) {
#line 440
    return (-22);
  } else {

  }
#line 442
  pvr2_hdw_execute_tuner_poll(hdw);
#line 443
  tmp = pvr2_hdw_get_tuner_status(hdw, vt);
#line 443
  return (tmp);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_tuner(struct file *file , void *priv , struct v4l2_tuner  const  *vt ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 448
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 449
  hdw = (fh->channel.mc_head)->hdw;
#line 451
  if ((unsigned int )vt->index != 0U) {
#line 452
    return (-22);
  } else {

  }
#line 454
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 5U);
#line 454
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )vt->audmode);
#line 454
  return (tmp___0);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_frequency(struct file *file , void *priv , struct v4l2_frequency  const  *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned long fv ;
  struct v4l2_tuner vt ;
  int cur_input ;
  struct pvr2_ctrl *ctrlp ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 461
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 462
  hdw = (fh->channel.mc_head)->hdw;
#line 469
  ret = pvr2_hdw_get_tuner_status(hdw, & vt);
#line 470
  if (ret != 0) {
#line 471
    return (ret);
  } else {

  }
#line 472
  ctrlp = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 473
  ret = pvr2_ctrl_get_value(ctrlp, & cur_input);
#line 474
  if (ret != 0) {
#line 475
    return (ret);
  } else {

  }
#line 476
  if ((unsigned int )vf->type == 1U) {
#line 477
    if (cur_input != 4) {
#line 478
      pvr2_ctrl_set_value(ctrlp, 4);
    } else {

    }
  } else
#line 480
  if (cur_input == 4) {
#line 481
    pvr2_ctrl_set_value(ctrlp, 0);
  } else {

  }
#line 483
  fv = (unsigned long )vf->frequency;
#line 484
  if ((int )vt.capability & 1) {
#line 485
    fv = (fv * 125UL) / 2UL;
  } else {
#line 487
    fv = fv * 62500UL;
  }
#line 488
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 6U);
#line 488
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )fv);
#line 488
  return (tmp___0);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_frequency(struct file *file , void *priv , struct v4l2_frequency *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int cur_input ;
  struct v4l2_tuner vt ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;

  {
#line 494
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 495
  hdw = (fh->channel.mc_head)->hdw;
#line 496
  val = 0;
#line 501
  ret = pvr2_hdw_get_tuner_status(hdw, & vt);
#line 502
  if (ret != 0) {
#line 503
    return (ret);
  } else {

  }
#line 504
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 6U);
#line 504
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 507
  if (ret != 0) {
#line 508
    return (ret);
  } else {

  }
#line 509
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 509
  pvr2_ctrl_get_value(tmp___0, & cur_input);
#line 512
  if (cur_input == 4) {
#line 513
    vf->type = 1U;
  } else {
#line 515
    vf->type = 2U;
  }
#line 516
  if ((int )vt.capability & 1) {
#line 517
    val = (val * 2) / 125;
  } else {
#line 519
    val = val / 62500;
  }
#line 520
  vf->frequency = (__u32 )val;
#line 521
  return (0);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_enum_fmt_vid_cap(struct file *file , void *priv , struct v4l2_fmtdesc *fd ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 527
  if (fd->index != 0U) {
#line 528
    return (-22);
  } else {

  }
#line 530
  __len = 64UL;
#line 530
  if (__len > 63UL) {
#line 530
    __ret = __memcpy((void *)fd, (void const   *)(& pvr_fmtdesc), __len);
  } else {
#line 530
    __ret = __builtin_memcpy((void *)fd, (void const   *)(& pvr_fmtdesc), __len);
  }
#line 531
  return (0);
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  size_t __len ;
  void *__ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;

  {
#line 536
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 537
  hdw = (fh->channel.mc_head)->hdw;
#line 540
  __len = 208UL;
#line 540
  if (__len > 63UL) {
#line 540
    __ret = __memcpy((void *)vf, (void const   *)(& pvr_format), __len);
  } else {
#line 540
    __ret = __builtin_memcpy((void *)vf, (void const   *)(& pvr_format), __len);
  }
#line 541
  val = 0;
#line 542
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 542
  pvr2_ctrl_get_value(tmp, & val);
#line 545
  vf->fmt.pix.width = (__u32 )val;
#line 546
  val = 0;
#line 547
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 547
  pvr2_ctrl_get_value(tmp___0, & val);
#line 550
  vf->fmt.pix.height = (__u32 )val;
#line 551
  return (0);
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_try_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int lmin ;
  int lmax ;
  int ldef ;
  struct pvr2_ctrl *hcp ;
  struct pvr2_ctrl *vcp ;
  int h ;
  int w ;
  size_t __len ;
  void *__ret ;

  {
#line 556
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 557
  hdw = (fh->channel.mc_head)->hdw;
#line 560
  h = (int )vf->fmt.pix.height;
#line 561
  w = (int )vf->fmt.pix.width;
#line 563
  hcp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 564
  vcp = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 566
  lmin = pvr2_ctrl_get_min(hcp);
#line 567
  lmax = pvr2_ctrl_get_max(hcp);
#line 568
  pvr2_ctrl_get_def(hcp, & ldef);
#line 569
  if (w == -1) {
#line 570
    w = ldef;
  } else
#line 571
  if (w < lmin) {
#line 572
    w = lmin;
  } else
#line 573
  if (w > lmax) {
#line 574
    w = lmax;
  } else {

  }
#line 575
  lmin = pvr2_ctrl_get_min(vcp);
#line 576
  lmax = pvr2_ctrl_get_max(vcp);
#line 577
  pvr2_ctrl_get_def(vcp, & ldef);
#line 578
  if (h == -1) {
#line 579
    h = ldef;
  } else
#line 580
  if (h < lmin) {
#line 581
    h = lmin;
  } else
#line 582
  if (h > lmax) {
#line 583
    h = lmax;
  } else {

  }
#line 585
  __len = 208UL;
#line 585
  if (__len > 63UL) {
#line 585
    __ret = __memcpy((void *)vf, (void const   *)(& pvr_format), __len);
  } else {
#line 585
    __ret = __builtin_memcpy((void *)vf, (void const   *)(& pvr_format), __len);
  }
#line 587
  vf->fmt.pix.width = (__u32 )w;
#line 588
  vf->fmt.pix.height = (__u32 )h;
#line 589
  return (0);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *hcp ;
  struct pvr2_ctrl *vcp ;
  int ret ;
  int tmp ;

  {
#line 594
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 595
  hdw = (fh->channel.mc_head)->hdw;
#line 597
  tmp = pvr2_try_fmt_vid_cap(file, (void *)fh, vf);
#line 597
  ret = tmp;
#line 599
  if (ret != 0) {
#line 600
    return (ret);
  } else {

  }
#line 601
  hcp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 602
  vcp = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 603
  pvr2_ctrl_set_value(hcp, (int )vf->fmt.pix.width);
#line 604
  pvr2_ctrl_set_value(vcp, (int )vf->fmt.pix.height);
#line 605
  return (0);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_streamon(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_v4l2_dev *pdi ;
  int ret ;
  int tmp ;

  {
#line 610
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 611
  hdw = (fh->channel.mc_head)->hdw;
#line 612
  pdi = fh->pdi;
#line 615
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 619
    return (-1);
  } else {

  }
#line 621
  ret = pvr2_hdw_set_stream_type(hdw, pdi->config);
#line 622
  if (ret < 0) {
#line 623
    return (ret);
  } else {

  }
#line 624
  tmp = pvr2_hdw_set_streaming(hdw, 1);
#line 624
  return (tmp);
}
}
#line 627 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_streamoff(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 629
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 630
  hdw = (fh->channel.mc_head)->hdw;
#line 632
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 636
    return (-1);
  } else {

  }
#line 638
  tmp = pvr2_hdw_set_streaming(hdw, 0);
#line 638
  return (tmp);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_queryctrl(struct file *file , void *priv , struct v4l2_queryctrl *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *cptr ;
  int val ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  enum pvr2_ctl_type tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 644
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 645
  hdw = (fh->channel.mc_head)->hdw;
#line 649
  if ((int )vc->id < 0) {
#line 650
    cptr = pvr2_hdw_get_ctrl_nextv4l(hdw, vc->id & 2147483647U);
#line 652
    if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 653
      tmp = pvr2_ctrl_get_v4lid(cptr);
#line 653
      vc->id = (__u32 )tmp;
    } else {

    }
  } else {
#line 655
    cptr = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
  }
#line 657
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 658
    if ((pvrusb2_debug & 2097152) != 0) {
#line 658
      printk("\016pvrusb2: QUERYCTRL id=0x%x not implemented here\n", vc->id);
    } else {

    }
#line 661
    return (-22);
  } else {

  }
#line 664
  if ((pvrusb2_debug & 2097152) != 0) {
#line 664
    tmp___0 = pvr2_ctrl_get_desc(cptr);
#line 664
    tmp___1 = pvr2_ctrl_get_name(cptr);
#line 664
    printk("\016pvrusb2: QUERYCTRL id=0x%x mapping name=%s (%s)\n", vc->id, tmp___1,
           tmp___0);
  } else {

  }
#line 668
  tmp___2 = pvr2_ctrl_get_desc(cptr);
#line 668
  strlcpy((char *)(& vc->name), tmp___2, 32UL);
#line 669
  vc->flags = pvr2_ctrl_get_v4lflags(cptr);
#line 670
  pvr2_ctrl_get_def(cptr, & val);
#line 671
  vc->default_value = val;
#line 672
  tmp___3 = pvr2_ctrl_get_type(cptr);
#line 672
  switch ((unsigned int )tmp___3) {
  case 1U: 
#line 674
  vc->type = 3U;
#line 675
  vc->minimum = 0;
#line 676
  tmp___4 = pvr2_ctrl_get_cnt(cptr);
#line 676
  vc->maximum = tmp___4 + -1;
#line 677
  vc->step = 1;
#line 678
  goto ldv_33832;
  case 3U: 
#line 680
  vc->type = 2U;
#line 681
  vc->minimum = 0;
#line 682
  vc->maximum = 1;
#line 683
  vc->step = 1;
#line 684
  goto ldv_33832;
  case 0U: 
#line 686
  vc->type = 1U;
#line 687
  vc->minimum = pvr2_ctrl_get_min(cptr);
#line 688
  vc->maximum = pvr2_ctrl_get_max(cptr);
#line 689
  vc->step = 1;
#line 690
  goto ldv_33832;
  default: ;
#line 692
  if ((pvrusb2_debug & 2097152) != 0) {
#line 692
    tmp___5 = pvr2_ctrl_get_name(cptr);
#line 692
    printk("\016pvrusb2: QUERYCTRL id=0x%x name=%s not mappable\n", vc->id, tmp___5);
  } else {

  }
#line 695
  return (-22);
  }
  ldv_33832: ;
#line 697
  return (0);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_querymenu(struct file *file , void *priv , struct v4l2_querymenu *vm ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned int cnt ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 702
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 703
  hdw = (fh->channel.mc_head)->hdw;
#line 704
  cnt = 0U;
#line 707
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vm->id);
#line 707
  ret = pvr2_ctrl_get_valname(tmp, (int )vm->index, (char *)(& vm->ldv_29327.name),
                              31U, & cnt);
#line 711
  vm->ldv_29327.name[cnt] = 0U;
#line 712
  return (ret);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_ctrl(struct file *file , void *priv , struct v4l2_control *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 717
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 718
  hdw = (fh->channel.mc_head)->hdw;
#line 719
  val = 0;
#line 722
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
#line 722
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 724
  vc->value = val;
#line 725
  return (ret);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_ctrl(struct file *file , void *priv , struct v4l2_control *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 730
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 731
  hdw = (fh->channel.mc_head)->hdw;
#line 733
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
#line 733
  tmp___0 = pvr2_ctrl_set_value(tmp, vc->value);
#line 733
  return (tmp___0);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  unsigned int idx ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 740
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 741
  hdw = (fh->channel.mc_head)->hdw;
#line 747
  ret = 0;
#line 748
  idx = 0U;
#line 748
  goto ldv_33873;
  ldv_33872: 
#line 749
  ctrl = ctls->controls + (unsigned long )idx;
#line 750
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 750
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 752
  if (ret != 0) {
#line 753
    ctls->error_idx = idx;
#line 754
    return (ret);
  } else {

  }
#line 758
  ctrl->ldv_29295.value64 = 0LL;
#line 759
  ctrl->ldv_29295.value = val;
#line 748
  idx = idx + 1U;
  ldv_33873: ;
#line 748
  if (ctls->count > idx) {
#line 750
    goto ldv_33872;
  } else {

  }

#line 761
  return (0);
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  unsigned int idx ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 767
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 768
  hdw = (fh->channel.mc_head)->hdw;
#line 773
  ret = 0;
#line 774
  idx = 0U;
#line 774
  goto ldv_33886;
  ldv_33885: 
#line 775
  ctrl = ctls->controls + (unsigned long )idx;
#line 776
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 776
  ret = pvr2_ctrl_set_value(tmp, ctrl->ldv_29295.value);
#line 779
  if (ret != 0) {
#line 780
    ctls->error_idx = idx;
#line 781
    return (ret);
  } else {

  }
#line 774
  idx = idx + 1U;
  ldv_33886: ;
#line 774
  if (ctls->count > idx) {
#line 776
    goto ldv_33885;
  } else {

  }

#line 784
  return (0);
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_try_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  struct pvr2_ctrl *pctl ;
  unsigned int idx ;

  {
#line 790
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 791
  hdw = (fh->channel.mc_head)->hdw;
#line 798
  idx = 0U;
#line 798
  goto ldv_33899;
  ldv_33898: 
#line 799
  ctrl = ctls->controls + (unsigned long )idx;
#line 800
  pctl = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 801
  if ((unsigned long )pctl == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 802
    ctls->error_idx = idx;
#line 803
    return (-22);
  } else {

  }
#line 798
  idx = idx + 1U;
  ldv_33899: ;
#line 798
  if (ctls->count > idx) {
#line 800
    goto ldv_33898;
  } else {

  }

#line 806
  return (0);
}
}
#line 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_cropcap(struct file *file , void *priv , struct v4l2_cropcap *cap ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int ret ;

  {
#line 811
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 812
  hdw = (fh->channel.mc_head)->hdw;
#line 815
  if (cap->type != 1U) {
#line 816
    return (-22);
  } else {

  }
#line 817
  ret = pvr2_hdw_get_cropcap(hdw, cap);
#line 818
  cap->type = 1U;
#line 819
  return (ret);
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_g_crop(struct file *file , void *priv , struct v4l2_crop *crop ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;
  struct pvr2_ctrl *tmp___1 ;
  struct pvr2_ctrl *tmp___2 ;

  {
#line 824
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 825
  hdw = (fh->channel.mc_head)->hdw;
#line 826
  val = 0;
#line 829
  if (crop->type != 1U) {
#line 830
    return (-22);
  } else {

  }
#line 831
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 9U);
#line 831
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 833
  if (ret != 0) {
#line 834
    return (-22);
  } else {

  }
#line 835
  crop->c.left = val;
#line 836
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 10U);
#line 836
  ret = pvr2_ctrl_get_value(tmp___0, & val);
#line 838
  if (ret != 0) {
#line 839
    return (-22);
  } else {

  }
#line 840
  crop->c.top = val;
#line 841
  tmp___1 = pvr2_hdw_get_ctrl_by_id(hdw, 11U);
#line 841
  ret = pvr2_ctrl_get_value(tmp___1, & val);
#line 843
  if (ret != 0) {
#line 844
    return (-22);
  } else {

  }
#line 845
  crop->c.width = (__u32 )val;
#line 846
  tmp___2 = pvr2_hdw_get_ctrl_by_id(hdw, 12U);
#line 846
  ret = pvr2_ctrl_get_value(tmp___2, & val);
#line 848
  if (ret != 0) {
#line 849
    return (-22);
  } else {

  }
#line 850
  crop->c.height = (__u32 )val;
#line 851
  return (0);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_s_crop(struct file *file , void *priv , struct v4l2_crop  const  *crop ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;
  struct pvr2_ctrl *tmp___1 ;
  struct pvr2_ctrl *tmp___2 ;

  {
#line 856
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 857
  hdw = (fh->channel.mc_head)->hdw;
#line 860
  if ((unsigned int )crop->type != 1U) {
#line 861
    return (-22);
  } else {

  }
#line 862
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 9U);
#line 862
  ret = pvr2_ctrl_set_value(tmp, crop->c.left);
#line 865
  if (ret != 0) {
#line 866
    return (-22);
  } else {

  }
#line 867
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 10U);
#line 867
  ret = pvr2_ctrl_set_value(tmp___0, crop->c.top);
#line 870
  if (ret != 0) {
#line 871
    return (-22);
  } else {

  }
#line 872
  tmp___1 = pvr2_hdw_get_ctrl_by_id(hdw, 11U);
#line 872
  ret = pvr2_ctrl_set_value(tmp___1, (int )crop->c.width);
#line 875
  if (ret != 0) {
#line 876
    return (-22);
  } else {

  }
#line 877
  tmp___2 = pvr2_hdw_get_ctrl_by_id(hdw, 12U);
#line 877
  ret = pvr2_ctrl_set_value(tmp___2, (int )crop->c.height);
#line 880
  if (ret != 0) {
#line 881
    return (-22);
  } else {

  }
#line 882
  return (0);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_log_status(struct file *file , void *priv ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;

  {
#line 887
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 888
  hdw = (fh->channel.mc_head)->hdw;
#line 890
  pvr2_hdw_trigger_module_log(hdw);
#line 891
  return (0);
}
}
#line 894 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct v4l2_ioctl_ops  const  pvr2_ioctl_ops  = 
#line 894
     {& pvr2_querycap, & pvr2_g_priority, & pvr2_s_priority, & pvr2_enum_fmt_vid_cap,
    0, 0, 0, 0, 0, & pvr2_g_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & pvr2_s_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & pvr2_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & pvr2_streamon, & pvr2_streamoff, & pvr2_g_std,
    & pvr2_s_std, & pvr2_querystd, & pvr2_enum_input, & pvr2_g_input, & pvr2_s_input,
    0, 0, 0, & pvr2_queryctrl, & pvr2_g_ctrl, & pvr2_s_ctrl, & pvr2_g_ext_ctrls, & pvr2_s_ext_ctrls,
    & pvr2_try_ext_ctrls, & pvr2_querymenu, & pvr2_enumaudio, & pvr2_g_audio, & pvr2_s_audio,
    0, 0, 0, 0, 0, & pvr2_cropcap, & pvr2_g_crop, & pvr2_s_crop, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & pvr2_g_tuner, & pvr2_s_tuner, & pvr2_g_frequency, & pvr2_s_frequency,
    0, 0, & pvr2_log_status, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_dev_destroy(struct pvr2_v4l2_dev *dip ) 
{ 
  struct pvr2_hdw *hdw ;
  enum pvr2_config cfg ;
  char msg[80U] ;
  unsigned int mcnt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 932
  hdw = ((dip->v4lp)->channel.mc_head)->hdw;
#line 933
  cfg = dip->config;
#line 940
  tmp = pvr2_config_get_name(cfg);
#line 940
  tmp___0 = video_device_node_name(& dip->devbase);
#line 940
  tmp___1 = scnprintf((char *)(& msg), 79UL, "pvrusb2: unregistered device %s [%s]",
                      tmp___0, tmp);
#line 940
  mcnt = (unsigned int )tmp___1;
#line 944
  msg[mcnt] = 0;
#line 946
  pvr2_hdw_v4l_store_minor_number(hdw, dip->minor_type, -1);
#line 949
  dip->v4lp = (struct pvr2_v4l2 *)0;
#line 950
  dip->stream = (struct pvr2_context_stream *)0;
#line 954
  video_unregister_device(& dip->devbase);
#line 956
  printk("\016%s\n", (char *)(& msg));
#line 957
  return;
}
}
#line 961 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_dev_disassociate_parent(struct pvr2_v4l2_dev *dip ) 
{ 


  {
#line 963
  if ((unsigned long )dip == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 963
    return;
  } else {

  }
#line 964
  if ((unsigned long )(dip->devbase.v4l2_dev)->dev == (unsigned long )((struct device *)0)) {
#line 964
    return;
  } else {

  }
#line 965
  (dip->devbase.v4l2_dev)->dev = (struct device *)0;
#line 966
  device_move(& dip->devbase.dev, (struct device *)0, 0);
#line 967
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_destroy_no_lock(struct pvr2_v4l2 *vp ) 
{ 


  {
#line 972
  if ((unsigned long )vp->dev_video != (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 973
    pvr2_v4l2_dev_destroy(vp->dev_video);
#line 974
    vp->dev_video = (struct pvr2_v4l2_dev *)0;
  } else {

  }
#line 976
  if ((unsigned long )vp->dev_radio != (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 977
    pvr2_v4l2_dev_destroy(vp->dev_radio);
#line 978
    vp->dev_radio = (struct pvr2_v4l2_dev *)0;
  } else {

  }
#line 981
  if ((pvrusb2_debug & 2048) != 0) {
#line 981
    printk("\016pvrusb2: Destroying pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 982
  pvr2_channel_done(& vp->channel);
#line 983
  kfree((void const   *)vp);
#line 984
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_video_device_release(struct video_device *vdev ) 
{ 
  struct pvr2_v4l2_dev *dev ;
  struct video_device  const  *__mptr ;

  {
#line 990
  __mptr = (struct video_device  const  *)vdev;
#line 990
  dev = (struct pvr2_v4l2_dev *)__mptr;
#line 991
  kfree((void const   *)dev);
#line 992
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_v4l2 *vp ;
  struct pvr2_channel  const  *__mptr ;

  {
#line 998
  __mptr = (struct pvr2_channel  const  *)chp;
#line 998
  vp = (struct pvr2_v4l2 *)__mptr;
#line 999
  if ((vp->channel.mc_head)->disconnect_flag == 0) {
#line 999
    return;
  } else {

  }
#line 1000
  pvr2_v4l2_dev_disassociate_parent(vp->dev_video);
#line 1001
  pvr2_v4l2_dev_disassociate_parent(vp->dev_radio);
#line 1002
  if ((unsigned long )vp->vfirst != (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1002
    return;
  } else {

  }
#line 1003
  pvr2_v4l2_destroy_no_lock(vp);
#line 1004
  return;
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static long pvr2_v4l2_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_v4l2 *vp ;
  struct pvr2_hdw *hdw ;
  long ret ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1011
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 1012
  vp = fh->vhead;
#line 1013
  hdw = (fh->channel.mc_head)->hdw;
#line 1014
  ret = -22L;
#line 1016
  if ((pvrusb2_debug & 2097152) != 0) {
#line 1017
    tmp = pvr2_hdw_get_driver_name(hdw);
#line 1017
    v4l_printk_ioctl(tmp, cmd);
  } else {

  }
#line 1019
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 1019
  if (tmp___0 == 0) {
#line 1020
    if ((pvrusb2_debug & 2) != 0) {
#line 1020
      printk("\016pvrusb2: ioctl failed - bad or no context\n");
    } else {

    }
#line 1022
    return (-14L);
  } else {

  }
#line 1026
  switch (cmd) {
  case 3221771804U: ;
  case 1074288152U: ;
  case 3221509671U: ;
  case 1079268894U: ;
  case 1076647481U: 
#line 1032
  tmp___1 = v4l2_prio_check(& vp->prio, fh->prio);
#line 1032
  ret = (long )tmp___1;
#line 1033
  if (ret != 0L) {
#line 1034
    return (ret);
  } else {

  }
  }
#line 1037
  ret = video_ioctl2(file, cmd, arg);
#line 1039
  pvr2_hdw_commit_ctl(hdw);
#line 1041
  if (ret < 0L) {
#line 1042
    if ((pvrusb2_debug & 2097152) != 0) {
#line 1043
      if ((pvrusb2_debug & 2097152) != 0) {
#line 1043
        printk("\016pvrusb2: pvr2_v4l2_do_ioctl failure, ret=%ld\n", ret);
      } else {

      }
    } else
#line 1046
    if ((pvrusb2_debug & 2097152) != 0) {
#line 1047
      if ((pvrusb2_debug & 2097152) != 0) {
#line 1047
        printk("\016pvrusb2: pvr2_v4l2_do_ioctl failure, ret=%ld command was:\n",
               ret);
      } else {

      }
#line 1050
      tmp___2 = pvr2_hdw_get_driver_name(hdw);
#line 1050
      v4l_printk_ioctl(tmp___2, cmd);
    } else {

    }
  } else
#line 1055
  if ((pvrusb2_debug & 2097152) != 0) {
#line 1055
    printk("\016pvrusb2: pvr2_v4l2_do_ioctl complete, ret=%ld (0x%lx)\n", ret, ret);
  } else {

  }
#line 1059
  return (ret);
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_v4l2_release(struct file *file ) 
{ 
  struct pvr2_v4l2_fh *fhp ;
  struct pvr2_v4l2 *vp ;
  struct pvr2_hdw *hdw ;
  struct pvr2_stream *sp ;

  {
#line 1066
  fhp = (struct pvr2_v4l2_fh *)file->private_data;
#line 1067
  vp = fhp->vhead;
#line 1068
  hdw = (fhp->channel.mc_head)->hdw;
#line 1070
  if ((pvrusb2_debug & 4096) != 0) {
#line 1070
    printk("\016pvrusb2: pvr2_v4l2_release\n");
  } else {

  }
#line 1072
  if ((unsigned long )fhp->rhp != (unsigned long )((struct pvr2_ioread *)0)) {
#line 1074
    pvr2_hdw_set_streaming(hdw, 0);
#line 1075
    sp = pvr2_ioread_get_stream(fhp->rhp);
#line 1076
    if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 1076
      pvr2_stream_set_callback(sp, (void (*)(void * ))0, (void *)0);
    } else {

    }
#line 1077
    pvr2_ioread_destroy(fhp->rhp);
#line 1078
    fhp->rhp = (struct pvr2_ioread *)0;
  } else {

  }
#line 1081
  v4l2_prio_close(& vp->prio, fhp->prio);
#line 1082
  file->private_data = (void *)0;
#line 1084
  if ((unsigned long )fhp->vnext != (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1085
    (fhp->vnext)->vprev = fhp->vprev;
  } else {
#line 1087
    vp->vlast = fhp->vprev;
  }
#line 1089
  if ((unsigned long )fhp->vprev != (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1090
    (fhp->vprev)->vnext = fhp->vnext;
  } else {
#line 1092
    vp->vfirst = fhp->vnext;
  }
#line 1094
  fhp->vnext = (struct pvr2_v4l2_fh *)0;
#line 1095
  fhp->vprev = (struct pvr2_v4l2_fh *)0;
#line 1096
  fhp->vhead = (struct pvr2_v4l2 *)0;
#line 1097
  pvr2_channel_done(& fhp->channel);
#line 1098
  if ((pvrusb2_debug & 2048) != 0) {
#line 1098
    printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p\n", fhp);
  } else {

  }
#line 1100
  if ((unsigned long )fhp->input_map != (unsigned long )((unsigned char *)0U)) {
#line 1101
    kfree((void const   *)fhp->input_map);
#line 1102
    fhp->input_map = (unsigned char *)0U;
  } else {

  }
#line 1104
  kfree((void const   *)fhp);
#line 1105
  if ((vp->channel.mc_head)->disconnect_flag != 0 && (unsigned long )vp->vfirst == (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1106
    pvr2_v4l2_destroy_no_lock(vp);
  } else {

  }
#line 1108
  return (0);
}
}
#line 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_v4l2_open(struct file *file ) 
{ 
  struct pvr2_v4l2_dev *dip ;
  struct pvr2_v4l2_fh *fhp ;
  struct pvr2_v4l2 *vp ;
  struct pvr2_hdw *hdw ;
  unsigned int input_mask ;
  unsigned int input_cnt ;
  unsigned int idx ;
  int ret ;
  struct video_device  const  *__mptr ;
  struct video_device *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1118
  input_mask = 0U;
#line 1120
  ret = 0;
#line 1122
  tmp = video_devdata(file);
#line 1122
  __mptr = (struct video_device  const  *)tmp;
#line 1122
  dip = (struct pvr2_v4l2_dev *)__mptr;
#line 1124
  vp = dip->v4lp;
#line 1125
  hdw = vp->channel.hdw;
#line 1127
  if ((pvrusb2_debug & 4096) != 0) {
#line 1127
    printk("\016pvrusb2: pvr2_v4l2_open\n");
  } else {

  }
#line 1129
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 1129
  if (tmp___0 == 0) {
#line 1130
    if ((pvrusb2_debug & 4096) != 0) {
#line 1130
      printk("\016pvrusb2: pvr2_v4l2_open: hardware not ready\n");
    } else {

    }
#line 1132
    return (-5);
  } else {

  }
#line 1135
  tmp___1 = kzalloc(224UL, 208U);
#line 1135
  fhp = (struct pvr2_v4l2_fh *)tmp___1;
#line 1136
  if ((unsigned long )fhp == (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1137
    return (-12);
  } else {

  }
#line 1140
  __init_waitqueue_head(& fhp->wait_data, "&fhp->wait_data", & __key);
#line 1141
  fhp->pdi = dip;
#line 1143
  if ((pvrusb2_debug & 2048) != 0) {
#line 1143
    printk("\016pvrusb2: Creating pvr_v4l2_fh id=%p\n", fhp);
  } else {

  }
#line 1144
  pvr2_channel_init(& fhp->channel, vp->channel.mc_head);
#line 1146
  if (dip->v4l_type == 2) {
#line 1149
    input_mask = 16U;
  } else {
#line 1153
    input_mask = 29U;
  }
#line 1158
  ret = pvr2_channel_limit_inputs(& fhp->channel, input_mask);
#line 1159
  if (ret != 0) {
#line 1160
    pvr2_channel_done(& fhp->channel);
#line 1161
    if ((pvrusb2_debug & 2048) != 0) {
#line 1161
      printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p (input mask error)\n", fhp);
    } else {

    }
#line 1165
    kfree((void const   *)fhp);
#line 1166
    return (ret);
  } else {

  }
#line 1169
  tmp___2 = pvr2_hdw_get_input_available(hdw);
#line 1169
  input_mask = tmp___2 & input_mask;
#line 1170
  input_cnt = 0U;
#line 1171
  idx = 0U;
#line 1171
  goto ldv_33994;
  ldv_33993: ;
#line 1172
  if (((unsigned int )(1 << (int )idx) & input_mask) != 0U) {
#line 1172
    input_cnt = input_cnt + 1U;
  } else {

  }
#line 1171
  idx = idx + 1U;
  ldv_33994: ;
#line 1171
  if (idx <= 31U) {
#line 1173
    goto ldv_33993;
  } else {

  }
#line 1174
  fhp->input_cnt = input_cnt;
#line 1175
  tmp___3 = kzalloc((size_t )input_cnt, 208U);
#line 1175
  fhp->input_map = (unsigned char *)tmp___3;
#line 1176
  if ((unsigned long )fhp->input_map == (unsigned long )((unsigned char *)0U)) {
#line 1177
    pvr2_channel_done(& fhp->channel);
#line 1178
    if ((pvrusb2_debug & 2048) != 0) {
#line 1178
      printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p (input map failure)\n", fhp);
    } else {

    }
#line 1181
    kfree((void const   *)fhp);
#line 1182
    return (-12);
  } else {

  }
#line 1184
  input_cnt = 0U;
#line 1185
  idx = 0U;
#line 1185
  goto ldv_33998;
  ldv_33997: ;
#line 1186
  if (((unsigned int )(1 << (int )idx) & input_mask) == 0U) {
#line 1186
    goto ldv_33996;
  } else {

  }
#line 1187
  tmp___4 = input_cnt;
#line 1187
  input_cnt = input_cnt + 1U;
#line 1187
  *(fhp->input_map + (unsigned long )tmp___4) = (unsigned char )idx;
  ldv_33996: 
#line 1185
  idx = idx + 1U;
  ldv_33998: ;
#line 1185
  if (idx <= 31U) {
#line 1187
    goto ldv_33997;
  } else {

  }
#line 1190
  fhp->vnext = (struct pvr2_v4l2_fh *)0;
#line 1191
  fhp->vprev = vp->vlast;
#line 1192
  if ((unsigned long )vp->vlast != (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 1193
    (vp->vlast)->vnext = fhp;
  } else {
#line 1195
    vp->vfirst = fhp;
  }
#line 1197
  vp->vlast = fhp;
#line 1198
  fhp->vhead = vp;
#line 1200
  fhp->file = file;
#line 1201
  file->private_data = (void *)fhp;
#line 1202
  v4l2_prio_open(& vp->prio, & fhp->prio);
#line 1204
  fhp->fw_mode_flag = pvr2_hdw_cpufw_get_enabled(hdw);
#line 1206
  return (0);
}
}
#line 1210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp ) 
{ 


  {
#line 1212
  __wake_up(& fhp->wait_data, 3U, 1, (void *)0);
#line 1213
  return;
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static int pvr2_v4l2_iosetup(struct pvr2_v4l2_fh *fh ) 
{ 
  int ret ;
  struct pvr2_stream *sp ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 1220
  if ((unsigned long )fh->rhp != (unsigned long )((struct pvr2_ioread *)0)) {
#line 1220
    return (0);
  } else {

  }
#line 1222
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 1225
    return (-1);
  } else {

  }
#line 1230
  ret = pvr2_channel_claim_stream(& fh->channel, (fh->pdi)->stream);
#line 1230
  if (ret != 0) {
#line 1233
    return (ret);
  } else {

  }
#line 1236
  fh->rhp = pvr2_channel_create_mpeg_stream((fh->pdi)->stream);
#line 1237
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1238
    pvr2_channel_claim_stream(& fh->channel, (struct pvr2_context_stream *)0);
#line 1239
    return (-12);
  } else {

  }
#line 1242
  hdw = (fh->channel.mc_head)->hdw;
#line 1243
  sp = ((fh->pdi)->stream)->stream;
#line 1244
  pvr2_stream_set_callback(sp, (void (*)(void * ))(& pvr2_v4l2_notify), (void *)fh);
#line 1245
  pvr2_hdw_set_stream_type(hdw, (fh->pdi)->config);
#line 1246
  ret = pvr2_hdw_set_streaming(hdw, 1);
#line 1246
  if (ret < 0) {
#line 1246
    return (ret);
  } else {

  }
#line 1247
  tmp = pvr2_ioread_set_enabled(fh->rhp, 1);
#line 1247
  return (tmp);
}
}
#line 1251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static ssize_t pvr2_v4l2_read(struct file *file , char *buff , size_t count , loff_t *ppos ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  int ret ;
  struct pvr2_hdw *hdw ;
  char *tbuf ;
  int c1 ;
  int c2 ;
  int tcnt ;
  unsigned int offs ;
  void *tmp ;
  unsigned long tmp___0 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1254
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 1257
  if (fh->fw_mode_flag != 0) {
#line 1258
    hdw = (fh->channel.mc_head)->hdw;
#line 1261
    tcnt = 0;
#line 1262
    offs = (unsigned int )*ppos;
#line 1264
    tmp = kmalloc(4096UL, 208U);
#line 1264
    tbuf = (char *)tmp;
#line 1265
    if ((unsigned long )tbuf == (unsigned long )((char *)0)) {
#line 1265
      return (-12L);
    } else {

    }
#line 1267
    goto ldv_34025;
    ldv_34024: 
#line 1268
    c1 = (int )count;
#line 1269
    if ((unsigned int )c1 > 4096U) {
#line 1269
      c1 = 4096;
    } else {

    }
#line 1270
    c2 = pvr2_hdw_cpufw_get(hdw, offs, tbuf, (unsigned int )c1);
#line 1271
    if (c2 < 0) {
#line 1272
      tcnt = c2;
#line 1273
      goto ldv_34023;
    } else {

    }
#line 1275
    if (c2 == 0) {
#line 1275
      goto ldv_34023;
    } else {

    }
#line 1276
    tmp___0 = copy_to_user((void *)buff, (void const   *)tbuf, (unsigned long )c2);
#line 1276
    if (tmp___0 != 0UL) {
#line 1277
      tcnt = -14;
#line 1278
      goto ldv_34023;
    } else {

    }
#line 1280
    offs = offs + (unsigned int )c2;
#line 1281
    tcnt = tcnt + c2;
#line 1282
    buff = buff + (unsigned long )c2;
#line 1283
    count = count - (size_t )c2;
#line 1284
    *ppos = *ppos + (loff_t )c2;
    ldv_34025: ;
#line 1267
    if (count != 0UL) {
#line 1269
      goto ldv_34024;
    } else {

    }
    ldv_34023: 
#line 1286
    kfree((void const   *)tbuf);
#line 1287
    return ((ssize_t )tcnt);
  } else {

  }
#line 1290
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1291
    ret = pvr2_v4l2_iosetup(fh);
#line 1292
    if (ret != 0) {
#line 1293
      return ((ssize_t )ret);
    } else {

    }
  } else {

  }
  ldv_34036: 
#line 1298
  ret = pvr2_ioread_read(fh->rhp, (void *)buff, (unsigned int )count);
#line 1299
  if (ret >= 0) {
#line 1299
    goto ldv_34026;
  } else {

  }
#line 1300
  if (ret != -11) {
#line 1300
    goto ldv_34026;
  } else {

  }
#line 1301
  if ((file->f_flags & 2048U) != 0U) {
#line 1301
    goto ldv_34026;
  } else {

  }
#line 1303
  __ret = 0;
#line 1303
  tmp___3 = pvr2_ioread_avail(fh->rhp);
#line 1303
  if (tmp___3 < 0) {
#line 1303
    __ret___0 = 0L;
#line 1303
    INIT_LIST_HEAD(& __wait.task_list);
#line 1303
    __wait.flags = 0U;
    ldv_34033: 
#line 1303
    tmp___1 = prepare_to_wait_event(& fh->wait_data, & __wait, 1);
#line 1303
    __int = tmp___1;
#line 1303
    tmp___2 = pvr2_ioread_avail(fh->rhp);
#line 1303
    if (tmp___2 >= 0) {
#line 1303
      goto ldv_34032;
    } else {

    }
#line 1303
    if (__int != 0L) {
#line 1303
      __ret___0 = __int;
#line 1303
      goto ldv_34032;
    } else {

    }
#line 1303
    schedule();
#line 1303
    goto ldv_34033;
    ldv_34032: 
#line 1303
    finish_wait(& fh->wait_data, & __wait);
#line 1303
    __ret = (int )__ret___0;
  } else {

  }
#line 1303
  ret = __ret;
#line 1306
  if (ret < 0) {
#line 1306
    goto ldv_34026;
  } else {

  }
#line 1307
  goto ldv_34036;
  ldv_34026: ;
#line 1309
  return ((ssize_t )ret);
}
}
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static unsigned int pvr2_v4l2_poll(struct file *file , poll_table *wait ) 
{ 
  unsigned int mask ;
  struct pvr2_v4l2_fh *fh ;
  int ret ;
  int tmp ;

  {
#line 1315
  mask = 0U;
#line 1316
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 1319
  if (fh->fw_mode_flag != 0) {
#line 1320
    mask = mask | 65U;
#line 1321
    return (mask);
  } else {

  }
#line 1324
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1325
    ret = pvr2_v4l2_iosetup(fh);
#line 1326
    if (ret != 0) {
#line 1326
      return (8U);
    } else {

    }
  } else {

  }
#line 1329
  poll_wait(file, & fh->wait_data, wait);
#line 1331
  tmp = pvr2_ioread_avail(fh->rhp);
#line 1331
  if (tmp >= 0) {
#line 1332
    mask = mask | 65U;
  } else {

  }
#line 1335
  return (mask);
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct v4l2_file_operations  const  vdev_fops  = 
#line 1339
     {& __this_module, & pvr2_v4l2_read, 0, & pvr2_v4l2_poll, & pvr2_v4l2_ioctl, 0,
    0, 0, 0, & pvr2_v4l2_open, & pvr2_v4l2_release};
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static struct video_device vdev_template  = 
#line 1349
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {.alsa = {0U, 0U, 0U}}}, & vdev_fops, {0,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {{0}},
                                                                                  {{{0L},
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}},
                                                                                   {{0,
                                                                                     0},
                                                                                    0UL,
                                                                                    0,
                                                                                    0,
                                                                                    0UL,
                                                                                    0,
                                                                                    0,
                                                                                    0,
                                                                                    {(char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0,
                                                                                     (char)0},
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}},
                                                                                   0,
                                                                                   0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0},
                                                                                 0,
                                                                                 0,
                                                                                 {{0},
                                                                                  {{{{{0U}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 {{0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{{{{0U}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  {0U,
                                                                                   {{{{{{0U}},
                                                                                       0U,
                                                                                       0U,
                                                                                       0,
                                                                                       {0,
                                                                                        {0,
                                                                                         0},
                                                                                        0,
                                                                                        0,
                                                                                        0UL}}}},
                                                                                    {0,
                                                                                     0}}},
                                                                                  0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{0,
                                                                                    0},
                                                                                   0UL,
                                                                                   0,
                                                                                   0,
                                                                                   0UL,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   {(char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0},
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  0UL,
                                                                                  {{0L},
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  {{{{{{0U}},
                                                                                      0U,
                                                                                      0U,
                                                                                      0,
                                                                                      {0,
                                                                                       {0,
                                                                                        0},
                                                                                       0,
                                                                                       0,
                                                                                       0UL}}}},
                                                                                   {0,
                                                                                    0}},
                                                                                  {0},
                                                                                  {0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0,
                                                                                  0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0ULL,
                                                                                 0UL,
                                                                                 0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 {0},
                                                                                 0U,
                                                                                 0U,
                                                                                 {{{{{0U}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0},
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  {{0}}},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0},
    0, 0, 0, 0, 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                       (char)0, (char)0, (char)0, (char)0}, 0, 0, 0, (unsigned short)0,
    0UL, 0, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0ULL, 0, 0,
    {0UL, 0UL, 0UL}, {0UL, 0UL, 0UL}, 0};
#line 1354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
static void pvr2_v4l2_dev_init(struct pvr2_v4l2_dev *dip , struct pvr2_v4l2 *vp ,
                               int v4l_type ) 
{ 
  int mindevnum ;
  int unit_number ;
  struct pvr2_hdw *hdw ;
  int *nr_ptr ;
  int val ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1361
  nr_ptr = (int *)0;
#line 1362
  dip->v4lp = vp;
#line 1364
  hdw = (vp->channel.mc_head)->hdw;
#line 1365
  dip->v4l_type = v4l_type;
#line 1366
  switch (v4l_type) {
  case 0: 
#line 1368
  dip->stream = & (vp->channel.mc_head)->video_stream;
#line 1369
  dip->config = 1;
#line 1370
  dip->minor_type = 0;
#line 1371
  nr_ptr = (int *)(& video_nr);
#line 1372
  if ((unsigned long )dip->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 1373
    printk("\vpvrusb2: Failed to set up pvrusb2 v4l video dev due to missing stream instance\n");
#line 1376
    return;
  } else {

  }
#line 1378
  goto ldv_34056;
  case 1: 
#line 1380
  dip->config = 2;
#line 1381
  dip->minor_type = 1;
#line 1382
  nr_ptr = (int *)(& vbi_nr);
#line 1383
  goto ldv_34056;
  case 2: 
#line 1385
  dip->stream = & (vp->channel.mc_head)->video_stream;
#line 1386
  dip->config = 1;
#line 1387
  dip->minor_type = 2;
#line 1388
  nr_ptr = (int *)(& radio_nr);
#line 1389
  goto ldv_34056;
  default: 
#line 1392
  printk("\vpvrusb2: Failed to set up pvrusb2 v4l dev due to unrecognized config\n");
#line 1394
  return;
  }
  ldv_34056: 
#line 1397
  dip->devbase = vdev_template;
#line 1398
  dip->devbase.release = & pvr2_video_device_release;
#line 1399
  dip->devbase.ioctl_ops = & pvr2_ioctl_ops;
#line 1402
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 3U);
#line 1402
  pvr2_ctrl_get_value(tmp, & val);
#line 1405
  dip->devbase.tvnorms = (unsigned long long )val;
#line 1408
  mindevnum = -1;
#line 1409
  unit_number = pvr2_hdw_get_unit_number(hdw);
#line 1410
  if (((unsigned long )nr_ptr != (unsigned long )((int *)0) && unit_number >= 0) && unit_number <= 19) {
#line 1411
    mindevnum = *(nr_ptr + (unsigned long )unit_number);
  } else {

  }
#line 1413
  pvr2_hdw_set_v4l2_dev(hdw, & dip->devbase);
#line 1414
  tmp___0 = video_register_device(& dip->devbase, dip->v4l_type, mindevnum);
#line 1414
  if (tmp___0 < 0) {
#line 1414
    tmp___1 = video_register_device(& dip->devbase, dip->v4l_type, -1);
#line 1414
    if (tmp___1 < 0) {
#line 1418
      printk("\vpvrusb2: Failed to register pvrusb2 v4l device\n");
    } else {

    }
  } else {

  }
#line 1422
  tmp___2 = pvr2_config_get_name(dip->config);
#line 1422
  tmp___3 = video_device_node_name(& dip->devbase);
#line 1422
  printk("\016pvrusb2: registered device %s [%s]\n", tmp___3, tmp___2);
#line 1426
  pvr2_hdw_v4l_store_minor_number(hdw, dip->minor_type, dip->devbase.minor);
#line 1428
  return;
}
}
#line 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
struct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp ) 
{ 
  struct pvr2_v4l2 *vp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1435
  tmp = kzalloc(104UL, 208U);
#line 1435
  vp = (struct pvr2_v4l2 *)tmp;
#line 1436
  if ((unsigned long )vp == (unsigned long )((struct pvr2_v4l2 *)0)) {
#line 1436
    return (vp);
  } else {

  }
#line 1437
  pvr2_channel_init(& vp->channel, mnp);
#line 1438
  if ((pvrusb2_debug & 2048) != 0) {
#line 1438
    printk("\016pvrusb2: Creating pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 1440
  vp->channel.check_func = & pvr2_v4l2_internal_check;
#line 1443
  tmp___0 = kzalloc(1872UL, 208U);
#line 1443
  vp->dev_video = (struct pvr2_v4l2_dev *)tmp___0;
#line 1444
  if ((unsigned long )vp->dev_video == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 1444
    goto fail;
  } else {

  }
#line 1445
  pvr2_v4l2_dev_init(vp->dev_video, vp, 0);
#line 1446
  tmp___2 = pvr2_hdw_get_input_available((vp->channel.mc_head)->hdw);
#line 1446
  if ((tmp___2 & 16U) != 0U) {
#line 1448
    tmp___1 = kzalloc(1872UL, 208U);
#line 1448
    vp->dev_radio = (struct pvr2_v4l2_dev *)tmp___1;
#line 1449
    if ((unsigned long )vp->dev_radio == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 1449
      goto fail;
    } else {

    }
#line 1450
    pvr2_v4l2_dev_init(vp->dev_radio, vp, 2);
  } else {

  }
#line 1453
  return (vp);
  fail: ;
#line 1455
  if ((pvrusb2_debug & 2048) != 0) {
#line 1455
    printk("\016pvrusb2: Failure creating pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 1456
  pvr2_v4l2_destroy_no_lock(vp);
#line 1457
  return ((struct pvr2_v4l2 *)0);
}
}
#line 1470 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
int ldv_retval_0  ;
#line 1473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1474
  tmp = ldv_zalloc(52UL);
#line 1474
  pvr2_ioctl_ops_group3 = (struct v4l2_audio *)tmp;
#line 1475
  tmp___0 = ldv_zalloc(512UL);
#line 1475
  pvr2_ioctl_ops_group1 = (struct file *)tmp___0;
#line 1476
  tmp___1 = ldv_zalloc(208UL);
#line 1476
  pvr2_ioctl_ops_group0 = (struct v4l2_format *)tmp___1;
#line 1477
  tmp___2 = ldv_zalloc(32UL);
#line 1477
  pvr2_ioctl_ops_group4 = (struct v4l2_ext_controls *)tmp___2;
#line 1478
  tmp___3 = ldv_zalloc(8UL);
#line 1478
  pvr2_ioctl_ops_group2 = (struct v4l2_control *)tmp___3;
#line 1479
  return;
}
}
#line 1481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_initialize_v4l2_file_operations_11(void) 
{ 
  void *tmp ;

  {
#line 1482
  tmp = ldv_zalloc(512UL);
#line 1482
  vdev_fops_group0 = (struct file *)tmp;
#line 1483
  return;
}
}
#line 1485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  size_t ldvarg2 ;
  size_t tmp ;
  unsigned int ldvarg5 ;
  unsigned int tmp___0 ;
  struct poll_table_struct *ldvarg0 ;
  void *tmp___1 ;
  char *ldvarg3 ;
  void *tmp___2 ;
  unsigned long ldvarg4 ;
  unsigned long tmp___3 ;
  loff_t *ldvarg1 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 1486
  tmp = __VERIFIER_nondet_size_t();
#line 1486
  ldvarg2 = tmp;
#line 1487
  tmp___0 = __VERIFIER_nondet_uint();
#line 1487
  ldvarg5 = tmp___0;
#line 1488
  tmp___1 = ldv_zalloc(16UL);
#line 1488
  ldvarg0 = (struct poll_table_struct *)tmp___1;
#line 1489
  tmp___2 = ldv_zalloc(1UL);
#line 1489
  ldvarg3 = (char *)tmp___2;
#line 1490
  tmp___3 = __VERIFIER_nondet_ulong();
#line 1490
  ldvarg4 = tmp___3;
#line 1491
  tmp___4 = ldv_zalloc(8UL);
#line 1491
  ldvarg1 = (loff_t *)tmp___4;
#line 1493
  tmp___5 = __VERIFIER_nondet_int();
#line 1493
  switch (tmp___5) {
  case 0: ;
#line 1496
  if (ldv_state_variable_11 == 2) {
#line 1498
    pvr2_v4l2_release(vdev_fops_group0);
#line 1500
    ldv_state_variable_11 = 1;
#line 1501
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1504
  goto ldv_34083;
  case 1: ;
#line 1507
  if (ldv_state_variable_11 == 1) {
#line 1509
    ldv_retval_0 = pvr2_v4l2_open(vdev_fops_group0);
#line 1511
    if (ldv_retval_0 == 0) {
#line 1512
      ldv_state_variable_11 = 2;
#line 1513
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1517
  goto ldv_34083;
  case 2: ;
#line 1520
  if (ldv_state_variable_11 == 1) {
#line 1522
    pvr2_v4l2_ioctl(vdev_fops_group0, ldvarg5, ldvarg4);
#line 1524
    ldv_state_variable_11 = 1;
  } else {

  }
#line 1527
  if (ldv_state_variable_11 == 2) {
#line 1529
    pvr2_v4l2_ioctl(vdev_fops_group0, ldvarg5, ldvarg4);
#line 1531
    ldv_state_variable_11 = 2;
  } else {

  }
#line 1534
  goto ldv_34083;
  case 3: ;
#line 1537
  if (ldv_state_variable_11 == 2) {
#line 1539
    pvr2_v4l2_read(vdev_fops_group0, ldvarg3, ldvarg2, ldvarg1);
#line 1541
    ldv_state_variable_11 = 2;
  } else {

  }
#line 1544
  goto ldv_34083;
  case 4: ;
#line 1547
  if (ldv_state_variable_11 == 1) {
#line 1549
    pvr2_v4l2_poll(vdev_fops_group0, ldvarg0);
#line 1551
    ldv_state_variable_11 = 1;
  } else {

  }
#line 1554
  if (ldv_state_variable_11 == 2) {
#line 1556
    pvr2_v4l2_poll(vdev_fops_group0, ldvarg0);
#line 1558
    ldv_state_variable_11 = 2;
  } else {

  }
#line 1561
  goto ldv_34083;
  default: 
#line 1562
  ldv_stop();
  }
  ldv_34083: ;
#line 1566
  return;
}
}
#line 1568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  void *ldvarg52 ;
  void *tmp ;
  void *ldvarg19 ;
  void *tmp___0 ;
  void *ldvarg22 ;
  void *tmp___1 ;
  void *ldvarg25 ;
  void *tmp___2 ;
  void *ldvarg17 ;
  void *tmp___3 ;
  void *ldvarg54 ;
  void *tmp___4 ;
  void *ldvarg21 ;
  void *tmp___5 ;
  void *ldvarg30 ;
  void *tmp___6 ;
  void *ldvarg15 ;
  void *tmp___7 ;
  void *ldvarg27 ;
  void *tmp___8 ;
  v4l2_std_id ldvarg26 ;
  struct v4l2_fmtdesc *ldvarg45 ;
  void *tmp___9 ;
  void *ldvarg9 ;
  void *tmp___10 ;
  struct v4l2_frequency *ldvarg40 ;
  void *tmp___11 ;
  void *ldvarg36 ;
  void *tmp___12 ;
  struct v4l2_input *ldvarg10 ;
  void *tmp___13 ;
  enum v4l2_priority ldvarg55 ;
  void *ldvarg13 ;
  void *tmp___14 ;
  struct v4l2_audio *ldvarg8 ;
  void *tmp___15 ;
  void *ldvarg57 ;
  void *tmp___16 ;
  enum v4l2_buf_type ldvarg49 ;
  void *ldvarg59 ;
  void *tmp___17 ;
  void *ldvarg41 ;
  void *tmp___18 ;
  void *ldvarg60 ;
  void *tmp___19 ;
  void *ldvarg31 ;
  void *tmp___20 ;
  struct v4l2_cropcap *ldvarg20 ;
  void *tmp___21 ;
  void *ldvarg39 ;
  void *tmp___22 ;
  struct v4l2_crop *ldvarg47 ;
  void *tmp___23 ;
  void *ldvarg28 ;
  void *tmp___24 ;
  void *ldvarg34 ;
  void *tmp___25 ;
  struct v4l2_frequency *ldvarg14 ;
  void *tmp___26 ;
  void *ldvarg48 ;
  void *tmp___27 ;
  struct v4l2_capability *ldvarg16 ;
  void *tmp___28 ;
  enum v4l2_buf_type ldvarg6 ;
  unsigned int ldvarg33 ;
  unsigned int tmp___29 ;
  unsigned int *ldvarg38 ;
  void *tmp___30 ;
  struct v4l2_crop *ldvarg35 ;
  void *tmp___31 ;
  void *ldvarg24 ;
  void *tmp___32 ;
  void *ldvarg44 ;
  void *tmp___33 ;
  struct v4l2_tuner *ldvarg29 ;
  void *tmp___34 ;
  struct v4l2_tuner *ldvarg53 ;
  void *tmp___35 ;
  void *ldvarg37 ;
  void *tmp___36 ;
  struct v4l2_querymenu *ldvarg58 ;
  void *tmp___37 ;
  void *ldvarg46 ;
  void *tmp___38 ;
  void *ldvarg50 ;
  void *tmp___39 ;
  void *ldvarg56 ;
  void *tmp___40 ;
  v4l2_std_id *ldvarg12 ;
  void *tmp___41 ;
  enum v4l2_priority *ldvarg42 ;
  void *tmp___42 ;
  void *ldvarg43 ;
  void *tmp___43 ;
  v4l2_std_id *ldvarg23 ;
  void *tmp___44 ;
  void *ldvarg7 ;
  void *tmp___45 ;
  void *ldvarg32 ;
  void *tmp___46 ;
  struct v4l2_queryctrl *ldvarg51 ;
  void *tmp___47 ;
  void *ldvarg11 ;
  void *tmp___48 ;
  void *ldvarg18 ;
  void *tmp___49 ;
  int tmp___50 ;

  {
#line 1569
  tmp = ldv_zalloc(1UL);
#line 1569
  ldvarg52 = tmp;
#line 1570
  tmp___0 = ldv_zalloc(1UL);
#line 1570
  ldvarg19 = tmp___0;
#line 1571
  tmp___1 = ldv_zalloc(1UL);
#line 1571
  ldvarg22 = tmp___1;
#line 1572
  tmp___2 = ldv_zalloc(1UL);
#line 1572
  ldvarg25 = tmp___2;
#line 1573
  tmp___3 = ldv_zalloc(1UL);
#line 1573
  ldvarg17 = tmp___3;
#line 1574
  tmp___4 = ldv_zalloc(1UL);
#line 1574
  ldvarg54 = tmp___4;
#line 1575
  tmp___5 = ldv_zalloc(1UL);
#line 1575
  ldvarg21 = tmp___5;
#line 1576
  tmp___6 = ldv_zalloc(1UL);
#line 1576
  ldvarg30 = tmp___6;
#line 1577
  tmp___7 = ldv_zalloc(1UL);
#line 1577
  ldvarg15 = tmp___7;
#line 1578
  tmp___8 = ldv_zalloc(1UL);
#line 1578
  ldvarg27 = tmp___8;
#line 1580
  tmp___9 = ldv_zalloc(64UL);
#line 1580
  ldvarg45 = (struct v4l2_fmtdesc *)tmp___9;
#line 1581
  tmp___10 = ldv_zalloc(1UL);
#line 1581
  ldvarg9 = tmp___10;
#line 1582
  tmp___11 = ldv_zalloc(44UL);
#line 1582
  ldvarg40 = (struct v4l2_frequency *)tmp___11;
#line 1583
  tmp___12 = ldv_zalloc(1UL);
#line 1583
  ldvarg36 = tmp___12;
#line 1584
  tmp___13 = ldv_zalloc(80UL);
#line 1584
  ldvarg10 = (struct v4l2_input *)tmp___13;
#line 1586
  tmp___14 = ldv_zalloc(1UL);
#line 1586
  ldvarg13 = tmp___14;
#line 1587
  tmp___15 = ldv_zalloc(52UL);
#line 1587
  ldvarg8 = (struct v4l2_audio *)tmp___15;
#line 1588
  tmp___16 = ldv_zalloc(1UL);
#line 1588
  ldvarg57 = tmp___16;
#line 1590
  tmp___17 = ldv_zalloc(1UL);
#line 1590
  ldvarg59 = tmp___17;
#line 1591
  tmp___18 = ldv_zalloc(1UL);
#line 1591
  ldvarg41 = tmp___18;
#line 1592
  tmp___19 = ldv_zalloc(1UL);
#line 1592
  ldvarg60 = tmp___19;
#line 1593
  tmp___20 = ldv_zalloc(1UL);
#line 1593
  ldvarg31 = tmp___20;
#line 1594
  tmp___21 = ldv_zalloc(44UL);
#line 1594
  ldvarg20 = (struct v4l2_cropcap *)tmp___21;
#line 1595
  tmp___22 = ldv_zalloc(1UL);
#line 1595
  ldvarg39 = tmp___22;
#line 1596
  tmp___23 = ldv_zalloc(20UL);
#line 1596
  ldvarg47 = (struct v4l2_crop *)tmp___23;
#line 1597
  tmp___24 = ldv_zalloc(1UL);
#line 1597
  ldvarg28 = tmp___24;
#line 1598
  tmp___25 = ldv_zalloc(1UL);
#line 1598
  ldvarg34 = tmp___25;
#line 1599
  tmp___26 = ldv_zalloc(44UL);
#line 1599
  ldvarg14 = (struct v4l2_frequency *)tmp___26;
#line 1600
  tmp___27 = ldv_zalloc(1UL);
#line 1600
  ldvarg48 = tmp___27;
#line 1601
  tmp___28 = ldv_zalloc(104UL);
#line 1601
  ldvarg16 = (struct v4l2_capability *)tmp___28;
#line 1603
  tmp___29 = __VERIFIER_nondet_uint();
#line 1603
  ldvarg33 = tmp___29;
#line 1604
  tmp___30 = ldv_zalloc(4UL);
#line 1604
  ldvarg38 = (unsigned int *)tmp___30;
#line 1605
  tmp___31 = ldv_zalloc(20UL);
#line 1605
  ldvarg35 = (struct v4l2_crop *)tmp___31;
#line 1606
  tmp___32 = ldv_zalloc(1UL);
#line 1606
  ldvarg24 = tmp___32;
#line 1607
  tmp___33 = ldv_zalloc(1UL);
#line 1607
  ldvarg44 = tmp___33;
#line 1608
  tmp___34 = ldv_zalloc(84UL);
#line 1608
  ldvarg29 = (struct v4l2_tuner *)tmp___34;
#line 1609
  tmp___35 = ldv_zalloc(84UL);
#line 1609
  ldvarg53 = (struct v4l2_tuner *)tmp___35;
#line 1610
  tmp___36 = ldv_zalloc(1UL);
#line 1610
  ldvarg37 = tmp___36;
#line 1611
  tmp___37 = ldv_zalloc(44UL);
#line 1611
  ldvarg58 = (struct v4l2_querymenu *)tmp___37;
#line 1612
  tmp___38 = ldv_zalloc(1UL);
#line 1612
  ldvarg46 = tmp___38;
#line 1613
  tmp___39 = ldv_zalloc(1UL);
#line 1613
  ldvarg50 = tmp___39;
#line 1614
  tmp___40 = ldv_zalloc(1UL);
#line 1614
  ldvarg56 = tmp___40;
#line 1615
  tmp___41 = ldv_zalloc(8UL);
#line 1615
  ldvarg12 = (v4l2_std_id *)tmp___41;
#line 1616
  tmp___42 = ldv_zalloc(4UL);
#line 1616
  ldvarg42 = (enum v4l2_priority *)tmp___42;
#line 1617
  tmp___43 = ldv_zalloc(1UL);
#line 1617
  ldvarg43 = tmp___43;
#line 1618
  tmp___44 = ldv_zalloc(8UL);
#line 1618
  ldvarg23 = (v4l2_std_id *)tmp___44;
#line 1619
  tmp___45 = ldv_zalloc(1UL);
#line 1619
  ldvarg7 = tmp___45;
#line 1620
  tmp___46 = ldv_zalloc(1UL);
#line 1620
  ldvarg32 = tmp___46;
#line 1621
  tmp___47 = ldv_zalloc(68UL);
#line 1621
  ldvarg51 = (struct v4l2_queryctrl *)tmp___47;
#line 1622
  tmp___48 = ldv_zalloc(1UL);
#line 1622
  ldvarg11 = tmp___48;
#line 1623
  tmp___49 = ldv_zalloc(1UL);
#line 1623
  ldvarg18 = tmp___49;
#line 1579
  memset((void *)(& ldvarg26), 0, 8UL);
#line 1585
  memset((void *)(& ldvarg55), 0, 4UL);
#line 1589
  memset((void *)(& ldvarg49), 0, 4UL);
#line 1602
  memset((void *)(& ldvarg6), 0, 4UL);
#line 1625
  tmp___50 = __VERIFIER_nondet_int();
#line 1625
  switch (tmp___50) {
  case 0: ;
#line 1628
  if (ldv_state_variable_12 == 1) {
#line 1630
    pvr2_g_ext_ctrls(pvr2_ioctl_ops_group1, ldvarg60, pvr2_ioctl_ops_group4);
#line 1632
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1635
  goto ldv_34148;
  case 1: ;
#line 1638
  if (ldv_state_variable_12 == 1) {
#line 1640
    pvr2_querymenu(pvr2_ioctl_ops_group1, ldvarg59, ldvarg58);
#line 1642
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1645
  goto ldv_34148;
  case 2: ;
#line 1648
  if (ldv_state_variable_12 == 1) {
#line 1650
    pvr2_try_fmt_vid_cap(pvr2_ioctl_ops_group1, ldvarg57, pvr2_ioctl_ops_group0);
#line 1652
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1655
  goto ldv_34148;
  case 3: ;
#line 1658
  if (ldv_state_variable_12 == 1) {
#line 1660
    pvr2_s_priority(pvr2_ioctl_ops_group1, ldvarg56, ldvarg55);
#line 1662
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1665
  goto ldv_34148;
  case 4: ;
#line 1668
  if (ldv_state_variable_12 == 1) {
#line 1670
    pvr2_s_tuner(pvr2_ioctl_ops_group1, ldvarg54, (struct v4l2_tuner  const  *)ldvarg53);
#line 1672
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1675
  goto ldv_34148;
  case 5: ;
#line 1678
  if (ldv_state_variable_12 == 1) {
#line 1680
    pvr2_queryctrl(pvr2_ioctl_ops_group1, ldvarg52, ldvarg51);
#line 1682
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1685
  goto ldv_34148;
  case 6: ;
#line 1688
  if (ldv_state_variable_12 == 1) {
#line 1690
    pvr2_streamoff(pvr2_ioctl_ops_group1, ldvarg50, ldvarg49);
#line 1692
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1695
  goto ldv_34148;
  case 7: ;
#line 1698
  if (ldv_state_variable_12 == 1) {
#line 1700
    pvr2_g_crop(pvr2_ioctl_ops_group1, ldvarg48, ldvarg47);
#line 1702
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1705
  goto ldv_34148;
  case 8: ;
#line 1708
  if (ldv_state_variable_12 == 1) {
#line 1710
    pvr2_enum_fmt_vid_cap(pvr2_ioctl_ops_group1, ldvarg46, ldvarg45);
#line 1712
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1715
  goto ldv_34148;
  case 9: ;
#line 1718
  if (ldv_state_variable_12 == 1) {
#line 1720
    pvr2_s_fmt_vid_cap(pvr2_ioctl_ops_group1, ldvarg44, pvr2_ioctl_ops_group0);
#line 1722
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1725
  goto ldv_34148;
  case 10: ;
#line 1728
  if (ldv_state_variable_12 == 1) {
#line 1730
    pvr2_g_priority(pvr2_ioctl_ops_group1, ldvarg43, ldvarg42);
#line 1732
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1735
  goto ldv_34148;
  case 11: ;
#line 1738
  if (ldv_state_variable_12 == 1) {
#line 1740
    pvr2_g_frequency(pvr2_ioctl_ops_group1, ldvarg41, ldvarg40);
#line 1742
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1745
  goto ldv_34148;
  case 12: ;
#line 1748
  if (ldv_state_variable_12 == 1) {
#line 1750
    pvr2_g_input(pvr2_ioctl_ops_group1, ldvarg39, ldvarg38);
#line 1752
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1755
  goto ldv_34148;
  case 13: ;
#line 1758
  if (ldv_state_variable_12 == 1) {
#line 1760
    pvr2_s_ext_ctrls(pvr2_ioctl_ops_group1, ldvarg37, pvr2_ioctl_ops_group4);
#line 1762
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1765
  goto ldv_34148;
  case 14: ;
#line 1768
  if (ldv_state_variable_12 == 1) {
#line 1770
    pvr2_s_crop(pvr2_ioctl_ops_group1, ldvarg36, (struct v4l2_crop  const  *)ldvarg35);
#line 1772
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1775
  goto ldv_34148;
  case 15: ;
#line 1778
  if (ldv_state_variable_12 == 1) {
#line 1780
    pvr2_s_input(pvr2_ioctl_ops_group1, ldvarg34, ldvarg33);
#line 1782
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1785
  goto ldv_34148;
  case 16: ;
#line 1788
  if (ldv_state_variable_12 == 1) {
#line 1790
    pvr2_enumaudio(pvr2_ioctl_ops_group1, ldvarg32, pvr2_ioctl_ops_group3);
#line 1792
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1795
  goto ldv_34148;
  case 17: ;
#line 1798
  if (ldv_state_variable_12 == 1) {
#line 1800
    pvr2_s_ctrl(pvr2_ioctl_ops_group1, ldvarg31, pvr2_ioctl_ops_group2);
#line 1802
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1805
  goto ldv_34148;
  case 18: ;
#line 1808
  if (ldv_state_variable_12 == 1) {
#line 1810
    pvr2_g_tuner(pvr2_ioctl_ops_group1, ldvarg30, ldvarg29);
#line 1812
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1815
  goto ldv_34148;
  case 19: ;
#line 1818
  if (ldv_state_variable_12 == 1) {
#line 1820
    pvr2_g_ctrl(pvr2_ioctl_ops_group1, ldvarg28, pvr2_ioctl_ops_group2);
#line 1822
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1825
  goto ldv_34148;
  case 20: ;
#line 1828
  if (ldv_state_variable_12 == 1) {
#line 1830
    pvr2_s_std(pvr2_ioctl_ops_group1, ldvarg27, ldvarg26);
#line 1832
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1835
  goto ldv_34148;
  case 21: ;
#line 1838
  if (ldv_state_variable_12 == 1) {
#line 1840
    pvr2_log_status(pvr2_ioctl_ops_group1, ldvarg25);
#line 1842
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1845
  goto ldv_34148;
  case 22: ;
#line 1848
  if (ldv_state_variable_12 == 1) {
#line 1850
    pvr2_querystd(pvr2_ioctl_ops_group1, ldvarg24, ldvarg23);
#line 1852
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1855
  goto ldv_34148;
  case 23: ;
#line 1858
  if (ldv_state_variable_12 == 1) {
#line 1860
    pvr2_try_ext_ctrls(pvr2_ioctl_ops_group1, ldvarg22, pvr2_ioctl_ops_group4);
#line 1862
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1865
  goto ldv_34148;
  case 24: ;
#line 1868
  if (ldv_state_variable_12 == 1) {
#line 1870
    pvr2_cropcap(pvr2_ioctl_ops_group1, ldvarg21, ldvarg20);
#line 1872
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1875
  goto ldv_34148;
  case 25: ;
#line 1878
  if (ldv_state_variable_12 == 1) {
#line 1880
    pvr2_g_fmt_vid_cap(pvr2_ioctl_ops_group1, ldvarg19, pvr2_ioctl_ops_group0);
#line 1882
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1885
  goto ldv_34148;
  case 26: ;
#line 1888
  if (ldv_state_variable_12 == 1) {
#line 1890
    pvr2_g_audio(pvr2_ioctl_ops_group1, ldvarg18, pvr2_ioctl_ops_group3);
#line 1892
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1895
  goto ldv_34148;
  case 27: ;
#line 1898
  if (ldv_state_variable_12 == 1) {
#line 1900
    pvr2_querycap(pvr2_ioctl_ops_group1, ldvarg17, ldvarg16);
#line 1902
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1905
  goto ldv_34148;
  case 28: ;
#line 1908
  if (ldv_state_variable_12 == 1) {
#line 1910
    pvr2_s_frequency(pvr2_ioctl_ops_group1, ldvarg15, (struct v4l2_frequency  const  *)ldvarg14);
#line 1912
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1915
  goto ldv_34148;
  case 29: ;
#line 1918
  if (ldv_state_variable_12 == 1) {
#line 1920
    pvr2_g_std(pvr2_ioctl_ops_group1, ldvarg13, ldvarg12);
#line 1922
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1925
  goto ldv_34148;
  case 30: ;
#line 1928
  if (ldv_state_variable_12 == 1) {
#line 1930
    pvr2_enum_input(pvr2_ioctl_ops_group1, ldvarg11, ldvarg10);
#line 1932
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1935
  goto ldv_34148;
  case 31: ;
#line 1938
  if (ldv_state_variable_12 == 1) {
#line 1940
    pvr2_s_audio(pvr2_ioctl_ops_group1, ldvarg9, (struct v4l2_audio  const  *)ldvarg8);
#line 1942
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1945
  goto ldv_34148;
  case 32: ;
#line 1948
  if (ldv_state_variable_12 == 1) {
#line 1950
    pvr2_streamon(pvr2_ioctl_ops_group1, ldvarg7, ldvarg6);
#line 1952
    ldv_state_variable_12 = 1;
  } else {

  }
#line 1955
  goto ldv_34148;
  default: 
#line 1956
  ldv_stop();
  }
  ldv_34148: ;
#line 1960
  return;
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void *ldv_kmem_cache_alloc_356(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2091
  ldv_check_alloc_flags(flags);
#line 2093
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2094
  return ((void *)0);
}
}
#line 376 "include/linux/kernel.h"
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 60 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_375(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr , int mask , int val ) ;
#line 58
int pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr ) ;
#line 71
int pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr ) ;
#line 81
int pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr ) ;
#line 84
int pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                                  unsigned int maxlen , unsigned int *len ) ;
#line 90
int pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr , char const   *buf , unsigned int len ,
                                  int *maskptr , int *valptr ) ;
#line 95
int pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                           unsigned int maxlen , unsigned int *len ) ;
#line 101
int pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr , char const   *ptr , unsigned int len ,
                           int *maskptr , int *valptr ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_383(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_391(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_385(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_381(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_389(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_386(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static int pvr2_ctrl_range_check(struct pvr2_ctrl *cptr , int val ) 
{ 
  int tmp ;
  int lim ;

  {
#line 120
  if ((unsigned long )(cptr->info)->check_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                             int  ))0)) {
#line 121
    tmp = (*((cptr->info)->check_value))(cptr, val);
#line 121
    if (tmp == 0) {
#line 121
      return (-34);
    } else {

    }
  } else
#line 122
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 123
    if (val < 0) {
#line 123
      return (-34);
    } else {

    }
#line 124
    if ((unsigned int )val >= (unsigned int )(cptr->info)->def.type_enum.count) {
#line 124
      return (-34);
    } else {

    }
  } else {
#line 127
    lim = (int )(cptr->info)->def.type_int.min_value;
#line 128
    if ((unsigned long )(cptr->info)->get_min_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                                 int * ))0)) {
#line 129
      (*((cptr->info)->get_min_value))(cptr, & lim);
    } else {

    }
#line 131
    if (val < lim) {
#line 131
      return (-34);
    } else {

    }
#line 132
    lim = (int )(cptr->info)->def.type_int.max_value;
#line 133
    if ((unsigned long )(cptr->info)->get_max_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                                 int * ))0)) {
#line 134
      (*((cptr->info)->get_max_value))(cptr, & lim);
    } else {

    }
#line 136
    if (val > lim) {
#line 136
      return (-34);
    } else {

    }
  }
#line 138
  return (0);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_set_value(struct pvr2_ctrl *cptr , int val ) 
{ 
  int tmp ;

  {
#line 145
  tmp = pvr2_ctrl_set_mask_value(cptr, -1, val);
#line 145
  return (tmp);
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr , int mask , int val ) 
{ 
  int ret ;

  {
#line 152
  ret = 0;
#line 153
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 153
    return (-22);
  } else {

  }
#line 154
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 154
  (cptr->hdw)->big_lock_held = 1;
#line 155
  if ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 156
    if ((unsigned int )(cptr->info)->type == 2U) {
#line 157
      mask = (int )((unsigned int )(cptr->info)->def.type_bitmask.valid_bits & (unsigned int )mask);
    } else
#line 158
    if ((unsigned int )(cptr->info)->type == 0U || (unsigned int )(cptr->info)->type == 1U) {
#line 160
      ret = pvr2_ctrl_range_check(cptr, val);
#line 161
      if (ret < 0) {
#line 161
        goto ldv_49748;
      } else {

      }
    } else
#line 162
    if ((unsigned int )(cptr->info)->type != 3U) {
#line 163
      goto ldv_49748;
    } else {

    }
#line 165
    ret = (*((cptr->info)->set_value))(cptr, mask, val);
  } else {
#line 167
    ret = -1;
  }
  ldv_49748: 
#line 169
  (cptr->hdw)->big_lock_held = 0;
#line 169
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 170
  return (ret);
}
}
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_value(struct pvr2_ctrl *cptr , int *valptr ) 
{ 
  int ret ;

  {
#line 177
  ret = 0;
#line 178
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 178
    return (-22);
  } else {

  }
#line 179
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 179
  (cptr->hdw)->big_lock_held = 1;
#line 180
  ret = (*((cptr->info)->get_value))(cptr, valptr);
#line 181
  (cptr->hdw)->big_lock_held = 0;
#line 181
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 182
  return (ret);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
enum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 189
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 189
    return (0);
  } else {

  }
#line 190
  return ((enum pvr2_ctl_type )(cptr->info)->type);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_max(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 197
  ret = 0;
#line 198
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 198
    return (0);
  } else {

  }
#line 199
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 199
  (cptr->hdw)->big_lock_held = 1;
#line 200
  if ((unsigned long )(cptr->info)->get_max_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 201
    (*((cptr->info)->get_max_value))(cptr, & ret);
  } else
#line 202
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 203
    ret = (int )(cptr->info)->def.type_int.max_value;
  } else {

  }
#line 205
  (cptr->hdw)->big_lock_held = 0;
#line 205
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 206
  return (ret);
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_min(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 213
  ret = 0;
#line 214
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 214
    return (0);
  } else {

  }
#line 215
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 215
  (cptr->hdw)->big_lock_held = 1;
#line 216
  if ((unsigned long )(cptr->info)->get_min_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 217
    (*((cptr->info)->get_min_value))(cptr, & ret);
  } else
#line 218
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 219
    ret = (int )(cptr->info)->def.type_int.min_value;
  } else {

  }
#line 221
  (cptr->hdw)->big_lock_held = 0;
#line 221
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 222
  return (ret);
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_def(struct pvr2_ctrl *cptr , int *valptr ) 
{ 
  int ret ;

  {
#line 229
  ret = 0;
#line 230
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 230
    return (-22);
  } else {

  }
#line 231
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 231
  (cptr->hdw)->big_lock_held = 1;
#line 232
  if ((unsigned long )(cptr->info)->get_def_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 233
    ret = (*((cptr->info)->get_def_value))(cptr, valptr);
  } else {
#line 235
    *valptr = (cptr->info)->default_value;
  }
#line 237
  (cptr->hdw)->big_lock_held = 0;
#line 237
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 238
  return (ret);
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 245
  ret = 0;
#line 246
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 246
    return (0);
  } else {

  }
#line 247
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 247
  (cptr->hdw)->big_lock_held = 1;
#line 248
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 249
    ret = (int )(cptr->info)->def.type_enum.count;
  } else {

  }
#line 251
  (cptr->hdw)->big_lock_held = 0;
#line 251
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 252
  return (ret);
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 259
  ret = 0;
#line 260
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 260
    return (0);
  } else {

  }
#line 261
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 261
  (cptr->hdw)->big_lock_held = 1;
#line 262
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 263
    ret = (int )(cptr->info)->def.type_bitmask.valid_bits;
  } else {

  }
#line 265
  (cptr->hdw)->big_lock_held = 0;
#line 265
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 266
  return (ret);
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
char const   *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 273
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 273
    return ((char const   *)0);
  } else {

  }
#line 274
  return ((char const   *)(cptr->info)->name);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
char const   *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 281
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 281
    return ((char const   *)0);
  } else {

  }
#line 282
  return ((char const   *)(cptr->info)->desc);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr , int val , char *bptr , unsigned int bmax ,
                          unsigned int *blen ) 
{ 
  int ret ;
  char const   * const  *names ;
  int tmp ;
  int tmp___0 ;
  char const   **names___0 ;
  unsigned int idx ;
  int msk ;
  int tmp___1 ;

  {
#line 291
  ret = -22;
#line 292
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 292
    return (0);
  } else {

  }
#line 293
  *blen = 0U;
#line 294
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 294
  (cptr->hdw)->big_lock_held = 1;
#line 295
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 297
    names = (cptr->info)->def.type_enum.value_names;
#line 298
    tmp___0 = pvr2_ctrl_range_check(cptr, val);
#line 298
    if (tmp___0 == 0) {
#line 299
      if ((unsigned long )*(names + (unsigned long )val) != (unsigned long )((char const   */* const  */)0)) {
#line 300
        tmp = scnprintf(bptr, (size_t )bmax, "%s", *(names + (unsigned long )val));
#line 300
        *blen = (unsigned int )tmp;
      } else {
#line 304
        *blen = 0U;
      }
#line 306
      ret = 0;
    } else {

    }
  } else
#line 308
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 312
    names___0 = (cptr->info)->def.type_bitmask.bit_names;
#line 313
    val = (int )((unsigned int )(cptr->info)->def.type_bitmask.valid_bits & (unsigned int )val);
#line 314
    idx = 0U;
#line 314
    msk = 1;
#line 314
    goto ldv_49798;
    ldv_49797: ;
#line 315
    if ((val & msk) != 0) {
#line 316
      tmp___1 = scnprintf(bptr, (size_t )bmax, "%s", *(names___0 + (unsigned long )idx));
#line 316
      *blen = (unsigned int )tmp___1;
#line 318
      ret = 0;
#line 319
      goto ldv_49796;
    } else {

    }
#line 314
    idx = idx + 1U;
#line 314
    msk = msk << 1;
    ldv_49798: ;
#line 314
    if (val != 0) {
#line 316
      goto ldv_49797;
    } else {

    }
    ldv_49796: ;
  } else {

  }
#line 323
  (cptr->hdw)->big_lock_held = 0;
#line 323
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 324
  return (ret);
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 331
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 331
    return (0);
  } else {

  }
#line 332
  return ((int )(cptr->info)->v4l_id);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
unsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr ) 
{ 
  unsigned int flags ;

  {
#line 338
  flags = 0U;
#line 340
  if ((unsigned long )(cptr->info)->get_v4lflags != (unsigned long )((unsigned int (*)(struct pvr2_ctrl * ))0)) {
#line 341
    flags = (*((cptr->info)->get_v4lflags))(cptr);
  } else {

  }
#line 344
  if ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 345
    flags = flags & 4294967291U;
  } else {
#line 347
    flags = flags | 4U;
  }
#line 350
  return (flags);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 357
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 357
    return (0);
  } else {

  }
#line 358
  return ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int  ,
                                                                               int  ))0));
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 365
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 365
    return (0);
  } else {

  }
#line 366
  if ((unsigned long )(cptr->info)->val_to_sym == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            int  ,
                                                                            int  ,
                                                                            char * ,
                                                                            unsigned int  ,
                                                                            unsigned int * ))0)) {
#line 366
    return (0);
  } else {

  }
#line 367
  if ((unsigned long )(cptr->info)->sym_to_val == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            char const   * ,
                                                                            unsigned int  ,
                                                                            int * ,
                                                                            int * ))0)) {
#line 367
    return (0);
  } else {

  }
#line 368
  return (1);
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                                  unsigned int maxlen , unsigned int *len ) 
{ 
  int tmp ;

  {
#line 378
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 378
    return (-22);
  } else {

  }
#line 379
  if ((unsigned long )(cptr->info)->val_to_sym == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            int  ,
                                                                            int  ,
                                                                            char * ,
                                                                            unsigned int  ,
                                                                            unsigned int * ))0)) {
#line 379
    return (-22);
  } else {

  }
#line 380
  tmp = (*((cptr->info)->val_to_sym))(cptr, mask, val, buf, maxlen, len);
#line 380
  return (tmp);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr , char const   *buf , unsigned int len ,
                                  int *maskptr , int *valptr ) 
{ 
  int tmp ;

  {
#line 389
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 389
    return (-22);
  } else {

  }
#line 390
  if ((unsigned long )(cptr->info)->sym_to_val == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            char const   * ,
                                                                            unsigned int  ,
                                                                            int * ,
                                                                            int * ))0)) {
#line 390
    return (-22);
  } else {

  }
#line 391
  tmp = (*((cptr->info)->sym_to_val))(cptr, buf, len, maskptr, valptr);
#line 391
  return (tmp);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static unsigned int gen_bitmask_string(int msk , int val , int msk_only , char const   **names ,
                                       char *ptr , unsigned int len ) 
{ 
  unsigned int idx ;
  long sm ;
  long um ;
  int spcFl ;
  unsigned int uc ;
  unsigned int cnt ;
  char const   *idStr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 405
  spcFl = 0;
#line 406
  uc = 0U;
#line 407
  um = 0L;
#line 408
  idx = 0U;
#line 408
  sm = 1L;
#line 408
  goto ldv_49843;
  ldv_49842: ;
#line 409
  if (((long )msk & sm) != 0L) {
#line 410
    msk = ~ ((int )sm) & msk;
#line 411
    idStr = *(names + (unsigned long )idx);
#line 412
    if ((unsigned long )idStr != (unsigned long )((char const   *)0)) {
#line 413
      tmp = scnprintf(ptr, (size_t )len, "%s%s%s", spcFl != 0 ? (char *)" " : (char *)"",
                      msk_only == 0 ? (((long )val & sm) != 0L ? (char *)"+" : (char *)"-") : (char *)"",
                      idStr);
#line 413
      cnt = (unsigned int )tmp;
#line 418
      ptr = ptr + (unsigned long )cnt;
#line 418
      len = len - cnt;
#line 418
      uc = uc + cnt;
#line 419
      spcFl = 1;
    } else {
#line 421
      um = um | sm;
    }
  } else {

  }
#line 408
  idx = idx + 1U;
#line 408
  sm = sm << 1;
  ldv_49843: ;
#line 408
  if (msk != 0) {
#line 410
    goto ldv_49842;
  } else {

  }

#line 425
  if (um != 0L) {
#line 426
    if (msk_only != 0) {
#line 427
      tmp___0 = scnprintf(ptr, (size_t )len, "%s0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          um);
#line 427
      cnt = (unsigned int )tmp___0;
#line 430
      ptr = ptr + (unsigned long )cnt;
#line 430
      len = len - cnt;
#line 430
      uc = uc + cnt;
#line 431
      spcFl = 1;
    } else
#line 432
    if (((long )val & um) != 0L) {
#line 433
      tmp___1 = scnprintf(ptr, (size_t )len, "%s+0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          (long )val & um);
#line 433
      cnt = (unsigned int )tmp___1;
#line 436
      ptr = ptr + (unsigned long )cnt;
#line 436
      len = len - cnt;
#line 436
      uc = uc + cnt;
#line 437
      spcFl = 1;
    } else
#line 438
    if (((long )(~ val) & um) != 0L) {
#line 439
      tmp___2 = scnprintf(ptr, (size_t )len, "%s+0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          (long )(~ val) & um);
#line 439
      cnt = (unsigned int )tmp___2;
#line 442
      ptr = ptr + (unsigned long )cnt;
#line 442
      len = len - cnt;
#line 442
      uc = uc + cnt;
#line 443
      spcFl = 1;
    } else {

    }
  } else {

  }
#line 446
  return (uc);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static char const   *boolNames[4U]  = {      "false",      "true",      "no",      "yes"};
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static int parse_token(char const   *ptr , unsigned int len , int *valptr , char const   * const  *names ,
                       unsigned int namecnt ) 
{ 
  char buf[33U] ;
  unsigned int slen ;
  unsigned int idx ;
  int negfl ;
  char *p2 ;
  size_t tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  long tmp___1 ;

  {
#line 467
  *valptr = 0;
#line 468
  if ((unsigned long )names == (unsigned long )((char const   * const  *)0)) {
#line 468
    namecnt = 0U;
  } else {

  }
#line 469
  idx = 0U;
#line 469
  goto ldv_49860;
  ldv_49859: ;
#line 470
  if ((unsigned long )*(names + (unsigned long )idx) == (unsigned long )((char const   */* const  */)0)) {
#line 470
    goto ldv_49858;
  } else {

  }
#line 471
  tmp = strlen(*(names + (unsigned long )idx));
#line 471
  slen = (unsigned int )tmp;
#line 472
  if (slen != len) {
#line 472
    goto ldv_49858;
  } else {

  }
#line 473
  tmp___0 = memcmp((void const   *)*(names + (unsigned long )idx), (void const   *)ptr,
                   (size_t )slen);
#line 473
  if (tmp___0 != 0) {
#line 473
    goto ldv_49858;
  } else {

  }
#line 474
  *valptr = (int )idx;
#line 475
  return (0);
  ldv_49858: 
#line 469
  idx = idx + 1U;
  ldv_49860: ;
#line 469
  if (idx < namecnt) {
#line 471
    goto ldv_49859;
  } else {

  }
#line 477
  negfl = 0;
#line 478
  if ((int )((signed char )*ptr) == 45 || (int )((signed char )*ptr) == 43) {
#line 479
    negfl = (int )((signed char )*ptr) == 45;
#line 480
    ptr = ptr + 1;
#line 480
    len = len - 1U;
  } else {

  }
#line 482
  if (len > 32U) {
#line 482
    return (-22);
  } else {

  }
#line 483
  __len = (size_t )len;
#line 483
  __ret = __builtin_memcpy((void *)(& buf), (void const   *)ptr, __len);
#line 484
  buf[len] = 0;
#line 485
  tmp___1 = simple_strtol((char const   *)(& buf), & p2, 0U);
#line 485
  *valptr = (int )tmp___1;
#line 486
  if (negfl != 0) {
#line 486
    *valptr = - *valptr;
  } else {

  }
#line 487
  if ((int )((signed char )*p2) != 0) {
#line 487
    return (-22);
  } else {

  }
#line 488
  return (1);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static int parse_mtoken(char const   *ptr , unsigned int len , int *valptr , char const   **names ,
                        int valid_bits ) 
{ 
  char buf[33U] ;
  unsigned int slen ;
  unsigned int idx ;
  char *p2 ;
  int msk ;
  size_t tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  long tmp___1 ;

  {
#line 501
  *valptr = 0;
#line 502
  idx = 0U;
#line 502
  msk = 1;
#line 502
  goto ldv_49879;
  ldv_49878: ;
#line 503
  if ((msk & valid_bits) == 0) {
#line 503
    goto ldv_49877;
  } else {

  }
#line 504
  valid_bits = ~ msk & valid_bits;
#line 505
  if ((unsigned long )*(names + (unsigned long )idx) == (unsigned long )((char const   *)0)) {
#line 505
    goto ldv_49877;
  } else {

  }
#line 506
  tmp = strlen(*(names + (unsigned long )idx));
#line 506
  slen = (unsigned int )tmp;
#line 507
  if (slen != len) {
#line 507
    goto ldv_49877;
  } else {

  }
#line 508
  tmp___0 = memcmp((void const   *)*(names + (unsigned long )idx), (void const   *)ptr,
                   (size_t )slen);
#line 508
  if (tmp___0 != 0) {
#line 508
    goto ldv_49877;
  } else {

  }
#line 509
  *valptr = msk;
#line 510
  return (0);
  ldv_49877: 
#line 502
  idx = idx + 1U;
#line 502
  msk = msk << 1;
  ldv_49879: ;
#line 502
  if (valid_bits != 0) {
#line 504
    goto ldv_49878;
  } else {

  }

#line 512
  if (len > 32U) {
#line 512
    return (-22);
  } else {

  }
#line 513
  __len = (size_t )len;
#line 513
  __ret = __builtin_memcpy((void *)(& buf), (void const   *)ptr, __len);
#line 514
  buf[len] = 0;
#line 515
  tmp___1 = simple_strtol((char const   *)(& buf), & p2, 0U);
#line 515
  *valptr = (int )tmp___1;
#line 516
  if ((int )((signed char )*p2) != 0) {
#line 516
    return (-22);
  } else {

  }
#line 517
  return (0);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
static int parse_tlist(char const   *ptr , unsigned int len , int *maskptr , int *valptr ,
                       char const   **names , int valid_bits ) 
{ 
  unsigned int cnt ;
  int mask ;
  int val ;
  int kv ;
  int mode ;
  int ret ;
  int tmp ;

  {
#line 527
  mask = 0;
#line 528
  val = 0;
#line 529
  ret = 0;
#line 530
  goto ldv_49911;
  ldv_49910: 
#line 531
  cnt = 0U;
#line 532
  goto ldv_49899;
  ldv_49898: 
#line 534
  cnt = cnt + 1U;
  ldv_49899: ;
#line 532
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32 || (int )((signed char )*(ptr + (unsigned long )cnt)) == 127)) {
#line 536
    goto ldv_49898;
  } else {

  }
#line 535
  ptr = ptr + (unsigned long )cnt;
#line 536
  len = len - cnt;
#line 537
  mode = 0;
#line 538
  if ((int )((signed char )*ptr) == 45 || (int )((signed char )*ptr) == 43) {
#line 539
    mode = (int )((signed char )*ptr) == 45 ? -1 : 1;
#line 540
    ptr = ptr + 1;
#line 541
    len = len - 1U;
  } else {

  }
#line 543
  cnt = 0U;
#line 544
  goto ldv_49903;
  ldv_49902: ;
#line 545
  if ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32) {
#line 545
    goto ldv_49901;
  } else {

  }
#line 546
  if ((int )((signed char )*(ptr + (unsigned long )cnt)) == 127) {
#line 546
    goto ldv_49901;
  } else {

  }
#line 547
  cnt = cnt + 1U;
  ldv_49903: ;
#line 544
  if (cnt < len) {
#line 546
    goto ldv_49902;
  } else {

  }
  ldv_49901: ;
#line 549
  if (cnt == 0U) {
#line 549
    goto ldv_49904;
  } else {

  }
#line 550
  tmp = parse_mtoken(ptr, cnt, & kv, names, valid_bits);
#line 550
  if (tmp != 0) {
#line 551
    ret = -22;
#line 552
    goto ldv_49904;
  } else {

  }
#line 554
  ptr = ptr + (unsigned long )cnt;
#line 555
  len = len - cnt;
#line 556
  switch (mode) {
  case 0: 
#line 558
  mask = valid_bits;
#line 559
  val = val | kv;
#line 560
  goto ldv_49906;
  case -1: 
#line 562
  mask = mask | kv;
#line 563
  val = ~ kv & val;
#line 564
  goto ldv_49906;
  case 1: 
#line 566
  mask = mask | kv;
#line 567
  val = val | kv;
#line 568
  goto ldv_49906;
  default: ;
#line 570
  goto ldv_49906;
  }
  ldv_49906: ;
  ldv_49911: ;
#line 530
  if (len != 0U) {
#line 532
    goto ldv_49910;
  } else {

  }
  ldv_49904: 
#line 573
  *maskptr = mask;
#line 574
  *valptr = val;
#line 575
  return (ret);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr , char const   *ptr , unsigned int len ,
                           int *maskptr , int *valptr ) 
{ 
  int ret ;
  unsigned int cnt ;

  {
#line 584
  ret = -22;
#line 587
  *maskptr = 0;
#line 588
  *valptr = 0;
#line 590
  cnt = 0U;
#line 591
  goto ldv_49922;
  ldv_49921: 
#line 591
  cnt = cnt + 1U;
  ldv_49922: ;
#line 591
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32 || (int )((signed char )*(ptr + (unsigned long )cnt)) == 127)) {
#line 593
    goto ldv_49921;
  } else {

  }
#line 592
  len = len - cnt;
#line 592
  ptr = ptr + (unsigned long )cnt;
#line 593
  cnt = 0U;
#line 594
  goto ldv_49925;
  ldv_49924: 
#line 595
  cnt = cnt + 1U;
  ldv_49925: ;
#line 594
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )((len - cnt) - 1U))) <= 32 || (int )((signed char )*(ptr + (unsigned long )((len - cnt) - 1U))) == 127)) {
#line 597
    goto ldv_49924;
  } else {

  }
#line 596
  len = len - cnt;
#line 598
  if (len == 0U) {
#line 598
    return (-22);
  } else {

  }
#line 600
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 600
  (cptr->hdw)->big_lock_held = 1;
#line 601
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 602
    ret = parse_token(ptr, len, valptr, (char const   * const  *)0, 0U);
#line 603
    if (ret >= 0) {
#line 604
      ret = pvr2_ctrl_range_check(cptr, *valptr);
    } else {

    }
#line 606
    *maskptr = -1;
  } else
#line 607
  if ((unsigned int )(cptr->info)->type == 3U) {
#line 608
    ret = parse_token(ptr, len, valptr, (char const   * const  *)(& boolNames), 4U);
#line 610
    if (ret == 1) {
#line 611
      *valptr = *valptr != 0;
    } else
#line 612
    if (ret == 0) {
#line 613
      *valptr = *valptr & 1;
    } else {

    }
#line 615
    *maskptr = 1;
  } else
#line 616
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 617
    ret = parse_token(ptr, len, valptr, (cptr->info)->def.type_enum.value_names, (cptr->info)->def.type_enum.count);
#line 621
    if (ret >= 0) {
#line 622
      ret = pvr2_ctrl_range_check(cptr, *valptr);
    } else {

    }
#line 624
    *maskptr = -1;
  } else
#line 625
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 626
    ret = parse_tlist(ptr, len, maskptr, valptr, (cptr->info)->def.type_bitmask.bit_names,
                      (int )(cptr->info)->def.type_bitmask.valid_bits);
  } else {

  }
#line 631
  (cptr->hdw)->big_lock_held = 0;
#line 631
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 632
  return (ret);
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr , int mask , int val ,
                                    char *buf , unsigned int maxlen , unsigned int *len ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  char const   * const  *names ;
  int tmp___1 ;

  {
#line 642
  ret = -22;
#line 644
  *len = 0U;
#line 645
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 646
    tmp = scnprintf(buf, (size_t )maxlen, "%d", val);
#line 646
    *len = (unsigned int )tmp;
#line 647
    ret = 0;
  } else
#line 648
  if ((unsigned int )(cptr->info)->type == 3U) {
#line 649
    tmp___0 = scnprintf(buf, (size_t )maxlen, "%s", val != 0 ? (char *)"true" : (char *)"false");
#line 649
    *len = (unsigned int )tmp___0;
#line 650
    ret = 0;
  } else
#line 651
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 653
    names = (cptr->info)->def.type_enum.value_names;
#line 654
    if (val >= 0 && (unsigned int )val < (unsigned int )(cptr->info)->def.type_enum.count) {
#line 656
      if ((unsigned long )*(names + (unsigned long )val) != (unsigned long )((char const   */* const  */)0)) {
#line 657
        tmp___1 = scnprintf(buf, (size_t )maxlen, "%s", *(names + (unsigned long )val));
#line 657
        *len = (unsigned int )tmp___1;
      } else {
#line 661
        *len = 0U;
      }
#line 663
      ret = 0;
    } else {

    }
  } else
#line 665
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 666
    *len = gen_bitmask_string((int )((unsigned int )(val & mask) & (unsigned int )(cptr->info)->def.type_bitmask.valid_bits),
                              -1, 1, (cptr->info)->def.type_bitmask.bit_names, buf,
                              maxlen);
  } else {

  }
#line 672
  return (ret);
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                           unsigned int maxlen , unsigned int *len ) 
{ 
  int ret ;

  {
#line 683
  mutex_lock_nested(& (cptr->hdw)->big_lock_mutex, 0U);
#line 683
  (cptr->hdw)->big_lock_held = 1;
#line 684
  ret = pvr2_ctrl_value_to_sym_internal(cptr, mask, val, buf, maxlen, len);
#line 686
  (cptr->hdw)->big_lock_held = 0;
#line 686
  mutex_unlock(& (cptr->hdw)->big_lock_mutex);
#line 687
  return (ret);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void *ldv_kmem_cache_alloc_375(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 820
  ldv_check_alloc_flags(flags);
#line 822
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 823
  return ((void *)0);
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int ldv_pskb_expand_head_381(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 864
  ldv_check_alloc_flags(flags);
#line 866
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 866
  return (tmp);
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv_skb_clone_383(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 880
  ldv_check_alloc_flags(flags);
#line 882
  tmp = skb_clone(ldv_func_arg1, flags);
#line 882
  return (tmp);
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv_skb_copy_385(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 896
  ldv_check_alloc_flags(flags);
#line 898
  tmp = skb_copy(ldv_func_arg1, flags);
#line 898
  return (tmp);
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_386(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 904
  ldv_check_alloc_flags(flags);
#line 906
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 906
  return (tmp);
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 912
  ldv_check_alloc_flags(flags);
#line 914
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 914
  return (tmp);
}
}
#line 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 920
  ldv_check_alloc_flags(flags);
#line 922
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 922
  return (tmp);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int ldv_pskb_expand_head_389(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 928
  ldv_check_alloc_flags(flags);
#line 930
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 930
  return (tmp);
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int ldv_pskb_expand_head_390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 936
  ldv_check_alloc_flags(flags);
#line 938
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 938
  return (tmp);
}
}
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
struct sk_buff *ldv_skb_clone_391(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 944
  ldv_check_alloc_flags(flags);
#line 946
  tmp = skb_clone(ldv_func_arg1, flags);
#line 946
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_417(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-std.h"
struct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr , v4l2_std_id id ) ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static struct std_name  const  std_groups[4U]  = {      {"PAL", 4095ULL}, 
        {"NTSC", 61440ULL}, 
        {"SECAM", 16711680ULL}, 
        {"ATSC", 50331648ULL}};
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static struct std_name  const  std_items[20U]  = 
#line 182
  {      {"B", 65537ULL}, 
        {"B1", 2ULL}, 
        {"D", 131104ULL}, 
        {"D1", 64ULL}, 
        {"G", 262148ULL}, 
        {"H", 524296ULL}, 
        {"I", 16ULL}, 
        {"K", 1048704ULL}, 
        {"K1", 2097152ULL}, 
        {"L", 4194304ULL}, 
        {"LC", 8388608ULL}, 
        {"M", 4352ULL}, 
        {"Mj", 8192ULL}, 
        {"443", 16384ULL}, 
        {"Mk", 32768ULL}, 
        {"N", 512ULL}, 
        {"Nc", 1024ULL}, 
        {"60", 2048ULL}, 
        {"8VSB", 16777216ULL}, 
        {"16VSB", 33554432ULL}};
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static struct std_name  const  *find_std_name(struct std_name  const  *arrPtr , unsigned int arrSize ,
                                              char const   *bufPtr , unsigned int bufSize ) 
{ 
  unsigned int idx ;
  struct std_name  const  *p ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 215
  idx = 0U;
#line 215
  goto ldv_17228;
  ldv_17227: 
#line 216
  p = arrPtr + (unsigned long )idx;
#line 217
  tmp = strlen(p->name);
#line 217
  if (tmp != (size_t )bufSize) {
#line 217
    goto ldv_17226;
  } else {

  }
#line 218
  tmp___0 = memcmp((void const   *)bufPtr, (void const   *)p->name, (size_t )bufSize);
#line 218
  if (tmp___0 == 0) {
#line 218
    return (p);
  } else {

  }
  ldv_17226: 
#line 215
  idx = idx + 1U;
  ldv_17228: ;
#line 215
  if (idx < arrSize) {
#line 217
    goto ldv_17227;
  } else {

  }

#line 220
  return ((struct std_name  const  *)0);
}
}
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
int pvr2_std_str_to_id(v4l2_std_id *idPtr , char const   *bufPtr , unsigned int bufSize ) 
{ 
  v4l2_std_id id ;
  v4l2_std_id cmsk ;
  v4l2_std_id t ;
  int mMode ;
  unsigned int cnt ;
  char ch ;
  struct std_name  const  *sp ;

  {
#line 227
  id = 0ULL;
#line 228
  cmsk = 0ULL;
#line 230
  mMode = 0;
#line 235
  goto ldv_17247;
  ldv_17253: ;
#line 236
  if (mMode == 0) {
#line 237
    cnt = 0U;
#line 238
    goto ldv_17243;
    ldv_17242: 
#line 238
    cnt = cnt + 1U;
    ldv_17243: ;
#line 238
    if (cnt < bufSize && (int )((signed char )*(bufPtr + (unsigned long )cnt)) != 45) {
#line 240
      goto ldv_17242;
    } else {

    }

#line 239
    if (cnt >= bufSize) {
#line 239
      return (0);
    } else {

    }
#line 240
    sp = find_std_name((struct std_name  const  *)(& std_groups), 4U, bufPtr, cnt);
#line 242
    if ((unsigned long )sp == (unsigned long )((struct std_name  const  *)0)) {
#line 242
      return (0);
    } else {

    }
#line 243
    cnt = cnt + 1U;
#line 244
    bufPtr = bufPtr + (unsigned long )cnt;
#line 245
    bufSize = bufSize - cnt;
#line 246
    mMode = 1;
#line 247
    cmsk = sp->id;
#line 248
    goto ldv_17247;
  } else {

  }
#line 250
  cnt = 0U;
#line 251
  goto ldv_17250;
  ldv_17249: 
#line 252
  ch = *(bufPtr + (unsigned long )cnt);
#line 253
  if ((int )((signed char )ch) == 59) {
#line 254
    mMode = 0;
#line 255
    goto ldv_17248;
  } else {

  }
#line 257
  if ((int )((signed char )ch) == 47) {
#line 257
    goto ldv_17248;
  } else {

  }
#line 258
  cnt = cnt + 1U;
  ldv_17250: ;
#line 251
  if (cnt < bufSize) {
#line 253
    goto ldv_17249;
  } else {

  }
  ldv_17248: 
#line 260
  sp = find_std_name((struct std_name  const  *)(& std_items), 20U, bufPtr, cnt);
#line 262
  if ((unsigned long )sp == (unsigned long )((struct std_name  const  *)0)) {
#line 262
    return (0);
  } else {

  }
#line 263
  t = (unsigned long long )sp->id & cmsk;
#line 264
  if (t == 0ULL) {
#line 264
    return (0);
  } else {

  }
#line 265
  id = id | t;
#line 266
  if (cnt < bufSize) {
#line 266
    cnt = cnt + 1U;
  } else {

  }
#line 267
  bufPtr = bufPtr + (unsigned long )cnt;
#line 268
  bufSize = bufSize - cnt;
  ldv_17247: ;
#line 235
  if (bufSize != 0U) {
#line 237
    goto ldv_17253;
  } else {

  }

#line 271
  if ((unsigned long )idPtr != (unsigned long )((v4l2_std_id *)0ULL)) {
#line 271
    *idPtr = id;
  } else {

  }
#line 272
  return (1);
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
unsigned int pvr2_std_id_to_str(char *bufPtr , unsigned int bufSize , v4l2_std_id id ) 
{ 
  unsigned int idx1 ;
  unsigned int idx2 ;
  struct std_name  const  *ip ;
  struct std_name  const  *gp ;
  int gfl ;
  int cfl ;
  unsigned int c1 ;
  unsigned int c2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  cfl = 0;
#line 284
  c1 = 0U;
#line 285
  idx1 = 0U;
#line 285
  goto ldv_17277;
  ldv_17276: 
#line 286
  gp = (struct std_name  const  *)(& std_groups) + (unsigned long )idx1;
#line 287
  gfl = 0;
#line 288
  idx2 = 0U;
#line 288
  goto ldv_17274;
  ldv_17273: 
#line 289
  ip = (struct std_name  const  *)(& std_items) + (unsigned long )idx2;
#line 290
  if ((((unsigned long long )gp->id & (unsigned long long )ip->id) & id) == 0ULL) {
#line 290
    goto ldv_17272;
  } else {

  }
#line 291
  if (gfl == 0) {
#line 292
    if (cfl != 0) {
#line 293
      tmp = scnprintf(bufPtr, (size_t )bufSize, ";");
#line 293
      c2 = (unsigned int )tmp;
#line 294
      c1 = c1 + c2;
#line 295
      bufSize = bufSize - c2;
#line 296
      bufPtr = bufPtr + (unsigned long )c2;
    } else {

    }
#line 298
    cfl = 1;
#line 299
    tmp___0 = scnprintf(bufPtr, (size_t )bufSize, "%s-", gp->name);
#line 299
    c2 = (unsigned int )tmp___0;
#line 301
    gfl = 1;
  } else {
#line 303
    tmp___1 = scnprintf(bufPtr, (size_t )bufSize, "/");
#line 303
    c2 = (unsigned int )tmp___1;
  }
#line 305
  c1 = c1 + c2;
#line 306
  bufSize = bufSize - c2;
#line 307
  bufPtr = bufPtr + (unsigned long )c2;
#line 308
  tmp___2 = scnprintf(bufPtr, (size_t )bufSize, ip->name);
#line 308
  c2 = (unsigned int )tmp___2;
#line 310
  c1 = c1 + c2;
#line 311
  bufSize = bufSize - c2;
#line 312
  bufPtr = bufPtr + (unsigned long )c2;
  ldv_17272: 
#line 288
  idx2 = idx2 + 1U;
  ldv_17274: ;
#line 288
  if (idx2 <= 19U) {
#line 290
    goto ldv_17273;
  } else {

  }
#line 285
  idx1 = idx1 + 1U;
  ldv_17277: ;
#line 285
  if (idx1 <= 3U) {
#line 287
    goto ldv_17276;
  } else {

  }

#line 315
  return (c1);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static struct v4l2_standard generic_standards[4U]  = {      {0U, 16713471ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1U, 25U}, 625U, {0U, 0U, 0U, 0U}}, 
        {0U, 45312ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}, 
        {0U, 2048ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}, 
        {0U, 16384ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}};
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static struct v4l2_standard *match_std(v4l2_std_id id ) 
{ 
  unsigned int idx ;

  {
#line 374
  idx = 0U;
#line 374
  goto ldv_17287;
  ldv_17286: ;
#line 375
  if ((generic_standards[idx].id & id) != 0ULL) {
#line 376
    return ((struct v4l2_standard *)(& generic_standards) + (unsigned long )idx);
  } else {

  }
#line 374
  idx = idx + 1U;
  ldv_17287: ;
#line 374
  if (idx <= 3U) {
#line 376
    goto ldv_17286;
  } else {

  }

#line 379
  return ((struct v4l2_standard *)0);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static int pvr2_std_fill(struct v4l2_standard *std , v4l2_std_id id ) 
{ 
  struct v4l2_standard *template ;
  int idx ;
  unsigned int bcnt ;
  size_t __len ;
  void *__ret ;

  {
#line 387
  template = match_std(id);
#line 388
  if ((unsigned long )template == (unsigned long )((struct v4l2_standard *)0)) {
#line 388
    return (0);
  } else {

  }
#line 389
  idx = (int )std->index;
#line 390
  __len = 72UL;
#line 390
  if (__len > 63UL) {
#line 390
    __ret = __memcpy((void *)std, (void const   *)template, __len);
  } else {
#line 390
    __ret = __builtin_memcpy((void *)std, (void const   *)template, __len);
  }
#line 391
  std->index = (__u32 )idx;
#line 392
  std->id = id;
#line 393
  bcnt = pvr2_std_id_to_str((char *)(& std->name), 23U, id);
#line 394
  std->name[bcnt] = 0U;
#line 395
  if ((pvrusb2_debug & 16) != 0) {
#line 395
    printk("\016pvrusb2: Set up standard idx=%u name=%s\n", std->index, (__u8 *)(& std->name));
  } else {

  }
#line 397
  return (1);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
static v4l2_std_id std_mixes[4U]  = {      5ULL,      160ULL,      327680ULL,      1179648ULL};
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
struct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr , v4l2_std_id id ) 
{ 
  unsigned int std_cnt ;
  unsigned int idx ;
  unsigned int bcnt ;
  unsigned int idx2 ;
  v4l2_std_id idmsk ;
  v4l2_std_id cmsk ;
  v4l2_std_id fmsk ;
  struct v4l2_standard *stddefs ;
  char buf[100U] ;
  struct v4l2_standard *tmp ;
  char buf___0[100U] ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 412
  std_cnt = 0U;
#line 417
  if ((pvrusb2_debug & 16) != 0) {
#line 419
    bcnt = pvr2_std_id_to_str((char *)(& buf), 100U, id);
#line 420
    if ((pvrusb2_debug & 16) != 0) {
#line 420
      printk("\016pvrusb2: Mapping standards mask=0x%x (%.*s)\n", (int )id, bcnt,
             (char *)(& buf));
    } else {

    }
  } else {

  }
#line 425
  *countptr = 0U;
#line 426
  std_cnt = 0U;
#line 427
  fmsk = 0ULL;
#line 428
  idmsk = 1ULL;
#line 428
  cmsk = id;
#line 428
  goto ldv_17315;
  ldv_17314: ;
#line 429
  if ((idmsk & cmsk) == 0ULL) {
#line 429
    goto ldv_17313;
  } else {

  }
#line 430
  cmsk = ~ idmsk & cmsk;
#line 431
  tmp = match_std(idmsk);
#line 431
  if ((unsigned long )tmp != (unsigned long )((struct v4l2_standard *)0)) {
#line 432
    std_cnt = std_cnt + 1U;
#line 433
    goto ldv_17313;
  } else {

  }
#line 435
  fmsk = fmsk | idmsk;
  ldv_17313: 
#line 428
  idmsk = idmsk << 1;
  ldv_17315: ;
#line 428
  if (cmsk != 0ULL) {
#line 430
    goto ldv_17314;
  } else {

  }
#line 438
  idx2 = 0U;
#line 438
  goto ldv_17320;
  ldv_17319: ;
#line 439
  if ((std_mixes[idx2] & id) == std_mixes[idx2]) {
#line 439
    std_cnt = std_cnt + 1U;
  } else {

  }
#line 438
  idx2 = idx2 + 1U;
  ldv_17320: ;
#line 438
  if (idx2 <= 3U) {
#line 440
    goto ldv_17319;
  } else {

  }
#line 443
  fmsk = fmsk & 0xfffffffffcffffffULL;
#line 445
  if (fmsk != 0ULL) {
#line 447
    bcnt = pvr2_std_id_to_str((char *)(& buf___0), 100U, fmsk);
#line 448
    if ((pvrusb2_debug & 2) != 0) {
#line 448
      printk("\016pvrusb2: WARNING: Failed to classify the following standard(s): %.*s\n",
             bcnt, (char *)(& buf___0));
    } else {

    }
  } else {

  }
#line 455
  if ((pvrusb2_debug & 16) != 0) {
#line 455
    printk("\016pvrusb2: Setting up %u unique standard(s)\n", std_cnt);
  } else {

  }
#line 457
  if (std_cnt == 0U) {
#line 457
    return ((struct v4l2_standard *)0);
  } else {

  }
#line 459
  tmp___0 = kzalloc((unsigned long )std_cnt * 72UL, 208U);
#line 459
  stddefs = (struct v4l2_standard *)tmp___0;
#line 461
  if ((unsigned long )stddefs == (unsigned long )((struct v4l2_standard *)0)) {
#line 462
    return ((struct v4l2_standard *)0);
  } else {

  }
#line 464
  idx = 0U;
#line 464
  goto ldv_17324;
  ldv_17323: 
#line 465
  (stddefs + (unsigned long )idx)->index = idx;
#line 464
  idx = idx + 1U;
  ldv_17324: ;
#line 464
  if (idx < std_cnt) {
#line 466
    goto ldv_17323;
  } else {

  }
#line 467
  idx = 0U;
#line 470
  idx2 = 0U;
#line 470
  goto ldv_17330;
  ldv_17329: ;
#line 472
  if ((std_mixes[idx2] & id) == 0ULL) {
#line 472
    goto ldv_17328;
  } else {

  }
#line 473
  tmp___1 = pvr2_std_fill(stddefs + (unsigned long )idx, std_mixes[idx2]);
#line 473
  if (tmp___1 != 0) {
#line 473
    idx = idx + 1U;
  } else {

  }
  ldv_17328: 
#line 471
  idx2 = idx2 + 1U;
  ldv_17330: ;
#line 470
  if (idx2 <= 3U && idx < std_cnt) {
#line 472
    goto ldv_17329;
  } else {

  }
#line 476
  idmsk = 1ULL;
#line 476
  cmsk = id;
#line 476
  goto ldv_17334;
  ldv_17333: ;
#line 477
  if ((idmsk & cmsk) == 0ULL) {
#line 477
    goto ldv_17332;
  } else {

  }
#line 478
  cmsk = ~ idmsk & cmsk;
#line 479
  tmp___2 = pvr2_std_fill(stddefs + (unsigned long )idx, idmsk);
#line 479
  if (tmp___2 == 0) {
#line 479
    goto ldv_17332;
  } else {

  }
#line 480
  idx = idx + 1U;
  ldv_17332: 
#line 476
  idmsk = idmsk << 1;
  ldv_17334: ;
#line 476
  if (cmsk != 0ULL && idx < std_cnt) {
#line 478
    goto ldv_17333;
  } else {

  }
#line 483
  *countptr = std_cnt;
#line 484
  return (stddefs);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
v4l2_std_id pvr2_std_get_usable(void) 
{ 


  {
#line 489
  return (67108863ULL);
}
}
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
void *ldv_kmem_cache_alloc_417(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 622
  ldv_check_alloc_flags(flags);
#line 624
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 625
  return ((void *)0);
}
}
#line 195 "include/linux/module.h"
extern void *__symbol_get(char const   * ) ;
#line 455
extern void __symbol_put(char const   * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_436(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_444(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_446(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_442(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_451(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_447(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_448(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_449(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_29xxx[4U]  = {      {3U, 0}, 
        {1U, 0}, 
        {4U, 0}, 
        {7U, 0}};
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static char const   *pvr2_fw1_names_29xxx[1U]  = {      "v4l-pvrusb2-29xxx-01.fw"};
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_29xxx  = 
#line 152
     {"WinTV PVR USB2 Model 29xxx", "29xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_29xxx),
                                                     4U}, {(char const   **)(& pvr2_fw1_names_29xxx),
                                                           1U}, 0, 0ULL, 0, 0U, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 4U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_24xxx[4U]  = {      {2U, 0}, 
        {4U, 0}, 
        {6U, 0}, 
        {7U, 0}};
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static char const   *pvr2_fw1_names_24xxx[1U]  = {      "v4l-pvrusb2-24xxx-01.fw"};
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_24xxx  = 
#line 186
     {"WinTV PVR USB2 Model 24xxx", "24xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_24xxx),
                                                     4U}, {(char const   **)(& pvr2_fw1_names_24xxx),
                                                           1U}, 0, 0ULL, 0, 0U, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, 1U,
    1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_gotview_2[3U]  = {      {2U, 0}, 
        {4U, 0}, 
        {7U, 0}};
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_gotview_2  = 
#line 216
     {"Gotview USB 2.0 DVD 2", "gv2", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_gotview_2),
                                              3U}, {0, 0U}, 0, 0ULL, 38, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_gotview_2d  = 
#line 237
     {"Gotview USB 2.0 DVD Deluxe", "gv2d", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_gotview_2),
                                                    3U}, {0, 0U}, 0, 0ULL, 38, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
    1U, 1U, (unsigned char)0, (unsigned char)0};
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_av400[1U]  = {      {2U, 0}};
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_av400  = 
#line 259
     {"Terratec Grabster AV400", "av400", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_av400),
                                                  1U}, {0, 0U}, 0, 0ULL, 0, 3U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 1U, 1U, (unsigned char)0,
    1U};
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct lgdt330x_config pvr2_lgdt3303_config  =    {14U, 2, 0, 0, 0, 1};
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_lgdt3303_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 286
  __r = (void *)0;
#line 286
  tmp___2 = __symbol_get("lgdt330x_attach");
#line 286
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 286
  if (tmp___1) {

  } else {
#line 286
    __request_module(1, "symbol:lgdt330x_attach");
#line 286
    tmp___0 = __symbol_get("lgdt330x_attach");
#line 286
    tmp___1 = (struct dvb_frontend *(*)(struct lgdt330x_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 286
  __a = tmp___1;
#line 286
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 286
    tmp___3 = (*__a)((struct lgdt330x_config  const  *)(& pvr2_lgdt3303_config), & (adap->channel.hdw)->i2c_adap);
#line 286
    __r = (void *)tmp___3;
#line 286
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 286
      __symbol_put("lgdt330x_attach");
    } else {

    }
  } else {
#line 286
    printk("\vDVB: Unable to find symbol lgdt330x_attach()\n");
  }
#line 286
  adap->fe = (struct dvb_frontend *)__r;
#line 288
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 289
    return (0);
  } else {

  }
#line 291
  return (-5);
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_lgh06xf_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              unsigned int  ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  unsigned int  ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 296
  __r = (void *)0;
#line 296
  tmp___2 = __symbol_get("simple_tuner_attach");
#line 296
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , unsigned int  ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                    struct i2c_adapter * ,
                                                                                                                                    u8  ,
                                                                                                                                    unsigned int  ))0);
#line 296
  if (tmp___1) {

  } else {
#line 296
    __request_module(1, "symbol:simple_tuner_attach");
#line 296
    tmp___0 = __symbol_get("simple_tuner_attach");
#line 296
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , unsigned int  ))tmp___0;
  }
#line 296
  __a = tmp___1;
#line 296
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , unsigned int  ))0)) {
#line 296
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 97, 64U);
#line 296
    __r = (void *)tmp___3;
#line 296
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 296
      __symbol_put("simple_tuner_attach");
    } else {

    }
  } else {
#line 296
    printk("\vDVB: Unable to find symbol simple_tuner_attach()\n");
  }
#line 300
  return (0);
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_dvb_props  const  pvr2_onair_creator_fe_props  =    {& pvr2_lgdt3303_attach, & pvr2_lgh06xf_attach};
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_onair_creator[3U]  = {      {3U, 0}, 
        {5U, 0}, 
        {4U, 0}};
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_onair_creator  = 
#line 315
     {"OnAir Creator Hybrid USB tuner", "oac", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_onair_creator),
                                                       3U}, {0, 0U}, & pvr2_onair_creator_fe_props,
    4096ULL, 64, 2U, (unsigned char)0, 2U, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct lgdt330x_config pvr2_lgdt3302_config  =    {14U, 1, 0, 0, 0, 0};
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_lgdt3302_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 346
  __r = (void *)0;
#line 346
  tmp___2 = __symbol_get("lgdt330x_attach");
#line 346
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 346
  if (tmp___1) {

  } else {
#line 346
    __request_module(1, "symbol:lgdt330x_attach");
#line 346
    tmp___0 = __symbol_get("lgdt330x_attach");
#line 346
    tmp___1 = (struct dvb_frontend *(*)(struct lgdt330x_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 346
  __a = tmp___1;
#line 346
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 346
    tmp___3 = (*__a)((struct lgdt330x_config  const  *)(& pvr2_lgdt3302_config), & (adap->channel.hdw)->i2c_adap);
#line 346
    __r = (void *)tmp___3;
#line 346
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 346
      __symbol_put("lgdt330x_attach");
    } else {

    }
  } else {
#line 346
    printk("\vDVB: Unable to find symbol lgdt330x_attach()\n");
  }
#line 346
  adap->fe = (struct dvb_frontend *)__r;
#line 348
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 349
    return (0);
  } else {

  }
#line 351
  return (-5);
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_fcv1236d_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              unsigned int  ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  unsigned int  ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 356
  __r = (void *)0;
#line 356
  tmp___2 = __symbol_get("simple_tuner_attach");
#line 356
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , unsigned int  ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                    struct i2c_adapter * ,
                                                                                                                                    u8  ,
                                                                                                                                    unsigned int  ))0);
#line 356
  if (tmp___1) {

  } else {
#line 356
    __request_module(1, "symbol:simple_tuner_attach");
#line 356
    tmp___0 = __symbol_get("simple_tuner_attach");
#line 356
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , unsigned int  ))tmp___0;
  }
#line 356
  __a = tmp___1;
#line 356
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , unsigned int  ))0)) {
#line 356
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 97, 42U);
#line 356
    __r = (void *)tmp___3;
#line 356
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 356
      __symbol_put("simple_tuner_attach");
    } else {

    }
  } else {
#line 356
    printk("\vDVB: Unable to find symbol simple_tuner_attach()\n");
  }
#line 360
  return (0);
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_dvb_props  const  pvr2_onair_usb2_fe_props  =    {& pvr2_lgdt3302_attach, & pvr2_fcv1236d_attach};
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_onair_usb2[3U]  = {      {3U, 0}, 
        {5U, 0}, 
        {4U, 0}};
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_onair_usb2  = 
#line 375
     {"OnAir USB2 Hybrid USB tuner", "oa2", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_onair_usb2),
                                                    3U}, {0, 0U}, & pvr2_onair_usb2_fe_props,
    4096ULL, 42, 2U, (unsigned char)0, 2U, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda10048_config hauppauge_tda10048_config  = 
#line 399
     {8U, 0U, 50U, 1U, 3300U, 3800U, 4300U, 16000U, 1U, (_Bool)0, (_Bool)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda829x_config tda829x_no_probe  =    {0, 1U, (unsigned char)0, 0};
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda18271_std_map hauppauge_tda18271_dvbt_std_map  = 
#line 415
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {3300U, 3U, 4U, (unsigned char)0, 1U, 55U}, {3800U, 3U, 5U, (unsigned char)0,
                                                 1U, 55U}, {4300U, 3U, 6U, (unsigned char)0,
                                                            1U, 55U}, {(unsigned short)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}};
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda18271_config hauppauge_tda18271_dvb_config  = 
#line 424
     {& hauppauge_tda18271_dvbt_std_map, 0, 1, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_tda10048_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 432
  __r = (void *)0;
#line 432
  tmp___2 = __symbol_get("tda10048_attach");
#line 432
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 432
  if (tmp___1) {

  } else {
#line 432
    __request_module(1, "symbol:tda10048_attach");
#line 432
    tmp___0 = __symbol_get("tda10048_attach");
#line 432
    tmp___1 = (struct dvb_frontend *(*)(struct tda10048_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 432
  __a = tmp___1;
#line 432
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 432
    tmp___3 = (*__a)((struct tda10048_config  const  *)(& hauppauge_tda10048_config),
                     & (adap->channel.hdw)->i2c_adap);
#line 432
    __r = (void *)tmp___3;
#line 432
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 432
      __symbol_put("tda10048_attach");
    } else {

    }
  } else {
#line 432
    printk("\vDVB: Unable to find symbol tda10048_attach()\n");
  }
#line 432
  adap->fe = (struct dvb_frontend *)__r;
#line 434
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 435
    return (0);
  } else {

  }
#line 437
  return (-5);
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_73xxx_tda18271_8295_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              struct tda829x_config * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  struct tda829x_config * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;

  {
#line 442
  __r = (void *)0;
#line 442
  tmp___2 = __symbol_get("tda829x_attach");
#line 442
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , struct tda829x_config * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                              struct i2c_adapter * ,
                                                                                                                                              u8  ,
                                                                                                                                              struct tda829x_config * ))0);
#line 442
  if (tmp___1) {

  } else {
#line 442
    __request_module(1, "symbol:tda829x_attach");
#line 442
    tmp___0 = __symbol_get("tda829x_attach");
#line 442
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , struct tda829x_config * ))tmp___0;
  }
#line 442
  __a = tmp___1;
#line 442
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , struct tda829x_config * ))0)) {
#line 442
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 66, & tda829x_no_probe);
#line 442
    __r = (void *)tmp___3;
#line 442
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 442
      __symbol_put("tda829x_attach");
    } else {

    }
  } else {
#line 442
    printk("\vDVB: Unable to find symbol tda829x_attach()\n");
  }
#line 445
  __r___0 = (void *)0;
#line 445
  tmp___7 = __symbol_get("tda18271_attach");
#line 445
  tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , u8  ,
                                                       struct i2c_adapter * , struct tda18271_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                                                u8  ,
                                                                                                                                                                struct i2c_adapter * ,
                                                                                                                                                                struct tda18271_config * ))0);
#line 445
  if (tmp___6) {

  } else {
#line 445
    __request_module(1, "symbol:tda18271_attach");
#line 445
    tmp___5 = __symbol_get("tda18271_attach");
#line 445
    tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                        struct tda18271_config * ))tmp___5;
  }
#line 445
  __a___0 = tmp___6;
#line 445
  if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                            u8  ,
                                                                            struct i2c_adapter * ,
                                                                            struct tda18271_config * ))0)) {
#line 445
    tmp___8 = (*__a___0)(adap->fe, 96, & (adap->channel.hdw)->i2c_adap, & hauppauge_tda18271_dvb_config);
#line 445
    __r___0 = (void *)tmp___8;
#line 445
    if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 445
      __symbol_put("tda18271_attach");
    } else {

    }
  } else {
#line 445
    printk("\vDVB: Unable to find symbol tda18271_attach()\n");
  }
#line 449
  return (0);
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_dvb_props  const  pvr2_73xxx_dvb_props  =    {& pvr2_tda10048_attach, & pvr2_73xxx_tda18271_8295_attach};
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_client_desc  const  pvr2_cli_73xxx[2U]  = {      {2U, 0}, 
        {4U, (unsigned char *)"B"}};
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static char const   *pvr2_fw1_names_73xxx[1U]  = {      "v4l-pvrusb2-73xxx-01.fw"};
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_73xxx  = 
#line 469
     {"WinTV HVR-1900 Model 73xxx", "73xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_73xxx),
                                                           1U}, & pvr2_73xxx_dvb_props,
    0ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct s5h1409_config pvr2_s5h1409_config  = 
#line 497
     {25U, 0U, 0U, 4000U, 1U, 1U, (unsigned short)0, (unsigned char)0};
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct s5h1411_config pvr2_s5h1411_config  =    {0U, 0U, (unsigned short)0, 4000U, 44000U, 1U, 1U};
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda18271_std_map hauppauge_tda18271_std_map  = 
#line 515
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {5380U, 3U, 3U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {4000U, 3U, 0U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct tda18271_config hauppauge_tda18271_config  = 
#line 522
     {& hauppauge_tda18271_std_map, 0, 1, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_s5h1409_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 530
  __r = (void *)0;
#line 530
  tmp___2 = __symbol_get("s5h1409_attach");
#line 530
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 530
  if (tmp___1) {

  } else {
#line 530
    __request_module(1, "symbol:s5h1409_attach");
#line 530
    tmp___0 = __symbol_get("s5h1409_attach");
#line 530
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1409_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 530
  __a = tmp___1;
#line 530
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 530
    tmp___3 = (*__a)((struct s5h1409_config  const  *)(& pvr2_s5h1409_config), & (adap->channel.hdw)->i2c_adap);
#line 530
    __r = (void *)tmp___3;
#line 530
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 530
      __symbol_put("s5h1409_attach");
    } else {

    }
  } else {
#line 530
    printk("\vDVB: Unable to find symbol s5h1409_attach()\n");
  }
#line 530
  adap->fe = (struct dvb_frontend *)__r;
#line 532
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 533
    return (0);
  } else {

  }
#line 535
  return (-5);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_s5h1411_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 540
  __r = (void *)0;
#line 540
  tmp___2 = __symbol_get("s5h1411_attach");
#line 540
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 540
  if (tmp___1) {

  } else {
#line 540
    __request_module(1, "symbol:s5h1411_attach");
#line 540
    tmp___0 = __symbol_get("s5h1411_attach");
#line 540
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1411_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 540
  __a = tmp___1;
#line 540
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 540
    tmp___3 = (*__a)((struct s5h1411_config  const  *)(& pvr2_s5h1411_config), & (adap->channel.hdw)->i2c_adap);
#line 540
    __r = (void *)tmp___3;
#line 540
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 540
      __symbol_put("s5h1411_attach");
    } else {

    }
  } else {
#line 540
    printk("\vDVB: Unable to find symbol s5h1411_attach()\n");
  }
#line 540
  adap->fe = (struct dvb_frontend *)__r;
#line 542
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 543
    return (0);
  } else {

  }
#line 545
  return (-5);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static int pvr2_tda18271_8295_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              struct tda829x_config * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  struct tda829x_config * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;

  {
#line 550
  __r = (void *)0;
#line 550
  tmp___2 = __symbol_get("tda829x_attach");
#line 550
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , struct tda829x_config * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                              struct i2c_adapter * ,
                                                                                                                                              u8  ,
                                                                                                                                              struct tda829x_config * ))0);
#line 550
  if (tmp___1) {

  } else {
#line 550
    __request_module(1, "symbol:tda829x_attach");
#line 550
    tmp___0 = __symbol_get("tda829x_attach");
#line 550
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , struct tda829x_config * ))tmp___0;
  }
#line 550
  __a = tmp___1;
#line 550
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , struct tda829x_config * ))0)) {
#line 550
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 66, & tda829x_no_probe);
#line 550
    __r = (void *)tmp___3;
#line 550
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 550
      __symbol_put("tda829x_attach");
    } else {

    }
  } else {
#line 550
    printk("\vDVB: Unable to find symbol tda829x_attach()\n");
  }
#line 553
  __r___0 = (void *)0;
#line 553
  tmp___7 = __symbol_get("tda18271_attach");
#line 553
  tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , u8  ,
                                                       struct i2c_adapter * , struct tda18271_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                                                u8  ,
                                                                                                                                                                struct i2c_adapter * ,
                                                                                                                                                                struct tda18271_config * ))0);
#line 553
  if (tmp___6) {

  } else {
#line 553
    __request_module(1, "symbol:tda18271_attach");
#line 553
    tmp___5 = __symbol_get("tda18271_attach");
#line 553
    tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                        struct tda18271_config * ))tmp___5;
  }
#line 553
  __a___0 = tmp___6;
#line 553
  if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                            u8  ,
                                                                            struct i2c_adapter * ,
                                                                            struct tda18271_config * ))0)) {
#line 553
    tmp___8 = (*__a___0)(adap->fe, 96, & (adap->channel.hdw)->i2c_adap, & hauppauge_tda18271_config);
#line 553
    __r___0 = (void *)tmp___8;
#line 553
    if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 553
      __symbol_put("tda18271_attach");
    } else {

    }
  } else {
#line 553
    printk("\vDVB: Unable to find symbol tda18271_attach()\n");
  }
#line 557
  return (0);
}
}
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_dvb_props  const  pvr2_750xx_dvb_props  =    {& pvr2_s5h1409_attach, & pvr2_tda18271_8295_attach};
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_dvb_props  const  pvr2_751xx_dvb_props  =    {& pvr2_s5h1411_attach, & pvr2_tda18271_8295_attach};
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static char const   *pvr2_fw1_names_75xxx[1U]  = {      "v4l-pvrusb2-73xxx-01.fw"};
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_750xx  = 
#line 576
     {"WinTV HVR-1950 Model 750xx", "750xx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_75xxx),
                                                           1U}, & pvr2_750xx_dvb_props,
    4096ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
static struct pvr2_device_desc  const  pvr2_device_751xx  = 
#line 599
     {"WinTV HVR-1950 Model 751xx", "751xx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_75xxx),
                                                           1U}, & pvr2_751xx_dvb_props,
    4096ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct usb_device_id pvr2_device_table[12U]  = 
#line 626
  {      {3U, 8256U, 10496U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_29xxx)}, 
        {3U, 8256U, 10576U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_29xxx)}, 
        {3U, 8256U, 9216U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_24xxx)}, 
        {3U, 4452U, 1570U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_gotview_2)}, 
        {3U, 4452U, 1538U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_gotview_2d)}, 
        {3U, 4538U, 4099U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_onair_creator)}, 
        {3U, 4538U, 4097U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_onair_usb2)}, 
        {3U, 8256U, 29440U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_73xxx)}, 
        {3U, 8256U, 29952U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_750xx)}, 
        {3U, 8256U, 29953U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_751xx)}, 
        {3U, 3277U, 57U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_av400)}};
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct usb_device_id  const  __mod_usb__pvr2_device_table_device_table  ;
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_10(void) 
{ 
  void *tmp ;

  {
#line 670
  tmp = ldv_zalloc(2624UL);
#line 670
  pvr2_onair_creator_fe_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 671
  return;
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_7(void) 
{ 
  void *tmp ;

  {
#line 674
  tmp = ldv_zalloc(2624UL);
#line 674
  pvr2_750xx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 675
  return;
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_9(void) 
{ 
  void *tmp ;

  {
#line 678
  tmp = ldv_zalloc(2624UL);
#line 678
  pvr2_onair_usb2_fe_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 679
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_8(void) 
{ 
  void *tmp ;

  {
#line 682
  tmp = ldv_zalloc(2624UL);
#line 682
  pvr2_73xxx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 683
  return;
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_6(void) 
{ 
  void *tmp ;

  {
#line 686
  tmp = ldv_zalloc(2624UL);
#line 686
  pvr2_751xx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 687
  return;
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  int tmp ;

  {
#line 691
  tmp = __VERIFIER_nondet_int();
#line 691
  switch (tmp) {
  case 0: ;
#line 694
  if (ldv_state_variable_8 == 1) {
#line 696
    pvr2_73xxx_tda18271_8295_attach(pvr2_73xxx_dvb_props_group0);
#line 698
    ldv_state_variable_8 = 1;
  } else {

  }
#line 701
  goto ldv_50064;
  case 1: ;
#line 704
  if (ldv_state_variable_8 == 1) {
#line 706
    pvr2_tda10048_attach(pvr2_73xxx_dvb_props_group0);
#line 708
    ldv_state_variable_8 = 1;
  } else {

  }
#line 711
  goto ldv_50064;
  default: 
#line 712
  ldv_stop();
  }
  ldv_50064: ;
#line 716
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  int tmp ;

  {
#line 720
  tmp = __VERIFIER_nondet_int();
#line 720
  switch (tmp) {
  case 0: ;
#line 723
  if (ldv_state_variable_6 == 1) {
#line 725
    pvr2_tda18271_8295_attach(pvr2_751xx_dvb_props_group0);
#line 727
    ldv_state_variable_6 = 1;
  } else {

  }
#line 730
  goto ldv_50071;
  case 1: ;
#line 733
  if (ldv_state_variable_6 == 1) {
#line 735
    pvr2_s5h1411_attach(pvr2_751xx_dvb_props_group0);
#line 737
    ldv_state_variable_6 = 1;
  } else {

  }
#line 740
  goto ldv_50071;
  default: 
#line 741
  ldv_stop();
  }
  ldv_50071: ;
#line 745
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  int tmp ;

  {
#line 749
  tmp = __VERIFIER_nondet_int();
#line 749
  switch (tmp) {
  case 0: ;
#line 752
  if (ldv_state_variable_7 == 1) {
#line 754
    pvr2_tda18271_8295_attach(pvr2_750xx_dvb_props_group0);
#line 756
    ldv_state_variable_7 = 1;
  } else {

  }
#line 759
  goto ldv_50078;
  case 1: ;
#line 762
  if (ldv_state_variable_7 == 1) {
#line 764
    pvr2_s5h1409_attach(pvr2_750xx_dvb_props_group0);
#line 766
    ldv_state_variable_7 = 1;
  } else {

  }
#line 769
  goto ldv_50078;
  default: 
#line 770
  ldv_stop();
  }
  ldv_50078: ;
#line 774
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  int tmp ;

  {
#line 778
  tmp = __VERIFIER_nondet_int();
#line 778
  switch (tmp) {
  case 0: ;
#line 781
  if (ldv_state_variable_10 == 1) {
#line 783
    pvr2_lgh06xf_attach(pvr2_onair_creator_fe_props_group0);
#line 785
    ldv_state_variable_10 = 1;
  } else {

  }
#line 788
  goto ldv_50085;
  case 1: ;
#line 791
  if (ldv_state_variable_10 == 1) {
#line 793
    pvr2_lgdt3303_attach(pvr2_onair_creator_fe_props_group0);
#line 795
    ldv_state_variable_10 = 1;
  } else {

  }
#line 798
  goto ldv_50085;
  default: 
#line 799
  ldv_stop();
  }
  ldv_50085: ;
#line 803
  return;
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  int tmp ;

  {
#line 807
  tmp = __VERIFIER_nondet_int();
#line 807
  switch (tmp) {
  case 0: ;
#line 810
  if (ldv_state_variable_9 == 1) {
#line 812
    pvr2_fcv1236d_attach(pvr2_onair_usb2_fe_props_group0);
#line 814
    ldv_state_variable_9 = 1;
  } else {

  }
#line 817
  goto ldv_50092;
  case 1: ;
#line 820
  if (ldv_state_variable_9 == 1) {
#line 822
    pvr2_lgdt3302_attach(pvr2_onair_usb2_fe_props_group0);
#line 824
    ldv_state_variable_9 = 1;
  } else {

  }
#line 827
  goto ldv_50092;
  default: 
#line 828
  ldv_stop();
  }
  ldv_50092: ;
#line 832
  return;
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void *ldv_kmem_cache_alloc_436(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 963
  ldv_check_alloc_flags(flags);
#line 965
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 966
  return ((void *)0);
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
int ldv_pskb_expand_head_442(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1007
  ldv_check_alloc_flags(flags);
#line 1009
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1009
  return (tmp);
}
}
#line 1020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv_skb_clone_444(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1023
  ldv_check_alloc_flags(flags);
#line 1025
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1025
  return (tmp);
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv_skb_copy_446(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1039
  ldv_check_alloc_flags(flags);
#line 1041
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1041
  return (tmp);
}
}
#line 1044 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_447(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1047
  ldv_check_alloc_flags(flags);
#line 1049
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1049
  return (tmp);
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_448(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1055
  ldv_check_alloc_flags(flags);
#line 1057
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1057
  return (tmp);
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_449(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1063
  ldv_check_alloc_flags(flags);
#line 1065
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1065
  return (tmp);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1071
  ldv_check_alloc_flags(flags);
#line 1073
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1073
  return (tmp);
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
int ldv_pskb_expand_head_451(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1079
  ldv_check_alloc_flags(flags);
#line 1081
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1081
  return (tmp);
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1087
  ldv_check_alloc_flags(flags);
#line 1089
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1089
  return (tmp);
}
}
#line 33 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 35
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 35
  return (tmp != 0L);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_478(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 2270 "include/linux/sched.h"
extern int wake_up_process(struct task_struct * ) ;
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp ) ;
#line 75 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
void pvr2_stream_kill(struct pvr2_stream *sp ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-ioread.h"
struct pvr2_ioread *pvr2_ioread_create(void) ;
#line 29
int pvr2_ioread_setup(struct pvr2_ioread *cp , struct pvr2_stream *sp ) ;
#line 31
void pvr2_ioread_set_sync_key(struct pvr2_ioread *cp , char const   *sync_key_ptr ,
                              unsigned int sync_key_len ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct pvr2_context *pvr2_context_exist_first  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct pvr2_context *pvr2_context_exist_last  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct pvr2_context *pvr2_context_notify_first  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct pvr2_context *pvr2_context_notify_last  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct mutex pvr2_context_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_mutex.wait_lock",
                                                           0, 0UL}}}}, {& pvr2_context_mutex.wait_list,
                                                                        & pvr2_context_mutex.wait_list},
    0, 0, (void *)(& pvr2_context_mutex), {0, {0, 0}, "pvr2_context_mutex", 0, 0UL}};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static wait_queue_head_t pvr2_context_sync_data  =    {{{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_sync_data.lock",
                                                      0, 0UL}}}}, {& pvr2_context_sync_data.task_list,
                                                                   & pvr2_context_sync_data.task_list}};
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static wait_queue_head_t pvr2_context_cleanup_data  =    {{{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_cleanup_data.lock",
                                                      0, 0UL}}}}, {& pvr2_context_cleanup_data.task_list,
                                                                   & pvr2_context_cleanup_data.task_list}};
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static int pvr2_context_cleanup_flag  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static int pvr2_context_cleaned_flag  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static struct task_struct *pvr2_context_thread_ptr  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_set_notify(struct pvr2_context *mp , int fl ) 
{ 
  int signal_flag ;

  {
#line 135
  signal_flag = 0;
#line 136
  mutex_lock_nested(& pvr2_context_mutex, 0U);
#line 137
  if (fl != 0) {
#line 138
    if (mp->notify_flag == 0) {
#line 139
      signal_flag = (unsigned long )pvr2_context_notify_first == (unsigned long )((struct pvr2_context *)0);
#line 140
      mp->notify_prev = pvr2_context_notify_last;
#line 141
      mp->notify_next = (struct pvr2_context *)0;
#line 142
      pvr2_context_notify_last = mp;
#line 143
      if ((unsigned long )mp->notify_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 144
        (mp->notify_prev)->notify_next = mp;
      } else {
#line 146
        pvr2_context_notify_first = mp;
      }
#line 148
      mp->notify_flag = 1;
    } else {

    }
  } else
#line 151
  if (mp->notify_flag != 0) {
#line 152
    mp->notify_flag = 0;
#line 153
    if ((unsigned long )mp->notify_next != (unsigned long )((struct pvr2_context *)0)) {
#line 154
      (mp->notify_next)->notify_prev = mp->notify_prev;
    } else {
#line 156
      pvr2_context_notify_last = mp->notify_prev;
    }
#line 158
    if ((unsigned long )mp->notify_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 159
      (mp->notify_prev)->notify_next = mp->notify_next;
    } else {
#line 161
      pvr2_context_notify_first = mp->notify_next;
    }
  } else {

  }
#line 165
  mutex_unlock(& pvr2_context_mutex);
#line 166
  if (signal_flag != 0) {
#line 166
    __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
  } else {

  }
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_destroy(struct pvr2_context *mp ) 
{ 


  {
#line 172
  if ((pvrusb2_debug & 8192) != 0) {
#line 172
    printk("\016pvrusb2: pvr2_context %p (destroy)\n", mp);
  } else {

  }
#line 173
  if ((unsigned long )mp->hdw != (unsigned long )((struct pvr2_hdw *)0)) {
#line 173
    pvr2_hdw_destroy(mp->hdw);
  } else {

  }
#line 174
  pvr2_context_set_notify(mp, 0);
#line 175
  mutex_lock_nested(& pvr2_context_mutex, 0U);
#line 176
  if ((unsigned long )mp->exist_next != (unsigned long )((struct pvr2_context *)0)) {
#line 177
    (mp->exist_next)->exist_prev = mp->exist_prev;
  } else {
#line 179
    pvr2_context_exist_last = mp->exist_prev;
  }
#line 181
  if ((unsigned long )mp->exist_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 182
    (mp->exist_prev)->exist_next = mp->exist_next;
  } else {
#line 184
    pvr2_context_exist_first = mp->exist_next;
  }
#line 186
  if ((unsigned long )pvr2_context_exist_first == (unsigned long )((struct pvr2_context *)0)) {
#line 189
    __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
  } else {

  }
#line 191
  mutex_unlock(& pvr2_context_mutex);
#line 192
  kfree((void const   *)mp);
#line 193
  return;
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_notify(struct pvr2_context *mp ) 
{ 


  {
#line 198
  pvr2_context_set_notify(mp, 1);
#line 199
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_check(struct pvr2_context *mp ) 
{ 
  struct pvr2_channel *ch1 ;
  struct pvr2_channel *ch2 ;
  int tmp ;

  {
#line 205
  if ((pvrusb2_debug & 8192) != 0) {
#line 205
    printk("\016pvrusb2: pvr2_context %p (notify)\n", mp);
  } else {

  }
#line 207
  if (mp->initialized_flag == 0 && mp->disconnect_flag == 0) {
#line 208
    mp->initialized_flag = 1;
#line 209
    if ((pvrusb2_debug & 8192) != 0) {
#line 209
      printk("\016pvrusb2: pvr2_context %p (initialize)\n", mp);
    } else {

    }
#line 212
    tmp = pvr2_hdw_initialize(mp->hdw, (void (*)(void * ))(& pvr2_context_notify),
                              (void *)mp);
#line 212
    if (tmp != 0) {
#line 215
      mp->video_stream.stream = pvr2_hdw_get_video_stream(mp->hdw);
#line 220
      if ((unsigned long )mp->setup_func != (unsigned long )((void (*)(struct pvr2_context * ))0)) {
#line 220
        (*(mp->setup_func))(mp);
      } else {

      }
    } else
#line 222
    if ((pvrusb2_debug & 8192) != 0) {
#line 222
      printk("\016pvrusb2: pvr2_context %p (thread skipping setup)\n", mp);
    } else {

    }
  } else {

  }
#line 233
  ch1 = mp->mc_first;
#line 233
  goto ldv_28932;
  ldv_28931: 
#line 234
  ch2 = ch1->mc_next;
#line 235
  if ((unsigned long )ch1->check_func != (unsigned long )((void (*)(struct pvr2_channel * ))0)) {
#line 235
    (*(ch1->check_func))(ch1);
  } else {

  }
#line 233
  ch1 = ch2;
  ldv_28932: ;
#line 233
  if ((unsigned long )ch1 != (unsigned long )((struct pvr2_channel *)0)) {
#line 235
    goto ldv_28931;
  } else {

  }

#line 238
  if (mp->disconnect_flag != 0 && (unsigned long )mp->mc_first == (unsigned long )((struct pvr2_channel *)0)) {
#line 240
    pvr2_context_destroy(mp);
#line 241
    return;
  } else {

  }
#line 243
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static int pvr2_context_shutok(void) 
{ 


  {
#line 248
  return (pvr2_context_cleanup_flag != 0 && (unsigned long )pvr2_context_exist_first == (unsigned long )((struct pvr2_context *)0));
}
}
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static int pvr2_context_thread_func(void *foo ) 
{ 
  struct pvr2_context *mp ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __ret___1 ;
  wait_queue_t __wait___0 ;
  long __ret___2 ;
  long __int___0 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 256
  if ((pvrusb2_debug & 8192) != 0) {
#line 256
    printk("\016pvrusb2: pvr2_context thread start\n");
  } else {

  }
  ldv_28953: ;
#line 259
  goto ldv_28942;
  ldv_28941: 
#line 260
  pvr2_context_set_notify(mp, 0);
#line 261
  pvr2_context_check(mp);
  ldv_28942: 
#line 259
  mp = pvr2_context_notify_first;
#line 259
  if ((unsigned long )mp != (unsigned long )((struct pvr2_context *)0)) {
#line 261
    goto ldv_28941;
  } else {

  }
#line 263
  __ret = 0;
#line 263
  if ((unsigned long )pvr2_context_notify_first == (unsigned long )((struct pvr2_context *)0)) {
#line 263
    tmp___1 = pvr2_context_shutok();
#line 263
    if (tmp___1 == 0) {
#line 263
      __ret___0 = 0L;
#line 263
      INIT_LIST_HEAD(& __wait.task_list);
#line 263
      __wait.flags = 0U;
      ldv_28950: 
#line 263
      tmp = prepare_to_wait_event(& pvr2_context_sync_data, & __wait, 1);
#line 263
      __int = tmp;
#line 263
      if ((unsigned long )pvr2_context_notify_first != (unsigned long )((struct pvr2_context *)0)) {
#line 263
        goto ldv_28949;
      } else {
#line 263
        tmp___0 = pvr2_context_shutok();
#line 263
        if (tmp___0 != 0) {
#line 263
          goto ldv_28949;
        } else {

        }
      }
#line 263
      if (__int != 0L) {
#line 263
        __ret___0 = __int;
#line 263
        goto ldv_28949;
      } else {

      }
#line 263
      schedule();
#line 263
      goto ldv_28950;
      ldv_28949: 
#line 263
      finish_wait(& pvr2_context_sync_data, & __wait);
#line 263
      __ret = (int )__ret___0;
    } else {

    }
  } else {

  }
#line 267
  tmp___2 = pvr2_context_shutok();
#line 267
  if (tmp___2 == 0) {
#line 269
    goto ldv_28953;
  } else {

  }
#line 269
  pvr2_context_cleaned_flag = 1;
#line 270
  __wake_up(& pvr2_context_cleanup_data, 3U, 1, (void *)0);
#line 272
  if ((pvrusb2_debug & 8192) != 0) {
#line 272
    printk("\016pvrusb2: pvr2_context thread cleaned up\n");
  } else {

  }
#line 274
  __ret___1 = 0;
#line 274
  tmp___5 = kthread_should_stop();
#line 274
  if (tmp___5) {
#line 274
    tmp___6 = 0;
  } else {
#line 274
    tmp___6 = 1;
  }
#line 274
  if (tmp___6) {
#line 274
    __ret___2 = 0L;
#line 274
    INIT_LIST_HEAD(& __wait___0.task_list);
#line 274
    __wait___0.flags = 0U;
    ldv_28961: 
#line 274
    tmp___3 = prepare_to_wait_event(& pvr2_context_sync_data, & __wait___0, 1);
#line 274
    __int___0 = tmp___3;
#line 274
    tmp___4 = kthread_should_stop();
#line 274
    if ((int )tmp___4) {
#line 274
      goto ldv_28960;
    } else {

    }
#line 274
    if (__int___0 != 0L) {
#line 274
      __ret___2 = __int___0;
#line 274
      goto ldv_28960;
    } else {

    }
#line 274
    schedule();
#line 274
    goto ldv_28961;
    ldv_28960: 
#line 274
    finish_wait(& pvr2_context_sync_data, & __wait___0);
#line 274
    __ret___1 = (int )__ret___2;
  } else {

  }
#line 278
  if ((pvrusb2_debug & 8192) != 0) {
#line 278
    printk("\016pvrusb2: pvr2_context thread end\n");
  } else {

  }
#line 280
  return (0);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
int pvr2_context_global_init(void) 
{ 
  struct task_struct *__k ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 286
  tmp = kthread_create_on_node(& pvr2_context_thread_func, (void *)0, -1, "pvrusb2-context");
#line 286
  __k = tmp;
#line 286
  tmp___0 = IS_ERR((void const   *)__k);
#line 286
  if (tmp___0) {
#line 286
    tmp___1 = 0;
  } else {
#line 286
    tmp___1 = 1;
  }
#line 286
  if (tmp___1) {
#line 286
    wake_up_process(__k);
  } else {

  }
#line 286
  pvr2_context_thread_ptr = __k;
#line 289
  return ((unsigned long )pvr2_context_thread_ptr != (unsigned long )((struct task_struct *)0) ? 0 : -12);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void pvr2_context_global_done(void) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;

  {
#line 295
  pvr2_context_cleanup_flag = 1;
#line 296
  __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
#line 297
  __ret = 0;
#line 297
  if (pvr2_context_cleaned_flag == 0) {
#line 297
    __ret___0 = 0L;
#line 297
    INIT_LIST_HEAD(& __wait.task_list);
#line 297
    __wait.flags = 0U;
    ldv_28978: 
#line 297
    tmp = prepare_to_wait_event(& pvr2_context_cleanup_data, & __wait, 1);
#line 297
    __int = tmp;
#line 297
    if (pvr2_context_cleaned_flag != 0) {
#line 297
      goto ldv_28977;
    } else {

    }
#line 297
    if (__int != 0L) {
#line 297
      __ret___0 = __int;
#line 297
      goto ldv_28977;
    } else {

    }
#line 297
    schedule();
#line 297
    goto ldv_28978;
    ldv_28977: 
#line 297
    finish_wait(& pvr2_context_cleanup_data, & __wait);
#line 297
    __ret = (int )__ret___0;
  } else {

  }
#line 300
  kthread_stop(pvr2_context_thread_ptr);
#line 301
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
struct pvr2_context *pvr2_context_create(struct usb_interface *intf , struct usb_device_id  const  *devid ,
                                         void (*setup_func)(struct pvr2_context * ) ) 
{ 
  struct pvr2_context *mp ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 309
  mp = (struct pvr2_context *)0;
#line 310
  tmp = kzalloc(264UL, 208U);
#line 310
  mp = (struct pvr2_context *)tmp;
#line 311
  if ((unsigned long )mp == (unsigned long )((struct pvr2_context *)0)) {
#line 311
    goto done;
  } else {

  }
#line 312
  if ((pvrusb2_debug & 8192) != 0) {
#line 312
    printk("\016pvrusb2: pvr2_context %p (create)\n", mp);
  } else {

  }
#line 313
  mp->setup_func = setup_func;
#line 314
  __mutex_init(& mp->mutex, "&mp->mutex", & __key);
#line 315
  mutex_lock_nested(& pvr2_context_mutex, 0U);
#line 316
  mp->exist_prev = pvr2_context_exist_last;
#line 317
  mp->exist_next = (struct pvr2_context *)0;
#line 318
  pvr2_context_exist_last = mp;
#line 319
  if ((unsigned long )mp->exist_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 320
    (mp->exist_prev)->exist_next = mp;
  } else {
#line 322
    pvr2_context_exist_first = mp;
  }
#line 324
  mutex_unlock(& pvr2_context_mutex);
#line 325
  mp->hdw = pvr2_hdw_create(intf, devid);
#line 326
  if ((unsigned long )mp->hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 327
    pvr2_context_destroy(mp);
#line 328
    mp = (struct pvr2_context *)0;
#line 329
    goto done;
  } else {

  }
#line 331
  pvr2_context_set_notify(mp, 1);
  done: ;
#line 333
  return (mp);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_reset_input_limits(struct pvr2_context *mp ) 
{ 
  unsigned int tmsk ;
  unsigned int mmsk ;
  struct pvr2_channel *cp ;
  struct pvr2_hdw *hdw ;

  {
#line 341
  hdw = mp->hdw;
#line 342
  mmsk = pvr2_hdw_get_input_available(hdw);
#line 343
  tmsk = mmsk;
#line 344
  cp = mp->mc_first;
#line 344
  goto ldv_28999;
  ldv_28998: ;
#line 345
  if (cp->input_mask == 0U) {
#line 345
    goto ldv_28997;
  } else {

  }
#line 346
  tmsk = cp->input_mask & tmsk;
  ldv_28997: 
#line 344
  cp = cp->mc_next;
  ldv_28999: ;
#line 344
  if ((unsigned long )cp != (unsigned long )((struct pvr2_channel *)0)) {
#line 346
    goto ldv_28998;
  } else {

  }
#line 348
  pvr2_hdw_set_input_allowed(hdw, mmsk, tmsk);
#line 349
  pvr2_hdw_commit_ctl(hdw);
#line 350
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_enter(struct pvr2_context *mp ) 
{ 


  {
#line 355
  mutex_lock_nested(& mp->mutex, 0U);
#line 356
  return;
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_context_exit(struct pvr2_context *mp ) 
{ 
  int destroy_flag ;

  {
#line 361
  destroy_flag = 0;
#line 362
  if ((unsigned long )mp->mc_first == (unsigned long )((struct pvr2_channel *)0) && mp->disconnect_flag != 0) {
#line 363
    destroy_flag = 1;
  } else {

  }
#line 365
  mutex_unlock(& mp->mutex);
#line 366
  if (destroy_flag != 0) {
#line 366
    pvr2_context_notify(mp);
  } else {

  }
#line 367
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void pvr2_context_disconnect(struct pvr2_context *mp ) 
{ 


  {
#line 372
  pvr2_hdw_disconnect(mp->hdw);
#line 373
  mp->disconnect_flag = 1;
#line 374
  pvr2_context_notify(mp);
#line 375
  return;
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void pvr2_channel_init(struct pvr2_channel *cp , struct pvr2_context *mp ) 
{ 


  {
#line 380
  pvr2_context_enter(mp);
#line 381
  cp->hdw = mp->hdw;
#line 382
  cp->mc_head = mp;
#line 383
  cp->mc_next = (struct pvr2_channel *)0;
#line 384
  cp->mc_prev = mp->mc_last;
#line 385
  if ((unsigned long )mp->mc_last != (unsigned long )((struct pvr2_channel *)0)) {
#line 386
    (mp->mc_last)->mc_next = cp;
  } else {
#line 388
    mp->mc_first = cp;
  }
#line 390
  mp->mc_last = cp;
#line 391
  pvr2_context_exit(mp);
#line 392
  return;
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static void pvr2_channel_disclaim_stream(struct pvr2_channel *cp ) 
{ 


  {
#line 397
  if ((unsigned long )cp->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 397
    return;
  } else {

  }
#line 398
  pvr2_stream_kill((cp->stream)->stream);
#line 399
  (cp->stream)->user = (struct pvr2_channel *)0;
#line 400
  cp->stream = (struct pvr2_context_stream *)0;
#line 401
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void pvr2_channel_done(struct pvr2_channel *cp ) 
{ 
  struct pvr2_context *mp ;

  {
#line 406
  mp = cp->mc_head;
#line 407
  pvr2_context_enter(mp);
#line 408
  cp->input_mask = 0U;
#line 409
  pvr2_channel_disclaim_stream(cp);
#line 410
  pvr2_context_reset_input_limits(mp);
#line 411
  if ((unsigned long )cp->mc_next != (unsigned long )((struct pvr2_channel *)0)) {
#line 412
    (cp->mc_next)->mc_prev = cp->mc_prev;
  } else {
#line 414
    mp->mc_last = cp->mc_prev;
  }
#line 416
  if ((unsigned long )cp->mc_prev != (unsigned long )((struct pvr2_channel *)0)) {
#line 417
    (cp->mc_prev)->mc_next = cp->mc_next;
  } else {
#line 419
    mp->mc_first = cp->mc_next;
  }
#line 421
  cp->hdw = (struct pvr2_hdw *)0;
#line 422
  pvr2_context_exit(mp);
#line 423
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
int pvr2_channel_limit_inputs(struct pvr2_channel *cp , unsigned int cmsk ) 
{ 
  unsigned int tmsk ;
  unsigned int mmsk ;
  int ret ;
  struct pvr2_channel *p2 ;
  struct pvr2_hdw *hdw ;

  {
#line 429
  ret = 0;
#line 431
  hdw = cp->hdw;
#line 433
  mmsk = pvr2_hdw_get_input_available(hdw);
#line 434
  cmsk = cmsk & mmsk;
#line 435
  if (cp->input_mask == cmsk) {
#line 437
    return (0);
  } else {

  }
#line 440
  pvr2_context_enter(cp->mc_head);
#line 442
  if (cmsk == 0U) {
#line 443
    cp->input_mask = 0U;
#line 444
    pvr2_context_reset_input_limits(cp->mc_head);
#line 445
    goto ldv_29031;
  } else {

  }
#line 447
  tmsk = mmsk;
#line 448
  p2 = (cp->mc_head)->mc_first;
#line 448
  goto ldv_29034;
  ldv_29033: ;
#line 449
  if ((unsigned long )p2 == (unsigned long )cp) {
#line 449
    goto ldv_29032;
  } else {

  }
#line 450
  if (p2->input_mask == 0U) {
#line 450
    goto ldv_29032;
  } else {

  }
#line 451
  tmsk = p2->input_mask & tmsk;
  ldv_29032: 
#line 448
  p2 = p2->mc_next;
  ldv_29034: ;
#line 448
  if ((unsigned long )p2 != (unsigned long )((struct pvr2_channel *)0)) {
#line 450
    goto ldv_29033;
  } else {

  }

#line 453
  if ((tmsk & cmsk) == 0U) {
#line 454
    ret = -1;
#line 455
    goto ldv_29031;
  } else {

  }
#line 457
  tmsk = tmsk & cmsk;
#line 458
  ret = pvr2_hdw_set_input_allowed(hdw, mmsk, tmsk);
#line 458
  if (ret != 0) {
#line 461
    goto ldv_29031;
  } else {

  }
#line 463
  cp->input_mask = cmsk;
#line 464
  pvr2_hdw_commit_ctl(hdw);
  ldv_29031: 
#line 466
  pvr2_context_exit(cp->mc_head);
#line 467
  return (ret);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp ) 
{ 


  {
#line 473
  return (cp->input_mask);
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
int pvr2_channel_claim_stream(struct pvr2_channel *cp , struct pvr2_context_stream *sp ) 
{ 
  int code ;

  {
#line 480
  code = 0;
#line 481
  pvr2_context_enter(cp->mc_head);
#line 482
  if ((unsigned long )cp->stream == (unsigned long )sp) {
#line 482
    goto ldv_29044;
  } else {

  }
#line 483
  if ((unsigned long )sp != (unsigned long )((struct pvr2_context_stream *)0) && (unsigned long )sp->user != (unsigned long )((struct pvr2_channel *)0)) {
#line 484
    code = -16;
#line 485
    goto ldv_29044;
  } else {

  }
#line 487
  pvr2_channel_disclaim_stream(cp);
#line 488
  if ((unsigned long )sp == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 488
    goto ldv_29044;
  } else {

  }
#line 489
  sp->user = cp;
#line 490
  cp->stream = sp;
  ldv_29044: 
#line 491
  pvr2_context_exit(cp->mc_head);
#line 492
  return (code);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
static char stream_sync_key[4U]  = {      0,      0,      1,      -70};
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
struct pvr2_ioread *pvr2_channel_create_mpeg_stream(struct pvr2_context_stream *sp ) 
{ 
  struct pvr2_ioread *cp ;

  {
#line 505
  cp = pvr2_ioread_create();
#line 506
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 506
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 507
  pvr2_ioread_setup(cp, sp->stream);
#line 508
  pvr2_ioread_set_sync_key(cp, (char const   *)(& stream_sync_key), 4U);
#line 509
  return (cp);
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void *ldv_kmem_cache_alloc_478(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 642
  ldv_check_alloc_flags(flags);
#line 644
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 645
  return ((void *)0);
}
}
#line 2 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 47 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 120 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 43 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6347.rlock);
}
}
#line 372 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_489(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 374
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
#line 375
  return;
}
}
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_497(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 1584 "include/linux/usb.h"
struct urb *ldv_usb_alloc_urb_500(int ldv_func_arg1 , gfp_t flags ) ;
#line 1592
int ldv_usb_submit_urb_501(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
int pvr2_stream_get_buffer_count(struct pvr2_stream *sp ) ;
#line 62
int pvr2_stream_set_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) ;
#line 66
struct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp ) ;
#line 67
struct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp ) ;
#line 68
struct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp , int id ) ;
#line 71
int pvr2_stream_get_ready_count(struct pvr2_stream *sp ) ;
#line 78
int pvr2_buffer_set_buffer(struct pvr2_buffer *bp , void *ptr , unsigned int cnt ) ;
#line 81
unsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp ) ;
#line 84
int pvr2_buffer_get_status(struct pvr2_buffer *bp ) ;
#line 87
int pvr2_buffer_get_id(struct pvr2_buffer *bp ) ;
#line 90
int pvr2_buffer_queue(struct pvr2_buffer *bp ) ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static char const   *pvr2_buffer_state_decode(enum pvr2_buffer_state st ) ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static char const   *pvr2_buffer_state_decode(enum pvr2_buffer_state st ) 
{ 


  {
#line 193
  switch ((unsigned int )st) {
  case 0U: ;
#line 194
  return ("none");
  case 1U: ;
#line 195
  return ("idle");
  case 2U: ;
#line 196
  return ("queued");
  case 3U: ;
#line 197
  return ("ready");
  }
#line 199
  return ("unknown");
}
}
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_remove(struct pvr2_buffer *bp ) 
{ 
  unsigned int *cnt ;
  unsigned int *bcnt ;
  unsigned int ccnt ;
  struct pvr2_stream *sp ;
  char const   *tmp ;

  {
#line 225
  sp = bp->stream;
#line 226
  switch ((unsigned int )bp->state) {
  case 1U: 
#line 228
  cnt = & sp->i_count;
#line 229
  bcnt = & sp->i_bcount;
#line 230
  ccnt = bp->max_count;
#line 231
  goto ldv_27196;
  case 2U: 
#line 233
  cnt = & sp->q_count;
#line 234
  bcnt = & sp->q_bcount;
#line 235
  ccnt = bp->max_count;
#line 236
  goto ldv_27196;
  case 3U: 
#line 238
  cnt = & sp->r_count;
#line 239
  bcnt = & sp->r_bcount;
#line 240
  ccnt = bp->used_count;
#line 241
  goto ldv_27196;
  default: ;
#line 243
  return;
  }
  ldv_27196: 
#line 245
  list_del_init(& bp->list_overhead);
#line 246
  *cnt = *cnt - 1U;
#line 247
  *bcnt = *bcnt - ccnt;
#line 248
  if ((pvrusb2_debug & 16777216) != 0) {
#line 248
    tmp = pvr2_buffer_state_decode(bp->state);
#line 248
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s dec cap=%07d cnt=%02d\n",
           tmp, *bcnt, *cnt);
  } else {

  }
#line 252
  bp->state = 0;
#line 253
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_set_none(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 260
  sp = bp->stream;
#line 261
  if ((pvrusb2_debug & 16777216) != 0) {
#line 261
    tmp = pvr2_buffer_state_decode(0);
#line 261
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 261
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 266
  ldv_spin_lock();
#line 267
  pvr2_buffer_remove(bp);
#line 268
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 269
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static int pvr2_buffer_set_ready(struct pvr2_buffer *bp ) 
{ 
  int fl ;
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 277
  sp = bp->stream;
#line 278
  if ((pvrusb2_debug & 16777216) != 0) {
#line 278
    tmp = pvr2_buffer_state_decode(3);
#line 278
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 278
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 283
  ldv_spin_lock();
#line 284
  fl = sp->r_count == 0U;
#line 285
  pvr2_buffer_remove(bp);
#line 286
  list_add_tail(& bp->list_overhead, & sp->ready_list);
#line 287
  bp->state = 3;
#line 288
  sp->r_count = sp->r_count + 1U;
#line 289
  sp->r_bcount = sp->r_bcount + bp->used_count;
#line 290
  if ((pvrusb2_debug & 16777216) != 0) {
#line 290
    tmp___1 = pvr2_buffer_state_decode(bp->state);
#line 290
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___1, sp->r_bcount, sp->r_count);
  } else {

  }
#line 295
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 296
  return (fl);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_set_idle(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 304
  sp = bp->stream;
#line 305
  if ((pvrusb2_debug & 16777216) != 0) {
#line 305
    tmp = pvr2_buffer_state_decode(1);
#line 305
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 305
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 310
  ldv_spin_lock();
#line 311
  pvr2_buffer_remove(bp);
#line 312
  list_add_tail(& bp->list_overhead, & sp->idle_list);
#line 313
  bp->state = 1;
#line 314
  sp->i_count = sp->i_count + 1U;
#line 315
  sp->i_bcount = sp->i_bcount + bp->max_count;
#line 316
  if ((pvrusb2_debug & 16777216) != 0) {
#line 316
    tmp___1 = pvr2_buffer_state_decode(bp->state);
#line 316
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___1, sp->i_bcount, sp->i_count);
  } else {

  }
#line 321
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 322
  return;
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_set_queued(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 329
  sp = bp->stream;
#line 330
  if ((pvrusb2_debug & 16777216) != 0) {
#line 330
    tmp = pvr2_buffer_state_decode(2);
#line 330
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 330
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 335
  ldv_spin_lock();
#line 336
  pvr2_buffer_remove(bp);
#line 337
  list_add_tail(& bp->list_overhead, & sp->queued_list);
#line 338
  bp->state = 2;
#line 339
  sp->q_count = sp->q_count + 1U;
#line 340
  sp->q_bcount = sp->q_bcount + bp->max_count;
#line 341
  if ((pvrusb2_debug & 16777216) != 0) {
#line 341
    tmp___1 = pvr2_buffer_state_decode(bp->state);
#line 341
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___1, sp->q_bcount, sp->q_count);
  } else {

  }
#line 346
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_wipe(struct pvr2_buffer *bp ) 
{ 


  {
#line 351
  if ((unsigned int )bp->state == 2U) {
#line 352
    usb_kill_urb(bp->purb);
  } else {

  }
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static int pvr2_buffer_init(struct pvr2_buffer *bp , struct pvr2_stream *sp , unsigned int id ) 
{ 


  {
#line 360
  memset((void *)bp, 0, 72UL);
#line 361
  bp->signature = 1197814385;
#line 362
  bp->id = (int )id;
#line 363
  if ((pvrusb2_debug & 8388608) != 0) {
#line 363
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferInit     %p stream=%p\n", bp,
           sp);
  } else {

  }
#line 365
  bp->stream = sp;
#line 366
  bp->state = 0;
#line 367
  INIT_LIST_HEAD(& bp->list_overhead);
#line 368
  bp->purb = ldv_usb_alloc_urb_500(0, 208U);
#line 369
  if ((unsigned long )bp->purb == (unsigned long )((struct urb *)0)) {
#line 369
    return (-12);
  } else {

  }
#line 373
  return (0);
}
}
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_buffer_done(struct pvr2_buffer *bp ) 
{ 


  {
#line 381
  pvr2_buffer_wipe(bp);
#line 382
  pvr2_buffer_set_none(bp);
#line 383
  bp->signature = 0;
#line 384
  bp->stream = (struct pvr2_stream *)0;
#line 385
  usb_free_urb(bp->purb);
#line 386
  if ((pvrusb2_debug & 8388608) != 0) {
#line 386
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferDone     %p\n", bp);
  } else {

  }
#line 387
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static int pvr2_stream_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) 
{ 
  int ret ;
  unsigned int scnt ;
  struct pvr2_buffer **nb ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  struct pvr2_buffer *bp ;
  void *tmp___0 ;
  struct pvr2_buffer *bp___0 ;
  struct pvr2_buffer **nb___0 ;
  void *tmp___1 ;

  {
#line 396
  if (sp->buffer_total_count == cnt) {
#line 396
    return (0);
  } else {

  }
#line 398
  if ((pvrusb2_debug & 8388608) != 0) {
#line 398
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ poolResize     stream=%p cur=%d adj=%+d\n",
           sp, sp->buffer_total_count, cnt - sp->buffer_total_count);
  } else {

  }
#line 405
  scnt = cnt & 4294967264U;
#line 406
  if (cnt > scnt) {
#line 406
    scnt = scnt + 32U;
  } else {

  }
#line 408
  if (sp->buffer_total_count < cnt) {
#line 409
    if (sp->buffer_slot_count < scnt) {
#line 411
      tmp = kmalloc((unsigned long )scnt * 8UL, 208U);
#line 411
      nb = (struct pvr2_buffer **)tmp;
#line 412
      if ((unsigned long )nb == (unsigned long )((struct pvr2_buffer **)0)) {
#line 412
        return (-12);
      } else {

      }
#line 413
      if (sp->buffer_slot_count != 0U) {
#line 414
        __len = (unsigned long )sp->buffer_slot_count * 8UL;
#line 414
        __ret = __builtin_memcpy((void *)nb, (void const   *)sp->buffers, __len);
#line 416
        kfree((void const   *)sp->buffers);
      } else {

      }
#line 418
      sp->buffers = nb;
#line 419
      sp->buffer_slot_count = scnt;
    } else {

    }
#line 421
    goto ldv_27244;
    ldv_27243: 
#line 423
    tmp___0 = kmalloc(72UL, 208U);
#line 423
    bp = (struct pvr2_buffer *)tmp___0;
#line 424
    if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 424
      return (-12);
    } else {

    }
#line 425
    ret = pvr2_buffer_init(bp, sp, sp->buffer_total_count);
#line 426
    if (ret != 0) {
#line 427
      kfree((void const   *)bp);
#line 428
      return (-12);
    } else {

    }
#line 430
    *(sp->buffers + (unsigned long )sp->buffer_total_count) = bp;
#line 431
    sp->buffer_total_count = sp->buffer_total_count + 1U;
#line 432
    pvr2_buffer_set_idle(bp);
    ldv_27244: ;
#line 421
    if (sp->buffer_total_count < cnt) {
#line 423
      goto ldv_27243;
    } else {

    }

  } else {
#line 435
    goto ldv_27248;
    ldv_27247: 
#line 437
    bp___0 = *(sp->buffers + (unsigned long )(sp->buffer_total_count - 1U));
#line 439
    *(sp->buffers + (unsigned long )(sp->buffer_total_count - 1U)) = (struct pvr2_buffer *)0;
#line 440
    sp->buffer_total_count = sp->buffer_total_count - 1U;
#line 441
    pvr2_buffer_done(bp___0);
#line 442
    kfree((void const   *)bp___0);
    ldv_27248: ;
#line 435
    if (sp->buffer_total_count > cnt) {
#line 437
      goto ldv_27247;
    } else {

    }

#line 444
    if (sp->buffer_slot_count > scnt) {
#line 445
      nb___0 = (struct pvr2_buffer **)0;
#line 446
      if (scnt != 0U) {
#line 447
        tmp___1 = kmemdup((void const   *)sp->buffers, (unsigned long )scnt * 8UL,
                          208U);
#line 447
        nb___0 = (struct pvr2_buffer **)tmp___1;
#line 449
        if ((unsigned long )nb___0 == (unsigned long )((struct pvr2_buffer **)0)) {
#line 449
          return (-12);
        } else {

        }
      } else {

      }
#line 451
      kfree((void const   *)sp->buffers);
#line 452
      sp->buffers = nb___0;
#line 453
      sp->buffer_slot_count = scnt;
    } else {

    }
  }
#line 456
  return (0);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static int pvr2_stream_achieve_buffer_count(struct pvr2_stream *sp ) 
{ 
  struct pvr2_buffer *bp ;
  unsigned int cnt ;
  int tmp ;

  {
#line 464
  if (sp->buffer_total_count == sp->buffer_target_count) {
#line 464
    return (0);
  } else {

  }
#line 466
  if ((pvrusb2_debug & 8388608) != 0) {
#line 466
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ poolCheck      stream=%p cur=%d tgt=%d\n",
           sp, sp->buffer_total_count, sp->buffer_target_count);
  } else {

  }
#line 471
  if (sp->buffer_total_count < sp->buffer_target_count) {
#line 472
    tmp = pvr2_stream_buffer_count(sp, sp->buffer_target_count);
#line 472
    return (tmp);
  } else {

  }
#line 475
  cnt = 0U;
#line 476
  goto ldv_27258;
  ldv_27257: 
#line 477
  bp = *(sp->buffers + (unsigned long )((sp->buffer_total_count - cnt) - 1U));
#line 478
  if ((unsigned int )bp->state != 1U) {
#line 478
    goto ldv_27256;
  } else {

  }
#line 479
  cnt = cnt + 1U;
  ldv_27258: ;
#line 476
  if (sp->buffer_total_count - cnt > sp->buffer_target_count) {
#line 478
    goto ldv_27257;
  } else {

  }
  ldv_27256: ;
#line 481
  if (cnt != 0U) {
#line 482
    pvr2_stream_buffer_count(sp, sp->buffer_total_count - cnt);
  } else {

  }
#line 485
  return (0);
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_stream_internal_flush(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct pvr2_buffer *bp1 ;
  struct list_head  const  *__mptr ;

  {
#line 492
  goto ldv_27266;
  ldv_27267: 
#line 493
  __mptr = (struct list_head  const  *)lp;
#line 493
  bp1 = (struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL;
#line 494
  pvr2_buffer_wipe(bp1);
#line 500
  if ((unsigned int )bp1->state != 2U) {
#line 500
    goto ldv_27266;
  } else {

  }
#line 501
  pvr2_buffer_set_idle(bp1);
  ldv_27266: 
#line 492
  lp = sp->queued_list.next;
#line 492
  if ((unsigned long )lp != (unsigned long )(& sp->queued_list)) {
#line 494
    goto ldv_27267;
  } else {

  }

#line 503
  if (sp->buffer_total_count != sp->buffer_target_count) {
#line 504
    pvr2_stream_achieve_buffer_count(sp);
  } else {

  }
#line 505
  return;
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_stream_init(struct pvr2_stream *sp ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 510
  spinlock_check(& sp->list_lock);
#line 510
  __raw_spin_lock_init(& sp->list_lock.ldv_6347.rlock, "&(&sp->list_lock)->rlock",
                       & __key);
#line 511
  __mutex_init(& sp->mutex, "&sp->mutex", & __key___0);
#line 512
  INIT_LIST_HEAD(& sp->queued_list);
#line 513
  INIT_LIST_HEAD(& sp->ready_list);
#line 514
  INIT_LIST_HEAD(& sp->idle_list);
#line 515
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void pvr2_stream_done(struct pvr2_stream *sp ) 
{ 


  {
#line 519
  mutex_lock_nested(& sp->mutex, 0U);
#line 520
  pvr2_stream_internal_flush(sp);
#line 521
  pvr2_stream_buffer_count(sp, 0U);
#line 522
  mutex_unlock(& sp->mutex);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
static void buffer_complete(struct urb *urb ) 
{ 
  struct pvr2_buffer *bp ;
  struct pvr2_stream *sp ;
  unsigned long irq_flags ;

  {
#line 527
  bp = (struct pvr2_buffer *)urb->context;
#line 531
  sp = bp->stream;
#line 532
  bp->used_count = 0U;
#line 533
  bp->status = 0;
#line 534
  if ((pvrusb2_debug & 16777216) != 0) {
#line 534
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferComplete %p stat=%d cnt=%d\n",
           bp, urb->status, urb->actual_length);
  } else {

  }
#line 537
  ldv_spin_lock();
#line 538
  if (((urb->status == 0 || urb->status == -2) || urb->status == -104) || urb->status == -108) {
#line 542
    sp->buffers_processed = sp->buffers_processed + 1U;
#line 543
    sp->bytes_processed = sp->bytes_processed + urb->actual_length;
#line 544
    bp->used_count = urb->actual_length;
#line 545
    if (sp->fail_count != 0U) {
#line 546
      if ((pvrusb2_debug & 4) != 0) {
#line 546
        printk("\016pvrusb2: stream %p transfer ok - fail count reset\n", sp);
      } else {

      }
#line 549
      sp->fail_count = 0U;
    } else {

    }
  } else
#line 551
  if (sp->fail_count < sp->fail_tolerance) {
#line 554
    sp->fail_count = sp->fail_count + 1U;
#line 555
    sp->buffers_failed = sp->buffers_failed + 1U;
#line 556
    if ((pvrusb2_debug & 4) != 0) {
#line 556
      printk("\016pvrusb2: stream %p ignoring error %d - fail count increased to %u\n",
             sp, urb->status, sp->fail_count);
    } else {

    }
  } else {
#line 561
    sp->buffers_failed = sp->buffers_failed + 1U;
#line 562
    bp->status = urb->status;
  }
#line 564
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 565
  pvr2_buffer_set_ready(bp);
#line 566
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0) && (unsigned long )sp->callback_func != (unsigned long )((void (*)(void * ))0)) {
#line 567
    (*(sp->callback_func))(sp->callback_data);
  } else {

  }
#line 568
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_stream *pvr2_stream_create(void) 
{ 
  struct pvr2_stream *sp ;
  void *tmp ;

  {
#line 574
  tmp = kzalloc(392UL, 208U);
#line 574
  sp = (struct pvr2_stream *)tmp;
#line 575
  if ((unsigned long )sp == (unsigned long )((struct pvr2_stream *)0)) {
#line 575
    return (sp);
  } else {

  }
#line 576
  if ((pvrusb2_debug & 32) != 0) {
#line 576
    printk("\016pvrusb2: pvr2_stream_create: sp=%p\n", sp);
  } else {

  }
#line 577
  pvr2_stream_init(sp);
#line 578
  return (sp);
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void pvr2_stream_destroy(struct pvr2_stream *sp ) 
{ 


  {
#line 583
  if ((unsigned long )sp == (unsigned long )((struct pvr2_stream *)0)) {
#line 583
    return;
  } else {

  }
#line 584
  if ((pvrusb2_debug & 32) != 0) {
#line 584
    printk("\016pvrusb2: pvr2_stream_destroy: sp=%p\n", sp);
  } else {

  }
#line 585
  pvr2_stream_done(sp);
#line 586
  kfree((void const   *)sp);
#line 587
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void pvr2_stream_setup(struct pvr2_stream *sp , struct usb_device *dev , int endpoint ,
                       unsigned int tolerance___0 ) 
{ 


  {
#line 594
  mutex_lock_nested(& sp->mutex, 0U);
#line 595
  pvr2_stream_internal_flush(sp);
#line 596
  sp->dev = dev;
#line 597
  sp->endpoint = endpoint;
#line 598
  sp->fail_tolerance = tolerance___0;
#line 599
  mutex_unlock(& sp->mutex);
#line 600
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void pvr2_stream_set_callback(struct pvr2_stream *sp , void (*func)(void * ) , void *data ) 
{ 
  unsigned long irq_flags ;

  {
#line 607
  mutex_lock_nested(& sp->mutex, 0U);
#line 608
  ldv_spin_lock();
#line 609
  sp->callback_data = data;
#line 610
  sp->callback_func = func;
#line 611
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 612
  mutex_unlock(& sp->mutex);
#line 613
  return;
}
}
#line 615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void pvr2_stream_get_stats(struct pvr2_stream *sp , struct pvr2_stream_stats *stats ,
                           int zero_counts ) 
{ 
  unsigned long irq_flags ;

  {
#line 620
  ldv_spin_lock();
#line 621
  if ((unsigned long )stats != (unsigned long )((struct pvr2_stream_stats *)0)) {
#line 622
    stats->buffers_in_queue = sp->q_count;
#line 623
    stats->buffers_in_idle = sp->i_count;
#line 624
    stats->buffers_in_ready = sp->r_count;
#line 625
    stats->buffers_processed = sp->buffers_processed;
#line 626
    stats->buffers_failed = sp->buffers_failed;
#line 627
    stats->bytes_processed = sp->bytes_processed;
  } else {

  }
#line 629
  if (zero_counts != 0) {
#line 630
    sp->buffers_processed = 0U;
#line 631
    sp->buffers_failed = 0U;
#line 632
    sp->bytes_processed = 0U;
  } else {

  }
#line 634
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 635
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_stream_get_buffer_count(struct pvr2_stream *sp ) 
{ 


  {
#line 640
  return ((int )sp->buffer_target_count);
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_stream_set_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) 
{ 
  int ret ;

  {
#line 646
  if (sp->buffer_target_count == cnt) {
#line 646
    return (0);
  } else {

  }
#line 647
  mutex_lock_nested(& sp->mutex, 0U);
#line 648
  sp->buffer_target_count = cnt;
#line 649
  ret = pvr2_stream_achieve_buffer_count(sp);
#line 650
  mutex_unlock(& sp->mutex);
#line 651
  return (ret);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct list_head  const  *__mptr ;

  {
#line 656
  lp = sp->idle_list.next;
#line 657
  if ((unsigned long )(& sp->idle_list) == (unsigned long )lp) {
#line 657
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 658
  __mptr = (struct list_head  const  *)lp;
#line 658
  return ((struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct list_head  const  *__mptr ;

  {
#line 663
  lp = sp->ready_list.next;
#line 664
  if ((unsigned long )(& sp->ready_list) == (unsigned long )lp) {
#line 664
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 665
  __mptr = (struct list_head  const  *)lp;
#line 665
  return ((struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL);
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp , int id ) 
{ 


  {
#line 670
  if (id < 0) {
#line 670
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 671
  if ((unsigned int )id >= sp->buffer_total_count) {
#line 671
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 672
  return (*(sp->buffers + (unsigned long )id));
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_stream_get_ready_count(struct pvr2_stream *sp ) 
{ 


  {
#line 677
  return ((int )sp->r_count);
}
}
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void pvr2_stream_kill(struct pvr2_stream *sp ) 
{ 
  struct pvr2_buffer *bp ;

  {
#line 683
  mutex_lock_nested(& sp->mutex, 0U);
#line 684
  pvr2_stream_internal_flush(sp);
#line 685
  goto ldv_27340;
  ldv_27339: 
#line 686
  pvr2_buffer_set_idle(bp);
  ldv_27340: 
#line 685
  bp = pvr2_stream_get_ready_buffer(sp);
#line 685
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 687
    goto ldv_27339;
  } else {

  }

#line 688
  if (sp->buffer_total_count != sp->buffer_target_count) {
#line 689
    pvr2_stream_achieve_buffer_count(sp);
  } else {

  }
#line 691
  mutex_unlock(& sp->mutex);
#line 692
  return;
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_buffer_queue(struct pvr2_buffer *bp ) 
{ 
  int ret ;
  struct pvr2_stream *sp ;
  unsigned int tmp ;

  {
#line 701
  ret = 0;
#line 703
  if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 703
    return (-22);
  } else {

  }
#line 704
  sp = bp->stream;
#line 705
  mutex_lock_nested(& sp->mutex, 0U);
#line 706
  pvr2_buffer_wipe(bp);
#line 707
  if ((unsigned long )sp->dev == (unsigned long )((struct usb_device *)0)) {
#line 708
    ret = -5;
#line 709
    goto ldv_27347;
  } else {

  }
#line 711
  pvr2_buffer_set_queued(bp);
#line 719
  bp->status = -115;
#line 720
  tmp = __create_pipe(sp->dev, (unsigned int )sp->endpoint);
#line 720
  usb_fill_bulk_urb(bp->purb, sp->dev, tmp | 3221225600U, bp->ptr, (int )bp->max_count,
                    & buffer_complete, (void *)bp);
#line 728
  ldv_usb_submit_urb_501(bp->purb, 208U);
  ldv_27347: 
#line 729
  mutex_unlock(& sp->mutex);
#line 730
  return (ret);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_buffer_set_buffer(struct pvr2_buffer *bp , void *ptr , unsigned int cnt ) 
{ 
  int ret ;
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;

  {
#line 735
  ret = 0;
#line 738
  if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 738
    return (-22);
  } else {

  }
#line 739
  sp = bp->stream;
#line 740
  mutex_lock_nested(& sp->mutex, 0U);
#line 741
  ldv_spin_lock();
#line 742
  if ((unsigned int )bp->state != 1U) {
#line 743
    ret = -1;
  } else {
#line 745
    bp->ptr = ptr;
#line 746
    (bp->stream)->i_bcount = (bp->stream)->i_bcount - bp->max_count;
#line 747
    bp->max_count = cnt;
#line 748
    (bp->stream)->i_bcount = (bp->stream)->i_bcount + bp->max_count;
#line 749
    if ((pvrusb2_debug & 16777216) != 0) {
#line 749
      tmp = pvr2_buffer_state_decode(1);
#line 749
      printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s cap cap=%07d cnt=%02d\n",
             tmp, (bp->stream)->i_bcount, (bp->stream)->i_count);
    } else {

    }
  }
#line 756
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 757
  mutex_unlock(& sp->mutex);
#line 758
  return (ret);
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
unsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp ) 
{ 


  {
#line 763
  return (bp->used_count);
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_buffer_get_status(struct pvr2_buffer *bp ) 
{ 


  {
#line 768
  return (bp->status);
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int pvr2_buffer_get_id(struct pvr2_buffer *bp ) 
{ 


  {
#line 773
  return (bp->id);
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 838
  ldv_spin_unlock();
#line 840
  ldv_spin_unlock_irqrestore_489(lock, flags);
#line 841
  return;
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void *ldv_kmem_cache_alloc_497(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 906
  ldv_check_alloc_flags(flags);
#line 908
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 909
  return ((void *)0);
}
}
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
struct urb *ldv_usb_alloc_urb_500(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 926
  ldv_check_alloc_flags(flags);
#line 928
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 928
  return (tmp);
}
}
#line 931 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int ldv_usb_submit_urb_501(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 934
  ldv_check_alloc_flags(flags);
#line 936
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 936
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_520(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static int pvr2_ioread_init(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;
  struct lock_class_key __key ;
  void *tmp ;

  {
#line 147
  cp->stream = (struct pvr2_stream *)0;
#line 148
  __mutex_init(& cp->mutex, "&cp->mutex", & __key);
#line 150
  idx = 0U;
#line 150
  goto ldv_29964;
  ldv_29963: 
#line 151
  tmp = kmalloc(16384UL, 208U);
#line 151
  cp->buffer_storage[idx] = (char *)tmp;
#line 152
  if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 152
    goto ldv_29962;
  } else {

  }
#line 150
  idx = idx + 1U;
  ldv_29964: ;
#line 150
  if (idx <= 31U) {
#line 152
    goto ldv_29963;
  } else {

  }
  ldv_29962: ;
#line 155
  if (idx <= 31U) {
#line 157
    idx = 0U;
#line 157
    goto ldv_29967;
    ldv_29966: ;
#line 158
    if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 158
      goto ldv_29965;
    } else {

    }
#line 159
    kfree((void const   *)cp->buffer_storage[idx]);
    ldv_29965: 
#line 157
    idx = idx + 1U;
    ldv_29967: ;
#line 157
    if (idx <= 31U) {
#line 159
      goto ldv_29966;
    } else {

    }

#line 161
    return (-12);
  } else {

  }
#line 163
  return (0);
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static void pvr2_ioread_done(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;

  {
#line 170
  pvr2_ioread_setup(cp, (struct pvr2_stream *)0);
#line 171
  idx = 0U;
#line 171
  goto ldv_29975;
  ldv_29974: ;
#line 172
  if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 172
    goto ldv_29973;
  } else {

  }
#line 173
  kfree((void const   *)cp->buffer_storage[idx]);
  ldv_29973: 
#line 171
  idx = idx + 1U;
  ldv_29975: ;
#line 171
  if (idx <= 31U) {
#line 173
    goto ldv_29974;
  } else {

  }

#line 178
  return;
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
struct pvr2_ioread *pvr2_ioread_create(void) 
{ 
  struct pvr2_ioread *cp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 180
  tmp = kzalloc(496UL, 208U);
#line 180
  cp = (struct pvr2_ioread *)tmp;
#line 181
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 181
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 182
  if ((pvrusb2_debug & 2048) != 0) {
#line 182
    printk("\016pvrusb2: pvr2_ioread_create id=%p\n", cp);
  } else {

  }
#line 183
  tmp___0 = pvr2_ioread_init(cp);
#line 183
  if (tmp___0 < 0) {
#line 184
    kfree((void const   *)cp);
#line 185
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 187
  return (cp);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void pvr2_ioread_destroy(struct pvr2_ioread *cp ) 
{ 


  {
#line 192
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 192
    return;
  } else {

  }
#line 193
  pvr2_ioread_done(cp);
#line 194
  if ((pvrusb2_debug & 2048) != 0) {
#line 194
    printk("\016pvrusb2: pvr2_ioread_destroy id=%p\n", cp);
  } else {

  }
#line 195
  if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 196
    kfree((void const   *)cp->sync_key_ptr);
#line 197
    cp->sync_key_ptr = (char *)0;
  } else {

  }
#line 199
  kfree((void const   *)cp);
#line 200
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void pvr2_ioread_set_sync_key(struct pvr2_ioread *cp , char const   *sync_key_ptr ,
                              unsigned int sync_key_len ) 
{ 
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 206
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 206
    return;
  } else {

  }
#line 208
  if ((unsigned long )sync_key_ptr == (unsigned long )((char const   *)0)) {
#line 208
    sync_key_len = 0U;
  } else {

  }
#line 209
  if (cp->sync_key_len == sync_key_len) {
#line 209
    if (sync_key_len == 0U) {
#line 211
      return;
    } else {
#line 209
      tmp = memcmp((void const   *)sync_key_ptr, (void const   *)cp->sync_key_ptr,
                   (size_t )sync_key_len);
#line 209
      if (tmp == 0) {
#line 211
        return;
      } else {

      }
    }
  } else {

  }
#line 213
  if (cp->sync_key_len != sync_key_len) {
#line 214
    if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 215
      kfree((void const   *)cp->sync_key_ptr);
#line 216
      cp->sync_key_ptr = (char *)0;
    } else {

    }
#line 218
    cp->sync_key_len = 0U;
#line 219
    if (sync_key_len != 0U) {
#line 220
      tmp___0 = kmalloc((size_t )sync_key_len, 208U);
#line 220
      cp->sync_key_ptr = (char *)tmp___0;
#line 221
      if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 222
        cp->sync_key_len = sync_key_len;
      } else {

      }
    } else {

    }
  } else {

  }
#line 226
  if (cp->sync_key_len == 0U) {
#line 226
    return;
  } else {

  }
#line 227
  __len = (size_t )cp->sync_key_len;
#line 227
  __ret = __builtin_memcpy((void *)cp->sync_key_ptr, (void const   *)sync_key_ptr,
                           __len);
#line 229
  return;
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static void pvr2_ioread_stop(struct pvr2_ioread *cp ) 
{ 


  {
#line 232
  if (cp->enabled == 0) {
#line 232
    return;
  } else {

  }
#line 233
  if ((pvrusb2_debug & 64) != 0) {
#line 233
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_stop id=%p\n", cp);
  } else {

  }
#line 235
  pvr2_stream_kill(cp->stream);
#line 236
  cp->c_buf = (struct pvr2_buffer *)0;
#line 237
  cp->c_data_ptr = (char *)0;
#line 238
  cp->c_data_len = 0U;
#line 239
  cp->c_data_offs = 0U;
#line 240
  cp->enabled = 0;
#line 241
  cp->stream_running = 0;
#line 242
  cp->spigot_open = 0;
#line 243
  if (cp->sync_state != 0U) {
#line 244
    if ((pvrusb2_debug & 33554432) != 0) {
#line 244
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 0\n");
    } else {

    }
#line 246
    cp->sync_state = 0U;
  } else {

  }
#line 248
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static int pvr2_ioread_start(struct pvr2_ioread *cp ) 
{ 
  int stat ;
  struct pvr2_buffer *bp ;

  {
#line 254
  if (cp->enabled != 0) {
#line 254
    return (0);
  } else {

  }
#line 255
  if ((unsigned long )cp->stream == (unsigned long )((struct pvr2_stream *)0)) {
#line 255
    return (0);
  } else {

  }
#line 256
  if ((pvrusb2_debug & 64) != 0) {
#line 256
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_start id=%p\n", cp);
  } else {

  }
#line 258
  goto ldv_30001;
  ldv_30000: 
#line 259
  stat = pvr2_buffer_queue(bp);
#line 260
  if (stat < 0) {
#line 261
    if ((pvrusb2_debug & 33554432) != 0) {
#line 261
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_start id=%p error=%d\n",
             cp, stat);
    } else {

    }
#line 266
    pvr2_ioread_stop(cp);
#line 267
    return (stat);
  } else {

  }
  ldv_30001: 
#line 258
  bp = pvr2_stream_get_idle_buffer(cp->stream);
#line 258
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 260
    goto ldv_30000;
  } else {

  }
#line 270
  cp->enabled = 1;
#line 271
  cp->c_buf = (struct pvr2_buffer *)0;
#line 272
  cp->c_data_ptr = (char *)0;
#line 273
  cp->c_data_len = 0U;
#line 274
  cp->c_data_offs = 0U;
#line 275
  cp->stream_running = 0;
#line 276
  if (cp->sync_key_len != 0U) {
#line 277
    if ((pvrusb2_debug & 33554432) != 0) {
#line 277
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 1\n");
    } else {

    }
#line 279
    cp->sync_state = 1U;
#line 280
    cp->sync_trashed_count = 0U;
#line 281
    cp->sync_buf_offs = 0U;
  } else {

  }
#line 283
  cp->spigot_open = 0;
#line 284
  return (0);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
struct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp ) 
{ 


  {
#line 289
  return (cp->stream);
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
int pvr2_ioread_setup(struct pvr2_ioread *cp , struct pvr2_stream *sp ) 
{ 
  int ret ;
  unsigned int idx ;
  struct pvr2_buffer *bp ;
  int tmp ;

  {
#line 298
  mutex_lock_nested(& cp->mutex, 0U);
#line 299
  if ((unsigned long )cp->stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 300
    if ((pvrusb2_debug & 64) != 0) {
#line 300
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_setup (tear-down) id=%p\n",
             cp);
    } else {

    }
#line 303
    pvr2_ioread_stop(cp);
#line 304
    pvr2_stream_kill(cp->stream);
#line 305
    tmp = pvr2_stream_get_buffer_count(cp->stream);
#line 305
    if (tmp != 0) {
#line 306
      pvr2_stream_set_buffer_count(cp->stream, 0U);
    } else {

    }
#line 308
    cp->stream = (struct pvr2_stream *)0;
  } else {

  }
#line 310
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 311
    if ((pvrusb2_debug & 64) != 0) {
#line 311
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_setup (setup) id=%p\n",
             cp);
    } else {

    }
#line 314
    pvr2_stream_kill(sp);
#line 315
    ret = pvr2_stream_set_buffer_count(sp, 32U);
#line 316
    if (ret < 0) {
#line 317
      mutex_unlock(& cp->mutex);
#line 318
      return (ret);
    } else {

    }
#line 320
    idx = 0U;
#line 320
    goto ldv_30014;
    ldv_30013: 
#line 321
    bp = pvr2_stream_get_buffer(sp, (int )idx);
#line 322
    pvr2_buffer_set_buffer(bp, (void *)cp->buffer_storage[idx], 16384U);
#line 320
    idx = idx + 1U;
    ldv_30014: ;
#line 320
    if (idx <= 31U) {
#line 322
      goto ldv_30013;
    } else {

    }
#line 326
    cp->stream = sp;
  } else {

  }
#line 328
  mutex_unlock(& cp->mutex);
#line 330
  return (0);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
int pvr2_ioread_set_enabled(struct pvr2_ioread *cp , int fl ) 
{ 
  int ret ;

  {
#line 335
  ret = 0;
#line 336
  if ((fl != 0) ^ (cp->enabled == 0)) {
#line 336
    return (ret);
  } else {

  }
#line 338
  mutex_lock_nested(& cp->mutex, 0U);
#line 339
  if (fl != 0) {
#line 340
    ret = pvr2_ioread_start(cp);
  } else {
#line 342
    pvr2_ioread_stop(cp);
  }
#line 344
  mutex_unlock(& cp->mutex);
#line 345
  return (ret);
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static int pvr2_ioread_get_buffer(struct pvr2_ioread *cp ) 
{ 
  int stat ;
  int tmp ;

  {
#line 352
  goto ldv_30026;
  ldv_30027: ;
#line 353
  if ((unsigned long )cp->c_buf != (unsigned long )((struct pvr2_buffer *)0)) {
#line 355
    stat = pvr2_buffer_queue(cp->c_buf);
#line 356
    if (stat < 0) {
#line 358
      if ((pvrusb2_debug & 33554432) != 0) {
#line 358
        printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p queue_error=%d\n",
               cp, stat);
      } else {

      }
#line 363
      pvr2_ioread_stop(cp);
#line 364
      return (0);
    } else {

    }
#line 366
    cp->c_buf = (struct pvr2_buffer *)0;
#line 367
    cp->c_data_ptr = (char *)0;
#line 368
    cp->c_data_len = 0U;
#line 369
    cp->c_data_offs = 0U;
  } else {

  }
#line 372
  cp->c_buf = pvr2_stream_get_ready_buffer(cp->stream);
#line 373
  if ((unsigned long )cp->c_buf == (unsigned long )((struct pvr2_buffer *)0)) {
#line 373
    goto ldv_30025;
  } else {

  }
#line 374
  cp->c_data_len = pvr2_buffer_get_count(cp->c_buf);
#line 375
  if (cp->c_data_len == 0U) {
#line 377
    stat = pvr2_buffer_get_status(cp->c_buf);
#line 378
    if (stat < 0) {
#line 380
      if ((pvrusb2_debug & 33554432) != 0) {
#line 380
        printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p buffer_error=%d\n",
               cp, stat);
      } else {

      }
#line 385
      pvr2_ioread_stop(cp);
#line 387
      return (0);
    } else {

    }
#line 390
    goto ldv_30026;
  } else {

  }
#line 392
  cp->c_data_offs = 0U;
#line 393
  tmp = pvr2_buffer_get_id(cp->c_buf);
#line 393
  cp->c_data_ptr = cp->buffer_storage[tmp];
  ldv_30026: ;
#line 352
  if (cp->c_data_len <= cp->c_data_offs) {
#line 354
    goto ldv_30027;
  } else {

  }
  ldv_30025: ;
#line 396
  return (1);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
static void pvr2_ioread_filter(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;
  int tmp ;

  {
#line 402
  if (cp->enabled == 0) {
#line 402
    return;
  } else {

  }
#line 403
  if (cp->sync_state != 1U) {
#line 403
    return;
  } else {

  }
#line 408
  mutex_lock_nested(& cp->mutex, 0U);
  ldv_30037: 
#line 410
  tmp = pvr2_ioread_get_buffer(cp);
#line 410
  if (tmp == 0) {
#line 410
    goto ldv_30032;
  } else {

  }
#line 411
  if (cp->c_data_len == 0U) {
#line 411
    goto ldv_30032;
  } else {

  }
#line 415
  idx = cp->c_data_offs;
#line 415
  goto ldv_30035;
  ldv_30034: ;
#line 416
  if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 416
    goto ldv_30033;
  } else {

  }
#line 417
  if ((int )((signed char )*(cp->c_data_ptr + (unsigned long )idx)) == (int )((signed char )*(cp->sync_key_ptr + (unsigned long )cp->sync_buf_offs))) {
#line 420
    cp->sync_buf_offs = cp->sync_buf_offs + 1U;
  } else {
#line 423
    cp->sync_buf_offs = 0U;
  }
#line 415
  idx = idx + 1U;
  ldv_30035: ;
#line 415
  if (cp->c_data_len > idx) {
#line 417
    goto ldv_30034;
  } else {

  }
  ldv_30033: 
#line 428
  cp->c_data_offs = cp->c_data_offs + idx;
#line 429
  cp->sync_trashed_count = cp->sync_trashed_count + idx;
#line 432
  if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 433
    cp->sync_trashed_count = cp->sync_trashed_count - cp->sync_key_len;
#line 434
    if ((pvrusb2_debug & 33554432) != 0) {
#line 434
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 2 (skipped %u bytes)\n",
             cp->sync_trashed_count);
    } else {

    }
#line 438
    cp->sync_state = 2U;
#line 439
    cp->sync_buf_offs = 0U;
#line 440
    goto ldv_30032;
  } else {

  }
#line 443
  if (cp->c_data_offs < cp->c_data_len) {
#line 445
    if ((pvrusb2_debug & 2) != 0) {
#line 445
      printk("\016pvrusb2: OLD_ERROR: pvr2_ioread filter sync problem len=%u offs=%u\n",
             cp->c_data_len, cp->c_data_offs);
    } else {

    }
#line 451
    goto ldv_30032;
  } else {

  }
#line 454
  goto ldv_30036;
  ldv_30036: ;
#line 455
  goto ldv_30037;
  ldv_30032: 
#line 455
  mutex_unlock(& cp->mutex);
#line 456
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
int pvr2_ioread_avail(struct pvr2_ioread *cp ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 461
  if (cp->enabled == 0) {
#line 463
    return (-5);
  } else {

  }
#line 466
  if (cp->sync_state == 1U) {
#line 467
    pvr2_ioread_filter(cp);
#line 468
    if (cp->sync_state == 1U) {
#line 468
      return (-11);
    } else {

    }
  } else {

  }
#line 471
  ret = 0;
#line 472
  if (cp->stream_running != 0) {
#line 473
    tmp = pvr2_stream_get_ready_count(cp->stream);
#line 473
    if (tmp == 0) {
#line 475
      ret = -11;
    } else {

    }
  } else {
#line 478
    tmp___0 = pvr2_stream_get_ready_count(cp->stream);
#line 478
    if (tmp___0 <= 15) {
#line 480
      ret = -11;
    } else {

    }
  }
#line 484
  if ((cp->spigot_open == 0) ^ (ret != 0)) {
#line 485
    cp->spigot_open = ret == 0;
#line 486
    if ((pvrusb2_debug & 33554432) != 0) {
#line 486
      printk("\016pvrusb2: /*---TRACE_READ---*/ data is %s\n", cp->spigot_open != 0 ? (char *)"available" : (char *)"pending");
    } else {

    }
  } else {

  }
#line 491
  return (ret);
}
}
#line 494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
int pvr2_ioread_read(struct pvr2_ioread *cp , void *buf , unsigned int cnt ) 
{ 
  unsigned int copied_cnt ;
  unsigned int bcnt ;
  char const   *src ;
  int stat ;
  int ret ;
  unsigned int req_cnt ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 500
  ret = 0;
#line 501
  req_cnt = cnt;
#line 503
  if (cnt == 0U) {
#line 504
    if ((pvrusb2_debug & 8) != 0) {
#line 504
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p ZERO Request? Returning zero.\n",
             cp);
    } else {

    }
#line 507
    return (0);
  } else {

  }
#line 510
  stat = pvr2_ioread_avail(cp);
#line 511
  if (stat < 0) {
#line 511
    return (stat);
  } else {

  }
#line 513
  cp->stream_running = 1;
#line 515
  mutex_lock_nested(& cp->mutex, 0U);
#line 518
  copied_cnt = 0U;
#line 519
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 519
    cnt = 0U;
  } else {

  }
  ldv_30054: 
#line 521
  tmp = pvr2_ioread_get_buffer(cp);
#line 521
  if (tmp == 0) {
#line 522
    ret = -5;
#line 523
    goto ldv_30053;
  } else {

  }
#line 526
  if (cnt == 0U) {
#line 526
    goto ldv_30053;
  } else {

  }
#line 528
  if (cp->sync_state == 2U) {
#line 531
    src = (char const   *)cp->sync_key_ptr + (unsigned long )cp->sync_buf_offs;
#line 532
    bcnt = cp->sync_key_len - cp->sync_buf_offs;
  } else {
#line 535
    src = (char const   *)cp->c_data_ptr + (unsigned long )cp->c_data_offs;
#line 536
    bcnt = cp->c_data_len - cp->c_data_offs;
  }
#line 539
  if (bcnt == 0U) {
#line 539
    goto ldv_30053;
  } else {

  }
#line 542
  if (bcnt > cnt) {
#line 542
    bcnt = cnt;
  } else {

  }
#line 544
  tmp___0 = copy_to_user(buf, (void const   *)src, (unsigned long )bcnt);
#line 544
  if (tmp___0 != 0UL) {
#line 548
    ret = -14;
#line 549
    goto ldv_30053;
  } else {

  }
#line 551
  cnt = cnt - bcnt;
#line 552
  buf = buf + (unsigned long )bcnt;
#line 553
  copied_cnt = copied_cnt + bcnt;
#line 555
  if (cp->sync_state == 2U) {
#line 558
    cp->sync_buf_offs = cp->sync_buf_offs + bcnt;
#line 559
    if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 562
      if ((pvrusb2_debug & 33554432) != 0) {
#line 562
        printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 0\n");
      } else {

      }
#line 565
      cp->sync_state = 0U;
    } else {

    }
  } else {
#line 569
    cp->c_data_offs = cp->c_data_offs + bcnt;
  }
#line 571
  goto ldv_30054;
  ldv_30053: 
#line 573
  mutex_unlock(& cp->mutex);
#line 575
  if (ret == 0) {
#line 576
    if (copied_cnt != 0U) {
#line 578
      ret = (int )copied_cnt;
    } else {
#line 582
      ret = -11;
    }
  } else {

  }
#line 586
  if ((pvrusb2_debug & 33554432) != 0) {
#line 586
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p request=%d result=%d\n",
           cp, req_cnt, ret);
  } else {

  }
#line 590
  return (ret);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void *ldv_kmem_cache_alloc_520(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 723
  ldv_check_alloc_flags(flags);
#line 725
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 726
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_539(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_547(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_555(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_549(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_545(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_553(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_554(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_550(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_551(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_552(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme_item  const  routing_scheme0___1[5U]  = {      {7, 8}, 
        {0, 0}, 
        {3, 0}, 
        {1296, 0}, 
        {3, 0}};
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme___0  const  routing_def0___1  =    {(struct routing_scheme_item  const  *)(& routing_scheme0___1), 5U};
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme_item  const  routing_schemegv[5U]  = {      {2, 5}, 
        {0, 0}, 
        {1, 0}, 
        {1072, 0}, 
        {1, 0}};
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme___0  const  routing_defgv  =    {(struct routing_scheme_item  const  *)(& routing_schemegv), 5U};
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme_item  const  routing_schemeav400[4U]  = {      {0, 0}, 
        {0, 0}, 
        {1, 0}, 
        {1056, 0}};
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme___0  const  routing_defav400  =    {(struct routing_scheme_item  const  *)(& routing_schemeav400), 4U};
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
static struct routing_scheme___0  const  *routing_schemes___1[4U]  = {      & routing_def0___1,      & routing_defgv,      0,      & routing_defav400};
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void pvr2_cx25840_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  enum cx25840_video_input vid_input ;
  enum cx25840_audio_input aud_input ;
  struct routing_scheme___0  const  *sp ;
  unsigned int sid ;

  {
#line 217
  if ((pvrusb2_debug & 65536) != 0) {
#line 217
    printk("\016pvrusb2: subdev cx2584x update...\n");
  } else {

  }
#line 218
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 222
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 224
    sp = sid <= 3U ? routing_schemes___1[sid] : (struct routing_scheme___0  const  *)0;
#line 226
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme___0  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 229
      if ((pvrusb2_debug & 2) != 0) {
#line 229
        printk("\016pvrusb2: *** WARNING *** subdev cx2584x set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 234
      return;
    } else {

    }
#line 236
    vid_input = (enum cx25840_video_input )(sp->def + (unsigned long )hdw->input_val)->vid;
#line 237
    aud_input = (enum cx25840_audio_input )(sp->def + (unsigned long )hdw->input_val)->aud;
#line 238
    if ((pvrusb2_debug & 65536) != 0) {
#line 238
      printk("\016pvrusb2: subdev cx2584x set_input vid=0x%x aud=0x%x\n", (unsigned int )vid_input,
             (unsigned int )aud_input);
    } else {

    }
#line 241
    (*(((sd->ops)->video)->s_routing))(sd, (unsigned int )vid_input, 0U, 0U);
#line 242
    (*(((sd->ops)->audio)->s_routing))(sd, (unsigned int )aud_input, 0U, 0U);
  } else {

  }
#line 244
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void *ldv_kmem_cache_alloc_539(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 376
  ldv_check_alloc_flags(flags);
#line 378
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 379
  return ((void *)0);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
int ldv_pskb_expand_head_545(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 420
  ldv_check_alloc_flags(flags);
#line 422
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 422
  return (tmp);
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv_skb_clone_547(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 436
  ldv_check_alloc_flags(flags);
#line 438
  tmp = skb_clone(ldv_func_arg1, flags);
#line 438
  return (tmp);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv_skb_copy_549(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 454
  tmp = skb_copy(ldv_func_arg1, flags);
#line 454
  return (tmp);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_550(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 460
  ldv_check_alloc_flags(flags);
#line 462
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 462
  return (tmp);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_551(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 468
  ldv_check_alloc_flags(flags);
#line 470
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 470
  return (tmp);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_552(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 476
  ldv_check_alloc_flags(flags);
#line 478
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 478
  return (tmp);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
int ldv_pskb_expand_head_553(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 484
  ldv_check_alloc_flags(flags);
#line 486
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 486
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
int ldv_pskb_expand_head_554(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 492
  ldv_check_alloc_flags(flags);
#line 494
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 494
  return (tmp);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
struct sk_buff *ldv_skb_clone_555(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 500
  ldv_check_alloc_flags(flags);
#line 502
  tmp = skb_clone(ldv_func_arg1, flags);
#line 502
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_581(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_589(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_597(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_591(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_587(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_595(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_596(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_592(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_593(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_594(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void pvr2_wm8775_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  u32 input ;

  {
#line 130
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 133
    switch (hdw->input_val) {
    case 4: 
#line 135
    input = 1U;
#line 136
    goto ldv_49743;
    default: 
#line 139
    input = 2U;
#line 140
    goto ldv_49743;
    }
    ldv_49743: ;
#line 142
    if ((pvrusb2_debug & 65536) != 0) {
#line 142
      printk("\016pvrusb2: subdev wm8775 set_input(val=%d route=0x%x)\n", hdw->input_val,
             input);
    } else {

    }
#line 146
    (*(((sd->ops)->audio)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 148
  return;
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void *ldv_kmem_cache_alloc_581(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 280
  ldv_check_alloc_flags(flags);
#line 282
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 283
  return ((void *)0);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
int ldv_pskb_expand_head_587(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 324
  ldv_check_alloc_flags(flags);
#line 326
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 326
  return (tmp);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv_skb_clone_589(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 340
  ldv_check_alloc_flags(flags);
#line 342
  tmp = skb_clone(ldv_func_arg1, flags);
#line 342
  return (tmp);
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv_skb_copy_591(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 356
  ldv_check_alloc_flags(flags);
#line 358
  tmp = skb_copy(ldv_func_arg1, flags);
#line 358
  return (tmp);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_592(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 364
  ldv_check_alloc_flags(flags);
#line 366
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 366
  return (tmp);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_593(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 372
  ldv_check_alloc_flags(flags);
#line 374
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 374
  return (tmp);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_594(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 380
  ldv_check_alloc_flags(flags);
#line 382
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 382
  return (tmp);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
int ldv_pskb_expand_head_595(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 390
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 390
  return (tmp);
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
int ldv_pskb_expand_head_596(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 396
  ldv_check_alloc_flags(flags);
#line 398
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 398
  return (tmp);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
struct sk_buff *ldv_skb_clone_597(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 404
  ldv_check_alloc_flags(flags);
#line 406
  tmp = skb_clone(ldv_func_arg1, flags);
#line 406
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_623(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_631(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_639(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_633(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_637(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_638(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_634(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_635(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_636(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
static int const   routing_scheme1___0[5U]  = {      2,      0,      0,      0, 
        2};
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
static struct routing_scheme  const  routing_def1___0  =    {(int const   *)(& routing_scheme1___0), 5U};
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
static struct routing_scheme  const  *routing_schemes___2[3U]  = {      0,      0,      & routing_def1___0};
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void pvr2_cs53l32a_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 153
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 155
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 157
    if ((pvrusb2_debug & 65536) != 0) {
#line 157
      printk("\016pvrusb2: subdev v4l2 set_input(%d)\n", hdw->input_val);
    } else {

    }
#line 159
    sp = sid <= 2U ? routing_schemes___2[sid] : (struct routing_scheme  const  *)0;
#line 161
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 164
      if ((pvrusb2_debug & 2) != 0) {
#line 164
        printk("\016pvrusb2: *** WARNING *** subdev v4l2 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 169
      return;
    } else {

    }
#line 171
    input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
#line 172
    (*(((sd->ops)->audio)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 174
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void *ldv_kmem_cache_alloc_623(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 306
  ldv_check_alloc_flags(flags);
#line 308
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 309
  return ((void *)0);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 350
  ldv_check_alloc_flags(flags);
#line 352
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 352
  return (tmp);
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv_skb_clone_631(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 366
  ldv_check_alloc_flags(flags);
#line 368
  tmp = skb_clone(ldv_func_arg1, flags);
#line 368
  return (tmp);
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv_skb_copy_633(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 382
  ldv_check_alloc_flags(flags);
#line 384
  tmp = skb_copy(ldv_func_arg1, flags);
#line 384
  return (tmp);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_634(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 390
  ldv_check_alloc_flags(flags);
#line 392
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 392
  return (tmp);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_635(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 398
  ldv_check_alloc_flags(flags);
#line 400
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 400
  return (tmp);
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_636(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 406
  ldv_check_alloc_flags(flags);
#line 408
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 408
  return (tmp);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
int ldv_pskb_expand_head_637(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 414
  ldv_check_alloc_flags(flags);
#line 416
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 416
  return (tmp);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
int ldv_pskb_expand_head_638(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 422
  ldv_check_alloc_flags(flags);
#line 424
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 424
  return (tmp);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
struct sk_buff *ldv_skb_clone_639(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 432
  tmp = skb_clone(ldv_func_arg1, flags);
#line 432
  return (tmp);
}
}
#line 165 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3067: ;
#line 14
  return (pfo_ret__);
}
}
#line 28 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 30
  return ((long )ptr);
}
}
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 27
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 54 "include/linux/debug_locks.h"
extern void debug_check_no_locks_held(void) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_665(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 12 "include/linux/freezer.h"
extern atomic_t system_freezing_cnt ;
#line 29
extern bool freezing_slow_path(struct task_struct * ) ;
#line 34 "include/linux/freezer.h"
__inline static bool freezing(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 36
  tmp = atomic_read((atomic_t const   *)(& system_freezing_cnt));
#line 36
  tmp___0 = ldv__builtin_expect(tmp == 0, 1L);
#line 36
  if (tmp___0 != 0L) {
#line 37
    return (0);
  } else {

  }
#line 38
  tmp___1 = freezing_slow_path(p);
#line 38
  return (tmp___1);
}
}
#line 44
extern bool __refrigerator(bool  ) ;
#line 54 "include/linux/freezer.h"
__inline static bool try_to_freeze_unsafe(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 56
  __might_sleep("include/linux/freezer.h", 56, 0);
#line 57
  tmp = get_current();
#line 57
  tmp___0 = freezing(tmp);
#line 57
  if (tmp___0) {
#line 57
    tmp___1 = 0;
  } else {
#line 57
    tmp___1 = 1;
  }
#line 57
  tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 57
  if (tmp___2 != 0L) {
#line 58
    return (0);
  } else {

  }
#line 59
  tmp___3 = __refrigerator(0);
#line 59
  return (tmp___3);
}
}
#line 62 "include/linux/freezer.h"
__inline static bool try_to_freeze(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;

  {
#line 64
  tmp = get_current();
#line 64
  if ((tmp->flags & 32768U) == 0U) {
#line 65
    debug_check_no_locks_held();
  } else {

  }
#line 66
  tmp___0 = try_to_freeze_unsafe();
#line 66
  return (tmp___0);
}
}
#line 70
extern bool set_freezable(void) ;
#line 99 "drivers/media/dvb-core/dvbdev.h"
extern int dvb_register_adapter(struct dvb_adapter * , char const   * , struct module * ,
                                struct device * , short * ) ;
#line 102
extern int dvb_unregister_adapter(struct dvb_adapter * ) ;
#line 423 "drivers/media/dvb-core/dvb_frontend.h"
extern int dvb_register_frontend(struct dvb_adapter * , struct dvb_frontend * ) ;
#line 426
extern int dvb_unregister_frontend(struct dvb_frontend * ) ;
#line 428
extern void dvb_frontend_detach(struct dvb_frontend * ) ;
#line 141 "drivers/media/dvb-core/dvb_demux.h"
extern int dvb_dmx_init(struct dvb_demux * ) ;
#line 142
extern void dvb_dmx_release(struct dvb_demux * ) ;
#line 145
extern void dvb_dmx_swfilter(struct dvb_demux * , u8 const   * , size_t  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_673(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_681(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_675(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_671(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_679(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_680(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_676(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_677(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_678(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 46 "drivers/media/dvb-core/dvb_net.h"
extern void dvb_net_release(struct dvb_net * ) ;
#line 47
extern int dvb_net_init(struct dvb_adapter * , struct dvb_net * , struct dmx_demux * ) ;
#line 116 "drivers/media/dvb-core/dmxdev.h"
extern int dvb_dmxdev_init(struct dmxdev * , struct dvb_adapter * ) ;
#line 117
extern void dvb_dmxdev_release(struct dmxdev * ) ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static short adapter_nr[8U]  = 
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_feed_func(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;
  unsigned int count ;
  struct pvr2_buffer *bp ;
  struct pvr2_stream *stream ;
  bool tmp ;
  int tmp___0 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 131
  if ((pvrusb2_debug & 268435456) != 0) {
#line 131
    printk("\016pvrusb2: dvb feed thread started\n");
  } else {

  }
#line 132
  set_freezable();
#line 134
  stream = (adap->channel.stream)->stream;
  ldv_49847: 
#line 137
  tmp = kthread_should_stop();
#line 137
  if ((int )tmp) {
#line 137
    goto ldv_49836;
  } else {

  }
#line 140
  try_to_freeze();
#line 142
  bp = pvr2_stream_get_ready_buffer(stream);
#line 143
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 144
    count = pvr2_buffer_get_count(bp);
#line 145
    if (count != 0U) {
#line 146
      tmp___0 = pvr2_buffer_get_id(bp);
#line 146
      dvb_dmx_swfilter(& adap->demux, (u8 const   *)adap->buffer_storage[tmp___0],
                       (size_t )count);
    } else {
#line 152
      ret = pvr2_buffer_get_status(bp);
#line 153
      if (ret < 0) {
#line 153
        goto ldv_49836;
      } else {

      }
    }
#line 155
    ret = pvr2_buffer_queue(bp);
#line 156
    if (ret < 0) {
#line 156
      goto ldv_49836;
    } else {

    }
#line 162
    goto ldv_49837;
  } else {

  }
#line 168
  __ret = 0;
#line 168
  tmp___4 = pvr2_stream_get_ready_count(stream);
#line 168
  if (tmp___4 <= 0) {
#line 168
    tmp___5 = kthread_should_stop();
#line 168
    if (tmp___5) {
#line 168
      tmp___6 = 0;
    } else {
#line 168
      tmp___6 = 1;
    }
#line 168
    if (tmp___6) {
#line 168
      __ret___0 = 0L;
#line 168
      INIT_LIST_HEAD(& __wait.task_list);
#line 168
      __wait.flags = 0U;
      ldv_49844: 
#line 168
      tmp___1 = prepare_to_wait_event(& adap->buffer_wait_data, & __wait, 1);
#line 168
      __int = tmp___1;
#line 168
      tmp___2 = pvr2_stream_get_ready_count(stream);
#line 168
      if (tmp___2 > 0) {
#line 168
        goto ldv_49843;
      } else {
#line 168
        tmp___3 = kthread_should_stop();
#line 168
        if ((int )tmp___3) {
#line 168
          goto ldv_49843;
        } else {

        }
      }
#line 168
      if (__int != 0L) {
#line 168
        __ret___0 = __int;
#line 168
        goto ldv_49843;
      } else {

      }
#line 168
      schedule();
#line 168
      goto ldv_49844;
      ldv_49843: 
#line 168
      finish_wait(& adap->buffer_wait_data, & __wait);
#line 168
      __ret = (int )__ret___0;
    } else {

    }
  } else {

  }
#line 168
  ret = __ret;
#line 172
  if (ret < 0) {
#line 172
    goto ldv_49836;
  } else {

  }
  ldv_49837: ;
#line 173
  goto ldv_49847;
  ldv_49836: ;
#line 178
  if ((pvrusb2_debug & 268435456) != 0) {
#line 178
    printk("\016pvrusb2: dvb feed thread stopped\n");
  } else {

  }
#line 180
  return (0);
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_feed_thread(void *data ) 
{ 
  int stat ;
  int tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;

  {
#line 185
  tmp = pvr2_dvb_feed_func((struct pvr2_dvb_adapter *)data);
#line 185
  stat = tmp;
#line 187
  goto ldv_49861;
  ldv_49860: 
#line 188
  __ret = 1L;
#line 188
  switch (8UL) {
  case 1UL: 
#line 188
  tmp___0 = get_current();
#line 188
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 188
  goto ldv_49854;
  case 2UL: 
#line 188
  tmp___1 = get_current();
#line 188
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 188
  goto ldv_49854;
  case 4UL: 
#line 188
  tmp___2 = get_current();
#line 188
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 188
  goto ldv_49854;
  case 8UL: 
#line 188
  tmp___3 = get_current();
#line 188
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 188
  goto ldv_49854;
  default: 
#line 188
  __xchg_wrong_size();
  }
  ldv_49854: 
#line 189
  schedule();
  ldv_49861: 
#line 187
  tmp___4 = kthread_should_stop();
#line 187
  if (tmp___4) {
#line 187
    tmp___5 = 0;
  } else {
#line 187
    tmp___5 = 1;
  }
#line 187
  if (tmp___5) {
#line 189
    goto ldv_49860;
  } else {

  }

#line 191
  return (stat);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 196
  __wake_up(& adap->buffer_wait_data, 3U, 1, (void *)0);
#line 197
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static void pvr2_dvb_stream_end(struct pvr2_dvb_adapter *adap ) 
{ 
  unsigned int idx ;
  struct pvr2_stream *stream ;

  {
#line 204
  if ((unsigned long )adap->thread != (unsigned long )((struct task_struct *)0)) {
#line 205
    kthread_stop(adap->thread);
#line 206
    adap->thread = (struct task_struct *)0;
  } else {

  }
#line 209
  if ((unsigned long )adap->channel.stream != (unsigned long )((struct pvr2_context_stream *)0)) {
#line 210
    stream = (adap->channel.stream)->stream;
  } else {
#line 212
    stream = (struct pvr2_stream *)0;
  }
#line 214
  if ((unsigned long )stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 215
    pvr2_hdw_set_streaming(adap->channel.hdw, 0);
#line 216
    pvr2_stream_set_callback(stream, (void (*)(void * ))0, (void *)0);
#line 217
    pvr2_stream_kill(stream);
#line 218
    pvr2_stream_set_buffer_count(stream, 0U);
#line 219
    pvr2_channel_claim_stream(& adap->channel, (struct pvr2_context_stream *)0);
  } else {

  }
#line 222
  if ((unsigned int )*((unsigned char *)adap + 2272UL) != 0U) {
#line 223
    idx = 0U;
#line 223
    goto ldv_49873;
    ldv_49872: ;
#line 224
    if ((unsigned long )adap->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 224
      goto ldv_49871;
    } else {

    }
#line 225
    kfree((void const   *)adap->buffer_storage[idx]);
#line 226
    adap->buffer_storage[idx] = (char *)0;
    ldv_49871: 
#line 223
    idx = idx + 1U;
    ldv_49873: ;
#line 223
    if (idx <= 31U) {
#line 225
      goto ldv_49872;
    } else {

    }
#line 228
    adap->stream_run = 0U;
  } else {

  }
#line 230
  return;
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_stream_do_start(struct pvr2_dvb_adapter *adap ) 
{ 
  struct pvr2_context *pvr ;
  unsigned int idx ;
  int ret ;
  struct pvr2_buffer *bp ;
  struct pvr2_stream *stream ;
  void *tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;

  {
#line 234
  pvr = adap->channel.mc_head;
#line 238
  stream = (struct pvr2_stream *)0;
#line 240
  if ((unsigned int )*((unsigned char *)adap + 2272UL) != 0U) {
#line 240
    return (-5);
  } else {

  }
#line 242
  ret = pvr2_channel_claim_stream(& adap->channel, & pvr->video_stream);
#line 244
  if (ret < 0) {
#line 244
    return (ret);
  } else {

  }
#line 246
  stream = (adap->channel.stream)->stream;
#line 248
  idx = 0U;
#line 248
  goto ldv_49884;
  ldv_49883: 
#line 249
  tmp = kmalloc(16384UL, 208U);
#line 249
  adap->buffer_storage[idx] = (char *)tmp;
#line 251
  if ((unsigned long )adap->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 251
    return (-12);
  } else {

  }
#line 248
  idx = idx + 1U;
  ldv_49884: ;
#line 248
  if (idx <= 31U) {
#line 250
    goto ldv_49883;
  } else {

  }
#line 254
  pvr2_stream_set_callback(pvr->video_stream.stream, (void (*)(void * ))(& pvr2_dvb_notify),
                           (void *)adap);
#line 257
  ret = pvr2_stream_set_buffer_count(stream, 32U);
#line 258
  if (ret < 0) {
#line 258
    return (ret);
  } else {

  }
#line 260
  idx = 0U;
#line 260
  goto ldv_49887;
  ldv_49886: 
#line 261
  bp = pvr2_stream_get_buffer(stream, (int )idx);
#line 262
  pvr2_buffer_set_buffer(bp, (void *)adap->buffer_storage[idx], 16384U);
#line 260
  idx = idx + 1U;
  ldv_49887: ;
#line 260
  if (idx <= 31U) {
#line 262
    goto ldv_49886;
  } else {

  }
#line 267
  ret = pvr2_hdw_set_streaming(adap->channel.hdw, 1);
#line 268
  if (ret < 0) {
#line 268
    return (ret);
  } else {

  }
#line 270
  goto ldv_49890;
  ldv_49889: 
#line 271
  ret = pvr2_buffer_queue(bp);
#line 272
  if (ret < 0) {
#line 272
    return (ret);
  } else {

  }
  ldv_49890: 
#line 270
  bp = pvr2_stream_get_idle_buffer(stream);
#line 270
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 272
    goto ldv_49889;
  } else {

  }
#line 275
  tmp___0 = kthread_create_on_node(& pvr2_dvb_feed_thread, (void *)adap, -1, "pvrusb2-dvb");
#line 275
  __k = tmp___0;
#line 275
  tmp___1 = IS_ERR((void const   *)__k);
#line 275
  if (tmp___1) {
#line 275
    tmp___2 = 0;
  } else {
#line 275
    tmp___2 = 1;
  }
#line 275
  if (tmp___2) {
#line 275
    wake_up_process(__k);
  } else {

  }
#line 275
  adap->thread = __k;
#line 277
  tmp___4 = IS_ERR((void const   *)adap->thread);
#line 277
  if ((int )tmp___4) {
#line 278
    tmp___3 = PTR_ERR((void const   *)adap->thread);
#line 278
    ret = (int )tmp___3;
#line 279
    adap->thread = (struct task_struct *)0;
#line 280
    return (ret);
  } else {

  }
#line 283
  adap->stream_run = 1U;
#line 285
  return (0);
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_stream_start(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;
  int tmp ;

  {
#line 290
  tmp = pvr2_dvb_stream_do_start(adap);
#line 290
  ret = tmp;
#line 291
  if (ret < 0) {
#line 291
    pvr2_dvb_stream_end(adap);
  } else {

  }
#line 292
  return (ret);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed , int onoff ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  int ret ;

  {
#line 297
  adap = (struct pvr2_dvb_adapter *)(dvbdmxfeed->demux)->priv;
#line 298
  ret = 0;
#line 300
  if ((unsigned long )adap == (unsigned long )((struct pvr2_dvb_adapter *)0)) {
#line 300
    return (-19);
  } else {

  }
#line 302
  mutex_lock_nested(& adap->lock, 0U);
#line 304
  if (onoff != 0) {
#line 305
    if (adap->feedcount == 0) {
#line 306
      if ((pvrusb2_debug & 268435456) != 0) {
#line 306
        printk("\016pvrusb2: start feeding demux\n");
      } else {

      }
#line 308
      ret = pvr2_dvb_stream_start(adap);
#line 309
      if (ret < 0) {
#line 309
        goto ldv_49904;
      } else {

      }
    } else {

    }
#line 311
    adap->feedcount = adap->feedcount + 1;
  } else
#line 312
  if (adap->feedcount > 0) {
#line 313
    adap->feedcount = adap->feedcount - 1;
#line 314
    if (adap->feedcount == 0) {
#line 315
      if ((pvrusb2_debug & 268435456) != 0) {
#line 315
        printk("\016pvrusb2: stop feeding demux\n");
      } else {

      }
#line 317
      pvr2_dvb_stream_end(adap);
    } else {

    }
  } else {

  }
  ldv_49904: 
#line 321
  mutex_unlock(& adap->lock);
#line 323
  return (ret);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed ) 
{ 
  int tmp ;

  {
#line 328
  if ((pvrusb2_debug & 268435456) != 0) {
#line 328
    printk("\016pvrusb2: start pid: 0x%04x\n", (int )dvbdmxfeed->pid);
  } else {

  }
#line 329
  tmp = pvr2_dvb_ctrl_feed(dvbdmxfeed, 1);
#line 329
  return (tmp);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed ) 
{ 
  int tmp ;

  {
#line 334
  if ((pvrusb2_debug & 268435456) != 0) {
#line 334
    printk("\016pvrusb2: stop pid: 0x%04x\n", (int )dvbdmxfeed->pid);
  } else {

  }
#line 335
  tmp = pvr2_dvb_ctrl_feed(dvbdmxfeed, 0);
#line 335
  return (tmp);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_bus_ctrl(struct dvb_frontend *fe , int acquire ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  int tmp ;

  {
#line 340
  adap = (struct pvr2_dvb_adapter *)(fe->dvb)->priv;
#line 341
  tmp = pvr2_channel_limit_inputs(& adap->channel, acquire != 0 ? 2U : 0U);
#line 341
  return (tmp);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_adapter_init(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;

  {
#line 350
  ret = dvb_register_adapter(& adap->dvb_adap, "pvrusb2-dvb", & __this_module, & ((adap->channel.hdw)->usb_dev)->dev,
                             (short *)(& adapter_nr));
#line 354
  if (ret < 0) {
#line 355
    if ((pvrusb2_debug & 2) != 0) {
#line 355
      printk("\016pvrusb2: dvb_register_adapter failed: error %d\n", ret);
    } else {

    }
#line 357
    goto err;
  } else {

  }
#line 359
  adap->dvb_adap.priv = (void *)adap;
#line 361
  adap->demux.dmx.capabilities = 13U;
#line 364
  adap->demux.priv = (void *)adap;
#line 365
  adap->demux.filternum = 256;
#line 366
  adap->demux.feednum = 256;
#line 367
  adap->demux.start_feed = & pvr2_dvb_start_feed;
#line 368
  adap->demux.stop_feed = & pvr2_dvb_stop_feed;
#line 369
  adap->demux.write_to_decoder = (int (*)(struct dvb_demux_feed * , u8 const   * ,
                                          size_t  ))0;
#line 371
  ret = dvb_dmx_init(& adap->demux);
#line 372
  if (ret < 0) {
#line 373
    if ((pvrusb2_debug & 2) != 0) {
#line 373
      printk("\016pvrusb2: dvb_dmx_init failed: error %d\n", ret);
    } else {

    }
#line 375
    goto err_dmx;
  } else {

  }
#line 378
  adap->dmxdev.filternum = adap->demux.filternum;
#line 379
  adap->dmxdev.demux = & adap->demux.dmx;
#line 380
  adap->dmxdev.capabilities = 0;
#line 382
  ret = dvb_dmxdev_init(& adap->dmxdev, & adap->dvb_adap);
#line 383
  if (ret < 0) {
#line 384
    if ((pvrusb2_debug & 2) != 0) {
#line 384
      printk("\016pvrusb2: dvb_dmxdev_init failed: error %d\n", ret);
    } else {

    }
#line 386
    goto err_dmx_dev;
  } else {

  }
#line 389
  dvb_net_init(& adap->dvb_adap, & adap->dvb_net, & adap->demux.dmx);
#line 391
  return (0);
  err_dmx_dev: 
#line 394
  dvb_dmx_release(& adap->demux);
  err_dmx: 
#line 396
  dvb_unregister_adapter(& adap->dvb_adap);
  err: ;
#line 398
  return (ret);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_adapter_exit(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 403
  if (pvrusb2_debug & 1) {
#line 403
    printk("\016pvrusb2: unregistering DVB devices\n");
  } else {

  }
#line 404
  dvb_net_release(& adap->dvb_net);
#line 405
  (*(adap->demux.dmx.close))(& adap->demux.dmx);
#line 406
  dvb_dmxdev_release(& adap->dmxdev);
#line 407
  dvb_dmx_release(& adap->demux);
#line 408
  dvb_unregister_adapter(& adap->dvb_adap);
#line 409
  return (0);
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_frontend_init(struct pvr2_dvb_adapter *adap ) 
{ 
  struct pvr2_hdw *hdw ;
  struct pvr2_dvb_props  const  *dvb_props ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 414
  hdw = adap->channel.hdw;
#line 415
  dvb_props = (hdw->hdw_desc)->dvb_props;
#line 416
  ret = 0;
#line 418
  if ((unsigned long )dvb_props == (unsigned long )((struct pvr2_dvb_props  const  *)0)) {
#line 419
    if ((pvrusb2_debug & 2) != 0) {
#line 419
      printk("\016pvrusb2: fe_props not defined!\n");
    } else {

    }
#line 420
    return (-22);
  } else {

  }
#line 423
  ret = pvr2_channel_limit_inputs(& adap->channel, 2U);
#line 426
  if (ret != 0) {
#line 427
    if ((pvrusb2_debug & 2) != 0) {
#line 427
      printk("\016pvrusb2: failed to grab control of dtv input (code=%d)\n", ret);
    } else {

    }
#line 430
    return (ret);
  } else {

  }
#line 433
  if ((unsigned long )dvb_props->frontend_attach == (unsigned long )((int (*/* const  */)(struct pvr2_dvb_adapter * ))0)) {
#line 434
    if ((pvrusb2_debug & 2) != 0) {
#line 434
      printk("\016pvrusb2: frontend_attach not defined!\n");
    } else {

    }
#line 436
    ret = -22;
#line 437
    goto done;
  } else {

  }
#line 440
  tmp___0 = (*(dvb_props->frontend_attach))(adap);
#line 440
  if (tmp___0 == 0 && (unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 442
    tmp = dvb_register_frontend(& adap->dvb_adap, adap->fe);
#line 442
    if (tmp != 0) {
#line 443
      if ((pvrusb2_debug & 2) != 0) {
#line 443
        printk("\016pvrusb2: frontend registration failed!\n");
      } else {

      }
#line 445
      dvb_frontend_detach(adap->fe);
#line 446
      adap->fe = (struct dvb_frontend *)0;
#line 447
      ret = -19;
#line 448
      goto done;
    } else {

    }
#line 451
    if ((unsigned long )dvb_props->tuner_attach != (unsigned long )((int (*/* const  */)(struct pvr2_dvb_adapter * ))0)) {
#line 452
      (*(dvb_props->tuner_attach))(adap);
    } else {

    }
#line 454
    if ((unsigned long )(adap->fe)->ops.analog_ops.standby != (unsigned long )((void (*)(struct dvb_frontend * ))0)) {
#line 455
      (*((adap->fe)->ops.analog_ops.standby))(adap->fe);
    } else {

    }
#line 458
    (adap->fe)->ops.ts_bus_ctrl = & pvr2_dvb_bus_ctrl;
  } else {
#line 461
    if ((pvrusb2_debug & 2) != 0) {
#line 461
      printk("\016pvrusb2: no frontend was attached!\n");
    } else {

    }
#line 463
    ret = -19;
#line 464
    return (ret);
  }
  done: 
#line 468
  pvr2_channel_limit_inputs(& adap->channel, 0U);
#line 469
  return (ret);
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static int pvr2_dvb_frontend_exit(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 474
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 475
    dvb_unregister_frontend(adap->fe);
#line 476
    dvb_frontend_detach(adap->fe);
  } else {

  }
#line 478
  return (0);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static void pvr2_dvb_destroy(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 483
  pvr2_dvb_stream_end(adap);
#line 484
  pvr2_dvb_frontend_exit(adap);
#line 485
  pvr2_dvb_adapter_exit(adap);
#line 486
  pvr2_channel_done(& adap->channel);
#line 487
  kfree((void const   *)adap);
#line 488
  return;
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
static void pvr2_dvb_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  struct pvr2_channel  const  *__mptr ;

  {
#line 493
  __mptr = (struct pvr2_channel  const  *)chp;
#line 493
  adap = (struct pvr2_dvb_adapter *)__mptr;
#line 494
  if ((adap->channel.mc_head)->disconnect_flag == 0) {
#line 494
    return;
  } else {

  }
#line 495
  pvr2_dvb_destroy(adap);
#line 496
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr ) 
{ 
  int ret ;
  struct pvr2_dvb_adapter *adap ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 500
  ret = 0;
#line 502
  if ((unsigned long )((pvr->hdw)->hdw_desc)->dvb_props == (unsigned long )((struct pvr2_dvb_props  const  */* const  */)0)) {
#line 505
    return ((struct pvr2_dvb_adapter *)0);
  } else {

  }
#line 507
  tmp = kzalloc(2624UL, 208U);
#line 507
  adap = (struct pvr2_dvb_adapter *)tmp;
#line 508
  if ((unsigned long )adap == (unsigned long )((struct pvr2_dvb_adapter *)0)) {
#line 508
    return (adap);
  } else {

  }
#line 509
  pvr2_channel_init(& adap->channel, pvr);
#line 510
  adap->channel.check_func = & pvr2_dvb_internal_check;
#line 511
  __init_waitqueue_head(& adap->buffer_wait_data, "&adap->buffer_wait_data", & __key);
#line 512
  __mutex_init(& adap->lock, "&adap->lock", & __key___0);
#line 513
  ret = pvr2_dvb_adapter_init(adap);
#line 514
  if (ret < 0) {
#line 514
    goto fail1;
  } else {

  }
#line 515
  ret = pvr2_dvb_frontend_init(adap);
#line 516
  if (ret < 0) {
#line 516
    goto fail2;
  } else {

  }
#line 517
  return (adap);
  fail2: 
#line 520
  pvr2_dvb_adapter_exit(adap);
  fail1: 
#line 522
  pvr2_channel_done(& adap->channel);
#line 523
  return ((struct pvr2_dvb_adapter *)0);
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void *ldv_kmem_cache_alloc_665(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 656
  ldv_check_alloc_flags(flags);
#line 658
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 659
  return ((void *)0);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
int ldv_pskb_expand_head_671(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 700
  ldv_check_alloc_flags(flags);
#line 702
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 702
  return (tmp);
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_673(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 716
  ldv_check_alloc_flags(flags);
#line 718
  tmp = skb_clone(ldv_func_arg1, flags);
#line 718
  return (tmp);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv_skb_copy_675(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 732
  ldv_check_alloc_flags(flags);
#line 734
  tmp = skb_copy(ldv_func_arg1, flags);
#line 734
  return (tmp);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_676(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 740
  ldv_check_alloc_flags(flags);
#line 742
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 742
  return (tmp);
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_677(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 748
  ldv_check_alloc_flags(flags);
#line 750
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 750
  return (tmp);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_678(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 756
  ldv_check_alloc_flags(flags);
#line 758
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 758
  return (tmp);
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
int ldv_pskb_expand_head_679(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 764
  ldv_check_alloc_flags(flags);
#line 766
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 766
  return (tmp);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
int ldv_pskb_expand_head_680(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 772
  ldv_check_alloc_flags(flags);
#line 774
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 774
  return (tmp);
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_681(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 780
  ldv_check_alloc_flags(flags);
#line 782
  tmp = skb_clone(ldv_func_arg1, flags);
#line 782
  return (tmp);
}
}
#line 221 "include/linux/sysfs.h"
extern int sysfs_create_group(struct kobject * , struct attribute_group  const  * ) ;
#line 227
extern void sysfs_remove_group(struct kobject * , struct attribute_group  const  * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_707(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 383 "include/linux/device.h"
extern int __class_register(struct class * , struct lock_class_key * ) ;
#line 385
extern void class_unregister(struct class * ) ;
#line 559
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 561
extern void device_remove_file(struct device * , struct device_attribute  const  * ) ;
#line 816
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 916
extern int device_register(struct device * ) ;
#line 917
extern void device_unregister(struct device * ) ;
#line 1004
extern struct device *get_device(struct device * ) ;
#line 1005
extern void put_device(struct device * ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
int pvr2_debugifc_print_info(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 35
int pvr2_debugifc_print_status(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 39
int pvr2_debugifc_docmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_name(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  char const   *name ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 183
  __mptr = (struct device_attribute  const  *)attr;
#line 183
  cip = (struct pvr2_sysfs_ctl_item *)__mptr;
#line 184
  name = pvr2_ctrl_get_desc(cip->cptr);
#line 185
  if ((pvrusb2_debug & 16384) != 0) {
#line 185
    printk("\016pvrusb2: pvr2_sysfs(%p) show_name(cid=%d) is %s\n", cip->chptr, cip->ctl_id,
           name);
  } else {

  }
#line 187
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 187
    return (-22L);
  } else {

  }
#line 188
  tmp = scnprintf(buf, 4096UL, "%s\n", name);
#line 188
  return ((ssize_t )tmp);
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_type(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  char const   *name ;
  enum pvr2_ctl_type tp ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 198
  __mptr = (struct device_attribute  const  *)attr;
#line 198
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffffd0UL;
#line 199
  tp = pvr2_ctrl_get_type(cip->cptr);
#line 200
  switch ((unsigned int )tp) {
  case 0U: 
#line 201
  name = "integer";
#line 201
  goto ldv_28898;
  case 1U: 
#line 202
  name = "enum";
#line 202
  goto ldv_28898;
  case 2U: 
#line 203
  name = "bitmask";
#line 203
  goto ldv_28898;
  case 3U: 
#line 204
  name = "boolean";
#line 204
  goto ldv_28898;
  default: 
#line 205
  name = "?";
#line 205
  goto ldv_28898;
  }
  ldv_28898: ;
#line 207
  if ((pvrusb2_debug & 16384) != 0) {
#line 207
    printk("\016pvrusb2: pvr2_sysfs(%p) show_type(cid=%d) is %s\n", cip->chptr, cip->ctl_id,
           name);
  } else {

  }
#line 209
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 209
    return (-22L);
  } else {

  }
#line 210
  tmp = scnprintf(buf, 4096UL, "%s\n", name);
#line 210
  return ((ssize_t )tmp);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_min(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  struct device_attribute  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 219
  __mptr = (struct device_attribute  const  *)attr;
#line 219
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffffa0UL;
#line 220
  tmp = pvr2_ctrl_get_min(cip->cptr);
#line 220
  val = (long )tmp;
#line 221
  if ((pvrusb2_debug & 16384) != 0) {
#line 221
    printk("\016pvrusb2: pvr2_sysfs(%p) show_min(cid=%d) is %ld\n", cip->chptr, cip->ctl_id,
           val);
  } else {

  }
#line 223
  tmp___0 = scnprintf(buf, 4096UL, "%ld\n", val);
#line 223
  return ((ssize_t )tmp___0);
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_max(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  struct device_attribute  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 232
  __mptr = (struct device_attribute  const  *)attr;
#line 232
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff70UL;
#line 233
  tmp = pvr2_ctrl_get_max(cip->cptr);
#line 233
  val = (long )tmp;
#line 234
  if ((pvrusb2_debug & 16384) != 0) {
#line 234
    printk("\016pvrusb2: pvr2_sysfs(%p) show_max(cid=%d) is %ld\n", cip->chptr, cip->ctl_id,
           val);
  } else {

  }
#line 236
  tmp___0 = scnprintf(buf, 4096UL, "%ld\n", val);
#line 236
  return ((ssize_t )tmp___0);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_def(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 246
  cnt = 0U;
#line 247
  __mptr = (struct device_attribute  const  *)attr;
#line 247
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff40UL;
#line 248
  ret = pvr2_ctrl_get_def(cip->cptr, & val);
#line 249
  if (ret < 0) {
#line 249
    return ((ssize_t )ret);
  } else {

  }
#line 250
  ret = pvr2_ctrl_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 252
  if ((pvrusb2_debug & 16384) != 0) {
#line 252
    printk("\016pvrusb2: pvr2_sysfs(%p) show_def(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 254
  *(buf + (unsigned long )cnt) = 10;
#line 255
  return ((ssize_t )(cnt + 1U));
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_val_norm(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 265
  cnt = 0U;
#line 266
  __mptr = (struct device_attribute  const  *)attr;
#line 266
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffeb0UL;
#line 267
  ret = pvr2_ctrl_get_value(cip->cptr, & val);
#line 268
  if (ret < 0) {
#line 268
    return ((ssize_t )ret);
  } else {

  }
#line 269
  ret = pvr2_ctrl_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 271
  if ((pvrusb2_debug & 16384) != 0) {
#line 271
    printk("\016pvrusb2: pvr2_sysfs(%p) show_val_norm(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 273
  *(buf + (unsigned long )cnt) = 10;
#line 274
  return ((ssize_t )(cnt + 1U));
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_val_custom(struct device *class_dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 284
  cnt = 0U;
#line 285
  __mptr = (struct device_attribute  const  *)attr;
#line 285
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffe80UL;
#line 286
  ret = pvr2_ctrl_get_value(cip->cptr, & val);
#line 287
  if (ret < 0) {
#line 287
    return ((ssize_t )ret);
  } else {

  }
#line 288
  ret = pvr2_ctrl_custom_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 290
  if ((pvrusb2_debug & 16384) != 0) {
#line 290
    printk("\016pvrusb2: pvr2_sysfs(%p) show_val_custom(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 292
  *(buf + (unsigned long )cnt) = 10;
#line 293
  return ((ssize_t )(cnt + 1U));
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_enum(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  unsigned int ecnt ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 303
  __mptr = (struct device_attribute  const  *)attr;
#line 303
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff10UL;
#line 304
  tmp = pvr2_ctrl_get_cnt(cip->cptr);
#line 304
  ecnt = (unsigned int )tmp;
#line 305
  bcnt = 0U;
#line 306
  val = 0L;
#line 306
  goto ldv_28969;
  ldv_28968: 
#line 307
  pvr2_ctrl_get_valname(cip->cptr, (int )val, buf + (unsigned long )bcnt, 4096U - bcnt,
                        & ccnt);
#line 309
  if (ccnt == 0U) {
#line 309
    goto ldv_28966;
  } else {

  }
#line 310
  bcnt = bcnt + ccnt;
#line 311
  if (bcnt > 4095U) {
#line 311
    goto ldv_28967;
  } else {

  }
#line 312
  *(buf + (unsigned long )bcnt) = 10;
#line 313
  bcnt = bcnt + 1U;
  ldv_28966: 
#line 306
  val = val + 1L;
  ldv_28969: ;
#line 306
  if ((long )ecnt > val) {
#line 308
    goto ldv_28968;
  } else {

  }
  ldv_28967: ;
#line 315
  if ((pvrusb2_debug & 16384) != 0) {
#line 315
    printk("\016pvrusb2: pvr2_sysfs(%p) show_enum(cid=%d)\n", cip->chptr, cip->ctl_id);
  } else {

  }
#line 317
  return ((ssize_t )bcnt);
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t show_bits(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int valid_bits ;
  int msk ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 327
  __mptr = (struct device_attribute  const  *)attr;
#line 327
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffee0UL;
#line 328
  valid_bits = pvr2_ctrl_get_mask(cip->cptr);
#line 329
  bcnt = 0U;
#line 330
  msk = 1;
#line 330
  goto ldv_28985;
  ldv_28984: ;
#line 331
  if ((msk & valid_bits) == 0) {
#line 331
    goto ldv_28982;
  } else {

  }
#line 332
  valid_bits = ~ msk & valid_bits;
#line 333
  pvr2_ctrl_get_valname(cip->cptr, msk, buf + (unsigned long )bcnt, 4096U - bcnt,
                        & ccnt);
#line 335
  bcnt = bcnt + ccnt;
#line 336
  if (bcnt > 4095U) {
#line 336
    goto ldv_28983;
  } else {

  }
#line 337
  *(buf + (unsigned long )bcnt) = 10;
#line 338
  bcnt = bcnt + 1U;
  ldv_28982: 
#line 330
  msk = msk << 1;
  ldv_28985: ;
#line 330
  if (valid_bits != 0) {
#line 332
    goto ldv_28984;
  } else {

  }
  ldv_28983: ;
#line 340
  if ((pvrusb2_debug & 16384) != 0) {
#line 340
    printk("\016pvrusb2: pvr2_sysfs(%p) show_bits(cid=%d)\n", cip->chptr, cip->ctl_id);
  } else {

  }
#line 342
  return ((ssize_t )bcnt);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static int store_val_any(struct pvr2_sysfs_ctl_item *cip , int customfl , char const   *buf ,
                         unsigned int count ) 
{ 
  int ret ;
  int mask ;
  int val ;

  {
#line 350
  if (customfl != 0) {
#line 351
    ret = pvr2_ctrl_custom_sym_to_value(cip->cptr, buf, count, & mask, & val);
  } else {
#line 354
    ret = pvr2_ctrl_sym_to_value(cip->cptr, buf, count, & mask, & val);
  }
#line 357
  if (ret < 0) {
#line 357
    return (ret);
  } else {

  }
#line 358
  ret = pvr2_ctrl_set_mask_value(cip->cptr, mask, val);
#line 359
  pvr2_hdw_commit_ctl((cip->chptr)->channel.hdw);
#line 360
  return (ret);
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t store_val_norm(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int ret ;
  struct device_attribute  const  *__mptr ;

  {
#line 369
  __mptr = (struct device_attribute  const  *)attr;
#line 369
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffeb0UL;
#line 370
  if ((pvrusb2_debug & 16384) != 0) {
#line 370
    printk("\016pvrusb2: pvr2_sysfs(%p) store_val_norm(cid=%d) \"%.*s\"\n", cip->chptr,
           cip->ctl_id, (int )count, buf);
  } else {

  }
#line 372
  ret = store_val_any(cip, 0, buf, (unsigned int )count);
#line 373
  if (ret == 0) {
#line 373
    ret = (int )count;
  } else {

  }
#line 374
  return ((ssize_t )ret);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t store_val_custom(struct device *class_dev , struct device_attribute *attr ,
                                char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int ret ;
  struct device_attribute  const  *__mptr ;

  {
#line 383
  __mptr = (struct device_attribute  const  *)attr;
#line 383
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffe80UL;
#line 384
  if ((pvrusb2_debug & 16384) != 0) {
#line 384
    printk("\016pvrusb2: pvr2_sysfs(%p) store_val_custom(cid=%d) \"%.*s\"\n", cip->chptr,
           cip->ctl_id, (int )count, buf);
  } else {

  }
#line 386
  ret = store_val_any(cip, 1, buf, (unsigned int )count);
#line 387
  if (ret == 0) {
#line 387
    ret = (int )count;
  } else {

  }
#line 388
  return ((ssize_t )ret);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_add_control(struct pvr2_sysfs *sfp , int ctl_id ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  struct pvr2_ctrl *cptr ;
  unsigned int cnt ;
  unsigned int acnt ;
  int ret ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;
  struct lock_class_key __key___7 ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  enum pvr2_ctl_type tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 398
  cptr = pvr2_hdw_get_ctrl_by_index(sfp->channel.hdw, (unsigned int )ctl_id);
#line 399
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 399
    return;
  } else {

  }
#line 401
  tmp = kzalloc(648UL, 208U);
#line 401
  cip = (struct pvr2_sysfs_ctl_item *)tmp;
#line 402
  if ((unsigned long )cip == (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 402
    return;
  } else {

  }
#line 403
  if ((pvrusb2_debug & 16384) != 0) {
#line 403
    printk("\016pvrusb2: Creating pvr2_sysfs_ctl_item id=%p\n", cip);
  } else {

  }
#line 405
  cip->cptr = cptr;
#line 406
  cip->ctl_id = ctl_id;
#line 408
  cip->chptr = sfp;
#line 409
  cip->item_next = (struct pvr2_sysfs_ctl_item *)0;
#line 410
  if ((unsigned long )sfp->item_last != (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 411
    (sfp->item_last)->item_next = cip;
  } else {
#line 413
    sfp->item_first = cip;
  }
#line 415
  sfp->item_last = cip;
#line 417
  cip->attr_name.attr.key = & __key;
#line 418
  cip->attr_name.attr.name = "name";
#line 419
  cip->attr_name.attr.mode = 292U;
#line 420
  cip->attr_name.show = & show_name;
#line 422
  cip->attr_type.attr.key = & __key___0;
#line 423
  cip->attr_type.attr.name = "type";
#line 424
  cip->attr_type.attr.mode = 292U;
#line 425
  cip->attr_type.show = & show_type;
#line 427
  cip->attr_min.attr.key = & __key___1;
#line 428
  cip->attr_min.attr.name = "min_val";
#line 429
  cip->attr_min.attr.mode = 292U;
#line 430
  cip->attr_min.show = & show_min;
#line 432
  cip->attr_max.attr.key = & __key___2;
#line 433
  cip->attr_max.attr.name = "max_val";
#line 434
  cip->attr_max.attr.mode = 292U;
#line 435
  cip->attr_max.show = & show_max;
#line 437
  cip->attr_def.attr.key = & __key___3;
#line 438
  cip->attr_def.attr.name = "def_val";
#line 439
  cip->attr_def.attr.mode = 292U;
#line 440
  cip->attr_def.show = & show_def;
#line 442
  cip->attr_val.attr.key = & __key___4;
#line 443
  cip->attr_val.attr.name = "cur_val";
#line 444
  cip->attr_val.attr.mode = 292U;
#line 446
  cip->attr_custom.attr.key = & __key___5;
#line 447
  cip->attr_custom.attr.name = "custom_val";
#line 448
  cip->attr_custom.attr.mode = 292U;
#line 450
  cip->attr_enum.attr.key = & __key___6;
#line 451
  cip->attr_enum.attr.name = "enum_val";
#line 452
  cip->attr_enum.attr.mode = 292U;
#line 453
  cip->attr_enum.show = & show_enum;
#line 455
  cip->attr_bits.attr.key = & __key___7;
#line 456
  cip->attr_bits.attr.name = "bit_val";
#line 457
  cip->attr_bits.attr.mode = 292U;
#line 458
  cip->attr_bits.show = & show_bits;
#line 460
  tmp___0 = pvr2_ctrl_is_writable(cptr);
#line 460
  if (tmp___0 != 0) {
#line 461
    cip->attr_val.attr.mode = (umode_t )((unsigned int )cip->attr_val.attr.mode | 144U);
#line 462
    cip->attr_custom.attr.mode = (umode_t )((unsigned int )cip->attr_custom.attr.mode | 144U);
  } else {

  }
#line 465
  acnt = 0U;
#line 466
  tmp___1 = acnt;
#line 466
  acnt = acnt + 1U;
#line 466
  cip->attr_gen[tmp___1] = & cip->attr_name.attr;
#line 467
  tmp___2 = acnt;
#line 467
  acnt = acnt + 1U;
#line 467
  cip->attr_gen[tmp___2] = & cip->attr_type.attr;
#line 468
  tmp___3 = acnt;
#line 468
  acnt = acnt + 1U;
#line 468
  cip->attr_gen[tmp___3] = & cip->attr_val.attr;
#line 469
  tmp___4 = acnt;
#line 469
  acnt = acnt + 1U;
#line 469
  cip->attr_gen[tmp___4] = & cip->attr_def.attr;
#line 470
  cip->attr_val.show = & show_val_norm;
#line 471
  cip->attr_val.store = & store_val_norm;
#line 472
  tmp___6 = pvr2_ctrl_has_custom_symbols(cptr);
#line 472
  if (tmp___6 != 0) {
#line 473
    tmp___5 = acnt;
#line 473
    acnt = acnt + 1U;
#line 473
    cip->attr_gen[tmp___5] = & cip->attr_custom.attr;
#line 474
    cip->attr_custom.show = & show_val_custom;
#line 475
    cip->attr_custom.store = & store_val_custom;
  } else {

  }
#line 477
  tmp___7 = pvr2_ctrl_get_type(cptr);
#line 477
  switch ((unsigned int )tmp___7) {
  case 1U: 
#line 480
  tmp___8 = acnt;
#line 480
  acnt = acnt + 1U;
#line 480
  cip->attr_gen[tmp___8] = & cip->attr_enum.attr;
#line 481
  goto ldv_29034;
  case 0U: 
#line 484
  tmp___9 = acnt;
#line 484
  acnt = acnt + 1U;
#line 484
  cip->attr_gen[tmp___9] = & cip->attr_min.attr;
#line 485
  tmp___10 = acnt;
#line 485
  acnt = acnt + 1U;
#line 485
  cip->attr_gen[tmp___10] = & cip->attr_max.attr;
#line 486
  goto ldv_29034;
  case 2U: 
#line 489
  tmp___11 = acnt;
#line 489
  acnt = acnt + 1U;
#line 489
  cip->attr_gen[tmp___11] = & cip->attr_bits.attr;
#line 490
  goto ldv_29034;
  default: ;
#line 491
  goto ldv_29034;
  }
  ldv_29034: 
#line 494
  tmp___12 = pvr2_ctrl_get_name(cptr);
#line 494
  tmp___13 = scnprintf((char *)(& cip->name), 79UL, "ctl_%s", tmp___12);
#line 494
  cnt = (unsigned int )tmp___13;
#line 496
  cip->name[cnt] = 0;
#line 497
  cip->grp.name = (char const   *)(& cip->name);
#line 498
  cip->grp.attrs = (struct attribute **)(& cip->attr_gen);
#line 500
  ret = sysfs_create_group(& (sfp->class_dev)->kobj, (struct attribute_group  const  *)(& cip->grp));
#line 501
  if (ret != 0) {
#line 502
    if ((pvrusb2_debug & 2) != 0) {
#line 502
      printk("\016pvrusb2: sysfs_create_group error: %d\n", ret);
    } else {

    }
#line 505
    return;
  } else {

  }
#line 507
  cip->created_ok = 1;
#line 508
  return;
}
}
#line 511
static ssize_t debuginfo_show(struct device *class_dev , struct device_attribute *attr ,
                              char *buf ) ;
#line 513
static ssize_t debugcmd_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) ;
#line 515
static ssize_t debugcmd_store(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) ;
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_add_debugifc(struct pvr2_sysfs *sfp ) 
{ 
  struct pvr2_sysfs_debugifc *dip ;
  int ret ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 523
  tmp = kzalloc(104UL, 208U);
#line 523
  dip = (struct pvr2_sysfs_debugifc *)tmp;
#line 524
  if ((unsigned long )dip == (unsigned long )((struct pvr2_sysfs_debugifc *)0)) {
#line 524
    return;
  } else {

  }
#line 525
  dip->attr_debugcmd.attr.key = & __key;
#line 526
  dip->attr_debugcmd.attr.name = "debugcmd";
#line 527
  dip->attr_debugcmd.attr.mode = 436U;
#line 528
  dip->attr_debugcmd.show = & debugcmd_show;
#line 529
  dip->attr_debugcmd.store = & debugcmd_store;
#line 530
  dip->attr_debuginfo.attr.key = & __key___0;
#line 531
  dip->attr_debuginfo.attr.name = "debuginfo";
#line 532
  dip->attr_debuginfo.attr.mode = 292U;
#line 533
  dip->attr_debuginfo.show = & debuginfo_show;
#line 534
  sfp->debugifc = dip;
#line 535
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& dip->attr_debugcmd));
#line 536
  if (ret < 0) {
#line 537
    if ((pvrusb2_debug & 2) != 0) {
#line 537
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 541
    dip->debugcmd_created_ok = 1;
  }
#line 543
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& dip->attr_debuginfo));
#line 544
  if (ret < 0) {
#line 545
    if ((pvrusb2_debug & 2) != 0) {
#line 545
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 549
    dip->debuginfo_created_ok = 1;
  }
#line 550
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_tear_down_debugifc(struct pvr2_sysfs *sfp ) 
{ 


  {
#line 556
  if ((unsigned long )sfp->debugifc == (unsigned long )((struct pvr2_sysfs_debugifc *)0)) {
#line 556
    return;
  } else {

  }
#line 557
  if ((sfp->debugifc)->debuginfo_created_ok != 0) {
#line 558
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& (sfp->debugifc)->attr_debuginfo));
  } else {

  }
#line 561
  if ((sfp->debugifc)->debugcmd_created_ok != 0) {
#line 562
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& (sfp->debugifc)->attr_debugcmd));
  } else {

  }
#line 565
  kfree((void const   *)sfp->debugifc);
#line 566
  sfp->debugifc = (struct pvr2_sysfs_debugifc *)0;
#line 567
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_add_controls(struct pvr2_sysfs *sfp ) 
{ 
  unsigned int idx ;
  unsigned int cnt ;

  {
#line 574
  cnt = pvr2_hdw_get_ctrl_count(sfp->channel.hdw);
#line 575
  idx = 0U;
#line 575
  goto ldv_29067;
  ldv_29066: 
#line 576
  pvr2_sysfs_add_control(sfp, (int )idx);
#line 575
  idx = idx + 1U;
  ldv_29067: ;
#line 575
  if (idx < cnt) {
#line 577
    goto ldv_29066;
  } else {

  }

#line 582
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp ) 
{ 
  struct pvr2_sysfs_ctl_item *cip1 ;
  struct pvr2_sysfs_ctl_item *cip2 ;

  {
#line 584
  cip1 = sfp->item_first;
#line 584
  goto ldv_29075;
  ldv_29074: 
#line 585
  cip2 = cip1->item_next;
#line 586
  if (cip1->created_ok != 0) {
#line 587
    sysfs_remove_group(& (sfp->class_dev)->kobj, (struct attribute_group  const  *)(& cip1->grp));
  } else {

  }
#line 589
  if ((pvrusb2_debug & 16384) != 0) {
#line 589
    printk("\016pvrusb2: Destroying pvr2_sysfs_ctl_item id=%p\n", cip1);
  } else {

  }
#line 590
  kfree((void const   *)cip1);
#line 584
  cip1 = cip2;
  ldv_29075: ;
#line 584
  if ((unsigned long )cip1 != (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 586
    goto ldv_29074;
  } else {

  }

#line 591
  return;
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_class_release(struct class *class ) 
{ 
  struct pvr2_sysfs_class *clp ;
  struct class  const  *__mptr ;

  {
#line 598
  __mptr = (struct class  const  *)class;
#line 598
  clp = (struct pvr2_sysfs_class *)__mptr;
#line 599
  if ((pvrusb2_debug & 16384) != 0) {
#line 599
    printk("\016pvrusb2: Destroying pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 600
  kfree((void const   *)clp);
#line 601
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_release(struct device *class_dev ) 
{ 


  {
#line 606
  if ((pvrusb2_debug & 16384) != 0) {
#line 606
    printk("\016pvrusb2: Releasing class_dev id=%p\n", class_dev);
  } else {

  }
#line 607
  kfree((void const   *)class_dev);
#line 608
  return;
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void class_dev_destroy(struct pvr2_sysfs *sfp ) 
{ 
  struct device *dev ;

  {
#line 614
  if ((unsigned long )sfp->class_dev == (unsigned long )((struct device *)0)) {
#line 614
    return;
  } else {

  }
#line 616
  pvr2_sysfs_tear_down_debugifc(sfp);
#line 618
  pvr2_sysfs_tear_down_controls(sfp);
#line 619
  if (sfp->hdw_desc_created_ok != 0) {
#line 620
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_desc));
  } else {

  }
#line 623
  if (sfp->hdw_name_created_ok != 0) {
#line 624
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_name));
  } else {

  }
#line 627
  if (sfp->bus_info_created_ok != 0) {
#line 628
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_bus_info));
  } else {

  }
#line 631
  if (sfp->v4l_minor_number_created_ok != 0) {
#line 632
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_minor_number));
  } else {

  }
#line 635
  if (sfp->v4l_radio_minor_number_created_ok != 0) {
#line 636
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_radio_minor_number));
  } else {

  }
#line 639
  if (sfp->unit_number_created_ok != 0) {
#line 640
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_unit_number));
  } else {

  }
#line 643
  if ((pvrusb2_debug & 16384) != 0) {
#line 643
    printk("\016pvrusb2: Destroying class_dev id=%p\n", sfp->class_dev);
  } else {

  }
#line 644
  dev_set_drvdata(sfp->class_dev, (void *)0);
#line 645
  dev = (sfp->class_dev)->parent;
#line 646
  (sfp->class_dev)->parent = (struct device *)0;
#line 647
  put_device(dev);
#line 648
  device_unregister(sfp->class_dev);
#line 649
  sfp->class_dev = (struct device *)0;
#line 650
  return;
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t v4l_minor_number_show(struct device *class_dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 657
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 657
  sfp = (struct pvr2_sysfs *)tmp;
#line 658
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 658
    return (-22L);
  } else {

  }
#line 659
  tmp___0 = pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw, 0);
#line 659
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 659
  return ((ssize_t )tmp___1);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t bus_info_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 669
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 669
  sfp = (struct pvr2_sysfs *)tmp;
#line 670
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 670
    return (-22L);
  } else {

  }
#line 671
  tmp___0 = pvr2_hdw_get_bus_info(sfp->channel.hdw);
#line 671
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 671
  return ((ssize_t )tmp___1);
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t hdw_name_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 680
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 680
  sfp = (struct pvr2_sysfs *)tmp;
#line 681
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 681
    return (-22L);
  } else {

  }
#line 682
  tmp___0 = pvr2_hdw_get_type(sfp->channel.hdw);
#line 682
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 682
  return ((ssize_t )tmp___1);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t hdw_desc_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 691
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 691
  sfp = (struct pvr2_sysfs *)tmp;
#line 692
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 692
    return (-22L);
  } else {

  }
#line 693
  tmp___0 = pvr2_hdw_get_desc(sfp->channel.hdw);
#line 693
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 693
  return ((ssize_t )tmp___1);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t v4l_radio_minor_number_show(struct device *class_dev , struct device_attribute *attr ,
                                           char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 703
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 703
  sfp = (struct pvr2_sysfs *)tmp;
#line 704
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 704
    return (-22L);
  } else {

  }
#line 705
  tmp___0 = pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw, 2);
#line 705
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 705
  return ((ssize_t )tmp___1);
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t unit_number_show(struct device *class_dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 715
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 715
  sfp = (struct pvr2_sysfs *)tmp;
#line 716
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 716
    return (-22L);
  } else {

  }
#line 717
  tmp___0 = pvr2_hdw_get_unit_number(sfp->channel.hdw);
#line 717
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 717
  return ((ssize_t )tmp___1);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void class_dev_create(struct pvr2_sysfs *sfp , struct pvr2_sysfs_class *class_ptr___0 ) 
{ 
  struct usb_device *usb_dev ;
  struct device *class_dev ;
  int ret ;
  void *tmp ;
  char const   *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;

  {
#line 729
  usb_dev = pvr2_hdw_get_dev(sfp->channel.hdw);
#line 730
  if ((unsigned long )usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 730
    return;
  } else {

  }
#line 731
  tmp = kzalloc(1416UL, 208U);
#line 731
  class_dev = (struct device *)tmp;
#line 732
  if ((unsigned long )class_dev == (unsigned long )((struct device *)0)) {
#line 732
    return;
  } else {

  }
#line 734
  if ((pvrusb2_debug & 16384) != 0) {
#line 734
    printk("\016pvrusb2: Creating class_dev id=%p\n", class_dev);
  } else {

  }
#line 736
  class_dev->class = & class_ptr___0->class;
#line 738
  tmp___0 = pvr2_hdw_get_device_identifier(sfp->channel.hdw);
#line 738
  dev_set_name(class_dev, "%s", tmp___0);
#line 741
  class_dev->parent = get_device(& usb_dev->dev);
#line 743
  sfp->class_dev = class_dev;
#line 744
  dev_set_drvdata(class_dev, (void *)sfp);
#line 745
  ret = device_register(class_dev);
#line 746
  if (ret != 0) {
#line 747
    if ((pvrusb2_debug & 2) != 0) {
#line 747
      printk("\016pvrusb2: device_register failed\n");
    } else {

    }
#line 749
    put_device(class_dev);
#line 750
    return;
  } else {

  }
#line 753
  sfp->attr_v4l_minor_number.attr.key = & __key;
#line 754
  sfp->attr_v4l_minor_number.attr.name = "v4l_minor_number";
#line 755
  sfp->attr_v4l_minor_number.attr.mode = 292U;
#line 756
  sfp->attr_v4l_minor_number.show = & v4l_minor_number_show;
#line 757
  sfp->attr_v4l_minor_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0;
#line 758
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_minor_number));
#line 760
  if (ret < 0) {
#line 761
    if ((pvrusb2_debug & 2) != 0) {
#line 761
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 765
    sfp->v4l_minor_number_created_ok = 1;
  }
#line 768
  sfp->attr_v4l_radio_minor_number.attr.key = & __key___0;
#line 769
  sfp->attr_v4l_radio_minor_number.attr.name = "v4l_radio_minor_number";
#line 770
  sfp->attr_v4l_radio_minor_number.attr.mode = 292U;
#line 771
  sfp->attr_v4l_radio_minor_number.show = & v4l_radio_minor_number_show;
#line 772
  sfp->attr_v4l_radio_minor_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                                        char const   * , size_t  ))0;
#line 773
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_radio_minor_number));
#line 775
  if (ret < 0) {
#line 776
    if ((pvrusb2_debug & 2) != 0) {
#line 776
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 780
    sfp->v4l_radio_minor_number_created_ok = 1;
  }
#line 783
  sfp->attr_unit_number.attr.key = & __key___1;
#line 784
  sfp->attr_unit_number.attr.name = "unit_number";
#line 785
  sfp->attr_unit_number.attr.mode = 292U;
#line 786
  sfp->attr_unit_number.show = & unit_number_show;
#line 787
  sfp->attr_unit_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0;
#line 788
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_unit_number));
#line 789
  if (ret < 0) {
#line 790
    if ((pvrusb2_debug & 2) != 0) {
#line 790
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 794
    sfp->unit_number_created_ok = 1;
  }
#line 797
  sfp->attr_bus_info.attr.key = & __key___2;
#line 798
  sfp->attr_bus_info.attr.name = "bus_info_str";
#line 799
  sfp->attr_bus_info.attr.mode = 292U;
#line 800
  sfp->attr_bus_info.show = & bus_info_show;
#line 801
  sfp->attr_bus_info.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 802
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_bus_info));
#line 804
  if (ret < 0) {
#line 805
    if ((pvrusb2_debug & 2) != 0) {
#line 805
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 809
    sfp->bus_info_created_ok = 1;
  }
#line 812
  sfp->attr_hdw_name.attr.key = & __key___3;
#line 813
  sfp->attr_hdw_name.attr.name = "device_hardware_type";
#line 814
  sfp->attr_hdw_name.attr.mode = 292U;
#line 815
  sfp->attr_hdw_name.show = & hdw_name_show;
#line 816
  sfp->attr_hdw_name.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 817
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_name));
#line 819
  if (ret < 0) {
#line 820
    if ((pvrusb2_debug & 2) != 0) {
#line 820
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 824
    sfp->hdw_name_created_ok = 1;
  }
#line 827
  sfp->attr_hdw_desc.attr.key = & __key___4;
#line 828
  sfp->attr_hdw_desc.attr.name = "device_hardware_description";
#line 829
  sfp->attr_hdw_desc.attr.mode = 292U;
#line 830
  sfp->attr_hdw_desc.show = & hdw_desc_show;
#line 831
  sfp->attr_hdw_desc.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 832
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_desc));
#line 834
  if (ret < 0) {
#line 835
    if ((pvrusb2_debug & 2) != 0) {
#line 835
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 839
    sfp->hdw_desc_created_ok = 1;
  }
#line 842
  pvr2_sysfs_add_controls(sfp);
#line 844
  pvr2_sysfs_add_debugifc(sfp);
#line 845
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static void pvr2_sysfs_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_sysfs *sfp ;
  struct pvr2_channel  const  *__mptr ;

  {
#line 852
  __mptr = (struct pvr2_channel  const  *)chp;
#line 852
  sfp = (struct pvr2_sysfs *)__mptr;
#line 853
  if ((sfp->channel.mc_head)->disconnect_flag == 0) {
#line 853
    return;
  } else {

  }
#line 854
  if ((pvrusb2_debug & 2048) != 0) {
#line 854
    printk("\016pvrusb2: Destroying pvr2_sysfs id=%p\n", sfp);
  } else {

  }
#line 855
  class_dev_destroy(sfp);
#line 856
  pvr2_channel_done(& sfp->channel);
#line 857
  kfree((void const   *)sfp);
#line 858
  return;
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
struct pvr2_sysfs *pvr2_sysfs_create(struct pvr2_context *mp , struct pvr2_sysfs_class *class_ptr___0 ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;

  {
#line 865
  tmp = kzalloc(400UL, 208U);
#line 865
  sfp = (struct pvr2_sysfs *)tmp;
#line 866
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 866
    return (sfp);
  } else {

  }
#line 867
  if ((pvrusb2_debug & 2048) != 0) {
#line 867
    printk("\016pvrusb2: Creating pvr2_sysfs id=%p\n", sfp);
  } else {

  }
#line 868
  pvr2_channel_init(& sfp->channel, mp);
#line 869
  sfp->channel.check_func = & pvr2_sysfs_internal_check;
#line 871
  class_dev_create(sfp, class_ptr___0);
#line 872
  return (sfp);
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
struct pvr2_sysfs_class *pvr2_sysfs_class_create(void) 
{ 
  struct pvr2_sysfs_class *clp ;
  void *tmp ;
  struct lock_class_key __key ;
  int tmp___0 ;

  {
#line 880
  tmp = kzalloc(120UL, 208U);
#line 880
  clp = (struct pvr2_sysfs_class *)tmp;
#line 881
  if ((unsigned long )clp == (unsigned long )((struct pvr2_sysfs_class *)0)) {
#line 881
    return (clp);
  } else {

  }
#line 882
  if ((pvrusb2_debug & 16384) != 0) {
#line 882
    printk("\016pvrusb2: Creating and registering pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 884
  clp->class.name = "pvrusb2";
#line 885
  clp->class.class_release = & pvr2_sysfs_class_release;
#line 886
  clp->class.dev_release = & pvr2_sysfs_release;
#line 887
  tmp___0 = __class_register(& clp->class, & __key);
#line 887
  if (tmp___0 != 0) {
#line 888
    if ((pvrusb2_debug & 16384) != 0) {
#line 888
      printk("\016pvrusb2: Registration failed for pvr2_sysfs_class id=%p\n", clp);
    } else {

    }
#line 890
    kfree((void const   *)clp);
#line 891
    clp = (struct pvr2_sysfs_class *)0;
  } else {

  }
#line 893
  return (clp);
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void pvr2_sysfs_class_destroy(struct pvr2_sysfs_class *clp ) 
{ 


  {
#line 899
  if ((pvrusb2_debug & 16384) != 0) {
#line 899
    printk("\016pvrusb2: Unregistering pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 900
  class_unregister(& clp->class);
#line 901
  return;
}
}
#line 905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t debuginfo_show(struct device *class_dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 909
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 909
  sfp = (struct pvr2_sysfs *)tmp;
#line 910
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 910
    return (-22L);
  } else {

  }
#line 911
  pvr2_hdw_trigger_module_log(sfp->channel.hdw);
#line 912
  tmp___0 = pvr2_debugifc_print_info(sfp->channel.hdw, buf, 4096U);
#line 912
  return ((ssize_t )tmp___0);
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t debugcmd_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 920
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 920
  sfp = (struct pvr2_sysfs *)tmp;
#line 921
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 921
    return (-22L);
  } else {

  }
#line 922
  tmp___0 = pvr2_debugifc_print_status(sfp->channel.hdw, buf, 4096U);
#line 922
  return ((ssize_t )tmp___0);
}
}
#line 926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
static ssize_t debugcmd_store(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs *sfp ;
  int ret ;
  void *tmp ;

  {
#line 933
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 933
  sfp = (struct pvr2_sysfs *)tmp;
#line 934
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 934
    return (-22L);
  } else {

  }
#line 936
  ret = pvr2_debugifc_docmd(sfp->channel.hdw, buf, (unsigned int )count);
#line 937
  if (ret < 0) {
#line 937
    return ((ssize_t )ret);
  } else {

  }
#line 938
  return ((ssize_t )count);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void *ldv_kmem_cache_alloc_707(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1071
  ldv_check_alloc_flags(flags);
#line 1073
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1074
  return ((void *)0);
}
}
#line 501 "include/linux/kernel.h"
extern int hex_to_bin(char  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_726(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static unsigned int debugifc_count_whitespace(char const   *buf , unsigned int count ) 
{ 
  unsigned int scnt ;
  char ch ;

  {
#line 128
  scnt = 0U;
#line 128
  goto ldv_28786;
  ldv_28785: 
#line 129
  ch = *(buf + (unsigned long )scnt);
#line 130
  if ((int )((signed char )ch) == 32) {
#line 130
    goto ldv_28783;
  } else {

  }
#line 131
  if ((int )((signed char )ch) == 9) {
#line 131
    goto ldv_28783;
  } else {

  }
#line 132
  if ((int )((signed char )ch) == 10) {
#line 132
    goto ldv_28783;
  } else {

  }
#line 133
  goto ldv_28784;
  ldv_28783: 
#line 128
  scnt = scnt + 1U;
  ldv_28786: ;
#line 128
  if (scnt < count) {
#line 130
    goto ldv_28785;
  } else {

  }
  ldv_28784: ;
#line 135
  return (scnt);
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static unsigned int debugifc_count_nonwhitespace(char const   *buf , unsigned int count ) 
{ 
  unsigned int scnt ;
  char ch ;

  {
#line 145
  scnt = 0U;
#line 145
  goto ldv_28795;
  ldv_28794: 
#line 146
  ch = *(buf + (unsigned long )scnt);
#line 147
  if ((int )((signed char )ch) == 32) {
#line 147
    goto ldv_28793;
  } else {

  }
#line 148
  if ((int )((signed char )ch) == 9) {
#line 148
    goto ldv_28793;
  } else {

  }
#line 149
  if ((int )((signed char )ch) == 10) {
#line 149
    goto ldv_28793;
  } else {

  }
#line 145
  scnt = scnt + 1U;
  ldv_28795: ;
#line 145
  if (scnt < count) {
#line 147
    goto ldv_28794;
  } else {

  }
  ldv_28793: ;
#line 151
  return (scnt);
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static unsigned int debugifc_isolate_word(char const   *buf , unsigned int count ,
                                          char const   **wstrPtr , unsigned int *wlenPtr ) 
{ 
  char const   *wptr ;
  unsigned int consume_cnt ;
  unsigned int wlen ;
  unsigned int scnt ;

  {
#line 160
  consume_cnt = 0U;
#line 164
  wptr = (char const   *)0;
#line 165
  wlen = 0U;
#line 166
  scnt = debugifc_count_whitespace(buf, count);
#line 167
  consume_cnt = consume_cnt + scnt;
#line 167
  count = count - scnt;
#line 167
  buf = buf + (unsigned long )scnt;
#line 168
  if (count == 0U) {
#line 168
    goto done;
  } else {

  }
#line 170
  scnt = debugifc_count_nonwhitespace(buf, count);
#line 171
  if (scnt == 0U) {
#line 171
    goto done;
  } else {

  }
#line 172
  wptr = buf;
#line 173
  wlen = scnt;
#line 174
  consume_cnt = consume_cnt + scnt;
#line 174
  count = count - scnt;
#line 174
  buf = buf + (unsigned long )scnt;
  done: 
#line 177
  *wstrPtr = wptr;
#line 178
  *wlenPtr = wlen;
#line 179
  return (consume_cnt);
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static int debugifc_parse_unsigned_number(char const   *buf , unsigned int count ,
                                          u32 *num_ptr ) 
{ 
  u32 result ;
  int radix ;
  int val ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 186
  result = 0U;
#line 187
  radix = 10;
#line 188
  if ((count > 1U && (int )((signed char )*buf) == 48) && ((int )((signed char )*(buf + 1UL)) == 120 || (int )((signed char )*(buf + 1UL)) == 88)) {
#line 190
    radix = 16;
#line 191
    count = count - 2U;
#line 192
    buf = buf + 2UL;
  } else
#line 193
  if (count != 0U && (int )((signed char )*buf) == 48) {
#line 194
    radix = 8;
  } else {

  }
#line 197
  goto ldv_28816;
  ldv_28815: 
#line 198
  tmp = buf;
#line 198
  buf = buf + 1;
#line 198
  tmp___0 = hex_to_bin((int )*tmp);
#line 198
  val = tmp___0;
#line 199
  if (val < 0 || val >= radix) {
#line 200
    return (-22);
  } else {

  }
#line 201
  result = result * (u32 )radix;
#line 202
  result = result + (u32 )val;
  ldv_28816: 
#line 197
  tmp___1 = count;
#line 197
  count = count - 1U;
#line 197
  if (tmp___1 != 0U) {
#line 199
    goto ldv_28815;
  } else {

  }
#line 204
  *num_ptr = result;
#line 205
  return (0);
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static int debugifc_match_keyword(char const   *buf , unsigned int count , char const   *keyword ) 
{ 
  unsigned int kl ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 213
  if ((unsigned long )keyword == (unsigned long )((char const   *)0)) {
#line 213
    return (0);
  } else {

  }
#line 214
  tmp = strlen(keyword);
#line 214
  kl = (unsigned int )tmp;
#line 215
  if (kl != count) {
#line 215
    return (0);
  } else {

  }
#line 216
  tmp___0 = memcmp((void const   *)buf, (void const   *)keyword, (size_t )kl);
#line 216
  return (tmp___0 == 0);
}
}
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
int pvr2_debugifc_print_info(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  int bcnt ;
  int ccnt ;
  char const   *tmp ;
  unsigned int tmp___0 ;

  {
#line 222
  bcnt = 0;
#line 224
  tmp = pvr2_hdw_get_desc(hdw);
#line 224
  ccnt = scnprintf(buf, (size_t )acnt, "Driver hardware description: %s\n", tmp);
#line 226
  bcnt = bcnt + ccnt;
#line 226
  acnt = acnt - (unsigned int )ccnt;
#line 226
  buf = buf + (unsigned long )ccnt;
#line 227
  ccnt = scnprintf(buf, (size_t )acnt, "Driver state info:\n");
#line 228
  bcnt = bcnt + ccnt;
#line 228
  acnt = acnt - (unsigned int )ccnt;
#line 228
  buf = buf + (unsigned long )ccnt;
#line 229
  tmp___0 = pvr2_hdw_state_report(hdw, buf, acnt);
#line 229
  ccnt = (int )tmp___0;
#line 230
  bcnt = bcnt + ccnt;
#line 230
  acnt = acnt - (unsigned int )ccnt;
#line 230
  buf = buf + (unsigned long )ccnt;
#line 232
  return (bcnt);
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
int pvr2_debugifc_print_status(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  int bcnt ;
  int ccnt ;
  int ret ;
  u32 gpio_dir ;
  u32 gpio_in ;
  u32 gpio_out ;
  struct pvr2_stream_stats stats ;
  struct pvr2_stream *sp ;
  int tmp ;

  {
#line 239
  bcnt = 0;
#line 246
  ret = pvr2_hdw_is_hsm(hdw);
#line 247
  ccnt = scnprintf(buf, (size_t )acnt, "USB link speed: %s\n", ret >= 0 ? (ret != 0 ? (char *)"high" : (char *)"full") : (char *)"FAIL");
#line 249
  bcnt = bcnt + ccnt;
#line 249
  acnt = acnt - (unsigned int )ccnt;
#line 249
  buf = buf + (unsigned long )ccnt;
#line 251
  gpio_dir = 0U;
#line 251
  gpio_in = 0U;
#line 251
  gpio_out = 0U;
#line 252
  pvr2_hdw_gpio_get_dir(hdw, & gpio_dir);
#line 253
  pvr2_hdw_gpio_get_out(hdw, & gpio_out);
#line 254
  pvr2_hdw_gpio_get_in(hdw, & gpio_in);
#line 255
  ccnt = scnprintf(buf, (size_t )acnt, "GPIO state: dir=0x%x in=0x%x out=0x%x\n",
                   gpio_dir, gpio_in, gpio_out);
#line 257
  bcnt = bcnt + ccnt;
#line 257
  acnt = acnt - (unsigned int )ccnt;
#line 257
  buf = buf + (unsigned long )ccnt;
#line 259
  tmp = pvr2_hdw_get_streaming(hdw);
#line 259
  ccnt = scnprintf(buf, (size_t )acnt, "Streaming is %s\n", tmp != 0 ? (char *)"on" : (char *)"off");
#line 261
  bcnt = bcnt + ccnt;
#line 261
  acnt = acnt - (unsigned int )ccnt;
#line 261
  buf = buf + (unsigned long )ccnt;
#line 264
  sp = pvr2_hdw_get_video_stream(hdw);
#line 265
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 266
    pvr2_stream_get_stats(sp, & stats, 0);
#line 267
    ccnt = scnprintf(buf, (size_t )acnt, "Bytes streamed=%u URBs: queued=%u idle=%u ready=%u processed=%u failed=%u\n",
                     stats.bytes_processed, stats.buffers_in_queue, stats.buffers_in_idle,
                     stats.buffers_in_ready, stats.buffers_processed, stats.buffers_failed);
#line 278
    bcnt = bcnt + ccnt;
#line 278
    acnt = acnt - (unsigned int )ccnt;
#line 278
    buf = buf + (unsigned long )ccnt;
  } else {

  }
#line 281
  return (bcnt);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
static int pvr2_debugifc_do1cmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) 
{ 
  char const   *wptr ;
  unsigned int wlen ;
  unsigned int scnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct pvr2_stream *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int dir_fl ;
  int ret ;
  u32 msk ;
  u32 val ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 292
  scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 293
  if (scnt == 0U) {
#line 293
    return (0);
  } else {

  }
#line 294
  count = count - scnt;
#line 294
  buf = buf + (unsigned long )scnt;
#line 295
  if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 295
    return (0);
  } else {

  }
#line 297
  if ((pvrusb2_debug & 67108864) != 0) {
#line 297
    printk("\016pvrusb2: debugifc cmd: \"%.*s\"\n", wlen, wptr);
  } else {

  }
#line 298
  tmp___22 = debugifc_match_keyword(wptr, wlen, "reset");
#line 298
  if (tmp___22 != 0) {
#line 299
    scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 300
    if (scnt == 0U) {
#line 300
      return (-22);
    } else {

    }
#line 301
    count = count - scnt;
#line 301
    buf = buf + (unsigned long )scnt;
#line 302
    if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 302
      return (-22);
    } else {

    }
#line 303
    tmp___12 = debugifc_match_keyword(wptr, wlen, "cpu");
#line 303
    if (tmp___12 != 0) {
#line 304
      pvr2_hdw_cpureset_assert(hdw, 1);
#line 305
      pvr2_hdw_cpureset_assert(hdw, 0);
#line 306
      return (0);
    } else {
#line 307
      tmp___11 = debugifc_match_keyword(wptr, wlen, "bus");
#line 307
      if (tmp___11 != 0) {
#line 308
        pvr2_hdw_device_reset(hdw);
      } else {
#line 309
        tmp___10 = debugifc_match_keyword(wptr, wlen, "soft");
#line 309
        if (tmp___10 != 0) {
#line 310
          tmp = pvr2_hdw_cmd_powerup(hdw);
#line 310
          return (tmp);
        } else {
#line 311
          tmp___9 = debugifc_match_keyword(wptr, wlen, "deep");
#line 311
          if (tmp___9 != 0) {
#line 312
            tmp___0 = pvr2_hdw_cmd_deep_reset(hdw);
#line 312
            return (tmp___0);
          } else {
#line 313
            tmp___8 = debugifc_match_keyword(wptr, wlen, "firmware");
#line 313
            if (tmp___8 != 0) {
#line 314
              tmp___1 = pvr2_upload_firmware2(hdw);
#line 314
              return (tmp___1);
            } else {
#line 315
              tmp___7 = debugifc_match_keyword(wptr, wlen, "decoder");
#line 315
              if (tmp___7 != 0) {
#line 316
                tmp___2 = pvr2_hdw_cmd_decoder_reset(hdw);
#line 316
                return (tmp___2);
              } else {
#line 317
                tmp___6 = debugifc_match_keyword(wptr, wlen, "worker");
#line 317
                if (tmp___6 != 0) {
#line 318
                  tmp___3 = pvr2_hdw_untrip(hdw);
#line 318
                  return (tmp___3);
                } else {
#line 319
                  tmp___5 = debugifc_match_keyword(wptr, wlen, "usbstats");
#line 319
                  if (tmp___5 != 0) {
#line 320
                    tmp___4 = pvr2_hdw_get_video_stream(hdw);
#line 320
                    pvr2_stream_get_stats(tmp___4, (struct pvr2_stream_stats *)0,
                                          1);
#line 322
                    return (0);
                  } else {

                  }
                }
              }
            }
          }
        }
      }
    }
#line 324
    return (-22);
  } else {
#line 325
    tmp___21 = debugifc_match_keyword(wptr, wlen, "cpufw");
#line 325
    if (tmp___21 != 0) {
#line 326
      scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 327
      if (scnt == 0U) {
#line 327
        return (-22);
      } else {

      }
#line 328
      count = count - scnt;
#line 328
      buf = buf + (unsigned long )scnt;
#line 329
      if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 329
        return (-22);
      } else {

      }
#line 330
      tmp___17 = debugifc_match_keyword(wptr, wlen, "fetch");
#line 330
      if (tmp___17 != 0) {
#line 331
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 332
        if (scnt != 0U && (unsigned long )wptr != (unsigned long )((char const   *)0)) {
#line 333
          count = count - scnt;
#line 333
          buf = buf + (unsigned long )scnt;
#line 334
          tmp___15 = debugifc_match_keyword(wptr, wlen, "prom");
#line 334
          if (tmp___15 != 0) {
#line 336
            pvr2_hdw_cpufw_set_enabled(hdw, 2, 1);
          } else {
#line 337
            tmp___14 = debugifc_match_keyword(wptr, wlen, "ram8k");
#line 337
            if (tmp___14 != 0) {
#line 339
              pvr2_hdw_cpufw_set_enabled(hdw, 0, 1);
            } else {
#line 340
              tmp___13 = debugifc_match_keyword(wptr, wlen, "ram16k");
#line 340
              if (tmp___13 != 0) {
#line 342
                pvr2_hdw_cpufw_set_enabled(hdw, 1, 1);
              } else {
#line 344
                return (-22);
              }
            }
          }
        } else {

        }
#line 347
        pvr2_hdw_cpufw_set_enabled(hdw, 0, 1);
#line 348
        return (0);
      } else {
#line 349
        tmp___16 = debugifc_match_keyword(wptr, wlen, "done");
#line 349
        if (tmp___16 != 0) {
#line 350
          pvr2_hdw_cpufw_set_enabled(hdw, 0, 0);
#line 351
          return (0);
        } else {
#line 353
          return (-22);
        }
      }
    } else {
#line 355
      tmp___20 = debugifc_match_keyword(wptr, wlen, "gpio");
#line 355
      if (tmp___20 != 0) {
#line 356
        dir_fl = 0;
#line 359
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 360
        if (scnt == 0U) {
#line 360
          return (-22);
        } else {

        }
#line 361
        count = count - scnt;
#line 361
        buf = buf + (unsigned long )scnt;
#line 362
        if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 362
          return (-22);
        } else {

        }
#line 363
        tmp___19 = debugifc_match_keyword(wptr, wlen, "dir");
#line 363
        if (tmp___19 != 0) {
#line 364
          dir_fl = 1;
        } else {
#line 365
          tmp___18 = debugifc_match_keyword(wptr, wlen, "out");
#line 365
          if (tmp___18 == 0) {
#line 366
            return (-22);
          } else {

          }
        }
#line 368
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 369
        if (scnt == 0U) {
#line 369
          return (-22);
        } else {

        }
#line 370
        count = count - scnt;
#line 370
        buf = buf + (unsigned long )scnt;
#line 371
        if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 371
          return (-22);
        } else {

        }
#line 372
        ret = debugifc_parse_unsigned_number(wptr, wlen, & msk);
#line 373
        if (ret != 0) {
#line 373
          return (ret);
        } else {

        }
#line 374
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 375
        if ((unsigned long )wptr != (unsigned long )((char const   *)0)) {
#line 376
          ret = debugifc_parse_unsigned_number(wptr, wlen, & val);
#line 377
          if (ret != 0) {
#line 377
            return (ret);
          } else {

          }
        } else {
#line 379
          val = msk;
#line 380
          msk = 4294967295U;
        }
#line 382
        if (dir_fl != 0) {
#line 383
          ret = pvr2_hdw_gpio_chg_dir(hdw, msk, val);
        } else {
#line 385
          ret = pvr2_hdw_gpio_chg_out(hdw, msk, val);
        }
#line 387
        return (ret);
      } else {

      }
    }
  }
#line 389
  if ((pvrusb2_debug & 67108864) != 0) {
#line 389
    printk("\016pvrusb2: debugifc failed to recognize cmd: \"%.*s\"\n", wlen, wptr);
  } else {

  }
#line 391
  return (-22);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
int pvr2_debugifc_docmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) 
{ 
  unsigned int bcnt ;
  int ret ;

  {
#line 398
  bcnt = 0U;
#line 401
  goto ldv_28867;
  ldv_28866: 
#line 402
  bcnt = 0U;
#line 402
  goto ldv_28865;
  ldv_28864: ;
#line 403
  if ((int )((signed char )*(buf + (unsigned long )bcnt)) == 10) {
#line 403
    goto ldv_28863;
  } else {

  }
#line 402
  bcnt = bcnt + 1U;
  ldv_28865: ;
#line 402
  if (bcnt < count) {
#line 404
    goto ldv_28864;
  } else {

  }
  ldv_28863: 
#line 406
  ret = pvr2_debugifc_do1cmd(hdw, buf, bcnt);
#line 407
  if (ret < 0) {
#line 407
    return (ret);
  } else {

  }
#line 408
  if (bcnt < count) {
#line 408
    bcnt = bcnt + 1U;
  } else {

  }
#line 409
  buf = buf + (unsigned long )bcnt;
#line 410
  count = count - bcnt;
  ldv_28867: ;
#line 401
  if (count != 0U) {
#line 403
    goto ldv_28866;
  } else {

  }

#line 413
  return (0);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/dscv/ri/43_2a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void *ldv_kmem_cache_alloc_726(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 546
  ldv_check_alloc_flags(flags);
#line 548
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 549
  return ((void *)0);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/3122/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
