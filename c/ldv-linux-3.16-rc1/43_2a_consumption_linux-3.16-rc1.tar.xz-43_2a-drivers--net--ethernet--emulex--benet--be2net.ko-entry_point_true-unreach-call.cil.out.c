extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 90 "include/linux/types.h"
typedef unsigned short ushort;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 163 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 168 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 395 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
#line 433 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 72 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 167 "./arch/x86/include/asm/fixmap.h"
struct notifier_block;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 906 "include/linux/mmzone.h"
struct ctl_table;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13764_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13766_128 {
   struct __anonstruct_ldv_13764_129 ldv_13764 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13766_128 ldv_13766 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 24 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14010_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14014_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_14015_135 {
   struct __anonstruct_ldv_14010_136 ldv_14010 ;
   struct __anonstruct_ldv_14014_137 ldv_14014 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14015_135 ldv_14015 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14124_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14130_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14140_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14142_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14140_144 ldv_14140 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14144_142 {
   union __anonunion_ldv_14142_143 ldv_14142 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14146_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14144_142 ldv_14144 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14147_139 {
   union __anonunion_ldv_14130_140 ldv_14130 ;
   union __anonunion_ldv_14146_141 ldv_14146 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14154_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14159_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14154_146 ldv_14154 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14165_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14124_138 ldv_14124 ;
   struct __anonstruct_ldv_14147_139 ldv_14147 ;
   union __anonunion_ldv_14159_145 ldv_14159 ;
   union __anonunion_ldv_14165_147 ldv_14165 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14528_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14528_153 ldv_14528 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14672_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14672_154 ldv_14672 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15347_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15347_155 ldv_15347 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15973_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15979_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_15980_156 {
   struct __anonstruct_ldv_15973_157 ldv_15973 ;
   struct __anonstruct_ldv_15979_158 ldv_15979 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15980_156 ldv_15980 ;
};
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_coalesce;
#line 35
struct ethtool_wolinfo;
#line 38
struct ethtool_pauseparam;
#line 44
struct ethtool_channels;
#line 46
struct ethtool_rxnfc;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 628
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
struct hotplug_slot;
#line 69 "include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 109 "include/linux/pci.h"
typedef int pci_power_t;
#line 136 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 137
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 162 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 185 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 242
struct pcie_link_state;
#line 243
struct pci_vpd;
#line 244
struct pci_sriov;
#line 245
struct pci_ats;
#line 246
struct proc_dir_entry;
#line 246
struct pci_driver;
#line 246 "include/linux/pci.h"
union __anonunion_ldv_17880_162 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 246 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_17880_162 ldv_17880 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 436
struct pci_ops;
#line 436
struct msi_chip;
#line 436 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 553 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 574 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 588 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 598 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 631 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1153 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 217 "./include/uapi/asm-generic/fcntl.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion_ldv_23122_163 {
   struct iovec  const  *iov ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_23122_163 ldv_23122 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 331
enum ldv_19670 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_19670 socket_state;
#line 54
struct poll_table_struct;
#line 55
struct pipe_inode_info;
#line 56
struct net;
#line 73
struct fasync_struct;
#line 73 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 94 "include/linux/net.h"
struct proto_ops;
#line 94 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 120
struct kiocb;
#line 121 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 38 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1153 "include/linux/dmaengine.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 218 "include/linux/capability.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_166 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_166 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_169 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_170 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_171 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_172 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_173 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_174 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_167 {
   int _pad[28U] ;
   struct __anonstruct__kill_168 _kill ;
   struct __anonstruct__timer_169 _timer ;
   struct __anonstruct__rt_170 _rt ;
   struct __anonstruct__sigchld_171 _sigchld ;
   struct __anonstruct__sigfault_172 _sigfault ;
   struct __anonstruct__sigpoll_173 _sigpoll ;
   struct __anonstruct__sigsys_174 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_167 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 459
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 466
struct pid_namespace;
#line 466 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_25945_177 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_25953_178 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_25966_180 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_25967_179 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_25966_180 ldv_25966 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_181 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_183 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_25982_182 {
   union __anonunion_payload_183 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_25945_177 ldv_25945 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_25953_178 ldv_25953 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_25967_179 ldv_25967 ;
   union __anonunion_type_data_181 type_data ;
   union __anonunion_ldv_25982_182 ldv_25982 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct tty_struct;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct backing_dev_info;
#line 779
struct reclaim_state;
#line 780 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1026
struct io_context;
#line 1060
struct uts_namespace;
#line 1061 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct files_struct;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 18 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 137 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 147 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 173
struct skb_frag_struct;
#line 173 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 174 "include/linux/skbuff.h"
struct __anonstruct_page_186 {
   struct page *p ;
};
#line 174 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_186 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 207 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
   ktime_t syststamp ;
};
#line 276 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 360 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 361 "include/linux/skbuff.h"
struct __anonstruct_ldv_27728_188 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 361 "include/linux/skbuff.h"
union __anonunion_ldv_27729_187 {
   u64 v64 ;
   struct __anonstruct_ldv_27728_188 ldv_27728 ;
};
#line 361 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_ldv_27729_187 ldv_27729 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_27748_189 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 414
struct sec_path;
#line 414 "include/linux/skbuff.h"
struct __anonstruct_ldv_27764_191 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_27765_190 {
   __wsum csum ;
   struct __anonstruct_ldv_27764_191 ldv_27764 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_27804_192 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_27810_193 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 414 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_27748_189 ldv_27748 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_27765_190 ldv_27765 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_27804_192 ldv_27804 ;
   __u32 secmark ;
   union __anonunion_ldv_27810_193 ldv_27810 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 641
struct dst_entry;
#line 709
struct rtable;
#line 825
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
} ;
#line 3161 "include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 84 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 48 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 53
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 59 "include/linux/pm_qos.h"
union __anonunion_data_194 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 59 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_194 data ;
   struct device *dev ;
};
#line 68
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 74 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 88 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 93 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 54 "include/linux/delay.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_195 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_195 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_196 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_196 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_197 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_197 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_198 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_198 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_199 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_199 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_200 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_200 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_201 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_201 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_202 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_202 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_203 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_204 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_203 ifr_ifrn ;
   union __anonunion_ifr_ifru_204 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_29549_207 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_29550_206 {
   struct __anonstruct_ldv_29549_207 ldv_29549 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_29550_206 ldv_29550 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct_ldv_29573_209 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion_ldv_29575_208 {
   struct __anonstruct_ldv_29573_209 ldv_29573 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_29575_208 ldv_29575 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_210 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_210 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_29936_212 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_29938_211 {
   struct __anonstruct_ldv_29936_212 ldv_29936 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_29938_211 ldv_29938 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct kstatfs;
#line 62
struct swap_info_struct;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_213 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_213 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_30463_214 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_30463_214 ldv_30463 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30877_217 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30897_218 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_30914_219 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_30877_217 ldv_30877 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_30897_218 ldv_30897 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_30914_219 ldv_30914 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_220 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_220 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_222 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_221 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_222 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_221 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 703 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 187 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 211 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 259 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 288 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 305 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 441 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 469 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 568 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 600 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 642 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 675 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 691 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 711 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 722 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 741 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 767 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 933 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 941 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1017 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 261 "include/linux/ethtool.h"
union __anonunion_in6_u_239 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 261 "include/linux/ethtool.h"
struct in6_addr {
   union __anonunion_in6_u_239 in6_u ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[103U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 102
struct neighbour;
#line 102 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 35 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 35
struct rt6_info;
#line 35
struct rt6_statistics;
#line 35
struct fib6_table;
#line 35 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 80 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 86 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
#line 21
struct sctp_mib;
#line 22 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 324 "include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 24 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 29 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 43 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 48 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 53 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 64 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 72
struct ip_conntrack_stat;
#line 72
struct nf_ct_event_notifier;
#line 72
struct nf_exp_event_notifier;
#line 72 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 111
struct nft_af_info;
#line 112 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 450 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 663 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 17 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 74
struct net_generic;
#line 75
struct netns_ipvs;
#line 76 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 400 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 205 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 919 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 103 "include/linux/security.h"
struct xfrm_policy;
#line 104
struct xfrm_state;
#line 124
struct request_sock;
#line 3161
struct mnt_namespace;
#line 3162
struct ipc_namespace;
#line 3163 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 180 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 547 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 28 "include/linux/if_link.h"
struct netpoll_info;
#line 29
struct phy_device;
#line 30
struct wireless_dev;
#line 61 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 106 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 125 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 186
struct neigh_parms;
#line 187 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 207 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 212 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 241 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 292 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 327
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 335 "include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 336
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 384 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 385 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 522
struct Qdisc;
#line 522 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 591 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 603 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 615 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 666 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 689 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 724 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 740 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 753 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_adj_list_250 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_251 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187
struct iw_handler_def;
#line 1187
struct iw_public_data;
#line 1187
struct forwarding_accel_ops;
#line 1187
struct vlan_info;
#line 1187
struct tipc_bearer;
#line 1187
struct in_device;
#line 1187
struct dn_dev;
#line 1187
struct inet6_dev;
#line 1187
struct cpu_rmap;
#line 1187
struct pcpu_lstats;
#line 1187
struct pcpu_sw_netstats;
#line 1187
struct pcpu_dstats;
#line 1187
struct pcpu_vstats;
#line 1187 "include/linux/netdevice.h"
union __anonunion_ldv_42064_252 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1187
struct garp_port;
#line 1187
struct mrp_port;
#line 1187
struct rtnl_link_ops;
#line 1187 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_250 adj_list ;
   struct __anonstruct_all_adj_list_251 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_42064_252 ldv_42064 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1806 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2548
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 600 "include/linux/memcontrol.h"
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
#line 222 "include/linux/res_counter.h"
struct kioctx;
#line 30 "include/linux/aio.h"
typedef int kiocb_cancel_fn(struct kiocb * );
#line 31 "include/linux/aio.h"
union __anonunion_ki_obj_253 {
   void *user ;
   struct task_struct *tsk ;
};
#line 31
struct eventfd_ctx;
#line 31 "include/linux/aio.h"
struct kiocb {
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void *private ;
   union __anonunion_ki_obj_253 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   size_t ki_nbytes ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 100 "include/linux/aio.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 49 "include/uapi/linux/filter.h"
struct sock_filter_int {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 314 "include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 320 "include/linux/filter.h"
union __anonunion_ldv_44054_254 {
   struct sock_filter insns[0U] ;
   struct sock_filter_int insnsi[0U] ;
   struct work_struct work ;
};
#line 320 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   unsigned char jited : 1 ;
   unsigned int len : 31 ;
   struct sock_fprog_kern *orig_prog ;
   struct callback_head rcu ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct sock_filter_int  const  * ) ;
   union __anonunion_ldv_44054_254 ldv_44054 ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 113 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
};
#line 167
struct neigh_table;
#line 167 "include/net/rtnetlink.h"
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[12U] ;
   unsigned long data_state[1U] ;
};
#line 111 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 130
struct neigh_ops;
#line 130 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 159 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 167 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 177 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 190 "include/net/neighbour.h"
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 462
struct dn_route;
#line 462 "include/net/neighbour.h"
union __anonunion_ldv_45547_259 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 462 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_ldv_45547_259 ldv_45547 ;
};
#line 123 "include/net/sock.h"
struct __anonstruct_socket_lock_t_260 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 123 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_260 socket_lock_t;
#line 123
struct proto;
#line 129 "include/net/sock.h"
typedef __u32 __portpair;
#line 130 "include/net/sock.h"
typedef __u64 __addrpair;
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_45782_262 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_45783_261 {
   __addrpair skc_addrpair ;
   struct __anonstruct_ldv_45782_262 ldv_45782 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_45787_263 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_45793_265 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_45794_264 {
   __portpair skc_portpair ;
   struct __anonstruct_ldv_45793_265 ldv_45793 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_45803_266 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_45812_267 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 131 "include/net/sock.h"
struct sock_common {
   union __anonunion_ldv_45783_261 ldv_45783 ;
   union __anonunion_ldv_45787_263 ldv_45787 ;
   union __anonunion_ldv_45794_264 ldv_45794 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion_ldv_45803_266 ldv_45803 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_ldv_45812_267 ldv_45812 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 216
struct cg_proto;
#line 217 "include/net/sock.h"
struct __anonstruct_sk_backlog_268 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 217 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_268 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 903
struct request_sock_ops;
#line 904
struct timewait_sock_ops;
#line 905
struct inet_hashinfo;
#line 906
struct raw_hashinfo;
#line 921
struct udp_table;
#line 921 "include/net/sock.h"
union __anonunion_h_269 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 921 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  , int  ,
                  int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_269 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1046 "include/net/sock.h"
struct cg_proto {
   struct res_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 8 "include/linux/unaligned/packed_struct.h"
struct __una_u32 {
   u32 x ;
};
#line 169 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
#line 47 "include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
#line 372 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 17 "include/linux/cryptohash.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 48 "include/uapi/linux/ipv6.h"
struct ipv6_opt_hdr {
   __u8 nexthdr ;
   __u8 hdrlen ;
};
#line 102 "include/uapi/linux/ipv6.h"
struct ipv6hdr {
   unsigned char priority : 4 ;
   unsigned char version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 166 "include/uapi/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   void *sysctl ;
};
#line 101 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 110 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 142 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 154 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 165 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 872 "include/net/ipv6.h"
union __anonunion_ldv_50160_283 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
#line 872 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_ldv_50160_283 ldv_50160 ;
};
#line 24 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_50175_284 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 29 "include/net/inetpeer.h"
struct __anonstruct_ldv_50179_286 {
   atomic_t rid ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_50182_285 {
   struct __anonstruct_ldv_50179_286 ldv_50179 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 29 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[15U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_ldv_50175_284 ldv_50175 ;
   union __anonunion_ldv_50182_285 ldv_50182 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 60 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
#line 50 "./include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
#line 315 "include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};
#line 95 "include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 103 "include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 115 "include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
   atomic_t bsockets ;
};
#line 42 "include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 498 "include/linux/if_vlan.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 73 "include/linux/firmware.h"
struct be_eq_entry {
   u32 evt ;
};
#line 280 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_wrb {
   u32 frag_pa_hi ;
   u32 frag_pa_lo ;
   u32 rsvd0 ;
   u32 frag_len ;
};
#line 313 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_hdr_wrb {
   u32 dw[4U] ;
};
#line 340 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_tx_compl {
   u32 dw[4U] ;
};
#line 344 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_d {
   u32 fragpa_hi ;
   u32 fragpa_lo ;
};
#line 422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_compl {
   u32 dw[4U] ;
};
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_comp {
   unsigned long offset ;
   int optype ;
   int size ;
   int img_type ;
};
#line 487 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct image_hdr {
   u32 imageid ;
   u32 imageoffset ;
   u32 imagelength ;
   u32 image_checksum ;
   u8 image_version[32U] ;
};
#line 506 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_file_hdr_g3 {
   u8 sign[52U] ;
   u8 ufi_version[4U] ;
   u32 file_len ;
   u32 cksum ;
   u32 antidote ;
   u32 num_imgs ;
   u8 build[24U] ;
   u8 asic_type_rev ;
   u8 rsvd[31U] ;
};
#line 518 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 num_images ;
   u8 id_string[128U] ;
   u32 rsvd[4U] ;
};
#line 527 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr_g2 {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 build_num ;
   u8 id_string[128U] ;
   u32 rsvd[8U] ;
};
#line 536 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_entry {
   u32 type ;
   u32 offset ;
   u32 pad_size ;
   u32 image_size ;
   u32 cksum ;
   u32 main ;
   u16 optype ;
   u16 rsvd0 ;
   u32 rsvd1 ;
   u8 ver_data[32U] ;
};
#line 549 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info {
   u8 cookie[32U] ;
   struct flash_section_hdr fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 555 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info_g2 {
   u8 cookie[32U] ;
   struct flash_section_hdr_g2 fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 561
struct ocrdma_dev;
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 131 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 187
struct be_adapter;
#line 187 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_eq_obj {
   struct be_queue_info q ;
   char desc[32U] ;
   bool enable_aic ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 eqd ;
   u32 cur_eqd ;
   u8 idx ;
   u8 msix_idx ;
   u16 tx_budget ;
   u16 spurious_intr ;
   struct napi_struct napi ;
   struct be_adapter *adapter ;
   unsigned int state ;
   spinlock_t lock ;
};
#line 218 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_aic_obj {
   bool enable ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 prev_eqd ;
   u32 et_eqd ;
   ulong jiffies ;
   u64 rx_pkts_prev ;
   u64 tx_reqs_prev ;
};
#line 235 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
   bool rearm_cq ;
};
#line 241 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_stats {
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_reqs ;
   u64 tx_wrbs ;
   u64 tx_compl ;
   ulong tx_jiffies ;
   u32 tx_stops ;
   u32 tx_drv_drops ;
   struct u64_stats_sync sync ;
   struct u64_stats_sync sync_compl ;
};
#line 254 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_obj {
   u32 db_offset ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct sk_buff *sent_skb_list[2048U] ;
   struct be_tx_stats stats ;
};
#line 263 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_page_info {
   struct page *page ;
   dma_addr_t bus ;
   u16 page_offset ;
   bool last_frag ;
};
#line 272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_stats {
   u64 rx_bytes ;
   u64 rx_pkts ;
   u32 rx_drops_no_skbs ;
   u32 rx_drops_no_frags ;
   u32 rx_post_fail ;
   u32 rx_compl ;
   u32 rx_mcast_pkts ;
   u32 rx_compl_err ;
   struct u64_stats_sync sync ;
};
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_compl_info {
   u32 rss_hash ;
   u16 vlan_tag ;
   u16 pkt_size ;
   u16 port ;
   u8 vlanf ;
   u8 num_rcvd ;
   u8 err ;
   u8 ipf ;
   u8 tcpf ;
   u8 udpf ;
   u8 ip_csum ;
   u8 l4_csum ;
   u8 ipv6 ;
   u8 qnq ;
   u8 pkt_type ;
   u8 ip_frag ;
   u8 tunneled ;
};
#line 304 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_obj {
   struct be_adapter *adapter ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct be_rx_compl_info rxcp ;
   struct be_rx_page_info page_info_tbl[1024U] ;
   struct be_rx_stats stats ;
   u8 rss_id ;
   bool rx_post_starved ;
};
#line 315 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_drv_stats {
   u32 be_on_die_temperature ;
   u32 eth_red_drops ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rx_drops_too_many_frags ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rx_roce_bytes_lsd ;
   u32 rx_roce_bytes_msd ;
   u32 rx_roce_frames ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
};
#line 356 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_vf_cfg {
   unsigned char mac_addr[6U] ;
   int if_handle ;
   int pmac_id ;
   u16 vlan_tag ;
   u32 tx_rate ;
   u32 plink_tracking ;
};
#line 373 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct phy_info {
   u8 transceiver ;
   u8 autoneg ;
   u8 fc_autoneg ;
   u8 port_type ;
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   int link_speed ;
   u32 dac_cable_len ;
   u32 advertising ;
   u32 supported ;
};
#line 403 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_resources {
   u16 max_vfs ;
   u16 max_mcast_mac ;
   u16 max_tx_qs ;
   u16 max_rss_qs ;
   u16 max_rx_qs ;
   u16 max_uc_mac ;
   u16 max_vlans ;
   u16 max_evt_qs ;
   u32 if_cap_flags ;
};
#line 415 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct rss_info {
   u64 rss_flags ;
   u8 rsstable[128U] ;
   u8 rss_queue[128U] ;
   u8 rss_hkey[40U] ;
};
#line 422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct __anonstruct_roce_db_291 {
   u32 size ;
   u32 total_size ;
   u64 io_addr ;
};
#line 422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_adapter {
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 *csr ;
   u8 *db ;
   struct mutex mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   u16 cfg_num_qs ;
   u16 num_evt_qs ;
   u16 num_msix_vec ;
   struct be_eq_obj eq_obj[32U] ;
   struct msix_entry msix_entries[32U] ;
   bool isr_registered ;
   u16 num_tx_qs ;
   struct be_tx_obj tx_obj[32U] ;
   u16 num_rx_qs ;
   struct be_rx_obj rx_obj[32U] ;
   u32 big_page_size ;
   struct be_drv_stats drv_stats ;
   struct be_aic_obj aic_obj[32U] ;
   u16 vlans_added ;
   unsigned long vids[64U] ;
   u8 vlan_prio_bmap ;
   u16 recommended_prio ;
   struct be_dma_mem rx_filter ;
   struct be_dma_mem stats_cmd ;
   struct delayed_work work ;
   u16 work_counter ;
   struct delayed_work func_recovery_work ;
   u32 flags ;
   u32 cmd_privileges ;
   char fw_ver[32U] ;
   char fw_on_flash[32U] ;
   int if_handle ;
   u32 *pmac_id ;
   u32 beacon_state ;
   bool eeh_error ;
   bool fw_timeout ;
   bool hw_error ;
   u32 port_num ;
   bool promiscuous ;
   u8 mc_type ;
   u32 function_mode ;
   u32 function_caps ;
   u32 rx_fc ;
   u32 tx_fc ;
   bool stats_cmd_sent ;
   struct __anonstruct_roce_db_291 roce_db ;
   u32 num_msix_roce_vec ;
   struct ocrdma_dev *ocrdma_dev ;
   struct list_head entry ;
   u32 flash_status ;
   struct completion et_cmd_compl ;
   struct be_resources res ;
   u16 num_vfs ;
   u8 virtfn ;
   struct be_vf_cfg *vf_cfg ;
   bool be3_native ;
   u32 sli_family ;
   u8 hba_port_num ;
   u16 pvid ;
   __be16 vxlan_port ;
   struct phy_info phy ;
   u8 wol_cap ;
   bool wol_en ;
   u32 uc_macs ;
   u16 asic_rev ;
   u16 qnq_vid ;
   u32 msg_enable ;
   int be_get_temp_freq ;
   u8 pf_number ;
   struct rss_info rss_info ;
};
#line 175 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd[3U] ;
};
#line 263 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd[2U] ;
   u8 base_status ;
   u8 addl_status ;
   u8 rsvd1[2U] ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 611 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v0 {
   u32 rx_bytes_lsd ;
   u32 rx_bytes_msd ;
   u32 rx_total_frames ;
   u32 rx_unicast_frames ;
   u32 rx_multicast_frames ;
   u32 rx_broadcast_frames ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_64_byte_packets ;
   u32 rx_65_127_byte_packets ;
   u32 rx_128_256_byte_packets ;
   u32 rx_256_511_byte_packets ;
   u32 rx_512_1023_byte_packets ;
   u32 rx_1024_1518_byte_packets ;
   u32 rx_1519_2047_byte_packets ;
   u32 rx_2048_4095_byte_packets ;
   u32 rx_4096_8191_byte_packets ;
   u32 rx_8192_9216_byte_packets ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rx_non_rss_packets ;
   u32 rx_ipv4_packets ;
   u32 rx_ipv6_packets ;
   u32 rx_ipv4_bytes_lsd ;
   u32 rx_ipv4_bytes_msd ;
   u32 rx_ipv6_bytes_lsd ;
   u32 rx_ipv6_bytes_msd ;
   u32 rx_chute1_packets ;
   u32 rx_chute2_packets ;
   u32 rx_chute3_packets ;
   u32 rx_management_packets ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 tx_bytes_lsd ;
   u32 tx_bytes_msd ;
   u32 tx_unicastframes ;
   u32 tx_multicastframes ;
   u32 tx_broadcastframes ;
   u32 tx_pauseframes ;
   u32 tx_controlframes ;
   u32 tx_64_byte_packets ;
   u32 tx_65_127_byte_packets ;
   u32 tx_128_256_byte_packets ;
   u32 tx_256_511_byte_packets ;
   u32 tx_512_1023_byte_packets ;
   u32 tx_1024_1518_byte_packets ;
   u32 tx_1519_2047_byte_packets ;
   u32 tx_2048_4095_byte_packets ;
   u32 tx_4096_8191_byte_packets ;
   u32 tx_8192_9216_byte_packets ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
};
#line 681 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v0 {
   struct be_port_rxf_stats_v0 port[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 management_rx_port_packets ;
   u32 management_rx_port_bytes ;
   u32 management_rx_port_pause_frames ;
   u32 management_rx_port_errors ;
   u32 management_tx_port_packets ;
   u32 management_tx_port_bytes ;
   u32 management_tx_port_pause ;
   u32 management_rx_port_rxfifo_overflow ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd0[7U] ;
   u32 port0_jabber_events ;
   u32 port1_jabber_events ;
   u32 rsvd1[6U] ;
};
#line 705 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v0 {
   u32 rx_drops_no_fragments[44U] ;
   u32 rsvd[4U] ;
};
#line 710 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pmem_stats {
   u32 eth_red_drops ;
   u32 rsvd[5U] ;
};
#line 715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v0 {
   struct be_rxf_stats_v0 rxf ;
   u32 rsvd[48U] ;
   struct be_erx_stats_v0 erx ;
   struct be_pmem_stats pmem ;
};
#line 727 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v0 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v0 hw_stats ;
};
#line 732 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_pport_stats {
   u32 tx_packets_lo ;
   u32 tx_packets_hi ;
   u32 tx_unicast_packets_lo ;
   u32 tx_unicast_packets_hi ;
   u32 tx_multicast_packets_lo ;
   u32 tx_multicast_packets_hi ;
   u32 tx_broadcast_packets_lo ;
   u32 tx_broadcast_packets_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
   u32 tx_unicast_bytes_lo ;
   u32 tx_unicast_bytes_hi ;
   u32 tx_multicast_bytes_lo ;
   u32 tx_multicast_bytes_hi ;
   u32 tx_broadcast_bytes_lo ;
   u32 tx_broadcast_bytes_hi ;
   u32 tx_discards_lo ;
   u32 tx_discards_hi ;
   u32 tx_errors_lo ;
   u32 tx_errors_hi ;
   u32 tx_pause_frames_lo ;
   u32 tx_pause_frames_hi ;
   u32 tx_pause_on_frames_lo ;
   u32 tx_pause_on_frames_hi ;
   u32 tx_pause_off_frames_lo ;
   u32 tx_pause_off_frames_hi ;
   u32 tx_internal_mac_errors_lo ;
   u32 tx_internal_mac_errors_hi ;
   u32 tx_control_frames_lo ;
   u32 tx_control_frames_hi ;
   u32 tx_packets_64_bytes_lo ;
   u32 tx_packets_64_bytes_hi ;
   u32 tx_packets_65_to_127_bytes_lo ;
   u32 tx_packets_65_to_127_bytes_hi ;
   u32 tx_packets_128_to_255_bytes_lo ;
   u32 tx_packets_128_to_255_bytes_hi ;
   u32 tx_packets_256_to_511_bytes_lo ;
   u32 tx_packets_256_to_511_bytes_hi ;
   u32 tx_packets_512_to_1023_bytes_lo ;
   u32 tx_packets_512_to_1023_bytes_hi ;
   u32 tx_packets_1024_to_1518_bytes_lo ;
   u32 tx_packets_1024_to_1518_bytes_hi ;
   u32 tx_packets_1519_to_2047_bytes_lo ;
   u32 tx_packets_1519_to_2047_bytes_hi ;
   u32 tx_packets_2048_to_4095_bytes_lo ;
   u32 tx_packets_2048_to_4095_bytes_hi ;
   u32 tx_packets_4096_to_8191_bytes_lo ;
   u32 tx_packets_4096_to_8191_bytes_hi ;
   u32 tx_packets_8192_to_9216_bytes_lo ;
   u32 tx_packets_8192_to_9216_bytes_hi ;
   u32 tx_lso_packets_lo ;
   u32 tx_lso_packets_hi ;
   u32 rx_packets_lo ;
   u32 rx_packets_hi ;
   u32 rx_unicast_packets_lo ;
   u32 rx_unicast_packets_hi ;
   u32 rx_multicast_packets_lo ;
   u32 rx_multicast_packets_hi ;
   u32 rx_broadcast_packets_lo ;
   u32 rx_broadcast_packets_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 rx_unicast_bytes_lo ;
   u32 rx_unicast_bytes_hi ;
   u32 rx_multicast_bytes_lo ;
   u32 rx_multicast_bytes_hi ;
   u32 rx_broadcast_bytes_lo ;
   u32 rx_broadcast_bytes_hi ;
   u32 rx_unknown_protos ;
   u32 rsvd_69 ;
   u32 rx_discards_lo ;
   u32 rx_discards_hi ;
   u32 rx_errors_lo ;
   u32 rx_errors_hi ;
   u32 rx_crc_errors_lo ;
   u32 rx_crc_errors_hi ;
   u32 rx_alignment_errors_lo ;
   u32 rx_alignment_errors_hi ;
   u32 rx_symbol_errors_lo ;
   u32 rx_symbol_errors_hi ;
   u32 rx_pause_frames_lo ;
   u32 rx_pause_frames_hi ;
   u32 rx_pause_on_frames_lo ;
   u32 rx_pause_on_frames_hi ;
   u32 rx_pause_off_frames_lo ;
   u32 rx_pause_off_frames_hi ;
   u32 rx_frames_too_long_lo ;
   u32 rx_frames_too_long_hi ;
   u32 rx_internal_mac_errors_lo ;
   u32 rx_internal_mac_errors_hi ;
   u32 rx_undersize_packets ;
   u32 rx_oversize_packets ;
   u32 rx_fragment_packets ;
   u32 rx_jabbers ;
   u32 rx_control_frames_lo ;
   u32 rx_control_frames_hi ;
   u32 rx_control_frames_unknown_opcode_lo ;
   u32 rx_control_frames_unknown_opcode_hi ;
   u32 rx_in_range_errors ;
   u32 rx_out_of_range_errors ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_invalid_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errors ;
   u32 rx_tcp_checksum_errors ;
   u32 rx_udp_checksum_errors ;
   u32 rx_non_rss_packets ;
   u32 rsvd_111 ;
   u32 rx_ipv4_packets_lo ;
   u32 rx_ipv4_packets_hi ;
   u32 rx_ipv6_packets_lo ;
   u32 rx_ipv6_packets_hi ;
   u32 rx_ipv4_bytes_lo ;
   u32 rx_ipv4_bytes_hi ;
   u32 rx_ipv6_bytes_lo ;
   u32 rx_ipv6_bytes_hi ;
   u32 rx_nic_packets_lo ;
   u32 rx_nic_packets_hi ;
   u32 rx_tcp_packets_lo ;
   u32 rx_tcp_packets_hi ;
   u32 rx_iscsi_packets_lo ;
   u32 rx_iscsi_packets_hi ;
   u32 rx_management_packets_lo ;
   u32 rx_management_packets_hi ;
   u32 rx_switched_unicast_packets_lo ;
   u32 rx_switched_unicast_packets_hi ;
   u32 rx_switched_multicast_packets_lo ;
   u32 rx_switched_multicast_packets_hi ;
   u32 rx_switched_broadcast_packets_lo ;
   u32 rx_switched_broadcast_packets_hi ;
   u32 num_forwards_lo ;
   u32 num_forwards_hi ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
   u32 rx_drops_too_many_frags_lo ;
   u32 rx_drops_too_many_frags_hi ;
   u32 rx_drops_invalid_queue ;
   u32 rsvd_141 ;
   u32 rx_drops_mtu_lo ;
   u32 rx_drops_mtu_hi ;
   u32 rx_packets_64_bytes_lo ;
   u32 rx_packets_64_bytes_hi ;
   u32 rx_packets_65_to_127_bytes_lo ;
   u32 rx_packets_65_to_127_bytes_hi ;
   u32 rx_packets_128_to_255_bytes_lo ;
   u32 rx_packets_128_to_255_bytes_hi ;
   u32 rx_packets_256_to_511_bytes_lo ;
   u32 rx_packets_256_to_511_bytes_hi ;
   u32 rx_packets_512_to_1023_bytes_lo ;
   u32 rx_packets_512_to_1023_bytes_hi ;
   u32 rx_packets_1024_to_1518_bytes_lo ;
   u32 rx_packets_1024_to_1518_bytes_hi ;
   u32 rx_packets_1519_to_2047_bytes_lo ;
   u32 rx_packets_1519_to_2047_bytes_hi ;
   u32 rx_packets_2048_to_4095_bytes_lo ;
   u32 rx_packets_2048_to_4095_bytes_hi ;
   u32 rx_packets_4096_to_8191_bytes_lo ;
   u32 rx_packets_4096_to_8191_bytes_hi ;
   u32 rx_packets_8192_to_9216_bytes_lo ;
   u32 rx_packets_8192_to_9216_bytes_hi ;
};
#line 913 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_pport_stats {
   struct be_cmd_resp_hdr hdr ;
   struct lancer_pport_stats pport_stats ;
};
#line 1070 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_set_eqd {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 1176 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flashrom_params {
   u32 op_code ;
   u32 op_type ;
   u32 data_buf_size ;
   u32 offset ;
};
#line 1184 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_write_flashrom {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 data_buf[32768U] ;
   u8 rsvd[4U] ;
};
#line 1618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v1 {
   u32 rsvd0[12U] ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd1[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd2[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd3[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd4[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd5[3U] ;
};
#line 1656 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v1 {
   struct be_port_rxf_stats_v1 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[14U] ;
};
#line 1672 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v1 {
   u32 rx_drops_no_fragments[68U] ;
   u32 rsvd[4U] ;
};
#line 1677 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v2 {
   u32 rsvd0[10U] ;
   u32 roce_bytes_received_lsd ;
   u32 roce_bytes_received_msd ;
   u32 rsvd1[5U] ;
   u32 roce_frames_received ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd2[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd3[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd4[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd5[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd6[3U] ;
   u32 rx_drops_payload_size ;
   u32 rx_drops_clipped_header ;
   u32 rx_drops_crc ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
   u32 rsvd7[19U] ;
};
#line 1723 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v2 {
   struct be_port_rxf_stats_v2 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[35U] ;
};
#line 1738 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v1 {
   struct be_rxf_stats_v1 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v1 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v1 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v1 hw_stats ;
};
#line 1756 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v2 {
   u32 rx_drops_no_fragments[136U] ;
   u32 rsvd[3U] ;
};
#line 1761 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v2 {
   struct be_rxf_stats_v2 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v2 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1774 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v2 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v2 hw_stats ;
};
#line 6522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 6543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 6588 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 426 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_hba_attribs {
   u8 flashrom_version_string[32U] ;
   u8 manufacturer_name[32U] ;
   u32 supported_modes ;
   u32 rsvd0[3U] ;
   u8 ncsi_ver_string[12U] ;
   u32 default_extended_timeout ;
   u8 controller_model_number[32U] ;
   u8 controller_description[64U] ;
   u8 controller_serial_number[32U] ;
   u8 ip_version_string[32U] ;
   u8 firmware_version_string[32U] ;
   u8 bios_version_string[32U] ;
   u8 redboot_version_string[32U] ;
   u8 driver_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
   u32 functionalities_supported ;
   u16 max_cdblength ;
   u8 asic_revision ;
   u8 generational_guid[16U] ;
   u8 hba_port_count ;
   u16 default_link_down_timeout ;
   u8 iscsi_ver_min_max ;
   u8 multifunction_device ;
   u8 cache_valid ;
   u8 hba_status ;
   u8 max_domains_supported ;
   u8 phy_port ;
   u32 firmware_post_status ;
   u32 hba_mtu[8U] ;
   u32 rsvd1[4U] ;
};
#line 459 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_controller_attrib {
   struct mgmt_hba_attribs hba_attribs ;
   u16 pci_vendor_id ;
   u16 pci_device_id ;
   u16 pci_sub_vendor_id ;
   u16 pci_sub_system_id ;
   u8 pci_bus_number ;
   u8 pci_device_number ;
   u8 pci_function_number ;
   u8 interface_type ;
   u64 unique_identifier ;
   u32 rsvd0[5U] ;
};
#line 895 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 len ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_payload_292 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_292 payload ;
};
#line 46
enum mcc_base_status {
    MCC_STATUS_SUCCESS = 0,
    MCC_STATUS_FAILED = 1,
    MCC_STATUS_ILLEGAL_REQUEST = 2,
    MCC_STATUS_ILLEGAL_FIELD = 3,
    MCC_STATUS_INSUFFICIENT_BUFFER = 4,
    MCC_STATUS_UNAUTHORIZED_REQUEST = 5,
    MCC_STATUS_NOT_SUPPORTED = 66
} ;
#line 56
enum mcc_addl_status {
    MCC_ADDL_STATUS_INSUFFICIENT_RESOURCES = 22,
    MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH = 77,
    MCC_ADDL_STATUS_TOO_MANY_INTERFACES = 74
} ;
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 94 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   u32 flags ;
};
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_qos_link_speed {
   u8 physical_port ;
   u8 rsvd[5U] ;
   u16 qos_link_speed ;
   u32 event_tag ;
   u32 flags ;
};
#line 135 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_cos_priority {
   u8 physical_port ;
   u8 available_priority_bmap ;
   u8 reco_default_priority ;
   u8 valid ;
   u8 rsvd0 ;
   u8 event_tag ;
   u32 flags ;
};
#line 148 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_pvid_state {
   u8 enabled ;
   u8 rsvd0 ;
   u16 tag ;
   u32 event_tag ;
   u32 rsvd1 ;
   u32 flags ;
};
#line 160 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_qnq {
   u8 valid ;
   u8 rsvd0 ;
   u16 vlan_tag ;
   u32 event_tag ;
   u8 rsvd1[4U] ;
   u32 flags ;
};
#line 170 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 320 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 msix_idx ;
};
#line 333 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mac_addr {
   u16 size_of_struct ;
   u8 addr[6U] ;
};
#line 339 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mac_query {
   struct be_cmd_req_hdr hdr ;
   u8 type ;
   u8 permanent ;
   u16 if_id ;
   u32 pmac_id ;
};
#line 347 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mac_query {
   struct be_cmd_resp_hdr hdr ;
   struct mac_addr mac ;
};
#line 352 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_add {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u8 mac_address[6U] ;
   u8 rsvd0[2U] ;
};
#line 360 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_pmac_add {
   struct be_cmd_resp_hdr hdr ;
   u32 pmac_id ;
};
#line 365 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_del {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u32 pmac_id ;
};
#line 414 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 430 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fat {
   struct be_cmd_req_hdr hdr ;
   u32 fat_operation ;
   u32 read_log_offset ;
   u32 read_log_length ;
   u32 data_buffer_size ;
   u32 data_buffer[1U] ;
};
#line 439 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fat {
   struct be_cmd_resp_hdr hdr ;
   u32 log_size ;
   u32 read_log_length ;
   u32 rsvd[2U] ;
   u32 data_buffer[1U] ;
};
#line 477 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 485 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_ext_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u32 async_event_bitmap[1U] ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 494 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 500 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_tx_create {
   struct be_cmd_req_hdr hdr ;
   u8 num_pages ;
   u8 ulp_num ;
   u16 type ;
   u16 if_id ;
   u8 queue_size ;
   u8 rsvd0 ;
   u32 rsvd1 ;
   u16 cq_id ;
   u16 rsvd2 ;
   u32 rsvd3[13U] ;
   struct phys_addr pages[8U] ;
};
#line 519 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_tx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cid ;
   u16 rid ;
   u32 db_offset ;
   u32 rsvd0[4U] ;
};
#line 527 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_rx_create {
   struct be_cmd_req_hdr hdr ;
   u16 cq_id ;
   u8 frag_size ;
   u8 num_pages ;
   struct phys_addr pages[2U] ;
   u32 interface_id ;
   u16 max_frame_size ;
   u16 rsvd0 ;
   u32 rss_queue ;
};
#line 540 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_rx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u8 rss_id ;
   u8 rsvd0 ;
};
#line 555 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 577 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_create {
   struct be_cmd_req_hdr hdr ;
   u32 version ;
   u32 capability_flags ;
   u32 enable_flags ;
   u8 mac_addr[6U] ;
   u8 rsvd0 ;
   u8 pmac_invalid ;
   u32 vlan_tag ;
};
#line 599 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_if_create {
   struct be_cmd_resp_hdr hdr ;
   u32 interface_id ;
   u32 pmac_id ;
};
#line 605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_destroy {
   struct be_cmd_req_hdr hdr ;
   u32 interface_id ;
};
#line 899 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct pport_stats_params {
   u16 pport_num ;
   u8 rsvd ;
   u8 reset_stats ;
};
#line 905 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_cmd_params_293 {
   struct pport_stats_params params ;
   u8 rsvd[656U] ;
};
#line 905 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_pport_stats {
   struct be_cmd_req_hdr hdr ;
   union __anonunion_cmd_params_293 cmd_params ;
};
#line 925 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_cntl_addnl_attribs {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd[8U] ;
};
#line 930 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_cntl_addnl_attribs {
   struct be_cmd_resp_hdr hdr ;
   u16 ipl_file_number ;
   u8 ipl_file_version ;
   u8 rsvd0 ;
   u8 on_die_temperature ;
   u8 rsvd1[3U] ;
};
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_vlan_config {
   struct be_cmd_req_hdr hdr ;
   u8 interface_id ;
   u8 promiscuous ;
   u8 untagged ;
   u8 num_vlan ;
   u16 normal_vlan[64U] ;
};
#line 948 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct macaddr {
   u8 byte[6U] ;
};
#line 954 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rx_filter {
   struct be_cmd_req_hdr hdr ;
   u32 global_flags_mask ;
   u32 global_flags ;
   u32 if_flags_mask ;
   u32 if_flags ;
   u32 if_id ;
   u32 mcast_num ;
   struct macaddr mcast_mac[64U] ;
};
#line 965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_link_status {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 988 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_link_status {
   struct be_cmd_resp_hdr hdr ;
   u8 physical_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 link_speed ;
   u8 logical_link_status ;
   u8 rsvd1[3U] ;
};
#line 1038 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fw_version {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[32U] ;
   u8 rsvd1[32U] ;
};
#line 1045 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fw_version {
   struct be_cmd_resp_hdr hdr ;
   u8 firmware_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
};
#line 1051 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_flow_control {
   struct be_cmd_req_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1058 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_flow_control {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1064 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_flow_control {
   struct be_cmd_resp_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1077 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   u32 num_eq ;
   struct be_set_eqd set_eqd[32U] ;
};
#line 1088 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_query_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd[31U] ;
};
#line 1101 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_query_fw_cfg {
   struct be_cmd_resp_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   u32 rsvd[26U] ;
   u32 function_caps ;
};
#line 1111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rss_config {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u16 enable_rss ;
   u16 cpu_table_size_log2 ;
   u32 hash[10U] ;
   u8 cpu_table[128U] ;
   u8 flush ;
   u8 rsvd0[3U] ;
};
#line 1145 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_enable_disable_beacon {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 beacon_state ;
   u8 beacon_duration ;
   u8 status_duration ;
};
#line 1163 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_beacon_state {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 rsvd0 ;
   u16 rsvd1 ;
};
#line 1170 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_beacon_state {
   struct be_cmd_resp_hdr resp_hdr ;
   u8 beacon_state ;
   u8 rsvd0[3U] ;
};
#line 1191 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_read_flash_crc {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 crc[4U] ;
   u8 rsvd[4U] ;
};
#line 1206 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_write_object {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
   u32 write_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1217 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_write_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_write_len ;
   u8 change_status ;
   u8 rsvd3[3U] ;
};
#line 1233 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_read_object {
   struct be_cmd_req_hdr hdr ;
   u32 desired_read_len ;
   u32 read_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_read_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_read_len ;
   u32 eof ;
};
#line 1265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0[145U] ;
   u8 magic_mac[6U] ;
   u8 rsvd2[2U] ;
};
#line 1273 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config_v1 {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 query_options ;
   u8 rsvd1[5U] ;
   u32 rsvd2[288U] ;
   u8 magic_mac[6U] ;
   u8 rsvd3[22U] ;
};
#line 1283 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_acpi_wol_magic_config_v1 {
   struct be_cmd_resp_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 wol_settings ;
   u8 rsvd1[5U] ;
   u32 rsvd2[295U] ;
};
#line 1291 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_loopback_test {
   struct be_cmd_req_hdr hdr ;
   u32 loopback_type ;
   u32 num_pkts ;
   u64 pattern ;
   u32 src_port ;
   u32 dest_port ;
   u32 pkt_size ;
};
#line 1311 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_loopback_test {
   struct be_cmd_resp_hdr resp_hdr ;
   u32 status ;
   u32 num_txfer ;
   u32 num_rx ;
   u32 miscomp_off ;
   u32 ticks_compl ;
};
#line 1320 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_lmode {
   struct be_cmd_req_hdr hdr ;
   u8 src_port ;
   u8 dest_port ;
   u8 loopback_type ;
   u8 loopback_state ;
};
#line 1333 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_ddrdma_test {
   struct be_cmd_req_hdr hdr ;
   u64 pattern ;
   u32 byte_count ;
   u32 rsvd0 ;
   u8 snd_buff[4096U] ;
   u8 rsvd1[4096U] ;
};
#line 1343 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_ddrdma_test {
   struct be_cmd_resp_hdr hdr ;
   u64 pattern ;
   u32 byte_cnt ;
   u32 snd_err ;
   u8 rsvd0[4096U] ;
   u8 rcv_buff[4096U] ;
};
#line 1352 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[1024U] ;
};
#line 1379 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_phy_info {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[24U] ;
};
#line 1409 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_phy_info {
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 ext_phy_details ;
   u16 rsvd ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   u32 future_use[2U] ;
};
#line 1425 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_qos {
   struct be_cmd_req_hdr hdr ;
   u32 valid_bits ;
   u32 max_bps_nic ;
   u32 rsvd[7U] ;
};
#line 1441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cntl_attribs {
   struct be_cmd_req_hdr hdr ;
};
#line 1446 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cntl_attribs {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attrib attribs ;
};
#line 1451 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_func_cap {
   struct be_cmd_req_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1462 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_set_func_cap {
   struct be_cmd_resp_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1483 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_priv_map {
   u8 opcode ;
   u8 subsystem ;
   u32 priv_mask ;
};
#line 1493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fn_privileges {
   struct be_cmd_resp_hdr hdr ;
   u32 privilege_mask ;
};
#line 1503 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 privileges ;
   u32 privileges_lancer ;
};
#line 1509 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_type ;
   u8 perm_override ;
   u16 iface_id ;
   u32 mac_id ;
   u32 rsvd[3U] ;
};
#line 1520 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct __anonstruct_s_mac_id_295 {
   u8 rsvd[2U] ;
   u32 mac_id ;
};
#line 1520 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_mac_addr_id_294 {
   u8 macaddr[6U] ;
   struct __anonstruct_s_mac_id_295 s_mac_id ;
};
#line 1520 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct get_list_macaddr {
   u16 mac_addr_size ;
   union __anonunion_mac_addr_id_294 mac_addr_id ;
};
#line 1531 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_mac_list {
   struct be_cmd_resp_hdr hdr ;
   struct get_list_macaddr fd_macaddr ;
   struct get_list_macaddr macid_macaddr ;
   u8 true_mac_count ;
   u8 pseudo_mac_count ;
   u8 mac_list_size ;
   u8 rsvd ;
   struct get_list_macaddr macaddr_list[64U] ;
};
#line 1543 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_count ;
   u8 rsvd1 ;
   u16 rsvd2 ;
   struct macaddr mac[64U] ;
};
#line 1569 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[20U] ;
};
#line 1596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
};
#line 1601 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_hsw_config {
   struct be_cmd_resp_hdr hdr ;
   u8 context[16U] ;
   u32 rsvd ;
};
#line 1607 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 1613 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u8 port_name[4U] ;
};
#line 1779 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_mode {
   u8 mode ;
   u8 rsvd0 ;
   u16 port_mask ;
   u32 dbg_lvl ;
   u64 fun_mask ;
};
#line 1794 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_modules {
   u8 modules_str[32U] ;
   u32 modules_id ;
   u32 num_modes ;
   struct ext_fat_mode trace_lvl[4U] ;
};
#line 1801 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_fat_conf_params {
   u32 max_log_entries ;
   u32 log_entry_size ;
   u8 log_type ;
   u8 max_log_funs ;
   u8 max_log_ports ;
   u8 rsvd0 ;
   u32 supp_modes ;
   u32 num_modules ;
   struct ext_fat_modules module[27U] ;
};
#line 1813 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   u32 parameter_type ;
};
#line 1823 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   struct be_fat_conf_params set_params ;
};
#line 1828 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_res_desc_hdr {
   u8 desc_type ;
   u8 desc_len ;
};
#line 1845 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd0 ;
   u8 flags ;
   u8 link_num ;
   u8 mc_type ;
   u16 rsvd1 ;
   u8 nv_flags ;
   u8 rsvd2 ;
   __le16 nv_port ;
   u32 rsvd3[19U] ;
};
#line 1864 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pcie_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd0 ;
   u8 flags ;
   u16 rsvd1 ;
   u8 pf_num ;
   u8 rsvd2 ;
   u32 rsvd3 ;
   u8 sriov_state ;
   u8 pf_state ;
   u8 pf_type ;
   u8 rsvd4 ;
   u16 num_vfs ;
   u16 rsvd5 ;
   u32 rsvd6[17U] ;
};
#line 1881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_nic_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd1 ;
   u8 flags ;
   u8 vf_num ;
   u8 rsvd2 ;
   u8 pf_num ;
   u8 rsvd3 ;
   u16 unicast_mac_count ;
   u8 rsvd4[6U] ;
   u16 mcc_count ;
   u16 vlan_count ;
   u16 mcast_mac_count ;
   u16 txq_count ;
   u16 rq_count ;
   u16 rssq_count ;
   u16 lro_count ;
   u16 cq_count ;
   u16 toe_conn_count ;
   u16 eq_count ;
   u16 vlan_id ;
   u16 iface_count ;
   u32 cap_flags ;
   u8 link_param ;
   u8 rsvd6 ;
   u16 channel_id_param ;
   u32 bw_min ;
   u32 bw_max ;
   u8 acpi_params ;
   u8 wol_param ;
   u16 rsvd7 ;
   u16 tunnel_iface_count ;
   u16 direct_tenant_iface_count ;
   u32 rsvd8[6U] ;
};
#line 1936 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_func_config {
   struct be_cmd_req_hdr hdr ;
};
#line 1940 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_func_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[23232U] ;
};
#line 1946 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_profile_config {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd ;
   u8 type ;
   u16 rsvd1 ;
};
#line 1954 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_profile_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[23232U] ;
};
#line 1960 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_profile_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
   u32 desc_count ;
   u8 desc[88U] ;
};
#line 1971 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_active_profile {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1976 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_active_profile {
   struct be_cmd_resp_hdr hdr ;
   u16 active_profile_id ;
   u16 next_profile_id ;
};
#line 1982 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_enable_disable_vf {
   struct be_cmd_req_hdr hdr ;
   u8 enable ;
   u8 rsvd[3U] ;
};
#line 1988 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_intr_set {
   struct be_cmd_req_hdr hdr ;
   u8 intr_enabled ;
   u8 rsvd[3U] ;
};
#line 1999 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_if_desc {
   u32 if_id ;
   u32 cap_flags ;
   u32 en_flags ;
};
#line 2006 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_iface_list {
   struct be_cmd_req_hdr hdr ;
};
#line 2010 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_iface_list {
   struct be_cmd_req_hdr hdr ;
   u32 if_cnt ;
   struct be_if_desc if_desc ;
};
#line 2016 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ll_link {
   struct be_cmd_req_hdr hdr ;
   u32 link_config ;
};
#line 2023 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_manage_iface_filters {
   struct be_cmd_req_hdr hdr ;
   u8 op ;
   u8 rsvd0 ;
   u8 flags ;
   u8 rsvd1 ;
   u32 tunnel_iface_id ;
   u32 target_iface_id ;
   u8 mac[6U] ;
   u16 vlan_tag ;
   u32 tenant_id ;
   u32 filter_id ;
   u32 cap_flags ;
   u32 cap_control_flags ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 1360 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 seeprom_data[1024U] ;
};
#line 2171 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_ethtool_stat {
   char desc[32U] ;
   int type ;
   int size ;
   int offset ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 562 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
enum be_interrupt_mode {
    BE_INTERRUPT_MODE_MSIX = 0,
    BE_INTERRUPT_MODE_INTX = 1,
    BE_INTERRUPT_MODE_MSI = 2
} ;
#line 568 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct __anonstruct_msix_290 {
   int num_vectors ;
   int start_vector ;
   u32 vector_list[32U] ;
};
#line 568 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_dev_info {
   u8 *db ;
   u64 unmapped_db ;
   u32 db_page_size ;
   u32 db_total_size ;
   u64 dpp_unmapped_addr ;
   u32 dpp_unmapped_len ;
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 mac_addr[6U] ;
   u32 dev_family ;
   enum be_interrupt_mode intr_mode ;
   struct __anonstruct_msix_290 msix ;
};
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
struct ocrdma_driver {
   unsigned char name[32U] ;
   u32 be_abi_version ;
   struct ocrdma_dev *(*add)(struct be_dev_info * ) ;
   void (*remove)(struct ocrdma_dev * ) ;
   void (*state_change_handler)(struct ocrdma_dev * , u32  ) ;
};
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14130_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14124_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
#line 1
void __builtin_prefetch(void const   *  , ...) ;
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 2 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 358 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 125 "include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 127
  return ((word << shift) | (word >> (8UL * sizeof(word) - (unsigned long )shift)));
}
}
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 165 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 388
extern int sprintf(char * , char const   *  , ...) ;
#line 403
extern int sscanf(char const   * , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 58
extern void *memmove(void * , void const   * , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 113 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , int  ) ;
#line 276 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ 
  int tmp___0 ;

  {
#line 280
  tmp___0 = __bitmap_weight(src, nbits);
#line 280
  return (tmp___0);
}
}
#line 28 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 467 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 469
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nr_cpu_ids);
#line 469
  return ((unsigned int )tmp);
}
}
#line 802 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 804
  if (tmp != 0L) {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
    ldv_4851: ;
#line 804
    goto ldv_4851;
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 155 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 27
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 49 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 51
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1,%0": "+m" (v->counter): "ir" (i));
#line 53
  return;
}
}
#line 63 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 65
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %1,%0": "+m" (v->counter): "ir" (i));
#line 67
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 8 "include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 17 "include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
#line 19
  __local_bh_disable_ip((unsigned long )((void *)0), 512U);
#line 21
  return;
}
}
#line 23
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 30 "include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
#line 32
  __local_bh_enable_ip((unsigned long )((void *)0), 512U);
#line 34
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 28
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6347.rlock);
}
}
#line 301 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_1(spinlock_t *lock ) 
{ 


  {
#line 303
  _raw_spin_lock(& lock->ldv_6347.rlock);
#line 304
  return;
}
}
#line 301
__inline static void spin_lock(spinlock_t *lock ) ;
#line 310 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_bh_2(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock_bh(& lock->ldv_6347.rlock);
#line 313
  return;
}
}
#line 310
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 345 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_5(spinlock_t *lock ) 
{ 


  {
#line 347
  _raw_spin_unlock(& lock->ldv_6347.rlock);
#line 348
  return;
}
}
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 354 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_bh_6(spinlock_t *lock ) 
{ 


  {
#line 356
  _raw_spin_unlock_bh(& lock->ldv_6347.rlock);
#line 357
  return;
}
}
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 8 "include/linux/mmdebug.h"
extern void dump_page(struct page * , char const   * ) ;
#line 68 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 120 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 295
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 303
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 94 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 180
extern void __init_work(struct work_struct * , int  ) ;
#line 355
extern struct workqueue_struct *system_wq ;
#line 433
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 485 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 489
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
#line 489
  return (tmp);
}
}
#line 558 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 561
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 561
  return (tmp);
}
}
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 72
extern void pci_iounmap(struct pci_dev * , void * ) ;
#line 17 "include/asm-generic/pci_iomap.h"
extern void *pci_iomap(struct pci_dev * , int  , unsigned long  ) ;
#line 67 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 70
void *ldv_vmalloc_34(unsigned long ldv_func_arg1 ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 174 "include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 331 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 334 "include/linux/gfp.h"
__inline static struct page *ldv_alloc_pages_11(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 336
  tmp = alloc_pages_current(gfp_mask, order);
#line 336
  return (tmp);
}
}
#line 334
__inline static struct page *alloc_pages(gfp_t flags , unsigned int order ) ;
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 315
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 316
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 323
void *ldv_kmem_cache_alloc_33(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 563 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 565
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 566
    return ((void *)0);
  } else {

  }
#line 567
  tmp = __kmalloc(n * size, flags);
#line 567
  return (tmp);
}
}
#line 576 "include/linux/slab.h"
__inline static void *ldv_kcalloc_14(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 578
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 578
  return (tmp);
}
}
#line 576
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_check_alloc_nonatomic(void) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 21
extern u32 __VERIFIER_nondet_u32(void) ;
#line 22
extern u16 __VERIFIER_nondet_u16(void) ;
#line 23
extern u8 __VERIFIER_nondet_u8(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_1  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_coalesce *be_ethtool_ops_group2  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_2  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct net_device *be_ethtool_ops_group5  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_1  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_0  =    0;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_wolinfo *be_ethtool_ops_group0  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_pauseparam *be_ethtool_ops_group3  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct pci_dev *be_driver_group0  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_channels *be_ethtool_ops_group4  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_3  =    0;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_rxnfc *be_ethtool_ops_group1  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct net_device *be_netdev_ops_group1  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_3  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_2  =    0;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_0  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ref_cnt  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_2  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct pci_dev *be_eeh_handlers_group0  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_3  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_1  =    0;
#line 63
void ldv_net_device_ops_6(void) ;
#line 64
void choose_interrupt_2(void) ;
#line 65
void disable_suitable_irq_2(int line , void *data ) ;
#line 66
void ldv_initialize_pci_driver_4(void) ;
#line 67
void activate_suitable_irq_2(int line , void *data ) ;
#line 68
void disable_suitable_irq_1(int line , void *data ) ;
#line 69
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 70
void activate_suitable_irq_1(int line , void *data ) ;
#line 71
int ldv_irq_1(int state , int line , void *data ) ;
#line 73
int ldv_irq_2(int state , int line , void *data ) ;
#line 74
void ldv_initialize_pci_error_handlers_5(void) ;
#line 75
void ldv_initialize_ethtool_ops_3(void) ;
#line 76
void choose_interrupt_1(void) ;
#line 77
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 1042
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1044
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1048
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 846 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 852
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 864 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 867
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 867
  return (tmp);
}
}
#line 877 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 880
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 880
  return (tmp);
}
}
#line 924
extern int pci_enable_device(struct pci_dev * ) ;
#line 941
extern void pci_disable_device(struct pci_dev * ) ;
#line 944
extern void pci_set_master(struct pci_dev * ) ;
#line 997
extern int pci_save_state(struct pci_dev * ) ;
#line 998
extern void pci_restore_state(struct pci_dev * ) ;
#line 1009
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1010
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 1013
extern int __pci_enable_wake(struct pci_dev * , pci_power_t  , bool  , bool  ) ;
#line 1022 "include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp ;

  {
#line 1025
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
#line 1025
  return (tmp);
}
}
#line 1062
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1064
extern void pci_release_regions(struct pci_dev * ) ;
#line 1107
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1116
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1188
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1200
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 349 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 349
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 349
  return (tmp);
}
}
#line 498 "include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 500 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 502
  tmp___1 = PageTail((struct page  const  *)page);
#line 502
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 502
  if (tmp___2 != 0L) {
#line 503
    tmp = __get_page_tail(page);
#line 503
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 503
    if (tmp___0 != 0L) {
#line 504
      return;
    } else {

    }
  } else {

  }
#line 509
  tmp___3 = atomic_read((atomic_t const   *)(& page->ldv_14147.ldv_14146.ldv_14144._count));
#line 509
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 509
  if (tmp___4 != 0L) {
#line 509
    dump_page(page, "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)");
#line 509
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (509), "i" (12UL));
    ldv_20258: ;
#line 509
    goto ldv_20258;
  } else {

  }
#line 510
  atomic_inc(& page->ldv_14147.ldv_14146.ldv_14144._count);
#line 511
  return;
}
}
#line 556
extern void put_page(struct page * ) ;
#line 912 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 914
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 69 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 71
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 76 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 78
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 59
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 27 "./arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_22378: ;
#line 19
    goto ldv_22378;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_22387: ;
#line 36
    goto ldv_22387;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 71 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 79
  if (tmp___2 != 0L) {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_22421: ;
#line 79
    goto ldv_22421;
  } else {

  }
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 83
  return (addr);
}
}
#line 86 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 91
  if (tmp___1 != 0L) {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_22429: ;
#line 91
    goto ldv_22429;
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 95
  return;
}
}
#line 97 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 101
  tmp = get_dma_ops(dev);
#line 101
  ops = tmp;
#line 103
  tmp___0 = valid_dma_direction((int )dir);
#line 103
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 103
  if (tmp___1 != 0L) {
#line 103
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (103), "i" (12UL));
    ldv_22437: ;
#line 103
    goto ldv_22437;
  } else {

  }
#line 104
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 107
  return;
}
}
#line 47 "./arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "./arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "./arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "./arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "./arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("./arch/x86/include/asm/dma-mapping.h", 166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 97 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 99
  tmp = dma_supported(dev, mask);
#line 99
  if (tmp == 0) {
#line 100
    return (-5);
  } else {

  }
#line 101
  dev->coherent_dma_mask = mask;
#line 102
  return (0);
}
}
#line 112 "include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp ;

  {
#line 114
  tmp = dma_set_mask(dev, mask);
#line 114
  rc = tmp;
#line 115
  if (rc == 0) {
#line 116
    dma_set_coherent_mask(dev, mask);
  } else {

  }
#line 117
  return (rc);
}
}
#line 176 "include/linux/dma-mapping.h"
__inline static void *ldv_dma_zalloc_coherent_19(struct device *dev , size_t size ,
                                                 dma_addr_t *dma_handle , gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 179
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
#line 179
  ret = tmp;
#line 181
  return (ret);
}
}
#line 176
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) ;
#line 1426 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1428
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1428
  return (tmp);
}
}
#line 1431 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1433
  dev_set_drvdata(& pdev->dev, data);
#line 1434
  return;
}
}
#line 1619
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1620
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 1621
extern int pci_num_vf(struct pci_dev * ) ;
#line 1622
extern int pci_vfs_assigned(struct pci_dev * ) ;
#line 1624
extern int pci_sriov_get_totalvfs(struct pci_dev * ) ;
#line 16 "include/linux/random.h"
extern void get_random_bytes(void * , int  ) ;
#line 188 "include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 190
  return ((unsigned int )frag->size);
}
}
#line 193 "include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 195
  frag->size = size;
#line 196
  return;
}
}
#line 198 "include/linux/skbuff.h"
__inline static void skb_frag_size_add(skb_frag_t *frag , int delta ) 
{ 


  {
#line 200
  frag->size = frag->size + (__u32 )delta;
#line 201
  return;
}
}
#line 714
extern void kfree_skb(struct sk_buff * ) ;
#line 717
extern void consume_skb(struct sk_buff * ) ;
#line 756
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 759
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 765
extern struct sk_buff *skb_copy(struct sk_buff  const  * , gfp_t  ) ;
#line 768
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 778
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 781
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 800
extern int skb_pad(struct sk_buff * , int  ) ;
#line 830 "include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb , __u32 hash , enum pkt_hash_types type ) 
{ 


  {
#line 832
  skb->l4_hash = (unsigned int )type == 3U;
#line 833
  skb->hash = hash;
#line 834
  return;
}
}
#line 869 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 871
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1020 "include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 1024
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 0U) {
#line 1025
    return (0);
  } else {

  }
#line 1027
  tmp = skb_end_pointer(skb);
#line 1027
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 1028
  dataref = (dataref & 65535) - (dataref >> 16);
#line 1029
  return (dataref != 1);
}
}
#line 1054 "include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff  const  *skb ) 
{ 
  int tmp ;

  {
#line 1056
  tmp = atomic_read(& skb->users);
#line 1056
  return (tmp != 1);
}
}
#line 1072 "include/linux/skbuff.h"
__inline static struct sk_buff *ldv_skb_share_check_23(struct sk_buff *skb , gfp_t pri ) 
{ 
  struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1074
  if ((pri & 16U) != 0U) {
#line 1074
    __might_sleep("include/linux/skbuff.h", 1074, 0);
  } else {

  }
#line 1075
  tmp___1 = skb_shared((struct sk_buff  const  *)skb);
#line 1075
  if (tmp___1 != 0) {
#line 1076
    tmp = ldv_skb_clone_24(skb, pri);
#line 1076
    nskb = tmp;
#line 1078
    tmp___0 = ldv__builtin_expect((unsigned long )nskb != (unsigned long )((struct sk_buff *)0),
                               1L);
#line 1078
    if (tmp___0 != 0L) {
#line 1079
      consume_skb(skb);
    } else {
#line 1081
      kfree_skb(skb);
    }
#line 1082
    skb = nskb;
  } else {

  }
#line 1084
  return (skb);
}
}
#line 1072
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t flags ) ;
#line 1440 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1442
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1445 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1447
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1532 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1534
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1535
  return;
}
}
#line 1537 "include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1539
  skb_reset_tail_pointer(skb);
#line 1540
  skb->tail = skb->tail + (sk_buff_data_t )offset;
#line 1541
  return;
}
}
#line 1575
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1627 "include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff  const  *skb ) 
{ 


  {
#line 1629
  return ((unsigned int )((long )skb->data) - (unsigned int )((long )skb->head));
}
}
#line 1702 "include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1704
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_network_header);
}
}
#line 1757 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1759
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1917
extern int ___pskb_trim(struct sk_buff * , unsigned int  ) ;
#line 1919 "include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
#line 1921
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1921
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1921
  if (tmp___1 != 0L) {
#line 1922
    __ret_warn_on = 1;
#line 1922
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1922
    if (tmp != 0L) {
#line 1922
      warn_slowpath_null("include/linux/skbuff.h", 1922);
    } else {

    }
#line 1922
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1923
    return;
  } else {

  }
#line 1925
  skb->len = len;
#line 1926
  skb_set_tail_pointer(skb, (int const   )len);
#line 1927
  return;
}
}
#line 1931 "include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;

  {
#line 1933
  if (skb->data_len != 0U) {
#line 1934
    tmp = ___pskb_trim(skb, len);
#line 1934
    return (tmp);
  } else {

  }
#line 1935
  __skb_trim(skb, len);
#line 1936
  return (0);
}
}
#line 1939 "include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1941
  if (skb->len > len) {
#line 1941
    tmp = __pskb_trim(skb, len);
#line 1941
    tmp___0 = tmp;
  } else {
#line 1941
    tmp___0 = 0;
  }
#line 1941
  return (tmp___0);
}
}
#line 2016
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2052 "include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                            unsigned int length ,
                                                            gfp_t gfp ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 2055
  tmp = ldv___netdev_alloc_skb_29(dev, length, gfp);
#line 2055
  skb = tmp;
#line 2059
  return (skb);
}
}
#line 2062 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                          unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2065
  tmp = __netdev_alloc_skb_ip_align(dev, length, 32U);
#line 2065
  return (tmp);
}
}
#line 2129 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2131
  return ((struct page *)frag->page.p);
}
}
#line 2215 "include/linux/skbuff.h"
__inline static void __skb_frag_set_page(skb_frag_t *frag , struct page *page ) 
{ 


  {
#line 2217
  frag->page.p = page;
#line 2218
  return;
}
}
#line 2228 "include/linux/skbuff.h"
__inline static void skb_frag_set_page(struct sk_buff *skb , int f , struct page *page ) 
{ 
  unsigned char *tmp ;

  {
#line 2231
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2231
  __skb_frag_set_page((skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )f,
                      page);
#line 2232
  return;
}
}
#line 2247 "include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2252
  tmp = skb_frag_page(frag);
#line 2252
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
#line 2252
  return (tmp___0);
}
}
#line 2284 "include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb , unsigned int headroom , int cloned ) 
{ 
  int delta ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___1 ;

  {
#line 2287
  delta = 0;
#line 2289
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
#line 2289
  if (tmp___0 < headroom) {
#line 2290
    tmp = skb_headroom((struct sk_buff  const  *)skb);
#line 2290
    delta = (int )(headroom - tmp);
  } else {

  }
#line 2292
  if (delta != 0 || cloned != 0) {
#line 2293
    _max1 = 32;
#line 2293
    _max2 = 64;
#line 2293
    _max1___0 = 32;
#line 2293
    _max2___0 = 64;
#line 2293
    tmp___1 = ldv_pskb_expand_head_30(skb, (((_max1 > _max2 ? _max1 : _max2) + -1) + delta) & - (_max1___0 > _max2___0 ? _max1___0 : _max2___0),
                                      0, 32U);
#line 2293
    return (tmp___1);
  } else {

  }
#line 2295
  return (0);
}
}
#line 2325 "include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb , unsigned int headroom ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2327
  tmp = skb_header_cloned((struct sk_buff  const  *)skb);
#line 2327
  tmp___0 = __skb_cow(skb, headroom, tmp);
#line 2327
  return (tmp___0);
}
}
#line 2341 "include/linux/skbuff.h"
__inline static int skb_padto(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int size ;
  long tmp ;
  int tmp___0 ;

  {
#line 2343
  size = skb->len;
#line 2344
  tmp = ldv__builtin_expect(size >= len, 1L);
#line 2344
  if (tmp != 0L) {
#line 2345
    return (0);
  } else {

  }
#line 2346
  tmp___0 = skb_pad(skb, (int )(len - size));
#line 2346
  return (tmp___0);
}
}
#line 2983 "include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 2985
  return ((u16 )skb->queue_mapping);
}
}
#line 2993 "include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 2995
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 2996
  return;
}
}
#line 3076 "include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3078
  tmp = skb_end_pointer(skb);
#line 3078
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 3082 "include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3084
  tmp = skb_end_pointer(skb);
#line 3084
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 3118 "include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 3120
  return;
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 50 "include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
#line 52
  msleep(seconds * 1000U);
#line 53
  return;
}
}
#line 77 "include/linux/u64_stats_sync.h"
__inline static void u64_stats_update_begin(struct u64_stats_sync *syncp ) 
{ 


  {
#line 79
  return;
}
}
#line 122 "include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 130
  return (0U);
}
}
#line 134 "include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync  const  *syncp ,
                                               unsigned int start ) 
{ 


  {
#line 143
  return (0);
}
}
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 123 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_35(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 141
__inline static int ldv_request_irq_37(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 150
extern void free_irq(unsigned int  , void * ) ;
#line 153
void ldv_free_irq_36(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 157
void ldv_free_irq_38(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 161
void ldv_free_irq_39(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 387 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 389 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 391
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
#line 391
  return (tmp != 0);
}
}
#line 403 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 405
  tmp = napi_disable_pending(n);
#line 405
  if (tmp) {
#line 405
    tmp___0 = 0;
  } else {
#line 405
    tmp___0 = 1;
  }
#line 405
  if (tmp___0) {
#line 405
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 405
    if (tmp___1 == 0) {
#line 405
      tmp___2 = 1;
    } else {
#line 405
      tmp___2 = 0;
    }
  } else {
#line 405
    tmp___2 = 0;
  }
#line 405
  return ((bool )tmp___2);
}
}
#line 416 "include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
#line 418
  tmp = napi_schedule_prep(n);
#line 418
  if ((int )tmp) {
#line 419
    __napi_schedule(n);
  } else {

  }
#line 420
  return;
}
}
#line 439
extern void napi_complete(struct napi_struct * ) ;
#line 456
extern void napi_hash_add(struct napi_struct * ) ;
#line 465
extern void napi_hash_del(struct napi_struct * ) ;
#line 474 "include/linux/netdevice.h"
__inline static void napi_disable(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 476
  __might_sleep("include/linux/netdevice.h", 476, 0);
#line 477
  set_bit(1L, (unsigned long volatile   *)(& n->state));
#line 478
  goto ldv_41557;
  ldv_41556: 
#line 479
  msleep(1U);
  ldv_41557: 
#line 478
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 478
  if (tmp != 0) {
#line 480
    goto ldv_41556;
  } else {

  }
#line 480
  clear_bit(1L, (unsigned long volatile   *)(& n->state));
#line 481
  return;
}
}
#line 490 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 492
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 492
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 492
  if (tmp___0 != 0L) {
#line 492
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (492), "i" (12UL));
    ldv_41562: ;
#line 492
    goto ldv_41562;
  } else {

  }
#line 493
  __asm__  volatile   ("": : : "memory");
#line 494
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
#line 495
  return;
}
}
#line 1621 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1624
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1687 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1689
  return ((void *)dev + 3264U);
}
}
#line 1718
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1727
extern void netif_napi_del(struct napi_struct * ) ;
#line 1975
extern void free_netdev(struct net_device * ) ;
#line 1978
void ldv_free_netdev_41(struct net_device *dev ) ;
#line 1982
void ldv_free_netdev_43(struct net_device *dev ) ;
#line 2148
extern void __netif_schedule(struct Qdisc * ) ;
#line 2164 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2166
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2167
  return;
}
}
#line 2180 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2184
  i = 0U;
#line 2184
  goto ldv_42476;
  ldv_42475: 
#line 2185
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2185
  txq = tmp;
#line 2186
  netif_tx_start_queue(txq);
#line 2184
  i = i + 1U;
  ldv_42476: ;
#line 2184
  if (dev->num_tx_queues > i) {
#line 2186
    goto ldv_42475;
  } else {

  }

#line 2191
  return;
}
}
#line 2210 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 2212
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 2212
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp != 0L) {
#line 2212
    warn_slowpath_null("include/linux/netdevice.h", 2212);
  } else {

  }
#line 2212
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp___0 != 0L) {
#line 2213
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
#line 2214
    return;
  } else {

  }
#line 2216
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2217
  return;
}
}
#line 2241 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2243
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2243
  return (tmp != 0);
}
}
#line 2398 "include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2400
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
#line 2400
  return (tmp != 0);
}
}
#line 2431 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2433
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2433
  txq = tmp;
#line 2434
  netif_tx_stop_queue(txq);
#line 2435
  return;
}
}
#line 2444 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2447
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2447
  txq = tmp;
#line 2449
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2449
  return (tmp___0);
}
}
#line 2465 "include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;

  {
#line 2467
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2467
  txq = tmp;
#line 2468
  tmp___0 = test_and_clear_bit(0L, (unsigned long volatile   *)(& txq->state));
#line 2468
  if (tmp___0 != 0) {
#line 2469
    __netif_schedule(txq->qdisc);
  } else {

  }
#line 2470
  return;
}
}
#line 2505
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2508
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2547
extern int netif_get_num_default_rss_queues(void) ;
#line 2555
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2586 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2588
  __dev_kfree_skb_any(skb, 1);
#line 2589
  return;
}
}
#line 2598
extern int netif_receive_skb(struct sk_buff * ) ;
#line 2601
extern struct sk_buff *napi_get_frags(struct napi_struct * ) ;
#line 2602
extern gro_result_t napi_gro_frags(struct napi_struct * ) ;
#line 2695
extern void netif_carrier_on(struct net_device * ) ;
#line 2697
extern void netif_carrier_off(struct net_device * ) ;
#line 2765
extern void netif_device_detach(struct net_device * ) ;
#line 2767
extern void netif_device_attach(struct net_device * ) ;
#line 2818 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 2820
  spin_lock(& txq->_xmit_lock);
#line 2821
  txq->xmit_lock_owner = cpu;
#line 2822
  return;
}
}
#line 2838 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 2840
  txq->xmit_lock_owner = -1;
#line 2841
  spin_unlock(& txq->_xmit_lock);
#line 2842
  return;
}
}
#line 2930 "include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2935
  local_bh_disable();
#line 2936
  __vpp_verify = (void const   *)0;
#line 2936
  switch (4UL) {
  case 1UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_43045;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_43045;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_43045;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2936
  goto ldv_43045;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_43045: 
#line 2936
  pscr_ret__ = pfo_ret__;
#line 2936
  goto ldv_43051;
  case 2UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_43055;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_43055;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_43055;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2936
  goto ldv_43055;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_43055: 
#line 2936
  pscr_ret__ = pfo_ret_____0;
#line 2936
  goto ldv_43051;
  case 4UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_43064;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_43064;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_43064;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2936
  goto ldv_43064;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_43064: 
#line 2936
  pscr_ret__ = pfo_ret_____1;
#line 2936
  goto ldv_43051;
  case 8UL: ;
#line 2936
  switch (4UL) {
  case 1UL: 
#line 2936
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_43073;
  case 2UL: 
#line 2936
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_43073;
  case 4UL: 
#line 2936
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_43073;
  case 8UL: 
#line 2936
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2936
  goto ldv_43073;
  default: 
#line 2936
  __bad_percpu_size();
  }
  ldv_43073: 
#line 2936
  pscr_ret__ = pfo_ret_____2;
#line 2936
  goto ldv_43051;
  default: 
#line 2936
  __bad_size_call_parameter();
#line 2936
  goto ldv_43051;
  }
  ldv_43051: 
#line 2936
  cpu = pscr_ret__;
#line 2937
  i = 0U;
#line 2937
  goto ldv_43083;
  ldv_43082: 
#line 2938
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2938
  txq = tmp;
#line 2940
  __netif_tx_lock(txq, cpu);
#line 2941
  netif_tx_stop_queue(txq);
#line 2942
  __netif_tx_unlock(txq);
#line 2937
  i = i + 1U;
  ldv_43083: ;
#line 2937
  if (dev->num_tx_queues > i) {
#line 2939
    goto ldv_43082;
  } else {

  }
#line 2944
  local_bh_enable();
#line 2945
  return;
}
}
#line 2998
extern int register_netdev(struct net_device * ) ;
#line 3001
int ldv_register_netdev_42(struct net_device *dev ) ;
#line 3003
extern void unregister_netdev(struct net_device * ) ;
#line 3006
void ldv_unregister_netdev_40(struct net_device *dev ) ;
#line 3333 "include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 3336
  dev->gso_max_size = size;
#line 3337
  return;
}
}
#line 32 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 89 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 92
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 107 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 109
  return (((int )*addr & 1) != 0);
}
}
#line 160 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 164
  tmp = is_multicast_ether_addr(addr);
#line 164
  if (tmp) {
#line 164
    tmp___0 = 0;
  } else {
#line 164
    tmp___0 = 1;
  }
#line 164
  if (tmp___0) {
#line 164
    tmp___1 = is_zero_ether_addr(addr);
#line 164
    if (tmp___1) {
#line 164
      tmp___2 = 0;
    } else {
#line 164
      tmp___2 = 1;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___3 = 1;
    } else {
#line 164
      tmp___3 = 0;
    }
  } else {
#line 164
    tmp___3 = 0;
  }
#line 164
  return ((bool )tmp___3);
}
}
#line 266 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 269
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 272
  return (fold == 0U);
}
}
#line 22 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 23
extern void rtnl_unlock(void) ;
#line 92
extern int ndo_dflt_bridge_getlink(struct sk_buff * , u32  , u32  , struct net_device * ,
                                   u16  ) ;
#line 238 "include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 289 "include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 291
  return ((void *)nlh + 16U);
}
}
#line 298 "include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 300
  return ((int )((unsigned int )nlh->nlmsg_len - 16U));
}
}
#line 308 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
#line 311
  tmp = nlmsg_data(nlh);
#line 311
  data = (unsigned char *)tmp;
#line 312
  return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
}
}
#line 320 "include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  int tmp ;

  {
#line 322
  tmp = nlmsg_len(nlh);
#line 322
  return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
}
}
#line 384 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr  const  *nlh , int hdrlen ,
                                               int attrtype ) 
{ 
  int tmp ;
  struct nlattr *tmp___0 ;
  struct nlattr *tmp___1 ;

  {
#line 387
  tmp = nlmsg_attrlen(nlh, hdrlen);
#line 387
  tmp___0 = nlmsg_attrdata(nlh, hdrlen);
#line 387
  tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
#line 387
  return (tmp___1);
}
}
#line 659 "include/net/netlink.h"
__inline static int nla_type(struct nlattr  const  *nla ) 
{ 


  {
#line 661
  return ((int )nla->nla_type & -49153);
}
}
#line 668 "include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 670
  return ((void *)nla + 4U);
}
}
#line 677 "include/net/netlink.h"
__inline static int nla_len(struct nlattr  const  *nla ) 
{ 


  {
#line 679
  return ((int )nla->nla_len + -4);
}
}
#line 687 "include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 689
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 702 "include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 704
  totlen = ((int )nla->nla_len + 3) & -4;
#line 706
  *remaining = *remaining - totlen;
#line 707
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 983 "include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
#line 985
  tmp = nla_data(nla);
#line 985
  return (*((u16 *)tmp));
}
}
#line 16 "include/linux/unaligned/packed_struct.h"
__inline static u32 __get_unaligned_cpu32(void const   *p ) 
{ 
  struct __una_u32  const  *ptr ;

  {
#line 18
  ptr = (struct __una_u32  const  *)p;
#line 19
  return ((u32 )ptr->x);
}
}
#line 70 "include/linux/jhash.h"
__inline static u32 jhash(void const   *key , u32 length , u32 initval ) 
{ 
  u32 a ;
  u32 b ;
  u32 c ;
  u8 const   *k ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;

  {
#line 73
  k = (u8 const   *)key;
#line 76
  c = (length + initval) + 3735928559U;
#line 76
  b = c;
#line 76
  a = b;
#line 79
  goto ldv_47033;
  ldv_47032: 
#line 80
  tmp = __get_unaligned_cpu32((void const   *)k);
#line 80
  a = tmp + a;
#line 81
  tmp___0 = __get_unaligned_cpu32((void const   *)k + 4U);
#line 81
  b = tmp___0 + b;
#line 82
  tmp___1 = __get_unaligned_cpu32((void const   *)k + 8U);
#line 82
  c = tmp___1 + c;
#line 83
  a = a - c;
#line 83
  tmp___2 = rol32(c, 4U);
#line 83
  a = tmp___2 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___3 = rol32(a, 6U);
#line 83
  b = tmp___3 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___4 = rol32(b, 8U);
#line 83
  c = tmp___4 ^ c;
#line 83
  b = b + a;
#line 83
  a = a - c;
#line 83
  tmp___5 = rol32(c, 16U);
#line 83
  a = tmp___5 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___6 = rol32(a, 19U);
#line 83
  b = tmp___6 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___7 = rol32(b, 4U);
#line 83
  c = tmp___7 ^ c;
#line 83
  b = b + a;
#line 84
  length = length - 12U;
#line 85
  k = k + 12UL;
  ldv_47033: ;
#line 79
  if (length > 12U) {
#line 81
    goto ldv_47032;
  } else {

  }

#line 89
  switch (length) {
  case 12U: 
#line 90
  c = ((unsigned int )*(k + 11UL) << 24) + c;
  case 11U: 
#line 91
  c = ((unsigned int )*(k + 10UL) << 16) + c;
  case 10U: 
#line 92
  c = ((unsigned int )*(k + 9UL) << 8) + c;
  case 9U: 
#line 93
  c = (u32 )*(k + 8UL) + c;
  case 8U: 
#line 94
  b = ((unsigned int )*(k + 7UL) << 24) + b;
  case 7U: 
#line 95
  b = ((unsigned int )*(k + 6UL) << 16) + b;
  case 6U: 
#line 96
  b = ((unsigned int )*(k + 5UL) << 8) + b;
  case 5U: 
#line 97
  b = (u32 )*(k + 4UL) + b;
  case 4U: 
#line 98
  a = ((unsigned int )*(k + 3UL) << 24) + a;
  case 3U: 
#line 99
  a = ((unsigned int )*(k + 2UL) << 16) + a;
  case 2U: 
#line 100
  a = ((unsigned int )*(k + 1UL) << 8) + a;
  case 1U: 
#line 101
  a = (u32 )*k + a;
#line 102
  c = c ^ b;
#line 102
  tmp___8 = rol32(b, 14U);
#line 102
  c = c - tmp___8;
#line 102
  a = a ^ c;
#line 102
  tmp___9 = rol32(c, 11U);
#line 102
  a = a - tmp___9;
#line 102
  b = b ^ a;
#line 102
  tmp___10 = rol32(a, 25U);
#line 102
  b = b - tmp___10;
#line 102
  c = c ^ b;
#line 102
  tmp___11 = rol32(b, 16U);
#line 102
  c = c - tmp___11;
#line 102
  a = a ^ c;
#line 102
  tmp___12 = rol32(c, 4U);
#line 102
  a = a - tmp___12;
#line 102
  b = b ^ a;
#line 102
  tmp___13 = rol32(a, 14U);
#line 102
  b = b - tmp___13;
#line 102
  c = c ^ b;
#line 102
  tmp___14 = rol32(b, 24U);
#line 102
  c = c - tmp___14;
  case 0U: ;
#line 104
  goto ldv_47048;
  }
  ldv_47048: ;
#line 107
  return (c);
}
}
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 28 "include/linux/ip.h"
__inline static struct iphdr *inner_ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 30
  tmp = skb_inner_network_header(skb);
#line 30
  return ((struct iphdr *)tmp);
}
}
#line 67 "include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 69
  tmp = skb_network_header(skb);
#line 69
  return ((struct ipv6hdr *)tmp);
}
}
#line 72 "include/linux/ipv6.h"
__inline static struct ipv6hdr *inner_ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 74
  tmp = skb_inner_network_header(skb);
#line 74
  return ((struct ipv6hdr *)tmp);
}
}
#line 304 "include/linux/if_vlan.h"
__inline static struct sk_buff *vlan_insert_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                u16 vlan_tci ) 
{ 
  struct vlan_ethhdr *veth ;
  int tmp ;
  unsigned char *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 309
  tmp = skb_cow_head(skb, 4U);
#line 309
  if (tmp < 0) {
#line 310
    dev_kfree_skb_any(skb);
#line 311
    return ((struct sk_buff *)0);
  } else {

  }
#line 313
  tmp___0 = skb_push(skb, 4U);
#line 313
  veth = (struct vlan_ethhdr *)tmp___0;
#line 316
  memmove((void *)skb->data, (void const   *)skb->data + 4U, 12UL);
#line 317
  skb->mac_header = (unsigned int )skb->mac_header + 65532U;
#line 320
  veth->h_vlan_proto = vlan_proto;
#line 323
  tmp___1 = __fswab16((int )vlan_tci);
#line 323
  veth->h_vlan_TCI = tmp___1;
#line 325
  return (skb);
}
}
#line 339 "include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                               u16 vlan_tci ) 
{ 


  {
#line 342
  skb = vlan_insert_tag(skb, (int )vlan_proto, (int )vlan_tci);
#line 343
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 344
    skb->protocol = vlan_proto;
  } else {

  }
#line 345
  return (skb);
}
}
#line 356 "include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                       u16 vlan_tci ) 
{ 


  {
#line 360
  skb->vlan_proto = vlan_proto;
#line 361
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 362
  return (skb);
}
}
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static char *nic_name(struct pci_dev *pdev ) 
{ 


  {
#line 64
  switch ((int )pdev->device) {
  case 1792: ;
#line 66
  return ((char *)"Emulex OneConnect");
  case 1808: ;
#line 68
  return ((char *)"Emulex OneConnect(be3)");
  case 57888: ;
  case 57896: ;
#line 71
  return ((char *)"Emulex OneConnect(Lancer)");
  case 545: ;
#line 73
  return ((char *)"Emulex BladeEngine3");
  case 1824: ;
  case 1832: ;
#line 76
  return ((char *)"Emulex OneConnect(Skyhawk)");
  default: ;
#line 78
  return ((char *)"Emulex BladeEngine2");
  }
}
}
#line 142 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 144
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 144
  if (tmp != 0L) {
#line 144
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (144), "i" (12UL));
    ldv_52846: ;
#line 144
    goto ldv_52846;
  } else {

  }
#line 145
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 148 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_adv(u16 *index , u16 val , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 150
  tmp = MODULO((int )*index + (int )val, (int )limit);
#line 150
  *index = (u16 )tmp;
#line 151
  return;
}
}
#line 153 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 155
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 155
  *index = (u16 )tmp;
#line 156
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 160
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 163 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 165
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
#line 175
  index_inc(& q->head, (int )q->len);
#line 176
  return;
}
}
#line 183 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
#line 185
  index_inc(& q->tail, (int )q->len);
#line 186
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u16 be_max_qs(struct be_adapter *adapter ) 
{ 
  u16 num ;
  u16 __max1 ;
  u16 __max2 ;
  u16 _min1 ;
  u16 _min2 ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp ;

  {
#line 550
  __max1 = adapter->res.max_rss_qs;
#line 550
  __max2 = 1U;
#line 550
  num = (u16 )((int )__max1 > (int )__max2 ? __max1 : __max2);
#line 552
  _min1 = num;
#line 552
  _min2 = adapter->res.max_evt_qs;
#line 552
  num = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 553
  __min1 = num;
#line 553
  tmp = cpumask_weight(cpu_online_mask);
#line 553
  __min2 = (u16 )tmp;
#line 553
  return ((u16 )((int )__min1 < (int )__min2 ? __min1 : __min2));
}
}
#line 581
struct ethtool_ops  const  be_ethtool_ops ;
#line 629 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 631
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 635 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 637
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 638
  *dw = *dw & ~ (mask << (int )offset);
#line 639
  *dw = *dw | ((mask & value) << (int )offset);
#line 640
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 651
  dw = (u32 *)ptr;
#line 652
  return ((*(dw + (unsigned long )dw_offset) >> (int )offset) & mask);
}
}
#line 663 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 665
  return;
}
}
#line 700 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool is_ipv4_pkt(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp ;
  int tmp___0 ;

  {
#line 702
  if ((unsigned int )skb->protocol == 8U) {
#line 702
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 702
    if ((unsigned int )*((unsigned char *)tmp + 0UL) == 64U) {
#line 702
      tmp___0 = 1;
    } else {
#line 702
      tmp___0 = 0;
    }
  } else {
#line 702
    tmp___0 = 0;
  }
#line 702
  return ((bool )tmp___0);
}
}
#line 705 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_vf_eth_addr_generate(struct be_adapter *adapter , u8 *mac ) 
{ 
  u32 addr ;
  size_t __len ;
  void *__ret ;

  {
#line 709
  addr = jhash((void const   *)(adapter->netdev)->dev_addr, 6U, 0U);
#line 711
  *(mac + 5UL) = (unsigned char )addr;
#line 712
  *(mac + 4UL) = (unsigned char )(addr >> 8);
#line 713
  *(mac + 3UL) = (unsigned char )(addr >> 16);
#line 715
  __len = 3UL;
#line 715
  if (__len > 63UL) {
#line 715
    __ret = __memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr, __len);
  } else {
#line 715
    __ret = __builtin_memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr,
                             __len);
  }
#line 717
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_multi_rxq(struct be_adapter  const  *adapter ) 
{ 


  {
#line 720
  return ((unsigned int )((unsigned short )adapter->num_rx_qs) > 1U);
}
}
#line 728 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_hw_error(struct be_adapter *adapter ) 
{ 


  {
#line 730
  return ((bool )((int )adapter->eeh_error || (int )adapter->hw_error));
}
}
#line 733 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_clear_all_error(struct be_adapter *adapter ) 
{ 


  {
#line 735
  adapter->eeh_error = 0;
#line 736
  adapter->hw_error = 0;
#line 737
  adapter->fw_timeout = 0;
#line 738
  return;
}
}
#line 758 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static int qnq_async_evt_rcvd(struct be_adapter *adapter ) 
{ 


  {
#line 760
  return ((int )adapter->flags & 2048);
}
}
#line 764 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_lock_napi(struct be_eq_obj *eqo ) 
{ 
  bool status ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 766
  status = 1;
#line 768
  spin_lock(& eqo->lock);
#line 769
  if ((eqo->state & 3U) != 0U) {
#line 770
    __ret_warn_on = (int )eqo->state & 1;
#line 770
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 770
    if (tmp != 0L) {
#line 770
      warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h",
                         770);
    } else {

    }
#line 770
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 771
    eqo->state = eqo->state | 4U;
#line 772
    status = 0;
  } else {
#line 774
    eqo->state = 1U;
  }
#line 776
  spin_unlock(& eqo->lock);
#line 777
  return (status);
}
}
#line 780 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_unlock_napi(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 782
  spin_lock(& eqo->lock);
#line 784
  __ret_warn_on = (eqo->state & 6U) != 0U;
#line 784
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 784
  if (tmp != 0L) {
#line 784
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h",
                       784);
  } else {

  }
#line 784
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 785
  eqo->state = 0U;
#line 787
  spin_unlock(& eqo->lock);
#line 788
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_lock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  bool status ;

  {
#line 792
  status = 1;
#line 794
  spin_lock_bh(& eqo->lock);
#line 795
  if ((eqo->state & 3U) != 0U) {
#line 796
    eqo->state = eqo->state | 8U;
#line 797
    status = 0;
  } else {
#line 799
    eqo->state = eqo->state | 2U;
  }
#line 801
  spin_unlock_bh(& eqo->lock);
#line 802
  return (status);
}
}
#line 805 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_unlock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 807
  spin_lock_bh(& eqo->lock);
#line 809
  __ret_warn_on = (int )eqo->state & 1;
#line 809
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 809
  if (tmp != 0L) {
#line 809
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h",
                       809);
  } else {

  }
#line 809
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 810
  eqo->state = 0U;
#line 812
  spin_unlock_bh(& eqo->lock);
#line 813
  return;
}
}
#line 815 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_enable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  struct lock_class_key __key ;

  {
#line 817
  spinlock_check(& eqo->lock);
#line 817
  __raw_spin_lock_init(& eqo->lock.ldv_6347.rlock, "&(&eqo->lock)->rlock", & __key);
#line 818
  eqo->state = 0U;
#line 819
  return;
}
}
#line 821 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_disable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 823
  local_bh_disable();
#line 828
  goto ldv_53236;
  ldv_53235: ;
#line 829
  if (1) {
#line 829
    __const_udelay(4295000UL);
  } else {
#line 829
    __ms = 1UL;
#line 829
    goto ldv_53233;
    ldv_53232: 
#line 829
    __const_udelay(4295000UL);
    ldv_53233: 
#line 829
    tmp = __ms;
#line 829
    __ms = __ms - 1UL;
#line 829
    if (tmp != 0UL) {
#line 831
      goto ldv_53232;
    } else {

    }

  }
  ldv_53236: 
#line 828
  tmp___0 = be_lock_napi(eqo);
#line 828
  if (tmp___0) {
#line 828
    tmp___1 = 0;
  } else {
#line 828
    tmp___1 = 1;
  }
#line 828
  if (tmp___1) {
#line 830
    goto ldv_53235;
  } else {

  }
#line 831
  local_bh_enable();
#line 832
  return;
}
}
#line 863
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) ;
#line 865
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) ;
#line 866
void be_parse_stats(struct be_adapter *adapter ) ;
#line 867
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) ;
#line 869
bool be_pause_supported(struct be_adapter *adapter ) ;
#line 872 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static int fw_major_num(char const   *fw_ver ) 
{ 
  int fw_major ;

  {
#line 874
  fw_major = 0;
#line 876
  sscanf(fw_ver, "%d.", & fw_major);
#line 878
  return (fw_major);
}
}
#line 881
int be_update_queues(struct be_adapter *adapter ) ;
#line 882
int be_poll(struct napi_struct *napi , int budget ) ;
#line 887
void be_roce_dev_add(struct be_adapter *adapter ) ;
#line 888
void be_roce_dev_remove(struct be_adapter *adapter ) ;
#line 893
void be_roce_dev_open(struct be_adapter *adapter ) ;
#line 894
void be_roce_dev_close(struct be_adapter *adapter ) ;
#line 920 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static struct lancer_pport_stats *pport_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct lancer_cmd_resp_pport_stats *cmd ;

  {
#line 922
  cmd = (struct lancer_cmd_resp_pport_stats *)adapter->stats_cmd.va;
#line 923
  return (& cmd->pport_stats);
}
}
#line 1932 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool be_is_mc(struct be_adapter *adapter ) 
{ 


  {
#line 1934
  return ((unsigned int )adapter->mc_type > 1U);
}
}
#line 2045
int be_fw_wait_ready(struct be_adapter *adapter ) ;
#line 2048
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) ;
#line 2050
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) ;
#line 2052
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) ;
#line 2054
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) ;
#line 2055
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) ;
#line 2056
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) ;
#line 2059
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) ;
#line 2061
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) ;
#line 2062
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) ;
#line 2064
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) ;
#line 2066
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) ;
#line 2067
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) ;
#line 2070
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2071
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2073
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) ;
#line 2075
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) ;
#line 2076
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num ) ;
#line 2078
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) ;
#line 2079
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) ;
#line 2080
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) ;
#line 2081
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) ;
#line 2083
int be_cmd_reset_function(struct be_adapter *adapter ) ;
#line 2084
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size , u8 const   *rss_hkey ) ;
#line 2086
int be_process_mcc(struct be_adapter *adapter ) ;
#line 2091
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) ;
#line 2093
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) ;
#line 2100
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , u16 optype ,
                         int offset ) ;
#line 2102
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) ;
#line 2104
int be_cmd_fw_init(struct be_adapter *adapter ) ;
#line 2105
int be_cmd_fw_clean(struct be_adapter *adapter ) ;
#line 2106
void be_async_mcc_enable(struct be_adapter *adapter ) ;
#line 2107
void be_async_mcc_disable(struct be_adapter *adapter ) ;
#line 2117
int be_cmd_get_phy_info(struct be_adapter *adapter ) ;
#line 2118
int be_cmd_config_qos(struct be_adapter *adapter , u32 max_rate , u16 link_speed ,
                      u8 domain ) ;
#line 2120
void be_detect_error(struct be_adapter *adapter ) ;
#line 2121
int be_cmd_get_die_temperature(struct be_adapter *adapter ) ;
#line 2122
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) ;
#line 2123
int be_cmd_req_native_mode(struct be_adapter *adapter ) ;
#line 2126
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) ;
#line 2128
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) ;
#line 2133
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) ;
#line 2135
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) ;
#line 2138
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) ;
#line 2139
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode ) ;
#line 2141
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode ) ;
#line 2143
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) ;
#line 2145
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) ;
#line 2151
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) ;
#line 2154
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) ;
#line 2155
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) ;
#line 2156
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) ;
#line 2158
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 domain ) ;
#line 2162
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) ;
#line 2163
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) ;
#line 2165
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) ;
#line 2166
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) ;
#line 2167
int be_cmd_set_logical_link_config(struct be_adapter *adapter , int link_state , u8 domain ) ;
#line 2169
int be_cmd_set_vxlan_port(struct be_adapter *adapter , __be16 port ) ;
#line 2170
int be_cmd_manage_iface(struct be_adapter *adapter , u32 iface , u8 op ) ;
#line 38 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 39
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 40
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 121 "include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb , struct napi_struct *napi ) 
{ 


  {
#line 124
  skb->ldv_27804.napi_id = napi->napi_id;
#line 125
  return;
}
}
#line 56 "include/net/vxlan.h"
extern void vxlan_get_rx_port(struct net_device * ) ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct pci_device_id  const  __mod_pci__be_dev_ids_device_table  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static unsigned int num_vfs  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static ushort rx_frag_size  =    2048U;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct pci_device_id  const  be_dev_ids[9U]  = 
#line 119
  {      {6562U, 529U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 545U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1792U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1808U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57888U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57896U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1824U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1832U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static char const   * const  ue_status_low_desc[32U]  = 
#line 132
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "AXGMAC0",      "AXGMAC1",      "JTAG",      "MPU_INTPEND"};
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static char const   * const  ue_status_hi_desc[32U]  = 
#line 167
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "HOST8",      "HOST9",      "NETC", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_queue_free(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 205
  mem = & q->dma_mem;
#line 206
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 207
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
#line 209
    mem->va = (void *)0;
  } else {

  }
#line 211
  return;
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_queue_alloc(struct be_adapter *adapter , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 216
  mem = & q->dma_mem;
#line 218
  memset((void *)q, 0, 40UL);
#line 219
  q->len = len;
#line 220
  q->entry_size = entry_size;
#line 221
  mem->size = (u32 )((int )len * (int )entry_size);
#line 222
  mem->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )mem->size, & mem->dma,
                                208U);
#line 224
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 225
    return (-12);
  } else {

  }
#line 226
  return (0);
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_reg_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  u32 reg ;
  u32 enabled ;

  {
#line 233
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 252, & reg);
#line 235
  enabled = reg & 536870912U;
#line 237
  if (enabled == 0U && (int )enable) {
#line 238
    reg = reg | 536870912U;
  } else
#line 239
  if (enabled != 0U && ! enable) {
#line 240
    reg = reg & 3758096383U;
  } else {
#line 242
    return;
  }
#line 244
  pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 252, reg);
#line 245
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  int status ;

  {
#line 250
  status = 0;
#line 253
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 254
    return;
  } else {

  }
#line 256
  if ((int )adapter->eeh_error) {
#line 257
    return;
  } else {

  }
#line 259
  status = be_cmd_intr_set(adapter, (int )enable);
#line 260
  if (status != 0) {
#line 261
    be_reg_intr_set(adapter, (int )enable);
  } else {

  }
#line 262
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rxq_notify(struct be_adapter *adapter , u16 qid , u16 posted ) 
{ 
  u32 val ;

  {
#line 266
  val = 0U;
#line 267
  val = ((u32 )qid & 1023U) | val;
#line 268
  val = (u32 )((int )posted << 24) | val;
#line 270
  __asm__  volatile   ("sfence": : : "memory");
#line 271
  iowrite32(val, (void *)adapter->db + 256U);
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_txq_notify(struct be_adapter *adapter , struct be_tx_obj *txo , u16 posted ) 
{ 
  u32 val ;

  {
#line 277
  val = 0U;
#line 278
  val = ((u32 )txo->q.id & 2047U) | val;
#line 279
  val = (u32 )(((int )posted & 16383) << 16) | val;
#line 281
  __asm__  volatile   ("sfence": : : "memory");
#line 282
  iowrite32(val, (void *)adapter->db + (unsigned long )txo->db_offset);
#line 283
  return;
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_eq_notify(struct be_adapter *adapter , u16 qid , bool arm , bool clear_int ,
                         u16 num_popped ) 
{ 
  u32 val ;

  {
#line 288
  val = 0U;
#line 289
  val = ((u32 )qid & 511U) | val;
#line 290
  val = (u32 )(((int )qid & 15872) << 2) | val;
#line 292
  if ((int )adapter->eeh_error) {
#line 293
    return;
  } else {

  }
#line 295
  if ((int )arm) {
#line 296
    val = val | 536870912U;
  } else {

  }
#line 297
  if ((int )clear_int) {
#line 298
    val = val | 512U;
  } else {

  }
#line 299
  val = val | 1024U;
#line 300
  val = (u32 )((int )num_popped << 16) | val;
#line 301
  iowrite32(val, (void *)adapter->db + 288U);
#line 302
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) 
{ 
  u32 val ;

  {
#line 306
  val = 0U;
#line 307
  val = ((u32 )qid & 1023U) | val;
#line 308
  val = (u32 )(((int )qid & 31744) << 1) | val;
#line 311
  if ((int )adapter->eeh_error) {
#line 312
    return;
  } else {

  }
#line 314
  if ((int )arm) {
#line 315
    val = val | 536870912U;
  } else {

  }
#line 316
  val = (u32 )((int )num_popped << 16) | val;
#line 317
  iowrite32(val, (void *)adapter->db + 288U);
#line 318
  return;
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_mac_addr_set(struct net_device *netdev , void *p ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  struct sockaddr *addr ;
  int status ;
  u8 mac[6U] ;
  u32 old_pmac_id ;
  u32 curr_pmac_id ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 322
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 322
  adapter = (struct be_adapter *)tmp;
#line 323
  dev = & (adapter->pdev)->dev;
#line 324
  addr = (struct sockaddr *)p;
#line 327
  old_pmac_id = *(adapter->pmac_id);
#line 327
  curr_pmac_id = 0U;
#line 329
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
#line 329
  if (tmp___0) {
#line 329
    tmp___1 = 0;
  } else {
#line 329
    tmp___1 = 1;
  }
#line 329
  if (tmp___1) {
#line 330
    return (-99);
  } else {

  }
#line 335
  tmp___2 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)netdev->dev_addr);
#line 335
  if ((int )tmp___2) {
#line 336
    return (0);
  } else {

  }
#line 344
  status = be_cmd_pmac_add(adapter, (u8 *)(& addr->sa_data), (u32 )adapter->if_handle,
                           adapter->pmac_id, 0U);
#line 346
  if (status == 0) {
#line 347
    curr_pmac_id = *(adapter->pmac_id);
#line 352
    if (*(adapter->pmac_id) != old_pmac_id) {
#line 353
      be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )old_pmac_id, 0U);
    } else {

    }
  } else {

  }
#line 360
  status = be_cmd_get_active_mac(adapter, curr_pmac_id, (u8 *)(& mac), (u32 )adapter->if_handle,
                                 1, 0U);
#line 362
  if (status != 0) {
#line 363
    goto err;
  } else {

  }
#line 368
  tmp___3 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)(& mac));
#line 368
  if (tmp___3) {
#line 368
    tmp___4 = 0;
  } else {
#line 368
    tmp___4 = 1;
  }
#line 368
  if (tmp___4) {
#line 369
    status = -1;
#line 370
    goto err;
  } else {

  }
#line 373
  __len = (size_t )netdev->addr_len;
#line 373
  __ret = __builtin_memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data),
                           __len);
#line 374
  _dev_info((struct device  const  *)dev, "MAC address changed to %pM\n", (u8 *)(& mac));
#line 375
  return (0);
  err: 
#line 377
  dev_warn((struct device  const  *)dev, "MAC address change to %pM failed\n", (char *)(& addr->sa_data));
#line 378
  return (status);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void *hw_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_cmd_resp_get_stats_v0 *cmd ;
  struct be_cmd_resp_get_stats_v1 *cmd___0 ;
  struct be_cmd_resp_get_stats_v2 *cmd___1 ;

  {
#line 384
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 385
    cmd = (struct be_cmd_resp_get_stats_v0 *)adapter->stats_cmd.va;
#line 387
    return ((void *)(& cmd->hw_stats));
  } else
#line 388
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 389
    cmd___0 = (struct be_cmd_resp_get_stats_v1 *)adapter->stats_cmd.va;
#line 391
    return ((void *)(& cmd___0->hw_stats));
  } else {
#line 393
    cmd___1 = (struct be_cmd_resp_get_stats_v2 *)adapter->stats_cmd.va;
#line 395
    return ((void *)(& cmd___1->hw_stats));
  }
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void *be_erx_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_hw_stats_v1 *hw_stats___0 ;
  void *tmp___0 ;
  struct be_hw_stats_v2 *hw_stats___1 ;
  void *tmp___1 ;

  {
#line 402
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 403
    tmp = hw_stats_from_cmd(adapter);
#line 403
    hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 405
    return ((void *)(& hw_stats->erx));
  } else
#line 406
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 407
    tmp___0 = hw_stats_from_cmd(adapter);
#line 407
    hw_stats___0 = (struct be_hw_stats_v1 *)tmp___0;
#line 409
    return ((void *)(& hw_stats___0->erx));
  } else {
#line 411
    tmp___1 = hw_stats_from_cmd(adapter);
#line 411
    hw_stats___1 = (struct be_hw_stats_v2 *)tmp___1;
#line 413
    return ((void *)(& hw_stats___1->erx));
  }
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void populate_be_v0_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v0 *rxf_stats ;
  struct be_port_rxf_stats_v0 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 419
  tmp = hw_stats_from_cmd(adapter);
#line 419
  hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 420
  pmem_sts = & hw_stats->pmem;
#line 421
  rxf_stats = & hw_stats->rxf;
#line 422
  port_stats = (struct be_port_rxf_stats_v0 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 424
  drvs = & adapter->drv_stats;
#line 426
  swap_dws((void *)hw_stats, 1060);
#line 427
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 428
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 429
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 430
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 431
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 432
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 433
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 434
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 435
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 436
  drvs->rxpp_fifo_overflow_drop = port_stats->rx_fifo_overflow;
#line 437
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 438
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 439
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 440
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 441
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow;
#line 442
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 444
  drvs->rx_address_filtered = port_stats->rx_address_filtered + port_stats->rx_vlan_filtered;
#line 447
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 450
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 451
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 453
  if (adapter->port_num != 0U) {
#line 454
    drvs->jabber_events = rxf_stats->port1_jabber_events;
  } else {
#line 456
    drvs->jabber_events = rxf_stats->port0_jabber_events;
  }
#line 457
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 458
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 459
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 460
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 461
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 462
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 463
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 464
  return;
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void populate_be_v1_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v1 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v1 *rxf_stats ;
  struct be_port_rxf_stats_v1 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 468
  tmp = hw_stats_from_cmd(adapter);
#line 468
  hw_stats = (struct be_hw_stats_v1 *)tmp;
#line 469
  pmem_sts = & hw_stats->pmem;
#line 470
  rxf_stats = & hw_stats->rxf;
#line 471
  port_stats = (struct be_port_rxf_stats_v1 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 473
  drvs = & adapter->drv_stats;
#line 475
  swap_dws((void *)hw_stats, 1848);
#line 476
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 477
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 478
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 479
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 480
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 481
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 482
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 483
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 484
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 485
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 486
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 487
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 488
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 489
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 490
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 491
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 493
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 495
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 496
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 498
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 499
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 500
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 501
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 502
  drvs->jabber_events = port_stats->jabber_events;
#line 503
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 504
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 505
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 506
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 507
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 508
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 509
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void populate_be_v2_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v2 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v2 *rxf_stats ;
  struct be_port_rxf_stats_v2 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 514
  tmp = hw_stats_from_cmd(adapter);
#line 514
  hw_stats = (struct be_hw_stats_v2 *)tmp;
#line 515
  pmem_sts = & hw_stats->pmem;
#line 516
  rxf_stats = & hw_stats->rxf;
#line 517
  port_stats = (struct be_port_rxf_stats_v2 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 519
  drvs = & adapter->drv_stats;
#line 521
  swap_dws((void *)hw_stats, 2680);
#line 522
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 523
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 524
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 525
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 526
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 527
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 528
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 529
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 530
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 531
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 532
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 533
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 534
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 535
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 536
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 537
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 539
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 541
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 542
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 544
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 545
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 546
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 547
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 548
  drvs->jabber_events = port_stats->jabber_events;
#line 549
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 550
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 551
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 552
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 553
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 554
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 555
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 556
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 557
    drvs->rx_roce_bytes_lsd = port_stats->roce_bytes_received_lsd;
#line 558
    drvs->rx_roce_bytes_msd = port_stats->roce_bytes_received_msd;
#line 559
    drvs->rx_roce_frames = port_stats->roce_frames_received;
#line 560
    drvs->roce_drops_crc = port_stats->roce_drops_crc;
#line 561
    drvs->roce_drops_payload_len = port_stats->roce_drops_payload_len;
  } else {

  }
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void populate_lancer_stats(struct be_adapter *adapter ) 
{ 
  struct be_drv_stats *drvs ;
  struct lancer_pport_stats *pport_stats ;
  struct lancer_pport_stats *tmp ;

  {
#line 569
  drvs = & adapter->drv_stats;
#line 570
  tmp = pport_stats_from_cmd(adapter);
#line 570
  pport_stats = tmp;
#line 572
  swap_dws((void *)pport_stats, 656);
#line 573
  drvs->rx_pause_frames = pport_stats->rx_pause_frames_lo;
#line 574
  drvs->rx_crc_errors = pport_stats->rx_crc_errors_lo;
#line 575
  drvs->rx_control_frames = pport_stats->rx_control_frames_lo;
#line 576
  drvs->rx_in_range_errors = pport_stats->rx_in_range_errors;
#line 577
  drvs->rx_frame_too_long = pport_stats->rx_frames_too_long_lo;
#line 578
  drvs->rx_dropped_runt = pport_stats->rx_dropped_runt;
#line 579
  drvs->rx_ip_checksum_errs = pport_stats->rx_ip_checksum_errors;
#line 580
  drvs->rx_tcp_checksum_errs = pport_stats->rx_tcp_checksum_errors;
#line 581
  drvs->rx_udp_checksum_errs = pport_stats->rx_udp_checksum_errors;
#line 582
  drvs->rx_dropped_tcp_length = pport_stats->rx_dropped_invalid_tcp_length;
#line 584
  drvs->rx_dropped_too_small = pport_stats->rx_dropped_too_small;
#line 585
  drvs->rx_dropped_too_short = pport_stats->rx_dropped_too_short;
#line 586
  drvs->rx_out_range_errors = pport_stats->rx_out_of_range_errors;
#line 587
  drvs->rx_dropped_header_too_small = pport_stats->rx_dropped_header_too_small;
#line 589
  drvs->rx_input_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 590
  drvs->rx_address_filtered = pport_stats->rx_address_filtered + pport_stats->rx_vlan_filtered;
#line 593
  drvs->rx_alignment_symbol_errors = pport_stats->rx_symbol_errors_lo;
#line 594
  drvs->rxpp_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 595
  drvs->tx_pauseframes = pport_stats->tx_pause_frames_lo;
#line 596
  drvs->tx_controlframes = pport_stats->tx_control_frames_lo;
#line 597
  drvs->jabber_events = pport_stats->rx_jabbers;
#line 598
  drvs->forwarded_packets = pport_stats->num_forwards_lo;
#line 599
  drvs->rx_drops_mtu = pport_stats->rx_drops_mtu_lo;
#line 600
  drvs->rx_drops_too_many_frags = pport_stats->rx_drops_too_many_frags_lo;
#line 602
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void accumulate_16bit_val(u32 *acc , u16 val ) 
{ 
  bool wrapped ;
  u32 newacc ;

  {
#line 608
  wrapped = (u32 )val < (*acc & 65535U);
#line 609
  newacc = (*acc & 4294901760U) + (u32 )val;
#line 611
  if ((int )wrapped) {
#line 612
    newacc = newacc + 65536U;
  } else {

  }
#line 613
  *((u32 volatile   *)acc) = newacc;
#line 614
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void populate_erx_stats(struct be_adapter *adapter , struct be_rx_obj *rxo ,
                               u32 erx_stat ) 
{ 


  {
#line 619
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 620
    rxo->stats.rx_drops_no_frags = erx_stat;
  } else {
#line 625
    accumulate_16bit_val(& rxo->stats.rx_drops_no_frags, (int )((unsigned short )erx_stat));
  }
#line 627
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void be_parse_stats(struct be_adapter *adapter ) 
{ 
  struct be_erx_stats_v2 *erx ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  int i ;
  u32 erx_stat ;

  {
#line 631
  tmp = be_erx_stats_from_cmd(adapter);
#line 631
  erx = (struct be_erx_stats_v2 *)tmp;
#line 636
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 637
    populate_lancer_stats(adapter);
  } else {
#line 639
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 640
      populate_be_v0_stats(adapter);
    } else
#line 641
    if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 643
      populate_be_v1_stats(adapter);
    } else {
#line 645
      populate_be_v2_stats(adapter);
    }
#line 648
    i = 0;
#line 648
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 648
    goto ldv_55380;
    ldv_55379: 
#line 649
    erx_stat = erx->rx_drops_no_fragments[(int )rxo->q.id];
#line 650
    populate_erx_stats(adapter, rxo, erx_stat);
#line 648
    i = i + 1;
#line 648
    rxo = rxo + 1;
    ldv_55380: ;
#line 648
    if ((int )adapter->num_rx_qs > i) {
#line 650
      goto ldv_55379;
    } else {

    }

  }
#line 656
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct rtnl_link_stats64 *be_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_drv_stats *drvs ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 pkts ;
  u64 bytes ;
  unsigned int start ;
  int i ;
  struct be_rx_stats  const  *rx_stats ;
  bool tmp___0 ;
  struct be_tx_stats  const  *tx_stats ;
  bool tmp___1 ;

  {
#line 658
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 658
  adapter = (struct be_adapter *)tmp;
#line 659
  drvs = & adapter->drv_stats;
#line 666
  i = 0;
#line 666
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 666
  goto ldv_55398;
  ldv_55397: 
#line 667
  rx_stats = (struct be_rx_stats  const  *)(& rxo->stats);
  ldv_55395: 
#line 669
  start = u64_stats_fetch_begin_irq(& rx_stats->sync);
#line 670
  pkts = rxo->stats.rx_pkts;
#line 671
  bytes = rxo->stats.rx_bytes;
#line 672
  tmp___0 = u64_stats_fetch_retry_irq(& rx_stats->sync, start);
#line 672
  if ((int )tmp___0) {
#line 674
    goto ldv_55395;
  } else {

  }
#line 673
  stats->rx_packets = stats->rx_packets + pkts;
#line 674
  stats->rx_bytes = stats->rx_bytes + bytes;
#line 675
  stats->multicast = stats->multicast + (__u64 )rxo->stats.rx_mcast_pkts;
#line 676
  stats->rx_dropped = stats->rx_dropped + (__u64 )(rxo->stats.rx_drops_no_skbs + rxo->stats.rx_drops_no_frags);
#line 666
  i = i + 1;
#line 666
  rxo = rxo + 1;
  ldv_55398: ;
#line 666
  if ((int )adapter->num_rx_qs > i) {
#line 668
    goto ldv_55397;
  } else {

  }
#line 680
  i = 0;
#line 680
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 680
  goto ldv_55404;
  ldv_55403: 
#line 681
  tx_stats = (struct be_tx_stats  const  *)(& txo->stats);
  ldv_55401: 
#line 683
  start = u64_stats_fetch_begin_irq(& tx_stats->sync);
#line 684
  pkts = txo->stats.tx_pkts;
#line 685
  bytes = txo->stats.tx_bytes;
#line 686
  tmp___1 = u64_stats_fetch_retry_irq(& tx_stats->sync, start);
#line 686
  if ((int )tmp___1) {
#line 688
    goto ldv_55401;
  } else {

  }
#line 687
  stats->tx_packets = stats->tx_packets + pkts;
#line 688
  stats->tx_bytes = stats->tx_bytes + bytes;
#line 680
  i = i + 1;
#line 680
  txo = txo + 1;
  ldv_55404: ;
#line 680
  if ((int )adapter->num_tx_qs > i) {
#line 682
    goto ldv_55403;
  } else {

  }
#line 692
  stats->rx_errors = (__u64 )(((((((((drvs->rx_crc_errors + drvs->rx_alignment_symbol_errors) + drvs->rx_in_range_errors) + drvs->rx_out_range_errors) + drvs->rx_frame_too_long) + drvs->rx_dropped_too_small) + drvs->rx_dropped_too_short) + drvs->rx_dropped_header_too_small) + drvs->rx_dropped_tcp_length) + drvs->rx_dropped_runt);
#line 704
  stats->rx_length_errors = (__u64 )((drvs->rx_in_range_errors + drvs->rx_out_range_errors) + drvs->rx_frame_too_long);
#line 708
  stats->rx_crc_errors = (__u64 )drvs->rx_crc_errors;
#line 711
  stats->rx_frame_errors = (__u64 )drvs->rx_alignment_symbol_errors;
#line 715
  stats->rx_fifo_errors = (__u64 )((drvs->rxpp_fifo_overflow_drop + drvs->rx_input_fifo_overflow_drop) + drvs->rx_drops_no_pbuf);
#line 718
  return (stats);
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) 
{ 
  struct net_device *netdev ;

  {
#line 723
  netdev = adapter->netdev;
#line 725
  if ((adapter->flags & 1U) == 0U) {
#line 726
    netif_carrier_off(netdev);
#line 727
    adapter->flags = adapter->flags | 1U;
  } else {

  }
#line 730
  if ((unsigned int )link_status != 0U) {
#line 731
    netif_carrier_on(netdev);
  } else {
#line 733
    netif_carrier_off(netdev);
  }
#line 734
  return;
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_tx_stats_update(struct be_tx_obj *txo , u32 wrb_cnt , u32 copied ,
                               u32 gso_segs , bool stopped ) 
{ 
  struct be_tx_stats *stats ;

  {
#line 740
  stats = & txo->stats;
#line 742
  u64_stats_update_begin(& stats->sync);
#line 743
  stats->tx_reqs = stats->tx_reqs + 1ULL;
#line 744
  stats->tx_wrbs = stats->tx_wrbs + (u64 )wrb_cnt;
#line 745
  stats->tx_bytes = stats->tx_bytes + (u64 )copied;
#line 746
  stats->tx_pkts = stats->tx_pkts + (gso_segs != 0U ? (u64 )gso_segs : 1ULL);
#line 747
  if ((int )stopped) {
#line 748
    stats->tx_stops = stats->tx_stops + 1U;
  } else {

  }
#line 749
  u64_stats_update_begin(& stats->sync);
#line 750
  return;
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u32 wrb_cnt_for_skb(struct be_adapter *adapter , struct sk_buff *skb , bool *dummy ) 
{ 
  int cnt ;
  unsigned char *tmp ;
  long tmp___0 ;

  {
#line 756
  cnt = skb->len > skb->data_len;
#line 758
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 758
  cnt = (int )((struct skb_shared_info *)tmp)->nr_frags + cnt;
#line 761
  cnt = cnt + 1;
#line 762
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (cnt & 1) == 0) {
#line 763
    *dummy = 0;
  } else {
#line 766
    cnt = cnt + 1;
#line 767
    *dummy = 1;
  }
#line 769
  tmp___0 = ldv__builtin_expect(cnt > 30, 0L);
#line 769
  if (tmp___0 != 0L) {
#line 769
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (769), "i" (12UL));
    ldv_55425: ;
#line 769
    goto ldv_55425;
  } else {

  }
#line 770
  return ((u32 )cnt);
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void wrb_fill(struct be_eth_wrb *wrb , u64 addr , int len ) 
{ 


  {
#line 775
  wrb->frag_pa_hi = (unsigned int )(addr >> 32ULL);
#line 776
  wrb->frag_pa_lo = (u32 )addr;
#line 777
  wrb->frag_len = (u32 )len & 65535U;
#line 778
  wrb->rsvd0 = 0U;
#line 779
  return;
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static u16 be_get_tx_vlan_tag(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  u8 vlan_prio ;
  u16 vlan_tag ;

  {
#line 787
  vlan_tag = (unsigned int )skb->vlan_tci & 61439U;
#line 788
  vlan_prio = (u8 )((int )vlan_tag >> 13);
#line 790
  if ((((int )adapter->vlan_prio_bmap >> (int )vlan_prio) & 1) == 0) {
#line 791
    vlan_tag = (u16 )(((int )((short )vlan_tag) & 8191) | (int )((short )adapter->recommended_prio));
  } else {

  }
#line 794
  return (vlan_tag);
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u16 skb_inner_ip_proto(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp___0 ;
  struct ipv6hdr *tmp___1 ;
  int tmp___2 ;
  struct iphdr *tmp___3 ;

  {
#line 800
  tmp___3 = inner_ip_hdr((struct sk_buff  const  *)skb);
#line 800
  if ((unsigned int )*((unsigned char *)tmp___3 + 0UL) == 64U) {
#line 800
    tmp___0 = inner_ip_hdr((struct sk_buff  const  *)skb);
#line 800
    tmp___2 = (u16 )tmp___0->protocol;
  } else {
#line 800
    tmp___1 = inner_ipv6_hdr((struct sk_buff  const  *)skb);
#line 800
    tmp___2 = (u16 )tmp___1->nexthdr;
  }
#line 800
  return (tmp___2);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u16 skb_ip_proto(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp___0 ;
  struct ipv6hdr *tmp___1 ;
  int tmp___2 ;
  struct iphdr *tmp___3 ;

  {
#line 806
  tmp___3 = ip_hdr((struct sk_buff  const  *)skb);
#line 806
  if ((unsigned int )*((unsigned char *)tmp___3 + 0UL) == 64U) {
#line 806
    tmp___0 = ip_hdr((struct sk_buff  const  *)skb);
#line 806
    tmp___2 = (u16 )tmp___0->protocol;
  } else {
#line 806
    tmp___1 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 806
    tmp___2 = (u16 )tmp___1->nexthdr;
  }
#line 806
  return (tmp___2);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void wrb_fill_hdr(struct be_adapter *adapter , struct be_eth_hdr_wrb *hdr ,
                         struct sk_buff *skb , u32 wrb_cnt , u32 len , bool skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  u16 proto ;
  u32 tmp ;
  u32 tmp___0 ;
  unsigned char *tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  bool tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  bool tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;

  {
#line 816
  memset((void *)hdr, 0, 16UL);
#line 818
  tmp = amap_mask(1U);
#line 818
  amap_set((void *)hdr, 2U, tmp, 2U, 1U);
#line 820
  tmp___8 = skb_is_gso((struct sk_buff  const  *)skb);
#line 820
  if ((int )tmp___8) {
#line 821
    tmp___0 = amap_mask(1U);
#line 821
    amap_set((void *)hdr, 2U, tmp___0, 9U, 1U);
#line 822
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 822
    tmp___2 = amap_mask(14U);
#line 822
    amap_set((void *)hdr, 2U, tmp___2, 18U, (u32 )((struct skb_shared_info *)tmp___1)->gso_size);
#line 824
    tmp___4 = skb_is_gso_v6((struct sk_buff  const  *)skb);
#line 824
    if ((int )tmp___4 && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 825
      tmp___3 = amap_mask(1U);
#line 825
      amap_set((void *)hdr, 2U, tmp___3, 4U, 1U);
    } else {

    }
  } else
#line 826
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 12U) {
#line 827
    if ((unsigned int )*((unsigned char *)skb + 171UL) != 0U) {
#line 828
      tmp___5 = amap_mask(1U);
#line 828
      amap_set((void *)hdr, 2U, tmp___5, 6U, 1U);
#line 829
      proto = skb_inner_ip_proto(skb);
    } else {
#line 831
      proto = skb_ip_proto(skb);
    }
#line 833
    if ((unsigned int )proto == 6U) {
#line 834
      tmp___6 = amap_mask(1U);
#line 834
      amap_set((void *)hdr, 2U, tmp___6, 8U, 1U);
    } else
#line 835
    if ((unsigned int )proto == 17U) {
#line 836
      tmp___7 = amap_mask(1U);
#line 836
      amap_set((void *)hdr, 2U, tmp___7, 7U, 1U);
    } else {

    }
  } else {

  }
#line 839
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 840
    tmp___9 = amap_mask(1U);
#line 840
    amap_set((void *)hdr, 2U, tmp___9, 10U, 1U);
#line 841
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
#line 842
    tmp___10 = amap_mask(16U);
#line 842
    amap_set((void *)hdr, 3U, tmp___10, 16U, (u32 )vlan_tag);
  } else {

  }
#line 846
  tmp___11 = amap_mask(1U);
#line 846
  amap_set((void *)hdr, 2U, tmp___11, 0U, (u32 )(! skip_hw_vlan));
#line 847
  tmp___12 = amap_mask(1U);
#line 847
  amap_set((void *)hdr, 2U, tmp___12, 1U, 1U);
#line 848
  tmp___13 = amap_mask(5U);
#line 848
  amap_set((void *)hdr, 2U, tmp___13, 13U, wrb_cnt);
#line 849
  tmp___14 = amap_mask(16U);
#line 849
  amap_set((void *)hdr, 3U, tmp___14, 0U, len);
#line 850
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void unmap_tx_frag(struct device *dev , struct be_eth_wrb *wrb , bool unmap_single ) 
{ 
  dma_addr_t dma ;

  {
#line 857
  swap_dws((void *)wrb, 16);
#line 859
  dma = ((unsigned long long )wrb->frag_pa_hi << 32) | (unsigned long long )wrb->frag_pa_lo;
#line 860
  if (wrb->frag_len != 0U) {
#line 861
    if ((int )unmap_single) {
#line 862
      dma_unmap_single_attrs(dev, dma, (size_t )wrb->frag_len, 1, (struct dma_attrs *)0);
    } else {
#line 865
      dma_unmap_page(dev, dma, (size_t )wrb->frag_len, 1);
    }
  } else {

  }
#line 866
  return;
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int make_tx_wrbs(struct be_adapter *adapter , struct be_queue_info *txq , struct sk_buff *skb ,
                        u32 wrb_cnt , bool dummy_wrb , bool skip_hw_vlan ) 
{ 
  dma_addr_t busaddr ;
  int i ;
  int copied ;
  struct device *dev ;
  struct sk_buff *first_skb ;
  struct be_eth_wrb *wrb ;
  struct be_eth_hdr_wrb *hdr ;
  bool map_single ;
  u16 map_head ;
  void *tmp ;
  int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct skb_frag_struct  const  *frag ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 874
  copied = 0;
#line 875
  dev = & (adapter->pdev)->dev;
#line 876
  first_skb = skb;
#line 879
  map_single = 0;
#line 882
  tmp = queue_head_node(txq);
#line 882
  hdr = (struct be_eth_hdr_wrb *)tmp;
#line 883
  queue_head_inc(txq);
#line 884
  map_head = txq->head;
#line 886
  if (skb->len > skb->data_len) {
#line 887
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 887
    len = (int )tmp___0;
#line 888
    busaddr = dma_map_single_attrs(dev, (void *)skb->data, (size_t )len, 1, (struct dma_attrs *)0);
#line 889
    tmp___1 = dma_mapping_error(dev, busaddr);
#line 889
    if (tmp___1 != 0) {
#line 890
      goto dma_err;
    } else {

    }
#line 891
    map_single = 1;
#line 892
    tmp___2 = queue_head_node(txq);
#line 892
    wrb = (struct be_eth_wrb *)tmp___2;
#line 893
    wrb_fill(wrb, busaddr, len);
#line 894
    swap_dws((void *)wrb, 16);
#line 895
    queue_head_inc(txq);
#line 896
    copied = copied + len;
  } else {

  }
#line 899
  i = 0;
#line 899
  goto ldv_55480;
  ldv_55479: 
#line 900
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 900
  frag = (struct skb_frag_struct  const  *)(& ((struct skb_shared_info *)tmp___3)->frags) + (unsigned long )i;
#line 901
  tmp___4 = skb_frag_size(frag);
#line 901
  busaddr = skb_frag_dma_map(dev, frag, 0UL, (size_t )tmp___4, 1);
#line 903
  tmp___5 = dma_mapping_error(dev, busaddr);
#line 903
  if (tmp___5 != 0) {
#line 904
    goto dma_err;
  } else {

  }
#line 905
  tmp___6 = queue_head_node(txq);
#line 905
  wrb = (struct be_eth_wrb *)tmp___6;
#line 906
  tmp___7 = skb_frag_size(frag);
#line 906
  wrb_fill(wrb, busaddr, (int )tmp___7);
#line 907
  swap_dws((void *)wrb, 16);
#line 908
  queue_head_inc(txq);
#line 909
  tmp___8 = skb_frag_size(frag);
#line 909
  copied = (int )(tmp___8 + (unsigned int )copied);
#line 899
  i = i + 1;
  ldv_55480: 
#line 899
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 899
  if ((int )((struct skb_shared_info *)tmp___9)->nr_frags > i) {
#line 901
    goto ldv_55479;
  } else {

  }

#line 912
  if ((int )dummy_wrb) {
#line 913
    tmp___10 = queue_head_node(txq);
#line 913
    wrb = (struct be_eth_wrb *)tmp___10;
#line 914
    wrb_fill(wrb, 0ULL, 0);
#line 915
    swap_dws((void *)wrb, 16);
#line 916
    queue_head_inc(txq);
  } else {

  }
#line 919
  wrb_fill_hdr(adapter, hdr, first_skb, wrb_cnt, (u32 )copied, (int )skip_hw_vlan);
#line 920
  swap_dws((void *)hdr, 16);
#line 922
  return (copied);
  dma_err: 
#line 924
  txq->head = map_head;
#line 925
  goto ldv_55483;
  ldv_55482: 
#line 926
  tmp___11 = queue_head_node(txq);
#line 926
  wrb = (struct be_eth_wrb *)tmp___11;
#line 927
  unmap_tx_frag(dev, wrb, (int )map_single);
#line 928
  map_single = 0;
#line 929
  copied = (int )((u32 )copied - wrb->frag_len);
#line 930
  queue_head_inc(txq);
  ldv_55483: ;
#line 925
  if (copied != 0) {
#line 927
    goto ldv_55482;
  } else {

  }

#line 932
  return (0);
}
}
#line 935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct sk_buff *be_insert_vlan_in_pkt(struct be_adapter *adapter , struct sk_buff *skb ,
                                             bool *skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 939
  vlan_tag = 0U;
#line 941
  skb = skb_share_check(skb, 32U);
#line 942
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 942
  if (tmp != 0L) {
#line 943
    return (skb);
  } else {

  }
#line 945
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 946
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
  } else {

  }
#line 948
  tmp___0 = qnq_async_evt_rcvd(adapter);
#line 948
  if (tmp___0 != 0 && (unsigned int )adapter->pvid != 0U) {
#line 949
    if ((unsigned int )vlan_tag == 0U) {
#line 950
      vlan_tag = adapter->pvid;
    } else {

    }
#line 954
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 955
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 958
  if ((unsigned int )vlan_tag != 0U) {
#line 959
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 960
    tmp___1 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 960
    if (tmp___1 != 0L) {
#line 961
      return (skb);
    } else {

    }
#line 962
    skb->vlan_tci = 0U;
  } else {

  }
#line 966
  if ((unsigned int )adapter->qnq_vid != 0U) {
#line 967
    vlan_tag = adapter->qnq_vid;
#line 968
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 969
    tmp___2 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 969
    if (tmp___2 != 0L) {
#line 970
      return (skb);
    } else {

    }
#line 971
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 972
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 975
  return (skb);
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static bool be_ipv6_exthdr_check(struct sk_buff *skb ) 
{ 
  struct ethhdr *eh ;
  u16 offset ;
  struct ipv6hdr *ip6h ;
  struct ipv6_opt_hdr *ehdr ;

  {
#line 980
  eh = (struct ethhdr *)skb->data;
#line 981
  offset = 14U;
#line 983
  if ((unsigned int )eh->h_proto == 56710U) {
#line 984
    ip6h = (struct ipv6hdr *)skb->data + (unsigned long )offset;
#line 986
    offset = (unsigned int )offset + 40U;
#line 987
    if ((unsigned int )ip6h->nexthdr != 6U && (unsigned int )ip6h->nexthdr != 17U) {
#line 989
      ehdr = (struct ipv6_opt_hdr *)skb->data + (unsigned long )offset;
#line 993
      if ((unsigned int )ehdr->hdrlen == 255U) {
#line 994
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 997
  return (0);
}
}
#line 1000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vlan_tag_tx_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 


  {
#line 1002
  return ((((int )skb->vlan_tci & 4096) != 0 || (unsigned int )adapter->pvid != 0U) || (unsigned int )adapter->qnq_vid != 0U);
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_ipv6_tx_stall_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 1007
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 1007
    tmp = be_ipv6_exthdr_check(skb);
#line 1007
    if ((int )tmp) {
#line 1007
      tmp___0 = 1;
    } else {
#line 1007
      tmp___0 = 0;
    }
  } else {
#line 1007
    tmp___0 = 0;
  }
#line 1007
  return (tmp___0);
}
}
#line 1010 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct sk_buff *be_lancer_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                                  bool *skip_hw_vlan ) 
{ 
  struct vlan_ethhdr *veh ;
  unsigned int eth_hdr_len ;
  struct iphdr *ip ;
  __u16 tmp ;
  __u16 tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1014
  veh = (struct vlan_ethhdr *)skb->data;
#line 1022
  tmp = __fswab16((int )skb->protocol);
#line 1022
  eth_hdr_len = (unsigned int )tmp == 33024U ? 18U : 14U;
#line 1024
  if (skb->len <= 60U && (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || ((int )skb->vlan_tci & 4096) != 0)) {
#line 1024
    tmp___1 = is_ipv4_pkt(skb);
#line 1024
    if ((int )tmp___1) {
#line 1027
      ip = ip_hdr((struct sk_buff  const  *)skb);
#line 1028
      tmp___0 = __fswab16((int )ip->tot_len);
#line 1028
      pskb_trim(skb, (unsigned int )tmp___0 + eth_hdr_len);
    } else {

    }
  } else {

  }
#line 1034
  if ((unsigned int )adapter->pvid != 0U && (unsigned int )veh->h_vlan_proto == 129U) {
#line 1036
    *skip_hw_vlan = 1;
  } else {

  }
#line 1042
  if ((unsigned int )*((unsigned char *)skb + 124UL) != 12U && ((int )skb->vlan_tci & 4096) != 0) {
#line 1044
    skb = be_insert_vlan_in_pkt(adapter, skb, skip_hw_vlan);
#line 1045
    tmp___2 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 1045
    if (tmp___2 != 0L) {
#line 1046
      goto err;
    } else {

    }
  } else {

  }
#line 1053
  tmp___3 = be_ipv6_tx_stall_chk(adapter, skb);
#line 1053
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 1053
  if (tmp___4 != 0L) {
#line 1053
    tmp___5 = ldv__builtin_expect((unsigned int )adapter->pvid != 0U, 0L);
#line 1053
    if (tmp___5 != 0L) {
#line 1053
      tmp___7 = 1;
    } else {
#line 1053
      tmp___6 = ldv__builtin_expect((unsigned int )adapter->qnq_vid != 0U, 0L);
#line 1053
      if (tmp___6 != 0L) {
#line 1053
        tmp___7 = 1;
      } else {
#line 1053
        tmp___7 = 0;
      }
    }
#line 1053
    if (tmp___7 != 0) {
#line 1053
      tmp___8 = 1;
    } else {
#line 1053
      tmp___8 = 0;
    }
  } else {
#line 1053
    tmp___8 = 0;
  }
#line 1053
  if (tmp___8 != 0) {
#line 1053
    tmp___9 = qnq_async_evt_rcvd(adapter);
#line 1053
    tmp___10 = ldv__builtin_expect(tmp___9 == 0, 0L);
#line 1053
    if (tmp___10 != 0L) {
#line 1056
      goto tx_drop;
    } else {

    }
  } else {

  }
#line 1064
  tmp___12 = be_ipv6_tx_stall_chk(adapter, skb);
#line 1064
  if (tmp___12 != 0) {
#line 1064
    tmp___13 = be_vlan_tag_tx_chk(adapter, skb);
#line 1064
    if (tmp___13 != 0) {
#line 1066
      skb = be_insert_vlan_in_pkt(adapter, skb, skip_hw_vlan);
#line 1067
      tmp___11 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                                  0L);
#line 1067
      if (tmp___11 != 0L) {
#line 1068
        goto err;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1071
  return (skb);
  tx_drop: 
#line 1073
  dev_kfree_skb_any(skb);
  err: ;
#line 1075
  return ((struct sk_buff *)0);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct sk_buff *be_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                           bool *skip_hw_vlan ) 
{ 
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
#line 1086
  tmp___0 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 545U, 0L);
#line 1086
  if (tmp___0 != 0L) {
#line 1086
    tmp___1 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 1808U, 0L);
#line 1086
    if (tmp___1 != 0L) {
#line 1086
      tmp___2 = 1;
    } else {
#line 1086
      tmp___2 = 0;
    }
  } else {
#line 1086
    tmp___2 = 0;
  }
#line 1086
  if (tmp___2 != 0) {
#line 1086
    tmp___3 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 529U, 0L);
#line 1086
    if (tmp___3 != 0L) {
#line 1086
      tmp___4 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 1792U,
                                 0L);
#line 1086
      if (tmp___4 != 0L) {
#line 1086
        tmp___5 = 1;
      } else {
#line 1086
        tmp___5 = 0;
      }
    } else {
#line 1086
      tmp___5 = 0;
    }
#line 1086
    if (tmp___5 != 0) {
#line 1086
      tmp___6 = 1;
    } else {
#line 1086
      tmp___6 = 0;
    }
  } else {
#line 1086
    tmp___6 = 0;
  }
#line 1086
  if (tmp___6 != 0) {
#line 1086
    tmp___7 = ldv__builtin_expect(skb->len <= 32U, 0L);
#line 1086
    if (tmp___7 != 0L) {
#line 1087
      tmp = skb_padto(skb, 36U);
#line 1087
      if (tmp != 0) {
#line 1088
        return ((struct sk_buff *)0);
      } else {

      }
#line 1089
      skb->len = 36U;
    } else {

    }
  } else {

  }
#line 1092
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 1093
    skb = be_lancer_xmit_workarounds(adapter, skb, skip_hw_vlan);
#line 1094
    if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1095
      return ((struct sk_buff *)0);
    } else {

    }
  } else {

  }
#line 1098
  return (skb);
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static netdev_tx_t be_xmit(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_tx_obj *txo ;
  u16 tmp___0 ;
  struct be_queue_info *txq ;
  bool dummy_wrb ;
  bool stopped ;
  u32 wrb_cnt ;
  u32 copied ;
  bool skip_hw_vlan ;
  u32 start ;
  int tmp___1 ;
  int gso_segs ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 tmp___4 ;
  int tmp___5 ;

  {
#line 1103
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1103
  adapter = (struct be_adapter *)tmp;
#line 1104
  tmp___0 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 1104
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )tmp___0;
#line 1105
  txq = & txo->q;
#line 1106
  stopped = 0;
#line 1107
  wrb_cnt = 0U;
#line 1107
  copied = 0U;
#line 1108
  skip_hw_vlan = 0;
#line 1109
  start = (u32 )txq->head;
#line 1111
  skb = be_xmit_workarounds(adapter, skb, & skip_hw_vlan);
#line 1112
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1113
    txo->stats.tx_drv_drops = txo->stats.tx_drv_drops + 1U;
#line 1114
    return (0);
  } else {

  }
#line 1117
  wrb_cnt = wrb_cnt_for_skb(adapter, skb, & dummy_wrb);
#line 1119
  tmp___1 = make_tx_wrbs(adapter, txq, skb, wrb_cnt, (int )dummy_wrb, (int )skip_hw_vlan);
#line 1119
  copied = (u32 )tmp___1;
#line 1121
  if (copied != 0U) {
#line 1122
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1122
    gso_segs = (int )((struct skb_shared_info *)tmp___2)->gso_segs;
#line 1125
    tmp___3 = ldv__builtin_expect((unsigned long )txo->sent_skb_list[start] != (unsigned long )((struct sk_buff *)0),
                               0L);
#line 1125
    if (tmp___3 != 0L) {
#line 1125
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                           "i" (1125), "i" (12UL));
      ldv_55535: ;
#line 1125
      goto ldv_55535;
    } else {

    }
#line 1126
    txo->sent_skb_list[start] = skb;
#line 1132
    atomic_add((int )wrb_cnt, & txq->used);
#line 1133
    tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
#line 1133
    if (tmp___5 + 30 >= (int )txq->len) {
#line 1135
      tmp___4 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 1135
      netif_stop_subqueue(netdev, (int )tmp___4);
#line 1136
      stopped = 1;
    } else {

    }
#line 1139
    be_txq_notify(adapter, txo, (int )((u16 )wrb_cnt));
#line 1141
    be_tx_stats_update(txo, wrb_cnt, copied, (u32 )gso_segs, (int )stopped);
  } else {
#line 1143
    txq->head = (u16 )start;
#line 1144
    txo->stats.tx_drv_drops = txo->stats.tx_drv_drops + 1U;
#line 1145
    dev_kfree_skb_any(skb);
  }
#line 1147
  return (0);
}
}
#line 1150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 1152
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1152
  adapter = (struct be_adapter *)tmp;
#line 1153
  if (new_mtu <= 255 || new_mtu > 9000) {
#line 1155
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU must be between %d and %d bytes\n",
              256, 9000);
#line 1159
    return (-22);
  } else {

  }
#line 1161
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU changed from %d to %d bytes\n",
            netdev->mtu, new_mtu);
#line 1163
  netdev->mtu = (unsigned int )new_mtu;
#line 1164
  return (0);
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vid_config(struct be_adapter *adapter ) 
{ 
  u16 vids[64U] ;
  u16 num ;
  u16 i ;
  int status ;
  unsigned long tmp ;
  u16 tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1174
  num = 0U;
#line 1174
  i = 0U;
#line 1175
  status = 0;
#line 1178
  if ((int )adapter->promiscuous) {
#line 1179
    return (0);
  } else {

  }
#line 1181
  if ((int )adapter->vlans_added > (int )adapter->res.max_vlans) {
#line 1182
    goto set_vlan_promisc;
  } else {

  }
#line 1185
  tmp = find_first_bit((unsigned long const   *)(& adapter->vids), 4096UL);
#line 1185
  i = (u16 )tmp;
#line 1185
  goto ldv_55550;
  ldv_55549: 
#line 1186
  tmp___0 = num;
#line 1186
  num = (u16 )((int )num + 1);
#line 1186
  vids[(int )tmp___0] = i;
#line 1185
  tmp___1 = find_next_bit((unsigned long const   *)(& adapter->vids), 4096UL, (unsigned long )((int )i + 1));
#line 1185
  i = (u16 )tmp___1;
  ldv_55550: ;
#line 1185
  if ((unsigned int )i <= 4095U) {
#line 1187
    goto ldv_55549;
  } else {

  }
#line 1188
  status = be_cmd_vlan_config(adapter, (u32 )adapter->if_handle, (u16 *)(& vids),
                              (u32 )num);
#line 1189
  if (status != 0) {
#line 1191
    if (status > 0 && ((unsigned int )(status >> 16) & 255U) == 22U) {
#line 1193
      goto set_vlan_promisc;
    } else {

    }
#line 1194
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Setting HW VLAN filtering failed.\n");
  } else
#line 1197
  if ((adapter->flags & 16U) != 0U) {
#line 1199
    status = be_cmd_rx_filter(adapter, 16U, 0U);
#line 1201
    if (status == 0) {
#line 1202
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabling VLAN Promiscuous mode.\n");
#line 1204
      adapter->flags = adapter->flags & 4294967279U;
    } else {

    }
  } else {

  }
#line 1209
  return (status);
  set_vlan_promisc: ;
#line 1212
  if ((adapter->flags & 16U) != 0U) {
#line 1213
    return (0);
  } else {

  }
#line 1215
  status = be_cmd_rx_filter(adapter, 16U, 1U);
#line 1216
  if (status == 0) {
#line 1217
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Enable VLAN Promiscuous mode\n");
#line 1218
    adapter->flags = adapter->flags | 16U;
  } else {
#line 1220
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to enable VLAN Promiscuous mode.\n");
  }
#line 1222
  return (status);
}
}
#line 1225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vlan_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  int tmp___0 ;

  {
#line 1227
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1227
  adapter = (struct be_adapter *)tmp;
#line 1228
  status = 0;
#line 1231
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1232
    return (status);
  } else {

  }
#line 1234
  tmp___0 = variable_test_bit((long )vid, (unsigned long const volatile   *)(& adapter->vids));
#line 1234
  if (tmp___0 != 0) {
#line 1235
    return (status);
  } else {

  }
#line 1237
  set_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
#line 1238
  adapter->vlans_added = (u16 )((int )adapter->vlans_added + 1);
#line 1240
  status = be_vid_config(adapter);
#line 1241
  if (status != 0) {
#line 1242
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
#line 1243
    clear_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
  } else {

  }
#line 1246
  return (status);
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vlan_rem_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1251
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1251
  adapter = (struct be_adapter *)tmp;
#line 1252
  status = 0;
#line 1255
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1256
    goto ret;
  } else {

  }
#line 1258
  clear_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
#line 1259
  status = be_vid_config(adapter);
#line 1260
  if (status == 0) {
#line 1261
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
  } else {
#line 1263
    set_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
  }
  ret: ;
#line 1265
  return (status);
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_clear_promisc(struct be_adapter *adapter ) 
{ 


  {
#line 1270
  adapter->promiscuous = 0;
#line 1271
  adapter->flags = adapter->flags & 4294967247U;
#line 1273
  be_cmd_rx_filter(adapter, 256U, 0U);
#line 1274
  return;
}
}
#line 1276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_set_rx_mode(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  struct netdev_hw_addr *ha ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1278
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1278
  adapter = (struct be_adapter *)tmp;
#line 1281
  if ((netdev->flags & 256U) != 0U) {
#line 1282
    be_cmd_rx_filter(adapter, 256U, 1U);
#line 1283
    adapter->promiscuous = 1;
#line 1284
    goto done;
  } else {

  }
#line 1288
  if ((int )adapter->promiscuous) {
#line 1289
    be_clear_promisc(adapter);
#line 1290
    if ((unsigned int )adapter->vlans_added != 0U) {
#line 1291
      be_vid_config(adapter);
    } else {

    }
  } else {

  }
#line 1295
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )adapter->res.max_mcast_mac) {
#line 1297
    goto set_mcast_promisc;
  } else {

  }
#line 1299
  if ((u32 )netdev->uc.count != adapter->uc_macs) {
#line 1301
    i = 1;
#line 1303
    goto ldv_55580;
    ldv_55579: 
#line 1304
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                    0U);
#line 1303
    adapter->uc_macs = adapter->uc_macs - 1U;
#line 1303
    i = i + 1;
    ldv_55580: ;
#line 1303
    if (adapter->uc_macs != 0U) {
#line 1305
      goto ldv_55579;
    } else {

    }

#line 1308
    if (netdev->uc.count > (int )adapter->res.max_uc_mac) {
#line 1309
      be_cmd_rx_filter(adapter, 256U, 1U);
#line 1310
      adapter->promiscuous = 1;
#line 1311
      goto done;
    } else {

    }
#line 1314
    __mptr = (struct list_head  const  *)(adapter->netdev)->uc.list.next;
#line 1314
    ha = (struct netdev_hw_addr *)__mptr;
#line 1314
    goto ldv_55587;
    ldv_55586: 
#line 1315
    adapter->uc_macs = adapter->uc_macs + 1U;
#line 1316
    be_cmd_pmac_add(adapter, (u8 *)(& ha->addr), (u32 )adapter->if_handle, adapter->pmac_id + (unsigned long )adapter->uc_macs,
                    0U);
#line 1314
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1314
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_55587: ;
#line 1314
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->uc.list)) {
#line 1316
      goto ldv_55586;
    } else {

    }

  } else {

  }
#line 1322
  status = be_cmd_rx_filter(adapter, 4096U, 1U);
#line 1323
  if (status == 0) {
#line 1324
    if ((adapter->flags & 32U) != 0U) {
#line 1325
      adapter->flags = adapter->flags & 4294967263U;
    } else {

    }
#line 1326
    goto done;
  } else {

  }
  set_mcast_promisc: ;
#line 1330
  if ((adapter->flags & 32U) != 0U) {
#line 1331
    return;
  } else {

  }
#line 1336
  status = be_cmd_rx_filter(adapter, 512U, 1U);
#line 1337
  if (status == 0) {
#line 1338
    adapter->flags = adapter->flags | 32U;
  } else {

  }
  done: ;
#line 1340
  return;
}
}
#line 1343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 1345
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1345
  adapter = (struct be_adapter *)tmp;
#line 1346
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1349
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1350
    return (-1);
  } else {

  }
#line 1352
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
#line 1352
  if (tmp___0) {
#line 1352
    tmp___1 = 0;
  } else {
#line 1352
    tmp___1 = 1;
  }
#line 1352
  if (tmp___1 || (int )adapter->num_vfs <= vf) {
#line 1353
    return (-22);
  } else {

  }
#line 1355
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1356
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, (u32 )(vf + 1));
#line 1359
    status = be_cmd_pmac_add(adapter, mac, (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             (u32 )(vf + 1));
  } else {
#line 1362
    status = be_cmd_set_mac(adapter, mac, vf_cfg->if_handle, (u32 )(vf + 1));
  }
#line 1366
  if (status != 0) {
#line 1367
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "MAC %pM set on VF %d Failed\n",
            mac, vf);
  } else {
#line 1370
    __len = 6UL;
#line 1370
    if (__len > 63UL) {
#line 1370
      __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)mac, __len);
    } else {
#line 1370
      __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)mac,
                               __len);
    }
  }
#line 1372
  return (status);
}
}
#line 1375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *vi ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  size_t __len ;
  void *__ret ;

  {
#line 1378
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1378
  adapter = (struct be_adapter *)tmp;
#line 1379
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1381
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1382
    return (-1);
  } else {

  }
#line 1384
  if ((int )adapter->num_vfs <= vf) {
#line 1385
    return (-22);
  } else {

  }
#line 1387
  vi->vf = (__u32 )vf;
#line 1388
  vi->max_tx_rate = vf_cfg->tx_rate;
#line 1389
  vi->min_tx_rate = 0U;
#line 1390
  vi->vlan = (__u32 )vf_cfg->vlan_tag & 4095U;
#line 1391
  vi->qos = (__u32 )((int )vf_cfg->vlan_tag >> 13);
#line 1392
  __len = 6UL;
#line 1392
  if (__len > 63UL) {
#line 1392
    __ret = __memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr), __len);
  } else {
#line 1392
    __ret = __builtin_memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr),
                             __len);
  }
#line 1393
  vi->linkstate = (adapter->vf_cfg + (unsigned long )vf)->plink_tracking;
#line 1395
  return (0);
}
}
#line 1398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;

  {
#line 1400
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1400
  adapter = (struct be_adapter *)tmp;
#line 1401
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1402
  status = 0;
#line 1404
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1405
    return (-1);
  } else {

  }
#line 1407
  if (((int )adapter->num_vfs <= vf || (unsigned int )vlan > 4095U) || (unsigned int )qos > 7U) {
#line 1408
    return (-22);
  } else {

  }
#line 1410
  if ((unsigned int )vlan != 0U || (unsigned int )qos != 0U) {
#line 1411
    vlan = (u16 )((int )((short )((int )qos << 13)) | (int )((short )vlan));
#line 1412
    if ((int )vf_cfg->vlan_tag != (int )vlan) {
#line 1413
      status = be_cmd_set_hsw_config(adapter, (int )vlan, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                     0);
    } else {

    }
  } else {
#line 1417
    status = be_cmd_set_hsw_config(adapter, 65535, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                   0);
  }
#line 1421
  if (status == 0) {
#line 1422
    vf_cfg->vlan_tag = vlan;
  } else {
#line 1424
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "VLAN %d config on VF %d failed\n",
              (int )vlan, vf);
  }
#line 1426
  return (status);
}
}
#line 1429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_set_vf_tx_rate(struct net_device *netdev , int vf , int min_tx_rate ,
                             int max_tx_rate ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int percent_rate ;
  int status ;
  u16 link_speed ;
  u8 link_status ;

  {
#line 1432
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1432
  adapter = (struct be_adapter *)tmp;
#line 1433
  dev = & (adapter->pdev)->dev;
#line 1434
  status = 0;
#line 1435
  link_speed = 0U;
#line 1438
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1439
    return (-1);
  } else {

  }
#line 1441
  if ((int )adapter->num_vfs <= vf) {
#line 1442
    return (-22);
  } else {

  }
#line 1444
  if (min_tx_rate != 0) {
#line 1445
    return (-22);
  } else {

  }
#line 1447
  if (max_tx_rate == 0) {
#line 1448
    goto config_qos;
  } else {

  }
#line 1450
  status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
#line 1452
  if (status != 0) {
#line 1453
    goto err;
  } else {

  }
#line 1455
  if ((unsigned int )link_status == 0U) {
#line 1456
    dev_err((struct device  const  *)dev, "TX-rate setting not allowed when link is down\n");
#line 1457
    status = -1;
#line 1458
    goto err;
  } else {

  }
#line 1461
  if (max_tx_rate <= 99 || (int )link_speed < max_tx_rate) {
#line 1462
    dev_err((struct device  const  *)dev, "TX-rate must be between 100 and %d Mbps\n",
            (int )link_speed);
#line 1464
    status = -22;
#line 1465
    goto err;
  } else {

  }
#line 1469
  percent_rate = (int )((unsigned int )link_speed / 100U);
#line 1470
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && max_tx_rate % percent_rate != 0) {
#line 1471
    dev_err((struct device  const  *)dev, "TX-rate must be a multiple of %d Mbps\n",
            percent_rate);
#line 1473
    status = -22;
#line 1474
    goto err;
  } else {

  }
  config_qos: 
#line 1478
  status = be_cmd_config_qos(adapter, (u32 )max_tx_rate, (int )link_speed, (int )((unsigned int )((u8 )vf) + 1U));
#line 1479
  if (status != 0) {
#line 1480
    goto err;
  } else {

  }
#line 1482
  (adapter->vf_cfg + (unsigned long )vf)->tx_rate = (u32 )max_tx_rate;
#line 1483
  return (0);
  err: 
#line 1486
  dev_err((struct device  const  *)dev, "TX-rate setting of %dMbps on VF%d failed\n",
          max_tx_rate, vf);
#line 1488
  return (status);
}
}
#line 1490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_set_vf_link_state(struct net_device *netdev , int vf , int link_state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1493
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1493
  adapter = (struct be_adapter *)tmp;
#line 1496
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1497
    return (-1);
  } else {

  }
#line 1499
  if ((int )adapter->num_vfs <= vf) {
#line 1500
    return (-22);
  } else {

  }
#line 1502
  status = be_cmd_set_logical_link_config(adapter, link_state, (int )((unsigned int )((u8 )vf) + 1U));
#line 1503
  if (status == 0) {
#line 1504
    (adapter->vf_cfg + (unsigned long )vf)->plink_tracking = (u32 )link_state;
  } else {

  }
#line 1506
  return (status);
}
}
#line 1509 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_aic_update(struct be_aic_obj *aic , u64 rx_pkts , u64 tx_pkts , ulong now ) 
{ 


  {
#line 1512
  aic->rx_pkts_prev = rx_pkts;
#line 1513
  aic->tx_reqs_prev = tx_pkts;
#line 1514
  aic->jiffies = now;
#line 1515
  return;
}
}
#line 1517 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_eqd_update(struct be_adapter *adapter ) 
{ 
  struct be_set_eqd set_eqd[32U] ;
  int eqd ;
  int i ;
  int num ;
  int start ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 rx_pkts ;
  u64 tx_pkts ;
  ulong now ;
  u32 pps ;
  u32 delta ;
  unsigned int tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  bool tmp___2 ;
  u32 __min1 ;
  u32 __min2 ;
  u32 __max1 ;
  u32 __max2 ;

  {
#line 1520
  num = 0;
#line 1529
  i = 0;
#line 1529
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 1529
  goto ldv_55682;
  ldv_55681: 
#line 1530
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )eqo->idx;
#line 1531
  if (! aic->enable) {
#line 1532
    if (aic->jiffies != 0UL) {
#line 1533
      aic->jiffies = 0UL;
    } else {

    }
#line 1534
    eqd = (int )aic->et_eqd;
#line 1535
    goto modify_eqd;
  } else {

  }
#line 1538
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )eqo->idx;
  ldv_55664: 
#line 1540
  tmp = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& rxo->stats.sync));
#line 1540
  start = (int )tmp;
#line 1541
  rx_pkts = rxo->stats.rx_pkts;
#line 1542
  tmp___0 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& rxo->stats.sync),
                                      (unsigned int )start);
#line 1542
  if ((int )tmp___0) {
#line 1544
    goto ldv_55664;
  } else {

  }
#line 1544
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )eqo->idx;
  ldv_55666: 
#line 1546
  tmp___1 = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& txo->stats.sync));
#line 1546
  start = (int )tmp___1;
#line 1547
  tx_pkts = txo->stats.tx_reqs;
#line 1548
  tmp___2 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& txo->stats.sync),
                                      (unsigned int )start);
#line 1548
  if ((int )tmp___2) {
#line 1550
    goto ldv_55666;
  } else {

  }
#line 1552
  now = jiffies;
#line 1553
  if (((aic->jiffies == 0UL || (long )(now - aic->jiffies) < 0L) || aic->rx_pkts_prev > rx_pkts) || aic->tx_reqs_prev > tx_pkts) {
#line 1556
    be_aic_update(aic, rx_pkts, tx_pkts, now);
#line 1557
    goto ldv_55674;
  } else {

  }
#line 1560
  delta = jiffies_to_msecs(now - aic->jiffies);
#line 1561
  pps = (((unsigned int )rx_pkts - (unsigned int )aic->rx_pkts_prev) * 1000U) / delta + (((unsigned int )tx_pkts - (unsigned int )aic->tx_reqs_prev) * 1000U) / delta;
#line 1563
  eqd = (int )(pps / 15000U << 2);
#line 1565
  if (eqd <= 7) {
#line 1566
    eqd = 0;
  } else {

  }
#line 1567
  __min1 = (u32 )eqd;
#line 1567
  __min2 = aic->max_eqd;
#line 1567
  eqd = (int )(__min1 < __min2 ? __min1 : __min2);
#line 1568
  __max1 = (u32 )eqd;
#line 1568
  __max2 = aic->min_eqd;
#line 1568
  eqd = (int )(__max1 > __max2 ? __max1 : __max2);
#line 1570
  be_aic_update(aic, rx_pkts, tx_pkts, now);
  modify_eqd: ;
#line 1572
  if ((u32 )eqd != aic->prev_eqd) {
#line 1573
    set_eqd[num].delay_multiplier = (u32 )((eqd * 65) / 100);
#line 1574
    set_eqd[num].eq_id = (u32 )eqo->q.id;
#line 1575
    aic->prev_eqd = (u32 )eqd;
#line 1576
    num = num + 1;
  } else {

  }
  ldv_55674: 
#line 1529
  i = i + 1;
#line 1529
  eqo = eqo + 1;
  ldv_55682: ;
#line 1529
  if ((int )adapter->num_evt_qs > i) {
#line 1531
    goto ldv_55681;
  } else {

  }

#line 1580
  if (num != 0) {
#line 1581
    be_cmd_modify_eqd(adapter, (struct be_set_eqd *)(& set_eqd), num);
  } else {

  }
#line 1582
  return;
}
}
#line 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_stats_update(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_stats *stats ;

  {
#line 1587
  stats = & rxo->stats;
#line 1589
  u64_stats_update_begin(& stats->sync);
#line 1590
  stats->rx_compl = stats->rx_compl + 1U;
#line 1591
  stats->rx_bytes = stats->rx_bytes + (u64 )rxcp->pkt_size;
#line 1592
  stats->rx_pkts = stats->rx_pkts + 1ULL;
#line 1593
  if ((unsigned int )rxcp->pkt_type == 1U) {
#line 1594
    stats->rx_mcast_pkts = stats->rx_mcast_pkts + 1U;
  } else {

  }
#line 1595
  if ((unsigned int )rxcp->err != 0U) {
#line 1596
    stats->rx_compl_err = stats->rx_compl_err + 1U;
  } else {

  }
#line 1597
  u64_stats_update_begin(& stats->sync);
#line 1598
  return;
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static bool csum_passed(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 1605
  return ((bool )(((((unsigned int )rxcp->tcpf != 0U || (unsigned int )rxcp->udpf != 0U) && (unsigned int )rxcp->l4_csum != 0U) && ((unsigned int )rxcp->ip_csum != 0U || (unsigned int )rxcp->ipv6 != 0U)) && (unsigned int )rxcp->err == 0U));
}
}
#line 1609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct be_rx_page_info *get_rx_page_info(struct be_rx_obj *rxo ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *rx_page_info ;
  struct be_queue_info *rxq ;
  u16 frag_idx ;
  long tmp ;

  {
#line 1611
  adapter = rxo->adapter;
#line 1613
  rxq = & rxo->q;
#line 1614
  frag_idx = rxq->tail;
#line 1616
  rx_page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )frag_idx;
#line 1617
  tmp = ldv__builtin_expect((unsigned long )rx_page_info->page == (unsigned long )((struct page *)0),
                         0L);
#line 1617
  if (tmp != 0L) {
#line 1617
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (1617), "i" (12UL));
    ldv_55699: ;
#line 1617
    goto ldv_55699;
  } else {

  }
#line 1619
  if ((int )rx_page_info->last_frag) {
#line 1620
    dma_unmap_page(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )adapter->big_page_size,
                   2);
#line 1623
    rx_page_info->last_frag = 0;
  } else {
#line 1625
    dma_sync_single_for_cpu(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )rx_frag_size,
                            2);
  }
#line 1630
  queue_tail_inc(rxq);
#line 1631
  atomic_dec(& rxq->used);
#line 1632
  return (rx_page_info);
}
}
#line 1636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_compl_discard(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 num_rcvd ;

  {
#line 1640
  num_rcvd = (u16 )rxcp->num_rcvd;
#line 1642
  i = 0U;
#line 1642
  goto ldv_55708;
  ldv_55707: 
#line 1643
  page_info = get_rx_page_info(rxo);
#line 1644
  put_page(page_info->page);
#line 1645
  memset((void *)page_info, 0, 24UL);
#line 1642
  i = (u16 )((int )i + 1);
  ldv_55708: ;
#line 1642
  if ((int )i < (int )num_rcvd) {
#line 1644
    goto ldv_55707;
  } else {

  }

#line 1649
  return;
}
}
#line 1653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void skb_fill_rx_data(struct be_rx_obj *rxo , struct sk_buff *skb , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 j ;
  u16 hdr_len ;
  u16 curr_frag_len ;
  u16 remaining ;
  u8 *start ;
  void *tmp ;
  u16 _min1 ;
  ushort _min2 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 _min1___0 ;
  ushort _min2___0 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;

  {
#line 1661
  page_info = get_rx_page_info(rxo);
#line 1662
  tmp = lowmem_page_address((struct page  const  *)page_info->page);
#line 1662
  start = (u8 *)tmp + (unsigned long )page_info->page_offset;
#line 1663
  __builtin_prefetch((void const   *)start);
#line 1666
  _min1 = rxcp->pkt_size;
#line 1666
  _min2 = rx_frag_size;
#line 1666
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 1668
  skb->len = (unsigned int )curr_frag_len;
#line 1669
  if ((unsigned int )curr_frag_len <= 64U) {
#line 1670
    __len = (size_t )curr_frag_len;
#line 1670
    __ret = __builtin_memcpy((void *)skb->data, (void const   *)start, __len);
#line 1672
    put_page(page_info->page);
#line 1673
    skb->data_len = 0U;
#line 1674
    skb->tail = skb->tail + (sk_buff_data_t )curr_frag_len;
  } else {
#line 1676
    hdr_len = 14U;
#line 1677
    __len___0 = (size_t )hdr_len;
#line 1677
    __ret___0 = __builtin_memcpy((void *)skb->data, (void const   *)start, __len___0);
#line 1678
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1678
    ((struct skb_shared_info *)tmp___0)->nr_frags = 1U;
#line 1679
    skb_frag_set_page(skb, 0, page_info->page);
#line 1680
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1680
    ((struct skb_shared_info *)tmp___1)->frags[0].page_offset = (__u32 )((int )page_info->page_offset + (int )hdr_len);
#line 1682
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1682
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___2)->frags),
                      (unsigned int )((int )curr_frag_len - (int )hdr_len));
#line 1684
    skb->data_len = (unsigned int )((int )curr_frag_len - (int )hdr_len);
#line 1685
    skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1686
    skb->tail = skb->tail + (sk_buff_data_t )hdr_len;
  }
#line 1688
  page_info->page = (struct page *)0;
#line 1690
  if ((int )rxcp->pkt_size <= (int )rx_frag_size) {
#line 1691
    tmp___3 = ldv__builtin_expect((unsigned int )rxcp->num_rcvd != 1U, 0L);
#line 1691
    if (tmp___3 != 0L) {
#line 1691
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                           "i" (1691), "i" (12UL));
      ldv_55731: ;
#line 1691
      goto ldv_55731;
    } else {

    }
#line 1692
    return;
  } else {

  }
#line 1696
  remaining = (int )rxcp->pkt_size - (int )curr_frag_len;
#line 1697
  i = 1U;
#line 1697
  j = 0U;
#line 1697
  goto ldv_55736;
  ldv_55735: 
#line 1698
  page_info = get_rx_page_info(rxo);
#line 1699
  _min1___0 = remaining;
#line 1699
  _min2___0 = rx_frag_size;
#line 1699
  curr_frag_len = (u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0);
#line 1702
  if ((unsigned int )page_info->page_offset == 0U) {
#line 1704
    j = (u16 )((int )j + 1);
#line 1705
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1706
    tmp___4 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1706
    ((struct skb_shared_info *)tmp___4)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1708
    tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1708
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___5)->frags) + (unsigned long )j,
                      0U);
#line 1709
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1709
    ((struct skb_shared_info *)tmp___6)->nr_frags = (unsigned char )((int )((struct skb_shared_info *)tmp___6)->nr_frags + 1);
  } else {
#line 1711
    put_page(page_info->page);
  }
#line 1714
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1714
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___7)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1715
  skb->len = skb->len + (unsigned int )curr_frag_len;
#line 1716
  skb->data_len = skb->data_len + (unsigned int )curr_frag_len;
#line 1717
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1718
  remaining = (int )remaining - (int )curr_frag_len;
#line 1719
  page_info->page = (struct page *)0;
#line 1697
  i = (u16 )((int )i + 1);
  ldv_55736: ;
#line 1697
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 1699
    goto ldv_55735;
  } else {

  }
#line 1721
  tmp___8 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 1721
  if (tmp___8 != 0L) {
#line 1721
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (1721), "i" (12UL));
    ldv_55738: ;
#line 1721
    goto ldv_55738;
  } else {

  }
#line 1723
  return;
}
}
#line 1725 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_compl_process(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  struct sk_buff *skb ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
#line 1728
  adapter = rxo->adapter;
#line 1729
  netdev = adapter->netdev;
#line 1732
  skb = netdev_alloc_skb_ip_align(netdev, 128U);
#line 1733
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 1733
  if (tmp != 0L) {
#line 1734
    rxo->stats.rx_drops_no_skbs = rxo->stats.rx_drops_no_skbs + 1U;
#line 1735
    be_rx_compl_discard(rxo, rxcp);
#line 1736
    return;
  } else {

  }
#line 1739
  skb_fill_rx_data(rxo, skb, rxcp);
#line 1741
  tmp___0 = ldv__builtin_expect((netdev->features & 17179869184ULL) != 0ULL, 1L);
#line 1741
  if (tmp___0 != 0L) {
#line 1741
    tmp___1 = csum_passed(rxcp);
#line 1741
    tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 1741
    if (tmp___2 != 0L) {
#line 1742
      skb->ip_summed = 1U;
    } else {
#line 1744
      skb_checksum_none_assert((struct sk_buff  const  *)skb);
    }
  } else {
#line 1744
    skb_checksum_none_assert((struct sk_buff  const  *)skb);
  }
#line 1746
  skb->protocol = eth_type_trans(skb, netdev);
#line 1747
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 1748
  if ((netdev->features & 8589934592ULL) != 0ULL) {
#line 1749
    skb_set_hash(skb, rxcp->rss_hash, 2);
  } else {

  }
#line 1751
  skb->encapsulation = rxcp->tunneled;
#line 1752
  skb_mark_napi_id(skb, napi);
#line 1754
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1755
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 1757
  netif_receive_skb(skb);
#line 1758
  return;
}
}
#line 1761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_compl_process_gro(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                    struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct sk_buff *skb ;
  u16 remaining ;
  u16 curr_frag_len ;
  u16 i ;
  u16 j ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 1765
  adapter = rxo->adapter;
#line 1767
  skb = (struct sk_buff *)0;
#line 1771
  skb = napi_get_frags(napi);
#line 1772
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1773
    be_rx_compl_discard(rxo, rxcp);
#line 1774
    return;
  } else {

  }
#line 1777
  remaining = rxcp->pkt_size;
#line 1778
  i = 0U;
#line 1778
  j = 65535U;
#line 1778
  goto ldv_55763;
  ldv_55762: 
#line 1779
  page_info = get_rx_page_info(rxo);
#line 1781
  _min1 = remaining;
#line 1781
  _min2 = rx_frag_size;
#line 1781
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 1784
  if ((unsigned int )i == 0U || (unsigned int )page_info->page_offset == 0U) {
#line 1786
    j = (u16 )((int )j + 1);
#line 1787
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1788
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1788
    ((struct skb_shared_info *)tmp)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1790
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1790
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___0)->frags) + (unsigned long )j,
                      0U);
  } else {
#line 1792
    put_page(page_info->page);
  }
#line 1794
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1794
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___1)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1795
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1796
  remaining = (int )remaining - (int )curr_frag_len;
#line 1797
  memset((void *)page_info, 0, 24UL);
#line 1778
  i = (u16 )((int )i + 1);
  ldv_55763: ;
#line 1778
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 1780
    goto ldv_55762;
  } else {

  }
#line 1799
  tmp___2 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 1799
  if (tmp___2 != 0L) {
#line 1799
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (1799), "i" (12UL));
    ldv_55765: ;
#line 1799
    goto ldv_55765;
  } else {

  }
#line 1801
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1801
  ((struct skb_shared_info *)tmp___3)->nr_frags = (unsigned int )((unsigned char )j) + 1U;
#line 1802
  skb->len = (unsigned int )rxcp->pkt_size;
#line 1803
  skb->data_len = (unsigned int )rxcp->pkt_size;
#line 1804
  skb->ip_summed = 1U;
#line 1805
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 1806
  if (((adapter->netdev)->features & 8589934592ULL) != 0ULL) {
#line 1807
    skb_set_hash(skb, rxcp->rss_hash, 2);
  } else {

  }
#line 1809
  skb->encapsulation = rxcp->tunneled;
#line 1810
  skb_mark_napi_id(skb, napi);
#line 1812
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1813
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 1815
  napi_gro_frags(napi);
#line 1816
  return;
}
}
#line 1818 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_parse_rx_compl_v1(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 1821
  tmp = amap_mask(14U);
#line 1821
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1821
  rxcp->pkt_size = (u16 )tmp___0;
#line 1823
  tmp___1 = amap_mask(1U);
#line 1823
  tmp___2 = amap_get((void *)compl, 0U, tmp___1, 30U);
#line 1823
  rxcp->vlanf = (u8 )tmp___2;
#line 1824
  tmp___3 = amap_mask(1U);
#line 1824
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1824
  rxcp->err = (u8 )tmp___4;
#line 1825
  tmp___5 = amap_mask(1U);
#line 1825
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1825
  rxcp->tcpf = (u8 )tmp___6;
#line 1826
  tmp___7 = amap_mask(1U);
#line 1826
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1826
  rxcp->udpf = (u8 )tmp___8;
#line 1827
  tmp___9 = amap_mask(1U);
#line 1827
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1827
  rxcp->ip_csum = (u8 )tmp___10;
#line 1829
  tmp___11 = amap_mask(1U);
#line 1829
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1829
  rxcp->l4_csum = (u8 )tmp___12;
#line 1831
  tmp___13 = amap_mask(1U);
#line 1831
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1831
  rxcp->ipv6 = (u8 )tmp___14;
#line 1833
  tmp___15 = amap_mask(3U);
#line 1833
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 1833
  rxcp->num_rcvd = (u8 )tmp___16;
#line 1835
  tmp___17 = amap_mask(2U);
#line 1835
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 1835
  rxcp->pkt_type = (u8 )tmp___18;
#line 1837
  tmp___19 = amap_mask(32U);
#line 1837
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
#line 1839
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1840
    tmp___20 = amap_mask(1U);
#line 1840
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 1840
    rxcp->qnq = (u8 )tmp___21;
#line 1842
    tmp___22 = amap_mask(16U);
#line 1842
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 1842
    rxcp->vlan_tag = (u16 )tmp___23;
  } else {

  }
#line 1845
  tmp___24 = amap_mask(2U);
#line 1845
  tmp___25 = amap_get((void *)compl, 2U, tmp___24, 5U);
#line 1845
  rxcp->port = (u16 )tmp___25;
#line 1846
  tmp___26 = amap_mask(1U);
#line 1846
  tmp___27 = amap_get((void *)compl, 2U, tmp___26, 30U);
#line 1846
  rxcp->tunneled = (u8 )tmp___27;
#line 1848
  return;
}
}
#line 1850 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_parse_rx_compl_v0(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 1853
  tmp = amap_mask(14U);
#line 1853
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1853
  rxcp->pkt_size = (u16 )tmp___0;
#line 1855
  tmp___1 = amap_mask(1U);
#line 1855
  tmp___2 = amap_get((void *)compl, 1U, tmp___1, 14U);
#line 1855
  rxcp->vlanf = (u8 )tmp___2;
#line 1856
  tmp___3 = amap_mask(1U);
#line 1856
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1856
  rxcp->err = (u8 )tmp___4;
#line 1857
  tmp___5 = amap_mask(1U);
#line 1857
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1857
  rxcp->tcpf = (u8 )tmp___6;
#line 1858
  tmp___7 = amap_mask(1U);
#line 1858
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1858
  rxcp->udpf = (u8 )tmp___8;
#line 1859
  tmp___9 = amap_mask(1U);
#line 1859
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1859
  rxcp->ip_csum = (u8 )tmp___10;
#line 1861
  tmp___11 = amap_mask(1U);
#line 1861
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1861
  rxcp->l4_csum = (u8 )tmp___12;
#line 1863
  tmp___13 = amap_mask(1U);
#line 1863
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1863
  rxcp->ipv6 = (u8 )tmp___14;
#line 1865
  tmp___15 = amap_mask(3U);
#line 1865
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 1865
  rxcp->num_rcvd = (u8 )tmp___16;
#line 1867
  tmp___17 = amap_mask(2U);
#line 1867
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 1867
  rxcp->pkt_type = (u8 )tmp___18;
#line 1869
  tmp___19 = amap_mask(32U);
#line 1869
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
#line 1871
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1872
    tmp___20 = amap_mask(1U);
#line 1872
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 1872
    rxcp->qnq = (u8 )tmp___21;
#line 1874
    tmp___22 = amap_mask(16U);
#line 1874
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 1874
    rxcp->vlan_tag = (u16 )tmp___23;
  } else {

  }
#line 1877
  tmp___24 = amap_mask(1U);
#line 1877
  tmp___25 = amap_get((void *)compl, 0U, tmp___24, 30U);
#line 1877
  rxcp->port = (u16 )tmp___25;
#line 1878
  tmp___26 = amap_mask(1U);
#line 1878
  tmp___27 = amap_get((void *)compl, 1U, tmp___26, 15U);
#line 1878
  rxcp->ip_frag = (u8 )tmp___27;
#line 1879
  return;
}
}
#line 1882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct be_rx_compl_info *be_rx_compl_get(struct be_rx_obj *rxo ) 
{ 
  struct be_eth_rx_compl *compl ;
  void *tmp ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  __u16 tmp___0 ;
  int tmp___1 ;

  {
#line 1884
  tmp = queue_tail_node(& rxo->cq);
#line 1884
  compl = (struct be_eth_rx_compl *)tmp;
#line 1885
  rxcp = & rxo->rxcp;
#line 1886
  adapter = rxo->adapter;
#line 1890
  if (compl->dw[2UL] == 0U) {
#line 1891
    return ((struct be_rx_compl_info *)0);
  } else {

  }
#line 1893
  __asm__  volatile   ("lfence": : : "memory");
#line 1894
  swap_dws((void *)compl, 16);
#line 1896
  if ((int )adapter->be3_native) {
#line 1897
    be_parse_rx_compl_v1(compl, rxcp);
  } else {
#line 1899
    be_parse_rx_compl_v0(compl, rxcp);
  }
#line 1901
  if ((unsigned int )rxcp->ip_frag != 0U) {
#line 1902
    rxcp->l4_csum = 0U;
  } else {

  }
#line 1904
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1909
    if ((((unsigned int )adapter->mc_type == 3U || (unsigned int )adapter->mc_type == 4U) || (unsigned int )adapter->mc_type == 6U) && (unsigned int )rxcp->qnq == 0U) {
#line 1910
      rxcp->vlanf = 0U;
    } else {

    }
#line 1912
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 1913
      tmp___0 = __fswab16((int )rxcp->vlan_tag);
#line 1913
      rxcp->vlan_tag = tmp___0;
    } else {

    }
#line 1915
    if ((int )adapter->pvid == ((int )rxcp->vlan_tag & 4095)) {
#line 1915
      tmp___1 = variable_test_bit((long )rxcp->vlan_tag, (unsigned long const volatile   *)(& adapter->vids));
#line 1915
      if (tmp___1 == 0) {
#line 1917
        rxcp->vlanf = 0U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1921
  compl->dw[2UL] = 0U;
#line 1923
  queue_tail_inc(& rxo->cq);
#line 1924
  return (rxcp);
}
}
#line 1927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static struct page *be_alloc_pages(u32 size , gfp_t gfp ) 
{ 
  u32 order ;
  int tmp ;
  struct page *tmp___0 ;

  {
#line 1929
  tmp = __get_order((unsigned long )size);
#line 1929
  order = (u32 )tmp;
#line 1931
  if (order != 0U) {
#line 1932
    gfp = gfp | 16384U;
  } else {

  }
#line 1933
  tmp___0 = alloc_pages(gfp, order);
#line 1933
  return (tmp___0);
}
}
#line 1940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_post_rx_frags(struct be_rx_obj *rxo , gfp_t gfp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct be_rx_page_info *prev_page_info ;
  struct be_queue_info *rxq ;
  struct page *pagep ;
  struct device *dev ;
  struct be_eth_rx_d *rxd ;
  u64 page_dmaaddr ;
  u64 frag_dmaaddr ;
  u32 posted ;
  u32 page_offset ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1942
  adapter = rxo->adapter;
#line 1943
  page_info = (struct be_rx_page_info *)0;
#line 1943
  prev_page_info = (struct be_rx_page_info *)0;
#line 1944
  rxq = & rxo->q;
#line 1945
  pagep = (struct page *)0;
#line 1946
  dev = & (adapter->pdev)->dev;
#line 1948
  page_dmaaddr = 0ULL;
#line 1949
  page_offset = 0U;
#line 1951
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1952
  posted = 0U;
#line 1952
  goto ldv_55802;
  ldv_55801: ;
#line 1953
  if ((unsigned long )pagep == (unsigned long )((struct page *)0)) {
#line 1954
    pagep = be_alloc_pages(adapter->big_page_size, gfp);
#line 1955
    tmp = ldv__builtin_expect((unsigned long )pagep == (unsigned long )((struct page *)0),
                           0L);
#line 1955
    if (tmp != 0L) {
#line 1956
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
#line 1957
      goto ldv_55800;
    } else {

    }
#line 1959
    page_dmaaddr = dma_map_page(dev, pagep, 0UL, (size_t )adapter->big_page_size,
                                2);
#line 1962
    tmp___0 = dma_mapping_error(dev, page_dmaaddr);
#line 1962
    if (tmp___0 != 0) {
#line 1963
      put_page(pagep);
#line 1964
      pagep = (struct page *)0;
#line 1965
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
#line 1966
      goto ldv_55800;
    } else {

    }
#line 1968
    page_offset = 0U;
  } else {
#line 1970
    get_page(pagep);
#line 1971
    page_offset = (u32 )rx_frag_size + page_offset;
  }
#line 1973
  page_info->page_offset = (u16 )page_offset;
#line 1974
  page_info->page = pagep;
#line 1976
  tmp___1 = queue_head_node(rxq);
#line 1976
  rxd = (struct be_eth_rx_d *)tmp___1;
#line 1977
  frag_dmaaddr = (u64 )page_info->page_offset + page_dmaaddr;
#line 1978
  rxd->fragpa_lo = (unsigned int )frag_dmaaddr;
#line 1979
  rxd->fragpa_hi = (unsigned int )(frag_dmaaddr >> 32ULL);
#line 1982
  if (((u32 )rx_frag_size + page_offset) + (u32 )rx_frag_size > adapter->big_page_size) {
#line 1984
    pagep = (struct page *)0;
#line 1985
    page_info->last_frag = 1;
#line 1986
    page_info->bus = page_dmaaddr;
  } else {
#line 1988
    page_info->bus = frag_dmaaddr;
  }
#line 1991
  prev_page_info = page_info;
#line 1992
  queue_head_inc(rxq);
#line 1993
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1952
  posted = posted + 1U;
  ldv_55802: ;
#line 1952
  if (posted <= 63U && (unsigned long )page_info->page == (unsigned long )((struct page *)0)) {
#line 1954
    goto ldv_55801;
  } else {

  }
  ldv_55800: ;
#line 1999
  if ((unsigned long )pagep != (unsigned long )((struct page *)0)) {
#line 2000
    prev_page_info->last_frag = 1;
#line 2001
    prev_page_info->bus = page_dmaaddr;
  } else {

  }
#line 2004
  if (posted != 0U) {
#line 2005
    atomic_add((int )posted, & rxq->used);
#line 2006
    if ((int )rxo->rx_post_starved) {
#line 2007
      rxo->rx_post_starved = 0;
    } else {

    }
#line 2008
    be_rxq_notify(adapter, (int )rxq->id, (int )((u16 )posted));
  } else {
#line 2009
    tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2009
    if (tmp___2 == 0) {
#line 2011
      rxo->rx_post_starved = 1;
    } else {

    }
  }
#line 2012
  return;
}
}
#line 2015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct be_eth_tx_compl *be_tx_compl_get(struct be_queue_info *tx_cq ) 
{ 
  struct be_eth_tx_compl *txcp ;
  void *tmp ;

  {
#line 2017
  tmp = queue_tail_node(tx_cq);
#line 2017
  txcp = (struct be_eth_tx_compl *)tmp;
#line 2019
  if (txcp->dw[3UL] == 0U) {
#line 2020
    return ((struct be_eth_tx_compl *)0);
  } else {

  }
#line 2022
  __asm__  volatile   ("lfence": : : "memory");
#line 2023
  swap_dws((void *)txcp, 16);
#line 2025
  txcp->dw[3UL] = 0U;
#line 2027
  queue_tail_inc(tx_cq);
#line 2028
  return (txcp);
}
}
#line 2031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u16 be_tx_compl_process(struct be_adapter *adapter , struct be_tx_obj *txo ,
                               u16 last_index ) 
{ 
  struct be_queue_info *txq ;
  struct be_eth_wrb *wrb ;
  struct sk_buff **sent_skbs ;
  struct sk_buff *sent_skb ;
  u16 cur_index ;
  u16 num_wrbs ;
  bool unmap_skb_hdr ;
  long tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 2034
  txq = & txo->q;
#line 2036
  sent_skbs = (struct sk_buff **)(& txo->sent_skb_list);
#line 2038
  num_wrbs = 1U;
#line 2039
  unmap_skb_hdr = 1;
#line 2041
  sent_skb = *(sent_skbs + (unsigned long )txq->tail);
#line 2042
  tmp = ldv__builtin_expect((unsigned long )sent_skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 2042
  if (tmp != 0L) {
#line 2042
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (2042), "i" (12UL));
    ldv_55819: ;
#line 2042
    goto ldv_55819;
  } else {

  }
#line 2043
  *(sent_skbs + (unsigned long )txq->tail) = (struct sk_buff *)0;
#line 2046
  queue_tail_inc(txq);
  ldv_55820: 
#line 2049
  cur_index = txq->tail;
#line 2050
  tmp___0 = queue_tail_node(txq);
#line 2050
  wrb = (struct be_eth_wrb *)tmp___0;
#line 2051
  if ((int )unmap_skb_hdr) {
#line 2051
    tmp___1 = skb_headlen((struct sk_buff  const  *)sent_skb);
#line 2051
    if (tmp___1 != 0U) {
#line 2051
      tmp___2 = 1;
    } else {
#line 2051
      tmp___2 = 0;
    }
  } else {
#line 2051
    tmp___2 = 0;
  }
#line 2051
  unmap_tx_frag(& (adapter->pdev)->dev, wrb, (int )((bool )tmp___2));
#line 2053
  unmap_skb_hdr = 0;
#line 2055
  num_wrbs = (u16 )((int )num_wrbs + 1);
#line 2056
  queue_tail_inc(txq);
#line 2057
  if ((int )cur_index != (int )last_index) {
#line 2059
    goto ldv_55820;
  } else {

  }
#line 2059
  dev_kfree_skb_any(sent_skb);
#line 2060
  return (num_wrbs);
}
}
#line 2064 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int events_get(struct be_eq_obj *eqo ) 
{ 
  struct be_eq_entry *eqe ;
  int num ;
  void *tmp ;

  {
#line 2067
  num = 0;
  ldv_55828: 
#line 2070
  tmp = queue_tail_node(& eqo->q);
#line 2070
  eqe = (struct be_eq_entry *)tmp;
#line 2071
  if (eqe->evt == 0U) {
#line 2072
    goto ldv_55827;
  } else {

  }
#line 2074
  __asm__  volatile   ("lfence": : : "memory");
#line 2075
  eqe->evt = 0U;
#line 2076
  num = num + 1;
#line 2077
  queue_tail_inc(& eqo->q);
#line 2078
  goto ldv_55828;
  ldv_55827: ;
#line 2080
  return (num);
}
}
#line 2084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_eq_clean(struct be_eq_obj *eqo ) 
{ 
  int num ;
  int tmp ;

  {
#line 2086
  tmp = events_get(eqo);
#line 2086
  num = tmp;
#line 2088
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num));
#line 2089
  return;
}
}
#line 2091 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_cq_clean(struct be_rx_obj *rxo ) 
{ 
  struct be_rx_page_info *page_info ;
  struct be_queue_info *rxq ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  int flush_wait ;
  int tmp ;
  bool tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  u16 tmp___5 ;

  {
#line 2094
  rxq = & rxo->q;
#line 2095
  rx_cq = & rxo->cq;
#line 2097
  adapter = rxo->adapter;
#line 2098
  flush_wait = 0;
  ldv_55847: 
#line 2107
  rxcp = be_rx_compl_get(rxo);
#line 2108
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2109
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2110
      goto ldv_55842;
    } else {

    }
#line 2112
    tmp = flush_wait;
#line 2112
    flush_wait = flush_wait + 1;
#line 2112
    if (tmp > 10) {
#line 2113
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 2115
      goto ldv_55842;
    } else {
#line 2112
      tmp___0 = be_hw_error(adapter);
#line 2112
      if ((int )tmp___0) {
#line 2113
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 2115
        goto ldv_55842;
      } else {

      }
    }
#line 2117
    be_cq_notify(adapter, (int )rx_cq->id, 1, 0);
#line 2118
    if (1) {
#line 2118
      __const_udelay(4295000UL);
    } else {
#line 2118
      __ms = 1UL;
#line 2118
      goto ldv_55845;
      ldv_55844: 
#line 2118
      __const_udelay(4295000UL);
      ldv_55845: 
#line 2118
      tmp___1 = __ms;
#line 2118
      __ms = __ms - 1UL;
#line 2118
      if (tmp___1 != 0UL) {
#line 2120
        goto ldv_55844;
      } else {

      }

    }
  } else {
#line 2120
    be_rx_compl_discard(rxo, rxcp);
#line 2121
    be_cq_notify(adapter, (int )rx_cq->id, 0, 1);
#line 2122
    if ((unsigned int )rxcp->num_rcvd == 0U) {
#line 2123
      goto ldv_55842;
    } else {

    }
  }
#line 2125
  goto ldv_55847;
  ldv_55842: 
#line 2128
  be_cq_notify(adapter, (int )rx_cq->id, 0, 0);
#line 2131
  goto ldv_55849;
  ldv_55848: 
#line 2132
  page_info = get_rx_page_info(rxo);
#line 2133
  put_page(page_info->page);
#line 2134
  memset((void *)page_info, 0, 24UL);
  ldv_55849: 
#line 2131
  tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2131
  if (tmp___2 > 0) {
#line 2133
    goto ldv_55848;
  } else {

  }
#line 2136
  tmp___3 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2136
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 2136
  if (tmp___4 != 0L) {
#line 2136
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"),
                         "i" (2136), "i" (12UL));
    ldv_55851: ;
#line 2136
    goto ldv_55851;
  } else {

  }
#line 2137
  tmp___5 = 0U;
#line 2137
  rxq->head = tmp___5;
#line 2137
  rxq->tail = tmp___5;
#line 2138
  return;
}
}
#line 2140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_tx_compl_clean(struct be_adapter *adapter ) 
{ 
  struct be_tx_obj *txo ;
  struct be_queue_info *txq ;
  struct be_eth_tx_compl *txcp ;
  u16 end_idx ;
  u16 cmpl ;
  u16 timeo ;
  u16 num_wrbs ;
  struct sk_buff *sent_skb ;
  bool dummy_wrb ;
  int i ;
  int pending_txqs ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  unsigned long __ms ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  int tmp___8 ;

  {
#line 2145
  cmpl = 0U;
#line 2145
  timeo = 0U;
#line 2145
  num_wrbs = 0U;
  ldv_55877: 
#line 2152
  pending_txqs = (int )adapter->num_tx_qs;
#line 2154
  i = 0;
#line 2154
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2154
  goto ldv_55870;
  ldv_55869: 
#line 2155
  cmpl = 0U;
#line 2156
  num_wrbs = 0U;
#line 2157
  txq = & txo->q;
#line 2158
  goto ldv_55867;
  ldv_55866: 
#line 2159
  tmp = amap_mask(16U);
#line 2159
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 2159
  end_idx = (u16 )tmp___0;
#line 2162
  tmp___1 = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 2162
  num_wrbs = (int )tmp___1 + (int )num_wrbs;
#line 2164
  cmpl = (u16 )((int )cmpl + 1);
  ldv_55867: 
#line 2158
  txcp = be_tx_compl_get(& txo->cq);
#line 2158
  if ((unsigned long )txcp != (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 2160
    goto ldv_55866;
  } else {

  }

#line 2166
  if ((unsigned int )cmpl != 0U) {
#line 2167
    be_cq_notify(adapter, (int )txo->cq.id, 0, (int )cmpl);
#line 2168
    atomic_sub((int )num_wrbs, & txq->used);
#line 2169
    timeo = 0U;
  } else {

  }
#line 2171
  tmp___2 = atomic_read((atomic_t const   *)(& txq->used));
#line 2171
  if (tmp___2 == 0) {
#line 2172
    pending_txqs = pending_txqs - 1;
  } else {

  }
#line 2154
  i = i + 1;
#line 2154
  txo = txo + 1;
  ldv_55870: ;
#line 2154
  if ((int )adapter->num_tx_qs > i) {
#line 2156
    goto ldv_55869;
  } else {

  }

#line 2175
  if (pending_txqs == 0) {
#line 2176
    goto ldv_55872;
  } else {
#line 2175
    timeo = (u16 )((int )timeo + 1);
#line 2175
    if ((unsigned int )timeo > 10U) {
#line 2176
      goto ldv_55872;
    } else {
#line 2175
      tmp___3 = be_hw_error(adapter);
#line 2175
      if ((int )tmp___3) {
#line 2176
        goto ldv_55872;
      } else {

      }
    }
  }
#line 2178
  if (1) {
#line 2178
    __const_udelay(4295000UL);
  } else {
#line 2178
    __ms = 1UL;
#line 2178
    goto ldv_55875;
    ldv_55874: 
#line 2178
    __const_udelay(4295000UL);
    ldv_55875: 
#line 2178
    tmp___4 = __ms;
#line 2178
    __ms = __ms - 1UL;
#line 2178
    if (tmp___4 != 0UL) {
#line 2180
      goto ldv_55874;
    } else {

    }

  }
#line 2179
  goto ldv_55877;
  ldv_55872: 
#line 2181
  i = 0;
#line 2181
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2181
  goto ldv_55882;
  ldv_55881: 
#line 2182
  txq = & txo->q;
#line 2183
  tmp___6 = atomic_read((atomic_t const   *)(& txq->used));
#line 2183
  if (tmp___6 != 0) {
#line 2184
    tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
#line 2184
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%d pending tx-compls\n",
            tmp___5);
  } else {

  }
#line 2188
  goto ldv_55879;
  ldv_55878: 
#line 2189
  sent_skb = txo->sent_skb_list[(int )txq->tail];
#line 2190
  end_idx = txq->tail;
#line 2191
  tmp___7 = wrb_cnt_for_skb(adapter, sent_skb, & dummy_wrb);
#line 2191
  num_wrbs = (u16 )tmp___7;
#line 2193
  index_adv(& end_idx, (int )((unsigned int )num_wrbs + 65535U), (int )txq->len);
#line 2194
  num_wrbs = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 2195
  atomic_sub((int )num_wrbs, & txq->used);
  ldv_55879: 
#line 2188
  tmp___8 = atomic_read((atomic_t const   *)(& txq->used));
#line 2188
  if (tmp___8 != 0) {
#line 2190
    goto ldv_55878;
  } else {

  }
#line 2181
  i = i + 1;
#line 2181
  txo = txo + 1;
  ldv_55882: ;
#line 2181
  if ((int )adapter->num_tx_qs > i) {
#line 2183
    goto ldv_55881;
  } else {

  }

#line 2188
  return;
}
}
#line 2200 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_evt_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 2205
  i = 0;
#line 2205
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2205
  goto ldv_55890;
  ldv_55889: ;
#line 2206
  if ((int )eqo->q.created) {
#line 2207
    be_eq_clean(eqo);
#line 2208
    be_cmd_q_destroy(adapter, & eqo->q, 1);
#line 2209
    napi_hash_del(& eqo->napi);
#line 2210
    netif_napi_del(& eqo->napi);
  } else {

  }
#line 2212
  be_queue_free(adapter, & eqo->q);
#line 2205
  i = i + 1;
#line 2205
  eqo = eqo + 1;
  ldv_55890: ;
#line 2205
  if ((int )adapter->num_evt_qs > i) {
#line 2207
    goto ldv_55889;
  } else {

  }

#line 2212
  return;
}
}
#line 2216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_evt_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_eq_obj *eqo ;
  struct be_aic_obj *aic ;
  int i ;
  int rc ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 2223
  __min1 = (unsigned int )adapter->num_msix_vec != 0U ? adapter->num_msix_vec : 1U;
#line 2223
  __min2 = adapter->cfg_num_qs;
#line 2223
  adapter->num_evt_qs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 2226
  i = 0;
#line 2226
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2226
  goto ldv_55904;
  ldv_55903: 
#line 2227
  netif_napi_add(adapter->netdev, & eqo->napi, & be_poll, 64);
#line 2229
  napi_hash_add(& eqo->napi);
#line 2230
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )i;
#line 2231
  eqo->adapter = adapter;
#line 2232
  eqo->tx_budget = 256U;
#line 2233
  eqo->idx = (u8 )i;
#line 2234
  aic->max_eqd = 128U;
#line 2235
  aic->enable = 1;
#line 2237
  eq = & eqo->q;
#line 2238
  rc = be_queue_alloc(adapter, eq, 1024, 4);
#line 2240
  if (rc != 0) {
#line 2241
    return (rc);
  } else {

  }
#line 2243
  rc = be_cmd_eq_create(adapter, eqo);
#line 2244
  if (rc != 0) {
#line 2245
    return (rc);
  } else {

  }
#line 2226
  i = i + 1;
#line 2226
  eqo = eqo + 1;
  ldv_55904: ;
#line 2226
  if ((int )adapter->num_evt_qs > i) {
#line 2228
    goto ldv_55903;
  } else {

  }

#line 2247
  return (0);
}
}
#line 2250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_mcc_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;

  {
#line 2254
  q = & adapter->mcc_obj.q;
#line 2255
  if ((int )q->created) {
#line 2256
    be_cmd_q_destroy(adapter, q, 5);
  } else {

  }
#line 2257
  be_queue_free(adapter, q);
#line 2259
  q = & adapter->mcc_obj.cq;
#line 2260
  if ((int )q->created) {
#line 2261
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2262
  be_queue_free(adapter, q);
#line 2263
  return;
}
}
#line 2266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_mcc_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2270
  cq = & adapter->mcc_obj.cq;
#line 2271
  tmp = be_queue_alloc(adapter, cq, 256, 16);
#line 2271
  if (tmp != 0) {
#line 2273
    goto err;
  } else {

  }
#line 2276
  tmp___0 = be_cmd_cq_create(adapter, cq, & ((struct be_eq_obj *)(& adapter->eq_obj))->q,
                             1, 0);
#line 2276
  if (tmp___0 != 0) {
#line 2277
    goto mcc_cq_free;
  } else {

  }
#line 2279
  q = & adapter->mcc_obj.q;
#line 2280
  tmp___1 = be_queue_alloc(adapter, q, 128, 256);
#line 2280
  if (tmp___1 != 0) {
#line 2281
    goto mcc_cq_destroy;
  } else {

  }
#line 2283
  tmp___2 = be_cmd_mccq_create(adapter, q, cq);
#line 2283
  if (tmp___2 != 0) {
#line 2284
    goto mcc_q_free;
  } else {

  }
#line 2286
  return (0);
  mcc_q_free: 
#line 2289
  be_queue_free(adapter, q);
  mcc_cq_destroy: 
#line 2291
  be_cmd_q_destroy(adapter, cq, 2);
  mcc_cq_free: 
#line 2293
  be_queue_free(adapter, cq);
  err: ;
#line 2295
  return (-1);
}
}
#line 2298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_tx_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_tx_obj *txo ;
  u8 i ;

  {
#line 2304
  i = 0U;
#line 2304
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2304
  goto ldv_55926;
  ldv_55925: 
#line 2305
  q = & txo->q;
#line 2306
  if ((int )q->created) {
#line 2307
    be_cmd_q_destroy(adapter, q, 3);
  } else {

  }
#line 2308
  be_queue_free(adapter, q);
#line 2310
  q = & txo->cq;
#line 2311
  if ((int )q->created) {
#line 2312
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2313
  be_queue_free(adapter, q);
#line 2304
  i = (u8 )((int )i + 1);
#line 2304
  txo = txo + 1;
  ldv_55926: ;
#line 2304
  if ((int )((unsigned short )i) < (int )adapter->num_tx_qs) {
#line 2306
    goto ldv_55925;
  } else {

  }

#line 2311
  return;
}
}
#line 2317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_tx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *cq ;
  struct be_queue_info *eq ;
  struct be_tx_obj *txo ;
  int status ;
  int i ;
  u16 _min1 ;
  u16 _min2 ;

  {
#line 2323
  _min1 = adapter->num_evt_qs;
#line 2323
  _min2 = adapter->res.max_tx_qs;
#line 2323
  adapter->num_tx_qs = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 2325
  i = 0;
#line 2325
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2325
  goto ldv_55940;
  ldv_55939: 
#line 2326
  cq = & txo->cq;
#line 2327
  status = be_queue_alloc(adapter, cq, 1024, 16);
#line 2329
  if (status != 0) {
#line 2330
    return (status);
  } else {

  }
#line 2338
  eq = & adapter->eq_obj[i % (int )adapter->num_evt_qs].q;
#line 2339
  status = be_cmd_cq_create(adapter, cq, eq, 0, 3);
#line 2340
  if (status != 0) {
#line 2341
    return (status);
  } else {

  }
#line 2343
  status = be_queue_alloc(adapter, & txo->q, 2048, 16);
#line 2345
  if (status != 0) {
#line 2346
    return (status);
  } else {

  }
#line 2348
  status = be_cmd_txq_create(adapter, txo);
#line 2349
  if (status != 0) {
#line 2350
    return (status);
  } else {

  }
#line 2325
  i = i + 1;
#line 2325
  txo = txo + 1;
  ldv_55940: ;
#line 2325
  if ((int )adapter->num_tx_qs > i) {
#line 2327
    goto ldv_55939;
  } else {

  }
#line 2353
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d TX queue(s)\n",
            (int )adapter->num_tx_qs);
#line 2355
  return (0);
}
}
#line 2358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_cqs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2364
  i = 0;
#line 2364
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2364
  goto ldv_55949;
  ldv_55948: 
#line 2365
  q = & rxo->cq;
#line 2366
  if ((int )q->created) {
#line 2367
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2368
  be_queue_free(adapter, q);
#line 2364
  i = i + 1;
#line 2364
  rxo = rxo + 1;
  ldv_55949: ;
#line 2364
  if ((int )adapter->num_rx_qs > i) {
#line 2366
    goto ldv_55948;
  } else {

  }

#line 2371
  return;
}
}
#line 2372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_rx_cqs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int tmp ;

  {
#line 2379
  adapter->num_rx_qs = adapter->num_evt_qs;
#line 2384
  if ((unsigned int )adapter->num_rx_qs > 1U) {
#line 2385
    adapter->num_rx_qs = (u16 )((int )adapter->num_rx_qs + 1);
  } else {

  }
#line 2387
  tmp = __get_order((unsigned long )rx_frag_size);
#line 2387
  adapter->big_page_size = (u32 )((unsigned long )(1 << tmp)) * 4096U;
#line 2388
  i = 0;
#line 2388
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2388
  goto ldv_55960;
  ldv_55959: 
#line 2389
  rxo->adapter = adapter;
#line 2390
  cq = & rxo->cq;
#line 2391
  rc = be_queue_alloc(adapter, cq, 1024, 16);
#line 2393
  if (rc != 0) {
#line 2394
    return (rc);
  } else {

  }
#line 2397
  eq = & adapter->eq_obj[i % (int )adapter->num_evt_qs].q;
#line 2398
  rc = be_cmd_cq_create(adapter, cq, eq, 0, 3);
#line 2399
  if (rc != 0) {
#line 2400
    return (rc);
  } else {

  }
#line 2388
  i = i + 1;
#line 2388
  rxo = rxo + 1;
  ldv_55960: ;
#line 2388
  if ((int )adapter->num_rx_qs > i) {
#line 2390
    goto ldv_55959;
  } else {

  }
#line 2403
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d RSS queue(s) and 1 default RX queue\n",
            (int )adapter->num_rx_qs + -1);
#line 2406
  return (0);
}
}
#line 2409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static irqreturn_t be_intx(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;
  struct be_adapter *adapter ;
  int num_evts ;
  bool tmp ;
  u16 tmp___0 ;

  {
#line 2411
  eqo = (struct be_eq_obj *)dev;
#line 2412
  adapter = eqo->adapter;
#line 2413
  num_evts = 0;
#line 2423
  tmp = napi_schedule_prep(& eqo->napi);
#line 2423
  if ((int )tmp) {
#line 2424
    num_evts = events_get(eqo);
#line 2425
    __napi_schedule(& eqo->napi);
#line 2426
    if (num_evts != 0) {
#line 2427
      eqo->spurious_intr = 0U;
    } else {

    }
  } else {

  }
#line 2429
  be_eq_notify(adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num_evts));
#line 2435
  if (num_evts != 0) {
#line 2436
    return (1);
  } else {
#line 2435
    tmp___0 = eqo->spurious_intr;
#line 2435
    eqo->spurious_intr = (u16 )((int )eqo->spurious_intr + 1);
#line 2435
    if ((unsigned int )tmp___0 == 0U) {
#line 2436
      return (1);
    } else {
#line 2438
      return (0);
    }
  }
}
}
#line 2441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static irqreturn_t be_msix(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;

  {
#line 2443
  eqo = (struct be_eq_obj *)dev;
#line 2445
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 2446
  napi_schedule(& eqo->napi);
#line 2447
  return (1);
}
}
#line 2450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static bool do_gro(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 2452
  return ((bool )(((unsigned int )rxcp->tcpf != 0U && (unsigned int )rxcp->err == 0U) && (unsigned int )rxcp->l4_csum != 0U));
}
}
#line 2455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_process_rx(struct be_rx_obj *rxo , struct napi_struct *napi , int budget ,
                         int polling ) 
{ 
  struct be_adapter *adapter ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  u32 work_done ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 2458
  adapter = rxo->adapter;
#line 2459
  rx_cq = & rxo->cq;
#line 2463
  work_done = 0U;
#line 2463
  goto ldv_55990;
  ldv_55989: 
#line 2464
  rxcp = be_rx_compl_get(rxo);
#line 2465
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2466
    goto ldv_55987;
  } else {

  }
#line 2469
  tmp = ldv__builtin_expect((unsigned int )rxcp->num_rcvd == 0U, 0L);
#line 2469
  if (tmp != 0L) {
#line 2470
    goto loop_continue;
  } else {

  }
#line 2473
  tmp___0 = ldv__builtin_expect((unsigned int )rxcp->pkt_size == 0U, 0L);
#line 2473
  if (tmp___0 != 0L) {
#line 2474
    be_rx_compl_discard(rxo, rxcp);
#line 2475
    goto loop_continue;
  } else {

  }
#line 2481
  tmp___1 = ldv__builtin_expect((u32 )rxcp->port != adapter->port_num, 0L);
#line 2481
  if (tmp___1 != 0L) {
#line 2481
    tmp___2 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 57888U, 0L);
#line 2481
    if (tmp___2 != 0L) {
#line 2481
      tmp___3 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 57896U,
                                 0L);
#line 2481
      if (tmp___3 != 0L) {
#line 2481
        tmp___4 = 1;
      } else {
#line 2481
        tmp___4 = 0;
      }
    } else {
#line 2481
      tmp___4 = 0;
    }
#line 2481
    if (tmp___4 != 0) {
#line 2483
      be_rx_compl_discard(rxo, rxcp);
#line 2484
      goto loop_continue;
    } else {

    }
  } else {

  }
#line 2488
  tmp___5 = do_gro(rxcp);
#line 2488
  if ((int )tmp___5 && polling != 1) {
#line 2489
    be_rx_compl_process_gro(rxo, napi, rxcp);
  } else {
#line 2491
    be_rx_compl_process(rxo, napi, rxcp);
  }
  loop_continue: 
#line 2494
  be_rx_stats_update(rxo, rxcp);
#line 2463
  work_done = work_done + 1U;
  ldv_55990: ;
#line 2463
  if ((u32 )budget > work_done) {
#line 2465
    goto ldv_55989;
  } else {

  }
  ldv_55987: ;
#line 2497
  if (work_done != 0U) {
#line 2498
    be_cq_notify(adapter, (int )rx_cq->id, 1, (int )((u16 )work_done));
#line 2503
    tmp___6 = atomic_read((atomic_t const   *)(& rxo->q.used));
#line 2503
    if (tmp___6 <= 959 && ! rxo->rx_post_starved) {
#line 2505
      be_post_rx_frags(rxo, 32U);
    } else {

    }
  } else {

  }
#line 2508
  return ((int )work_done);
}
}
#line 2511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static bool be_process_tx(struct be_adapter *adapter , struct be_tx_obj *txo , int budget ,
                          int idx ) 
{ 
  struct be_eth_tx_compl *txcp ;
  int num_wrbs ;
  int work_done ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2515
  num_wrbs = 0;
#line 2517
  work_done = 0;
#line 2517
  goto ldv_56002;
  ldv_56001: 
#line 2518
  txcp = be_tx_compl_get(& txo->cq);
#line 2519
  if ((unsigned long )txcp == (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 2520
    goto ldv_56000;
  } else {

  }
#line 2521
  tmp = amap_mask(16U);
#line 2521
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 2521
  tmp___1 = be_tx_compl_process(adapter, txo, (int )((u16 )tmp___0));
#line 2521
  num_wrbs = (int )tmp___1 + num_wrbs;
#line 2517
  work_done = work_done + 1;
  ldv_56002: ;
#line 2517
  if (work_done < budget) {
#line 2519
    goto ldv_56001;
  } else {

  }
  ldv_56000: ;
#line 2527
  if (work_done != 0) {
#line 2528
    be_cq_notify(adapter, (int )txo->cq.id, 1, (int )((u16 )work_done));
#line 2529
    atomic_sub(num_wrbs, & txo->q.used);
#line 2533
    tmp___2 = __netif_subqueue_stopped((struct net_device  const  *)adapter->netdev,
                                       (int )((u16 )idx));
#line 2533
    if ((int )tmp___2) {
#line 2533
      tmp___3 = atomic_read((atomic_t const   *)(& txo->q.used));
#line 2533
      if (tmp___3 < (int )((unsigned int )txo->q.len / 2U)) {
#line 2535
        netif_wake_subqueue(adapter->netdev, (int )((u16 )idx));
      } else {

      }
    } else {

    }
#line 2538
    u64_stats_update_begin(& txo->stats.sync_compl);
#line 2539
    txo->stats.tx_compl = txo->stats.tx_compl + (u64 )work_done;
#line 2540
    u64_stats_update_begin(& txo->stats.sync_compl);
  } else {

  }
#line 2542
  return (work_done < budget);
}
}
#line 2545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int be_poll(struct napi_struct *napi , int budget ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  int max_work ;
  int work ;
  int i ;
  int num_evts ;
  struct be_rx_obj *rxo ;
  bool tx_done ;
  int _max1 ;
  int _max2 ;
  bool tmp ;

  {
#line 2547
  __mptr = (struct napi_struct  const  *)napi;
#line 2547
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffff98UL;
#line 2548
  adapter = eqo->adapter;
#line 2549
  max_work = 0;
#line 2553
  num_evts = events_get(eqo);
#line 2556
  i = (int )eqo->idx;
#line 2556
  goto ldv_56018;
  ldv_56017: 
#line 2557
  tx_done = be_process_tx(adapter, (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i,
                          (int )eqo->tx_budget, i);
#line 2559
  if (! tx_done) {
#line 2560
    max_work = budget;
  } else {

  }
#line 2556
  i = (int )adapter->num_evt_qs + i;
  ldv_56018: ;
#line 2556
  if ((int )adapter->num_tx_qs > i) {
#line 2558
    goto ldv_56017;
  } else {

  }
#line 2563
  tmp = be_lock_napi(eqo);
#line 2563
  if ((int )tmp) {
#line 2568
    i = (int )eqo->idx;
#line 2568
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2568
    goto ldv_56024;
    ldv_56023: 
#line 2569
    work = be_process_rx(rxo, napi, budget, 0);
#line 2570
    _max1 = work;
#line 2570
    _max2 = max_work;
#line 2570
    max_work = _max1 > _max2 ? _max1 : _max2;
#line 2568
    i = (int )adapter->num_evt_qs + i;
#line 2568
    rxo = rxo + (unsigned long )adapter->num_evt_qs;
    ldv_56024: ;
#line 2568
    if ((int )adapter->num_rx_qs > i) {
#line 2570
      goto ldv_56023;
    } else {

    }
#line 2572
    be_unlock_napi(eqo);
  } else {
#line 2574
    max_work = budget;
  }
#line 2577
  if ((unsigned int )eqo->idx == 0U) {
#line 2578
    be_process_mcc(adapter);
  } else {

  }
#line 2580
  if (max_work < budget) {
#line 2581
    napi_complete(napi);
#line 2582
    be_eq_notify(adapter, (int )eqo->q.id, 1, 0, (int )((u16 )num_evts));
  } else {
#line 2585
    be_eq_notify(adapter, (int )eqo->q.id, 0, 0, (int )((u16 )num_evts));
  }
#line 2587
  return (max_work);
}
}
#line 2591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_busy_poll(struct napi_struct *napi ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  struct be_rx_obj *rxo ;
  int i ;
  int work ;
  bool tmp ;
  int tmp___0 ;

  {
#line 2593
  __mptr = (struct napi_struct  const  *)napi;
#line 2593
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffff98UL;
#line 2594
  adapter = eqo->adapter;
#line 2596
  work = 0;
#line 2598
  tmp = be_lock_busy_poll(eqo);
#line 2598
  if (tmp) {
#line 2598
    tmp___0 = 0;
  } else {
#line 2598
    tmp___0 = 1;
  }
#line 2598
  if (tmp___0) {
#line 2599
    return (-2);
  } else {

  }
#line 2601
  i = (int )eqo->idx;
#line 2601
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2601
  goto ldv_56038;
  ldv_56037: 
#line 2602
  work = be_process_rx(rxo, napi, 4, 1);
#line 2603
  if (work != 0) {
#line 2604
    goto ldv_56036;
  } else {

  }
#line 2601
  i = (int )adapter->num_evt_qs + i;
#line 2601
  rxo = rxo + (unsigned long )adapter->num_evt_qs;
  ldv_56038: ;
#line 2601
  if ((int )adapter->num_rx_qs > i) {
#line 2603
    goto ldv_56037;
  } else {

  }
  ldv_56036: 
#line 2607
  be_unlock_busy_poll(eqo);
#line 2608
  return (work);
}
}
#line 2612 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void be_detect_error(struct be_adapter *adapter ) 
{ 
  u32 ue_lo ;
  u32 ue_hi ;
  u32 ue_lo_mask ;
  u32 ue_hi_mask ;
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;
  u32 i ;
  bool error_detected ;
  struct device *dev ;
  struct net_device *netdev ;
  bool tmp ;

  {
#line 2614
  ue_lo = 0U;
#line 2614
  ue_hi = 0U;
#line 2614
  ue_lo_mask = 0U;
#line 2614
  ue_hi_mask = 0U;
#line 2615
  sliport_status = 0U;
#line 2615
  sliport_err1 = 0U;
#line 2615
  sliport_err2 = 0U;
#line 2617
  error_detected = 0;
#line 2618
  dev = & (adapter->pdev)->dev;
#line 2619
  netdev = adapter->netdev;
#line 2621
  tmp = be_hw_error(adapter);
#line 2621
  if ((int )tmp) {
#line 2622
    return;
  } else {

  }
#line 2624
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2625
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 2626
    if ((int )sliport_status < 0) {
#line 2627
      sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 2629
      sliport_err2 = ioread32((void *)adapter->db + 1040U);
#line 2631
      adapter->hw_error = 1;
#line 2633
      if (sliport_err1 == 2U && sliport_err2 == 0U) {
#line 2635
        _dev_info((struct device  const  *)dev, "Firmware update in progress\n");
      } else {
#line 2637
        error_detected = 1;
#line 2638
        dev_err((struct device  const  *)dev, "Error detected in the card\n");
#line 2639
        dev_err((struct device  const  *)dev, "ERR: sliport status 0x%x\n", sliport_status);
#line 2641
        dev_err((struct device  const  *)dev, "ERR: sliport error1 0x%x\n", sliport_err1);
#line 2643
        dev_err((struct device  const  *)dev, "ERR: sliport error2 0x%x\n", sliport_err2);
      }
    } else {

    }
  } else {
#line 2648
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 160, & ue_lo);
#line 2650
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 164, & ue_hi);
#line 2652
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 168, & ue_lo_mask);
#line 2654
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 172, & ue_hi_mask);
#line 2657
    ue_lo = ~ ue_lo_mask & ue_lo;
#line 2658
    ue_hi = ~ ue_hi_mask & ue_hi;
#line 2665
    if (ue_lo != 0U || ue_hi != 0U) {
#line 2666
      error_detected = 1;
#line 2667
      dev_err((struct device  const  *)dev, "Unrecoverable Error detected in the adapter");
#line 2669
      dev_err((struct device  const  *)dev, "Please reboot server to recover");
#line 2670
      if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 2671
        adapter->hw_error = 1;
      } else {

      }
#line 2672
      i = 0U;
#line 2672
      goto ldv_56054;
      ldv_56053: ;
#line 2673
      if ((int )ue_lo & 1) {
#line 2674
        dev_err((struct device  const  *)dev, "UE: %s bit set\n", ue_status_low_desc[i]);
      } else {

      }
#line 2672
      ue_lo = ue_lo >> 1;
#line 2672
      i = i + 1U;
      ldv_56054: ;
#line 2672
      if (ue_lo != 0U) {
#line 2674
        goto ldv_56053;
      } else {

      }
#line 2677
      i = 0U;
#line 2677
      goto ldv_56057;
      ldv_56056: ;
#line 2678
      if ((int )ue_hi & 1) {
#line 2679
        dev_err((struct device  const  *)dev, "UE: %s bit set\n", ue_status_hi_desc[i]);
      } else {

      }
#line 2677
      ue_hi = ue_hi >> 1;
#line 2677
      i = i + 1U;
      ldv_56057: ;
#line 2677
      if (ue_hi != 0U) {
#line 2679
        goto ldv_56056;
      } else {

      }

    } else {

    }
  }
#line 2684
  if ((int )error_detected) {
#line 2685
    netif_carrier_off(netdev);
  } else {

  }
#line 2686
  return;
}
}
#line 2688 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_msix_disable(struct be_adapter *adapter ) 
{ 


  {
#line 2690
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 2691
    pci_disable_msix(adapter->pdev);
#line 2692
    adapter->num_msix_vec = 0U;
#line 2693
    adapter->num_msix_roce_vec = 0U;
  } else {

  }
#line 2695
  return;
}
}
#line 2697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_msix_enable(struct be_adapter *adapter ) 
{ 
  int i ;
  int num_vec ;
  struct device *dev ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;

  {
#line 2700
  dev = & (adapter->pdev)->dev;
#line 2706
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 2707
    __min1 = (int )adapter->res.max_evt_qs * 2;
#line 2707
    tmp = cpumask_weight(cpu_online_mask);
#line 2707
    __min2 = (int )(tmp * 2U);
#line 2707
    num_vec = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 2710
    num_vec = (int )adapter->cfg_num_qs;
  }
#line 2712
  i = 0;
#line 2712
  goto ldv_56072;
  ldv_56071: 
#line 2713
  adapter->msix_entries[i].entry = (u16 )i;
#line 2712
  i = i + 1;
  ldv_56072: ;
#line 2712
  if (i < num_vec) {
#line 2714
    goto ldv_56071;
  } else {

  }
#line 2715
  num_vec = pci_enable_msix_range(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                                  1, num_vec);
#line 2717
  if (num_vec < 0) {
#line 2718
    goto fail;
  } else {

  }
#line 2720
  if ((((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) && num_vec > 1) {
#line 2721
    adapter->num_msix_roce_vec = (u32 )(num_vec / 2);
#line 2722
    _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for RoCE\n",
              adapter->num_msix_roce_vec);
  } else {

  }
#line 2726
  adapter->num_msix_vec = (int )((u16 )num_vec) - (int )((u16 )adapter->num_msix_roce_vec);
#line 2728
  _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for NIC\n",
            (int )adapter->num_msix_vec);
#line 2730
  return (0);
  fail: 
#line 2733
  dev_warn((struct device  const  *)dev, "MSIx enable failed\n");
#line 2736
  if ((unsigned int )adapter->virtfn != 0U) {
#line 2737
    return (num_vec);
  } else {

  }
#line 2738
  return (0);
}
}
#line 2741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int be_msix_vec_get(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 


  {
#line 2744
  return ((int )adapter->msix_entries[(int )eqo->msix_idx].vector);
}
}
#line 2747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_msix_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int status ;
  int i ;
  int vec ;
  int tmp ;

  {
#line 2749
  netdev = adapter->netdev;
#line 2753
  i = 0;
#line 2753
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2753
  goto ldv_56089;
  ldv_56088: 
#line 2754
  sprintf((char *)(& eqo->desc), "%s-q%d", (char *)(& netdev->name), i);
#line 2755
  vec = be_msix_vec_get(adapter, eqo);
#line 2756
  status = ldv_request_irq_35((unsigned int )vec, & be_msix, 0UL, (char const   *)(& eqo->desc),
                              (void *)eqo);
#line 2757
  if (status != 0) {
#line 2758
    goto err_msix;
  } else {

  }
#line 2753
  i = i + 1;
#line 2753
  eqo = eqo + 1;
  ldv_56089: ;
#line 2753
  if ((int )adapter->num_evt_qs > i) {
#line 2755
    goto ldv_56088;
  } else {

  }

#line 2761
  return (0);
  err_msix: 
#line 2763
  i = i - 1;
#line 2763
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2763
  goto ldv_56092;
  ldv_56091: 
#line 2764
  tmp = be_msix_vec_get(adapter, eqo);
#line 2764
  ldv_free_irq_36((unsigned int )tmp, (void *)eqo);
#line 2763
  i = i - 1;
#line 2763
  eqo = eqo - 1;
  ldv_56092: ;
#line 2763
  if (i >= 0) {
#line 2765
    goto ldv_56091;
  } else {

  }
#line 2765
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "MSIX Request IRQ failed - err %d\n",
           status);
#line 2767
  be_msix_disable(adapter);
#line 2768
  return (status);
}
}
#line 2771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_irq_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 2773
  netdev = adapter->netdev;
#line 2776
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 2777
    status = be_msix_register(adapter);
#line 2778
    if (status == 0) {
#line 2779
      goto done;
    } else {

    }
#line 2781
    if ((unsigned int )adapter->virtfn != 0U) {
#line 2782
      return (status);
    } else {

    }
  } else {

  }
#line 2786
  netdev->irq = (int )(adapter->pdev)->irq;
#line 2787
  status = ldv_request_irq_37((unsigned int )netdev->irq, & be_intx, 128UL, (char const   *)(& netdev->name),
                              (void *)(& adapter->eq_obj));
#line 2789
  if (status != 0) {
#line 2790
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "INTx request IRQ failed - err %d\n",
            status);
#line 2792
    return (status);
  } else {

  }
  done: 
#line 2795
  adapter->isr_registered = 1;
#line 2796
  return (0);
}
}
#line 2799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_irq_unregister(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp ;

  {
#line 2801
  netdev = adapter->netdev;
#line 2805
  if (! adapter->isr_registered) {
#line 2806
    return;
  } else {

  }
#line 2809
  if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 2810
    ldv_free_irq_38((unsigned int )netdev->irq, (void *)(& adapter->eq_obj));
#line 2811
    goto done;
  } else {

  }
#line 2815
  i = 0;
#line 2815
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2815
  goto ldv_56108;
  ldv_56107: 
#line 2816
  tmp = be_msix_vec_get(adapter, eqo);
#line 2816
  ldv_free_irq_39((unsigned int )tmp, (void *)eqo);
#line 2815
  i = i + 1;
#line 2815
  eqo = eqo + 1;
  ldv_56108: ;
#line 2815
  if ((int )adapter->num_evt_qs > i) {
#line 2817
    goto ldv_56107;
  } else {

  }

  done: 
#line 2819
  adapter->isr_registered = 0;
#line 2820
  return;
}
}
#line 2822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_rx_qs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2828
  i = 0;
#line 2828
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2828
  goto ldv_56117;
  ldv_56116: 
#line 2829
  q = & rxo->q;
#line 2830
  if ((int )q->created) {
#line 2831
    be_cmd_rxq_destroy(adapter, q);
#line 2832
    be_rx_cq_clean(rxo);
  } else {

  }
#line 2834
  be_queue_free(adapter, q);
#line 2828
  i = i + 1;
#line 2828
  rxo = rxo + 1;
  ldv_56117: ;
#line 2828
  if ((int )adapter->num_rx_qs > i) {
#line 2830
    goto ldv_56116;
  } else {

  }

#line 2835
  return;
}
}
#line 2838 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_close(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp___0 ;

  {
#line 2840
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2840
  adapter = (struct be_adapter *)tmp;
#line 2847
  if ((adapter->flags & 8192U) == 0U) {
#line 2848
    return (0);
  } else {

  }
#line 2850
  be_roce_dev_close(adapter);
#line 2852
  if ((adapter->flags & 512U) != 0U) {
#line 2853
    i = 0;
#line 2853
    eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2853
    goto ldv_56126;
    ldv_56125: 
#line 2854
    napi_disable(& eqo->napi);
#line 2855
    be_disable_busy_poll(eqo);
#line 2853
    i = i + 1;
#line 2853
    eqo = eqo + 1;
    ldv_56126: ;
#line 2853
    if ((int )adapter->num_evt_qs > i) {
#line 2855
      goto ldv_56125;
    } else {

    }
#line 2857
    adapter->flags = adapter->flags & 4294966783U;
  } else {

  }
#line 2860
  be_async_mcc_disable(adapter);
#line 2865
  netif_tx_disable(netdev);
#line 2866
  be_tx_compl_clean(adapter);
#line 2868
  be_rx_qs_destroy(adapter);
#line 2870
  i = 1;
#line 2870
  goto ldv_56129;
  ldv_56128: 
#line 2871
  be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                  0U);
#line 2870
  i = i + 1;
  ldv_56129: ;
#line 2870
  if ((u32 )i < adapter->uc_macs + 1U) {
#line 2872
    goto ldv_56128;
  } else {

  }
#line 2873
  adapter->uc_macs = 0U;
#line 2875
  i = 0;
#line 2875
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2875
  goto ldv_56132;
  ldv_56131: ;
#line 2876
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 2877
    tmp___0 = be_msix_vec_get(adapter, eqo);
#line 2877
    synchronize_irq((unsigned int )tmp___0);
  } else {
#line 2879
    synchronize_irq((unsigned int )netdev->irq);
  }
#line 2880
  be_eq_clean(eqo);
#line 2875
  i = i + 1;
#line 2875
  eqo = eqo + 1;
  ldv_56132: ;
#line 2875
  if ((int )adapter->num_evt_qs > i) {
#line 2877
    goto ldv_56131;
  } else {

  }
#line 2883
  be_irq_unregister(adapter);
#line 2885
  return (0);
}
}
#line 2888 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_rx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int j ;
  u8 rss_hkey[40U] ;
  struct rss_info *rss ;
  bool tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2893
  rss = & adapter->rss_info;
#line 2895
  i = 0;
#line 2895
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2895
  goto ldv_56144;
  ldv_56143: 
#line 2896
  rc = be_queue_alloc(adapter, & rxo->q, 1024, 8);
#line 2898
  if (rc != 0) {
#line 2899
    return (rc);
  } else {

  }
#line 2895
  i = i + 1;
#line 2895
  rxo = rxo + 1;
  ldv_56144: ;
#line 2895
  if ((int )adapter->num_rx_qs > i) {
#line 2897
    goto ldv_56143;
  } else {

  }
#line 2903
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + ((unsigned long )adapter->num_rx_qs + 0xffffffffffffffffUL);
#line 2904
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 0U, & rxo->rss_id);
#line 2906
  if (rc != 0) {
#line 2907
    return (rc);
  } else {

  }
#line 2909
  i = 0;
#line 2909
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2909
  goto ldv_56147;
  ldv_56146: 
#line 2910
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 1U, & rxo->rss_id);
#line 2913
  if (rc != 0) {
#line 2914
    return (rc);
  } else {

  }
#line 2909
  i = i + 1;
#line 2909
  rxo = rxo + 1;
  ldv_56147: ;
#line 2909
  if ((int )adapter->num_rx_qs + -1 > i) {
#line 2911
    goto ldv_56146;
  } else {

  }
#line 2917
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 2917
  if ((int )tmp) {
#line 2918
    j = 0;
#line 2918
    goto ldv_56153;
    ldv_56152: 
#line 2920
    i = 0;
#line 2920
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2920
    goto ldv_56151;
    ldv_56150: ;
#line 2921
    if (j + i > 127) {
#line 2922
      goto ldv_56149;
    } else {

    }
#line 2923
    rss->rsstable[j + i] = rxo->rss_id;
#line 2924
    rss->rss_queue[j + i] = (u8 )i;
#line 2920
    i = i + 1;
#line 2920
    rxo = rxo + 1;
    ldv_56151: ;
#line 2920
    if ((int )adapter->num_rx_qs + -1 > i) {
#line 2922
      goto ldv_56150;
    } else {

    }
    ldv_56149: 
#line 2919
    j = ((int )adapter->num_rx_qs + -1) + j;
    ldv_56153: ;
#line 2918
    if (j <= 127) {
#line 2920
      goto ldv_56152;
    } else {

    }
#line 2927
    rss->rss_flags = 15ULL;
#line 2930
    if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 2931
      rss->rss_flags = rss->rss_flags | 48ULL;
    } else {

    }
  } else {
#line 2935
    rss->rss_flags = 0ULL;
  }
#line 2938
  get_random_bytes((void *)(& rss_hkey), 40);
#line 2939
  rc = be_cmd_rss_config(adapter, (u8 *)(& rss->rsstable), (u32 )rss->rss_flags, 128,
                         (u8 const   *)(& rss_hkey));
#line 2941
  if (rc != 0) {
#line 2942
    rss->rss_flags = 0ULL;
#line 2943
    return (rc);
  } else {

  }
#line 2946
  __len = 40UL;
#line 2946
  if (__len > 63UL) {
#line 2946
    __ret = __memcpy((void *)(& rss->rss_hkey), (void const   *)(& rss_hkey), __len);
  } else {
#line 2946
    __ret = __builtin_memcpy((void *)(& rss->rss_hkey), (void const   *)(& rss_hkey),
                             __len);
  }
#line 2949
  i = 0;
#line 2949
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2949
  goto ldv_56159;
  ldv_56158: 
#line 2950
  be_post_rx_frags(rxo, 208U);
#line 2949
  i = i + 1;
#line 2949
  rxo = rxo + 1;
  ldv_56159: ;
#line 2949
  if ((int )adapter->num_rx_qs > i) {
#line 2951
    goto ldv_56158;
  } else {

  }

#line 2951
  return (0);
}
}
#line 2954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_open(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u8 link_status ;
  int status ;
  int i ;

  {
#line 2956
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2956
  adapter = (struct be_adapter *)tmp;
#line 2963
  status = be_rx_qs_create(adapter);
#line 2964
  if (status != 0) {
#line 2965
    goto err;
  } else {

  }
#line 2967
  status = be_irq_register(adapter);
#line 2968
  if (status != 0) {
#line 2969
    goto err;
  } else {

  }
#line 2971
  i = 0;
#line 2971
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2971
  goto ldv_56173;
  ldv_56172: 
#line 2972
  be_cq_notify(adapter, (int )rxo->cq.id, 1, 0);
#line 2971
  i = i + 1;
#line 2971
  rxo = rxo + 1;
  ldv_56173: ;
#line 2971
  if ((int )adapter->num_rx_qs > i) {
#line 2973
    goto ldv_56172;
  } else {

  }
#line 2974
  i = 0;
#line 2974
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2974
  goto ldv_56176;
  ldv_56175: 
#line 2975
  be_cq_notify(adapter, (int )txo->cq.id, 1, 0);
#line 2974
  i = i + 1;
#line 2974
  txo = txo + 1;
  ldv_56176: ;
#line 2974
  if ((int )adapter->num_tx_qs > i) {
#line 2976
    goto ldv_56175;
  } else {

  }
#line 2977
  be_async_mcc_enable(adapter);
#line 2979
  i = 0;
#line 2979
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2979
  goto ldv_56179;
  ldv_56178: 
#line 2980
  napi_enable(& eqo->napi);
#line 2981
  be_enable_busy_poll(eqo);
#line 2982
  be_eq_notify(adapter, (int )eqo->q.id, 1, 0, 0);
#line 2979
  i = i + 1;
#line 2979
  eqo = eqo + 1;
  ldv_56179: ;
#line 2979
  if ((int )adapter->num_evt_qs > i) {
#line 2981
    goto ldv_56178;
  } else {

  }
#line 2984
  adapter->flags = adapter->flags | 512U;
#line 2986
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
#line 2987
  if (status == 0) {
#line 2988
    be_link_status_update(adapter, (int )link_status);
  } else {

  }
#line 2990
  netif_tx_start_all_queues(netdev);
#line 2991
  be_roce_dev_open(adapter);
#line 2994
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 2995
    vxlan_get_rx_port(netdev);
  } else {

  }
#line 2998
  return (0);
  err: 
#line 3000
  be_close(adapter->netdev);
#line 3001
  return (-5);
}
}
#line 3004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_setup_wol(struct be_adapter *adapter , bool enable ) 
{ 
  struct be_dma_mem cmd ;
  int status ;
  u8 mac[6U] ;

  {
#line 3007
  status = 0;
#line 3010
  memset((void *)(& mac), 0, 6UL);
#line 3012
  cmd.size = 604U;
#line 3013
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               208U);
#line 3015
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3016
    return (-1);
  } else {

  }
#line 3018
  if ((int )enable) {
#line 3019
    status = pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 68, 264U);
#line 3022
    if (status != 0) {
#line 3023
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Could not enable Wake-on-lan\n");
#line 3025
      dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3027
      return (status);
    } else {

    }
#line 3029
    status = be_cmd_enable_magic_wol(adapter, (adapter->netdev)->dev_addr, & cmd);
#line 3032
    pci_enable_wake(adapter->pdev, 3, 1);
#line 3033
    pci_enable_wake(adapter->pdev, 4, 1);
  } else {
#line 3035
    status = be_cmd_enable_magic_wol(adapter, (u8 *)(& mac), & cmd);
#line 3036
    pci_enable_wake(adapter->pdev, 3, 0);
#line 3037
    pci_enable_wake(adapter->pdev, 4, 0);
  }
#line 3040
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3041
  return (status);
}
}
#line 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vf_eth_addr_config(struct be_adapter *adapter ) 
{ 
  u32 vf ;
  int status ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;
  size_t __len ;
  void *__ret ;

  {
#line 3053
  status = 0;
#line 3057
  be_vf_eth_addr_generate(adapter, (u8 *)(& mac));
#line 3059
  vf = 0U;
#line 3059
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3059
  goto ldv_56199;
  ldv_56198: ;
#line 3060
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3061
    status = be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             vf + 1U);
  } else {
#line 3065
    status = be_cmd_set_mac(adapter, (u8 *)(& mac), vf_cfg->if_handle, vf + 1U);
  }
#line 3068
  if (status != 0) {
#line 3069
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Mac address assignment failed for VF %d\n",
            vf);
  } else {
#line 3073
    __len = 6UL;
#line 3073
    if (__len > 63UL) {
#line 3073
      __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), __len);
    } else {
#line 3073
      __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac),
                               __len);
    }
  }
#line 3075
  mac[5] = (unsigned int )mac[5] + 1U;
#line 3059
  vf = vf + 1U;
#line 3059
  vf_cfg = vf_cfg + 1;
  ldv_56199: ;
#line 3059
  if ((u32 )adapter->num_vfs > vf) {
#line 3061
    goto ldv_56198;
  } else {

  }

#line 3077
  return (status);
}
}
#line 3080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vfs_mac_query(struct be_adapter *adapter ) 
{ 
  int status ;
  int vf ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;
  size_t __len ;
  void *__ret ;

  {
#line 3086
  vf = 0;
#line 3086
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3086
  goto ldv_56212;
  ldv_56211: 
#line 3087
  status = be_cmd_get_active_mac(adapter, (u32 )vf_cfg->pmac_id, (u8 *)(& mac), (u32 )vf_cfg->if_handle,
                                 0, (u32 )(vf + 1));
#line 3090
  if (status != 0) {
#line 3091
    return (status);
  } else {

  }
#line 3092
  __len = 6UL;
#line 3092
  if (__len > 63UL) {
#line 3092
    __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), __len);
  } else {
#line 3092
    __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac),
                             __len);
  }
#line 3086
  vf = vf + 1;
#line 3086
  vf_cfg = vf_cfg + 1;
  ldv_56212: ;
#line 3086
  if ((int )adapter->num_vfs > vf) {
#line 3088
    goto ldv_56211;
  } else {

  }

#line 3094
  return (0);
}
}
#line 3097 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_vf_clear(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u32 vf ;
  int tmp ;

  {
#line 3102
  tmp = pci_vfs_assigned(adapter->pdev);
#line 3102
  if (tmp != 0) {
#line 3103
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VFs are assigned to VMs: not disabling VFs\n");
#line 3105
    goto done;
  } else {

  }
#line 3108
  pci_disable_sriov(adapter->pdev);
#line 3110
  vf = 0U;
#line 3110
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3110
  goto ldv_56221;
  ldv_56220: ;
#line 3111
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3112
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, vf + 1U);
  } else {
#line 3115
    be_cmd_set_mac(adapter, (u8 *)0U, vf_cfg->if_handle, vf + 1U);
  }
#line 3118
  be_cmd_if_destroy(adapter, vf_cfg->if_handle, vf + 1U);
#line 3110
  vf = vf + 1U;
#line 3110
  vf_cfg = vf_cfg + 1;
  ldv_56221: ;
#line 3110
  if ((u32 )adapter->num_vfs > vf) {
#line 3112
    goto ldv_56220;
  } else {

  }

  done: 
#line 3121
  kfree((void const   *)adapter->vf_cfg);
#line 3122
  adapter->num_vfs = 0U;
#line 3123
  return;
}
}
#line 3125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_clear_queues(struct be_adapter *adapter ) 
{ 


  {
#line 3127
  be_mcc_queues_destroy(adapter);
#line 3128
  be_rx_cqs_destroy(adapter);
#line 3129
  be_tx_queues_destroy(adapter);
#line 3130
  be_evt_queues_destroy(adapter);
#line 3131
  return;
}
}
#line 3133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_cancel_worker(struct be_adapter *adapter ) 
{ 


  {
#line 3135
  if ((adapter->flags & 8U) != 0U) {
#line 3136
    cancel_delayed_work_sync(& adapter->work);
#line 3137
    adapter->flags = adapter->flags & 4294967287U;
  } else {

  }
#line 3139
  return;
}
}
#line 3141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_mac_clear(struct be_adapter *adapter ) 
{ 
  int i ;

  {
#line 3145
  if ((unsigned long )adapter->pmac_id != (unsigned long )((u32 *)0U)) {
#line 3146
    i = 0;
#line 3146
    goto ldv_56234;
    ldv_56233: 
#line 3147
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                    0U);
#line 3146
    i = i + 1;
    ldv_56234: ;
#line 3146
    if ((u32 )i < adapter->uc_macs + 1U) {
#line 3148
      goto ldv_56233;
    } else {

    }
#line 3149
    adapter->uc_macs = 0U;
#line 3151
    kfree((void const   *)adapter->pmac_id);
#line 3152
    adapter->pmac_id = (u32 *)0U;
  } else {

  }
#line 3154
  return;
}
}
#line 3157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_disable_vxlan_offloads(struct be_adapter *adapter ) 
{ 


  {
#line 3159
  if ((adapter->flags & 4096U) != 0U) {
#line 3160
    be_cmd_manage_iface(adapter, (u32 )adapter->if_handle, 1);
  } else {

  }
#line 3163
  if ((unsigned int )adapter->vxlan_port != 0U) {
#line 3164
    be_cmd_set_vxlan_port(adapter, 0);
  } else {

  }
#line 3166
  adapter->flags = adapter->flags & 4294963199U;
#line 3167
  adapter->vxlan_port = 0U;
#line 3168
  return;
}
}
#line 3171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_clear(struct be_adapter *adapter ) 
{ 


  {
#line 3173
  be_cancel_worker(adapter);
#line 3175
  if ((unsigned int )adapter->num_vfs != 0U) {
#line 3176
    be_vf_clear(adapter);
  } else {

  }
#line 3179
  be_disable_vxlan_offloads(adapter);
#line 3182
  be_mac_clear(adapter);
#line 3184
  be_cmd_if_destroy(adapter, adapter->if_handle, 0U);
#line 3186
  be_clear_queues(adapter);
#line 3188
  be_msix_disable(adapter);
#line 3189
  adapter->flags = adapter->flags & 4294959103U;
#line 3190
  return (0);
}
}
#line 3193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vfs_if_create(struct be_adapter *adapter ) 
{ 
  struct be_resources res ;
  struct be_vf_cfg *vf_cfg ;
  u32 cap_flags ;
  u32 en_flags ;
  u32 vf ;
  int status ;

  {
#line 3195
  res.max_vfs = 0U;
#line 3195
  res.max_mcast_mac = (unsigned short)0;
#line 3195
  res.max_tx_qs = (unsigned short)0;
#line 3195
  res.max_rss_qs = (unsigned short)0;
#line 3195
  res.max_rx_qs = (unsigned short)0;
#line 3195
  res.max_uc_mac = (unsigned short)0;
#line 3195
  res.max_vlans = (unsigned short)0;
#line 3195
  res.max_evt_qs = (unsigned short)0;
#line 3195
  res.if_cap_flags = 0U;
#line 3198
  status = 0;
#line 3200
  cap_flags = 4144U;
#line 3203
  vf = 0U;
#line 3203
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3203
  goto ldv_56253;
  ldv_56252: ;
#line 3204
  if ((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) {
#line 3205
    status = be_cmd_get_profile_config(adapter, & res, (int )((unsigned int )((u8 )vf) + 1U));
#line 3207
    if (status == 0) {
#line 3208
      cap_flags = res.if_cap_flags;
    } else {

    }
  } else {

  }
#line 3212
  en_flags = cap_flags & 4144U;
#line 3215
  status = be_cmd_if_create(adapter, cap_flags, en_flags, (u32 *)(& vf_cfg->if_handle),
                            vf + 1U);
#line 3218
  if (status != 0) {
#line 3219
    goto err;
  } else {

  }
#line 3203
  vf = vf + 1U;
#line 3203
  vf_cfg = vf_cfg + 1;
  ldv_56253: ;
#line 3203
  if ((u32 )adapter->num_vfs > vf) {
#line 3205
    goto ldv_56252;
  } else {

  }

  err: ;
#line 3222
  return (status);
}
}
#line 3225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vf_setup_init(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  int vf ;
  void *tmp ;

  {
#line 3230
  tmp = kcalloc((size_t )adapter->num_vfs, 28UL, 208U);
#line 3230
  adapter->vf_cfg = (struct be_vf_cfg *)tmp;
#line 3232
  if ((unsigned long )adapter->vf_cfg == (unsigned long )((struct be_vf_cfg *)0)) {
#line 3233
    return (-12);
  } else {

  }
#line 3235
  vf = 0;
#line 3235
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3235
  goto ldv_56261;
  ldv_56260: 
#line 3236
  vf_cfg->if_handle = -1;
#line 3237
  vf_cfg->pmac_id = -1;
#line 3235
  vf = vf + 1;
#line 3235
  vf_cfg = vf_cfg + 1;
  ldv_56261: ;
#line 3235
  if ((int )adapter->num_vfs > vf) {
#line 3237
    goto ldv_56260;
  } else {

  }

#line 3239
  return (0);
}
}
#line 3242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_vf_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  int old_vfs ;
  int vf ;
  u32 privileges ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 3244
  dev = & (adapter->pdev)->dev;
#line 3249
  old_vfs = pci_num_vf(adapter->pdev);
#line 3250
  if (old_vfs != 0) {
#line 3251
    _dev_info((struct device  const  *)dev, "%d VFs are already enabled\n", old_vfs);
#line 3252
    if ((unsigned int )old_vfs != num_vfs) {
#line 3253
      dev_warn((struct device  const  *)dev, "Ignoring num_vfs=%d setting\n", num_vfs);
    } else {

    }
#line 3254
    adapter->num_vfs = (u16 )old_vfs;
  } else {
#line 3256
    if ((unsigned int )adapter->res.max_vfs < num_vfs) {
#line 3257
      _dev_info((struct device  const  *)dev, "Device supports %d VFs and not %d\n",
                (int )adapter->res.max_vfs, num_vfs);
    } else {

    }
#line 3259
    __min1 = (u16 )num_vfs;
#line 3259
    __min2 = adapter->res.max_vfs;
#line 3259
    adapter->num_vfs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 3260
    if ((unsigned int )adapter->num_vfs == 0U) {
#line 3261
      return (0);
    } else {

    }
  }
#line 3264
  status = be_vf_setup_init(adapter);
#line 3265
  if (status != 0) {
#line 3266
    goto err;
  } else {

  }
#line 3268
  if (old_vfs != 0) {
#line 3269
    vf = 0;
#line 3269
    vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3269
    goto ldv_56277;
    ldv_56276: 
#line 3270
    status = be_cmd_get_if_id(adapter, vf_cfg, vf);
#line 3271
    if (status != 0) {
#line 3272
      goto err;
    } else {

    }
#line 3269
    vf = vf + 1;
#line 3269
    vf_cfg = vf_cfg + 1;
    ldv_56277: ;
#line 3269
    if ((int )adapter->num_vfs > vf) {
#line 3271
      goto ldv_56276;
    } else {

    }

  } else {
#line 3275
    status = be_vfs_if_create(adapter);
#line 3276
    if (status != 0) {
#line 3277
      goto err;
    } else {

    }
  }
#line 3280
  if (old_vfs != 0) {
#line 3281
    status = be_vfs_mac_query(adapter);
#line 3282
    if (status != 0) {
#line 3283
      goto err;
    } else {

    }
  } else {
#line 3285
    status = be_vf_eth_addr_config(adapter);
#line 3286
    if (status != 0) {
#line 3287
      goto err;
    } else {

    }
  }
#line 3290
  vf = 0;
#line 3290
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3290
  goto ldv_56280;
  ldv_56279: 
#line 3292
  status = be_cmd_get_fn_privileges(adapter, & privileges, (u32 )(vf + 1));
#line 3293
  if (status == 0 && (privileges & 64U) == 0U) {
#line 3294
    status = be_cmd_set_fn_privileges(adapter, privileges | 64U, (u32 )(vf + 1));
#line 3298
    if (status == 0) {
#line 3299
      _dev_info((struct device  const  *)dev, "VF%d has FILTMGMT privilege\n", vf);
    } else {

    }
  } else {

  }
#line 3304
  if (old_vfs == 0) {
#line 3305
    be_cmd_config_qos(adapter, 0U, 0, (int )((unsigned int )((u8 )vf) + 1U));
  } else {

  }
#line 3307
  if (old_vfs == 0) {
#line 3308
    be_cmd_enable_vf(adapter, (int )((unsigned int )((u8 )vf) + 1U));
#line 3309
    be_cmd_set_logical_link_config(adapter, 0, (int )((unsigned int )((u8 )vf) + 1U));
  } else {

  }
#line 3290
  vf = vf + 1;
#line 3290
  vf_cfg = vf_cfg + 1;
  ldv_56280: ;
#line 3290
  if ((int )adapter->num_vfs > vf) {
#line 3292
    goto ldv_56279;
  } else {

  }

#line 3315
  if (old_vfs == 0) {
#line 3316
    status = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
#line 3317
    if (status != 0) {
#line 3318
      dev_err((struct device  const  *)dev, "SRIOV enable failed\n");
#line 3319
      adapter->num_vfs = 0U;
#line 3320
      goto err;
    } else {

    }
  } else {

  }
#line 3323
  return (0);
  err: 
#line 3325
  dev_err((struct device  const  *)dev, "VF setup failed\n");
#line 3326
  be_vf_clear(adapter);
#line 3327
  return (status);
}
}
#line 3332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u8 be_convert_mc_type(u32 function_mode ) 
{ 


  {
#line 3334
  if ((function_mode & 131072U) != 0U && (function_mode & 1024U) != 0U) {
#line 3335
    return (4U);
  } else
#line 3336
  if ((function_mode & 1024U) != 0U) {
#line 3337
    return (3U);
  } else
#line 3338
  if ((function_mode & 131072U) != 0U) {
#line 3339
    return (7U);
  } else
#line 3340
  if ((function_mode & 16777216U) != 0U) {
#line 3341
    return (2U);
  } else {
#line 3343
    return (1U);
  }
}
}
#line 3347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void BEx_get_resources(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  struct pci_dev *pdev ;
  bool use_sriov ;
  int max_vfs ;
  int _min1 ;
  int _min2 ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 3350
  pdev = adapter->pdev;
#line 3351
  use_sriov = 0;
#line 3352
  max_vfs = 0;
#line 3354
  if ((unsigned int )adapter->virtfn == 0U && ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U)) {
#line 3355
    be_cmd_get_profile_config(adapter, res, 0);
#line 3357
    if ((unsigned int )res->max_vfs == 0U) {
#line 3358
      max_vfs = pci_sriov_get_totalvfs(pdev);
#line 3359
      if (max_vfs > 0) {
#line 3359
        _min1 = 30;
#line 3359
        _min2 = max_vfs;
#line 3359
        res->max_vfs = (u16 )(_min1 < _min2 ? _min1 : _min2);
      } else {
#line 3359
        res->max_vfs = 0U;
      }
    } else {

    }
#line 3361
    if ((unsigned int )res->max_vfs != 0U) {
#line 3361
      if ((unsigned int )adapter->virtfn == 0U) {
#line 3361
        if (num_vfs != 0U) {
#line 3361
          tmp___0 = 1;
        } else {
#line 3361
          tmp = pci_num_vf(adapter->pdev);
#line 3361
          if (tmp != 0) {
#line 3361
            tmp___0 = 1;
          } else {
#line 3361
            tmp___0 = 0;
          }
        }
      } else {
#line 3361
        tmp___0 = 0;
      }
    } else {
#line 3361
      tmp___0 = 0;
    }
#line 3361
    use_sriov = (bool )tmp___0;
  } else {

  }
#line 3364
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3365
    res->max_uc_mac = 30U;
  } else {
#line 3367
    res->max_uc_mac = 2U;
  }
#line 3369
  adapter->mc_type = be_convert_mc_type(adapter->function_mode);
#line 3371
  tmp___1 = be_is_mc(adapter);
#line 3371
  if ((int )tmp___1) {
#line 3375
    if (((unsigned int )adapter->mc_type == 3U || (unsigned int )adapter->mc_type == 4U) || (unsigned int )adapter->mc_type == 6U) {
#line 3376
      res->max_vlans = 8U;
    } else {
#line 3381
      res->max_vlans = 15U;
    }
  } else {
#line 3383
    res->max_vlans = 64U;
  }
#line 3386
  res->max_mcast_mac = 64U;
#line 3392
  if (((((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) || (int )use_sriov) || adapter->port_num > 1U) || (unsigned int )adapter->virtfn != 0U) {
#line 3395
    res->max_tx_qs = 1U;
  } else {
#line 3392
    tmp___2 = be_is_mc(adapter);
#line 3392
    if ((int )tmp___2 && (adapter->function_caps & 2U) == 0U) {
#line 3395
      res->max_tx_qs = 1U;
    } else {
#line 3397
      res->max_tx_qs = 16U;
    }
  }
#line 3399
  if (((adapter->function_caps & 2U) != 0U && ! use_sriov) && (unsigned int )adapter->virtfn == 0U) {
#line 3401
    res->max_rss_qs = (int )adapter->be3_native ? 16U : 4U;
  } else {

  }
#line 3403
  res->max_rx_qs = (unsigned int )res->max_rss_qs + 1U;
#line 3405
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3406
    res->max_evt_qs = (unsigned int )res->max_vfs != 0U ? 8U : 16U;
  } else {
#line 3409
    res->max_evt_qs = 1U;
  }
#line 3411
  res->if_cap_flags = 7100U;
#line 3412
  if ((adapter->function_caps & 2U) == 0U) {
#line 3413
    res->if_cap_flags = res->if_cap_flags & 4294967291U;
  } else {

  }
#line 3414
  return;
}
}
#line 3416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_setup_init(struct be_adapter *adapter ) 
{ 


  {
#line 3418
  adapter->vlan_prio_bmap = 255U;
#line 3419
  adapter->phy.link_speed = -1;
#line 3420
  adapter->if_handle = -1;
#line 3421
  adapter->be3_native = 0;
#line 3422
  adapter->promiscuous = 0;
#line 3423
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3424
    adapter->cmd_privileges = 1792U;
  } else {
#line 3426
    adapter->cmd_privileges = 1U;
  }
#line 3427
  return;
}
}
#line 3429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_get_resources(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_resources res ;
  int status ;

  {
#line 3431
  dev = & (adapter->pdev)->dev;
#line 3432
  res.max_vfs = 0U;
#line 3432
  res.max_mcast_mac = (unsigned short)0;
#line 3432
  res.max_tx_qs = (unsigned short)0;
#line 3432
  res.max_rss_qs = (unsigned short)0;
#line 3432
  res.max_rx_qs = (unsigned short)0;
#line 3432
  res.max_uc_mac = (unsigned short)0;
#line 3432
  res.max_vlans = (unsigned short)0;
#line 3432
  res.max_evt_qs = (unsigned short)0;
#line 3432
  res.if_cap_flags = 0U;
#line 3435
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3436
    BEx_get_resources(adapter, & res);
#line 3437
    adapter->res = res;
  } else {

  }
#line 3444
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 3445
    status = be_cmd_get_func_config(adapter, & res);
#line 3446
    if (status != 0) {
#line 3447
      return (status);
    } else {

    }
#line 3450
    if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 3451
      res.max_evt_qs = (u16 )((unsigned int )res.max_evt_qs / 2U);
    } else {

    }
#line 3452
    adapter->res = res;
#line 3454
    if ((unsigned int )adapter->virtfn == 0U) {
#line 3455
      status = be_cmd_get_profile_config(adapter, & res, 0);
#line 3456
      if (status != 0) {
#line 3457
        return (status);
      } else {

      }
#line 3458
      adapter->res.max_vfs = res.max_vfs;
    } else {

    }
#line 3461
    _dev_info((struct device  const  *)dev, "Max: txqs %d, rxqs %d, rss %d, eqs %d, vfs %d\n",
              (int )adapter->res.max_tx_qs, (int )adapter->res.max_rx_qs, (int )adapter->res.max_rss_qs,
              (int )adapter->res.max_evt_qs, (int )adapter->res.max_vfs);
#line 3465
    _dev_info((struct device  const  *)dev, "Max: uc-macs %d, mc-macs %d, vlans %d\n",
              (int )adapter->res.max_uc_mac, (int )adapter->res.max_mcast_mac, (int )adapter->res.max_vlans);
  } else {

  }
#line 3470
  return (0);
}
}
#line 3474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_get_config(struct be_adapter *adapter ) 
{ 
  u16 profile_id ;
  int status ;
  void *tmp ;
  u16 _min1 ;
  u16 _min2 ;
  u16 tmp___0 ;

  {
#line 3479
  status = be_cmd_query_fw_cfg(adapter, & adapter->port_num, & adapter->function_mode,
                               & adapter->function_caps, & adapter->asic_rev);
#line 3483
  if (status != 0) {
#line 3484
    return (status);
  } else {

  }
#line 3486
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3487
    status = be_cmd_get_active_profile(adapter, & profile_id);
#line 3488
    if (status == 0) {
#line 3489
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Using profile 0x%x\n",
                (int )profile_id);
    } else {

    }
  } else {

  }
#line 3493
  status = be_get_resources(adapter);
#line 3494
  if (status != 0) {
#line 3495
    return (status);
  } else {

  }
#line 3497
  tmp = kcalloc((size_t )adapter->res.max_uc_mac, 4UL, 208U);
#line 3497
  adapter->pmac_id = (u32 *)tmp;
#line 3499
  if ((unsigned long )adapter->pmac_id == (unsigned long )((u32 *)0U)) {
#line 3500
    return (-12);
  } else {

  }
#line 3503
  _min1 = adapter->cfg_num_qs;
#line 3503
  tmp___0 = be_max_qs(adapter);
#line 3503
  _min2 = tmp___0;
#line 3503
  adapter->cfg_num_qs = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 3505
  return (0);
}
}
#line 3508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_mac_setup(struct be_adapter *adapter ) 
{ 
  u8 mac[6U] ;
  int status ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  bool tmp ;

  {
#line 3513
  tmp = is_zero_ether_addr((u8 const   *)(adapter->netdev)->dev_addr);
#line 3513
  if ((int )tmp) {
#line 3514
    status = be_cmd_get_perm_mac(adapter, (u8 *)(& mac));
#line 3515
    if (status != 0) {
#line 3516
      return (status);
    } else {

    }
#line 3518
    __len = 6UL;
#line 3518
    if (__len > 63UL) {
#line 3518
      __ret = __memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac),
                       __len);
    } else {
#line 3518
      __ret = __builtin_memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac),
                               __len);
    }
#line 3519
    __len___0 = 6UL;
#line 3519
    if (__len___0 > 63UL) {
#line 3519
      __ret___0 = __memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac),
                           __len___0);
    } else {
#line 3519
      __ret___0 = __builtin_memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac),
                                   __len___0);
    }
  } else {
#line 3522
    __len___1 = 6UL;
#line 3522
    if (__len___1 > 63UL) {
#line 3522
      __ret___1 = __memcpy((void *)(& mac), (void const   *)(adapter->netdev)->dev_addr,
                           __len___1);
    } else {
#line 3522
      __ret___1 = __builtin_memcpy((void *)(& mac), (void const   *)(adapter->netdev)->dev_addr,
                                   __len___1);
    }
  }
#line 3526
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) || (unsigned int )adapter->virtfn == 0U) {
#line 3527
    be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )adapter->if_handle, adapter->pmac_id,
                    0U);
  } else {

  }
#line 3529
  return (0);
}
}
#line 3532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_schedule_worker(struct be_adapter *adapter ) 
{ 
  unsigned long tmp ;

  {
#line 3534
  tmp = msecs_to_jiffies(1000U);
#line 3534
  schedule_delayed_work(& adapter->work, tmp);
#line 3535
  adapter->flags = adapter->flags | 8U;
#line 3536
  return;
}
}
#line 3538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_setup_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 3540
  netdev = adapter->netdev;
#line 3543
  status = be_evt_queues_create(adapter);
#line 3544
  if (status != 0) {
#line 3545
    goto err;
  } else {

  }
#line 3547
  status = be_tx_qs_create(adapter);
#line 3548
  if (status != 0) {
#line 3549
    goto err;
  } else {

  }
#line 3551
  status = be_rx_cqs_create(adapter);
#line 3552
  if (status != 0) {
#line 3553
    goto err;
  } else {

  }
#line 3555
  status = be_mcc_queues_create(adapter);
#line 3556
  if (status != 0) {
#line 3557
    goto err;
  } else {

  }
#line 3559
  status = netif_set_real_num_rx_queues(netdev, (unsigned int )adapter->num_rx_qs);
#line 3560
  if (status != 0) {
#line 3561
    goto err;
  } else {

  }
#line 3563
  status = netif_set_real_num_tx_queues(netdev, (unsigned int )adapter->num_tx_qs);
#line 3564
  if (status != 0) {
#line 3565
    goto err;
  } else {

  }
#line 3567
  return (0);
  err: 
#line 3569
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "queue_setup failed\n");
#line 3570
  return (status);
}
}
#line 3573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int be_update_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 3575
  netdev = adapter->netdev;
#line 3578
  tmp = netif_running((struct net_device  const  *)netdev);
#line 3578
  if ((int )tmp) {
#line 3579
    be_close(netdev);
  } else {

  }
#line 3581
  be_cancel_worker(adapter);
#line 3586
  if (adapter->num_msix_roce_vec == 0U) {
#line 3587
    be_msix_disable(adapter);
  } else {

  }
#line 3589
  be_clear_queues(adapter);
#line 3591
  if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 3592
    status = be_msix_enable(adapter);
#line 3593
    if (status != 0) {
#line 3594
      return (status);
    } else {

    }
  } else {

  }
#line 3597
  status = be_setup_queues(adapter);
#line 3598
  if (status != 0) {
#line 3599
    return (status);
  } else {

  }
#line 3601
  be_schedule_worker(adapter);
#line 3603
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 3603
  if ((int )tmp___0) {
#line 3604
    status = be_open(netdev);
  } else {

  }
#line 3606
  return (status);
}
}
#line 3609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  u32 tx_fc ;
  u32 rx_fc ;
  u32 en_flags ;
  int status ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 3611
  dev = & (adapter->pdev)->dev;
#line 3615
  be_setup_init(adapter);
#line 3617
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3618
    be_cmd_req_native_mode(adapter);
  } else {

  }
#line 3620
  status = be_get_config(adapter);
#line 3621
  if (status != 0) {
#line 3622
    goto err;
  } else {

  }
#line 3624
  status = be_msix_enable(adapter);
#line 3625
  if (status != 0) {
#line 3626
    goto err;
  } else {

  }
#line 3628
  en_flags = 6192U;
#line 3630
  if ((adapter->function_caps & 2U) != 0U) {
#line 3631
    en_flags = en_flags | 4U;
  } else {

  }
#line 3632
  en_flags = adapter->res.if_cap_flags & en_flags;
#line 3633
  status = be_cmd_if_create(adapter, adapter->res.if_cap_flags, en_flags, (u32 *)(& adapter->if_handle),
                            0U);
#line 3635
  if (status != 0) {
#line 3636
    goto err;
  } else {

  }
#line 3639
  rtnl_lock();
#line 3640
  status = be_setup_queues(adapter);
#line 3641
  rtnl_unlock();
#line 3642
  if (status != 0) {
#line 3643
    goto err;
  } else {

  }
#line 3645
  be_cmd_get_fn_privileges(adapter, & adapter->cmd_privileges, 0U);
#line 3647
  status = be_mac_setup(adapter);
#line 3648
  if (status != 0) {
#line 3649
    goto err;
  } else {

  }
#line 3651
  be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), (char *)(& adapter->fw_on_flash));
#line 3653
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 3653
    tmp = fw_major_num((char const   *)(& adapter->fw_ver));
#line 3653
    if (tmp <= 3) {
#line 3654
      dev_err((struct device  const  *)dev, "Firmware on card is old(%s), IRQs may not work.",
              (char *)(& adapter->fw_ver));
#line 3656
      dev_err((struct device  const  *)dev, "Please upgrade firmware to version >= 4.0\n");
    } else {

    }
  } else {

  }
#line 3659
  if ((unsigned int )adapter->vlans_added != 0U) {
#line 3660
    be_vid_config(adapter);
  } else {

  }
#line 3662
  be_set_rx_mode(adapter->netdev);
#line 3664
  be_cmd_get_acpi_wol_cap(adapter);
#line 3666
  be_cmd_get_flow_control(adapter, & tx_fc, & rx_fc);
#line 3668
  if (adapter->rx_fc != rx_fc || adapter->tx_fc != tx_fc) {
#line 3669
    be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
  } else {

  }
#line 3672
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3673
    be_cmd_set_logical_link_config(adapter, 0, 0);
  } else {

  }
#line 3676
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3676
    if (num_vfs != 0U) {
#line 3676
      goto _L;
    } else {
#line 3676
      tmp___0 = pci_num_vf(adapter->pdev);
#line 3676
      if (tmp___0 != 0) {
        _L: /* CIL Label */ 
#line 3677
        if ((unsigned int )adapter->res.max_vfs != 0U) {
#line 3678
          be_vf_setup(adapter);
        } else {
#line 3680
          dev_warn((struct device  const  *)dev, "device doesn\'t support SRIOV\n");
        }
      } else {

      }
    }
  } else {

  }
#line 3683
  status = be_cmd_get_phy_info(adapter);
#line 3684
  if (status == 0) {
#line 3684
    tmp___1 = be_pause_supported(adapter);
#line 3684
    if ((int )tmp___1) {
#line 3685
      adapter->phy.fc_autoneg = 1U;
    } else {

    }
  } else {

  }
#line 3687
  be_schedule_worker(adapter);
#line 3688
  adapter->flags = adapter->flags | 8192U;
#line 3689
  return (0);
  err: 
#line 3691
  be_clear(adapter);
#line 3692
  return (status);
}
}
#line 3696 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_netpoll(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 3698
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3698
  adapter = (struct be_adapter *)tmp;
#line 3702
  i = 0;
#line 3702
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3702
  goto ldv_56356;
  ldv_56355: 
#line 3703
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 3704
  napi_schedule(& eqo->napi);
#line 3702
  i = i + 1;
#line 3702
  eqo = eqo + 1;
  ldv_56356: ;
#line 3702
  if ((int )adapter->num_evt_qs > i) {
#line 3704
    goto ldv_56355;
  } else {

  }

#line 3707
  return;
}
}
#line 3711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static char flash_cookie[2U][16U]  = { {        '*',        '*',        '*',        ' ', 
            'S',        'E',        ' ',        'F', 
            'L',        'A',        'S',        '\000'}, 
   {        'H',        ' ',        'D',        'I', 
            'R',        'E',        'C',        'T', 
            'O',        'R',        'Y',        ' ', 
            '*',        '*',        '*',        ' '}};
#line 3713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static bool phy_flashing_required(struct be_adapter *adapter ) 
{ 


  {
#line 3715
  return ((bool )((unsigned int )adapter->phy.phy_type == 13U && (unsigned int )adapter->phy.interface_type == 6U));
}
}
#line 3719 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static bool is_comp_in_ufi(struct be_adapter *adapter , struct flash_section_info *fsec ,
                           int type ) 
{ 
  int i ;
  int img_type ;
  struct flash_section_info_g2 *fsec_g2 ;

  {
#line 3722
  i = 0;
#line 3722
  img_type = 0;
#line 3723
  fsec_g2 = (struct flash_section_info_g2 *)0;
#line 3725
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 3726
    fsec_g2 = (struct flash_section_info_g2 *)fsec;
  } else {

  }
#line 3728
  i = 0;
#line 3728
  goto ldv_56371;
  ldv_56370: ;
#line 3729
  if ((unsigned long )fsec_g2 != (unsigned long )((struct flash_section_info_g2 *)0)) {
#line 3730
    img_type = (int )fsec_g2->fsec_entry[i].type;
  } else {
#line 3732
    img_type = (int )fsec->fsec_entry[i].type;
  }
#line 3734
  if (img_type == type) {
#line 3735
    return (1);
  } else {

  }
#line 3728
  i = i + 1;
  ldv_56371: ;
#line 3728
  if (i <= 31) {
#line 3730
    goto ldv_56370;
  } else {

  }

#line 3737
  return (0);
}
}
#line 3741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct flash_section_info *get_fsec_info(struct be_adapter *adapter , int header_size ,
                                                struct firmware  const  *fw ) 
{ 
  struct flash_section_info *fsec ;
  u8 const   *p ;
  int tmp ;

  {
#line 3745
  fsec = (struct flash_section_info *)0;
#line 3746
  p = fw->data;
#line 3748
  p = p + (unsigned long )header_size;
#line 3749
  goto ldv_56381;
  ldv_56380: 
#line 3750
  fsec = (struct flash_section_info *)p;
#line 3751
  tmp = memcmp((void const   *)(& flash_cookie), (void const   *)(& fsec->cookie),
               32UL);
#line 3751
  if (tmp == 0) {
#line 3752
    return (fsec);
  } else {

  }
#line 3753
  p = p + 32UL;
  ldv_56381: ;
#line 3749
  if ((unsigned long )((unsigned char const   *)(fw->data + fw->size)) > (unsigned long )p) {
#line 3751
    goto ldv_56380;
  } else {

  }

#line 3755
  return ((struct flash_section_info *)0);
}
}
#line 3758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_check_flash_crc(struct be_adapter *adapter , u8 const   *p , u32 img_offset ,
                              u32 img_size , int hdr_size , u16 img_optype , bool *crc_match ) 
{ 
  u32 crc_offset ;
  int status ;
  u8 crc[4U] ;
  int tmp ;

  {
#line 3766
  status = be_cmd_get_flash_crc(adapter, (u8 *)(& crc), (int )img_optype, (int )(img_size - 4U));
#line 3767
  if (status != 0) {
#line 3768
    return (status);
  } else {

  }
#line 3770
  crc_offset = (((u32 )hdr_size + img_offset) + img_size) - 4U;
#line 3773
  tmp = memcmp((void const   *)(& crc), (void const   *)p + (unsigned long )crc_offset,
               4UL);
#line 3773
  if (tmp == 0) {
#line 3774
    *crc_match = 1;
  } else {
#line 3776
    *crc_match = 0;
  }
#line 3778
  return (status);
}
}
#line 3781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_flash(struct be_adapter *adapter , u8 const   *img , struct be_dma_mem *flash_cmd ,
                    int optype , int img_size ) 
{ 
  struct be_cmd_write_flashrom *req ;
  u32 total_bytes ;
  u32 flash_op ;
  u32 num_bytes ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 3784
  req = (struct be_cmd_write_flashrom *)flash_cmd->va;
#line 3788
  total_bytes = (u32 )img_size;
#line 3789
  goto ldv_56415;
  ldv_56414: 
#line 3790
  __min1 = 32768U;
#line 3790
  __min2 = total_bytes;
#line 3790
  num_bytes = __min1 < __min2 ? __min1 : __min2;
#line 3792
  total_bytes = total_bytes - num_bytes;
#line 3794
  if (total_bytes == 0U) {
#line 3795
    if (optype == 99) {
#line 3796
      flash_op = 9U;
    } else {
#line 3798
      flash_op = 1U;
    }
  } else
#line 3800
  if (optype == 99) {
#line 3801
    flash_op = 10U;
  } else {
#line 3803
    flash_op = 2U;
  }
#line 3806
  __len = (size_t )num_bytes;
#line 3806
  __ret = __builtin_memcpy((void *)(& req->data_buf), (void const   *)img, __len);
#line 3807
  img = img + (unsigned long )num_bytes;
#line 3808
  status = be_cmd_write_flashrom(adapter, flash_cmd, (u32 )optype, flash_op, num_bytes);
#line 3810
  if ((status > 0 && ((unsigned int )status & 65535U) == 2U) && optype == 99) {
#line 3812
    goto ldv_56413;
  } else
#line 3813
  if (status != 0) {
#line 3814
    return (status);
  } else {

  }
  ldv_56415: ;
#line 3789
  if (total_bytes != 0U) {
#line 3791
    goto ldv_56414;
  } else {

  }
  ldv_56413: ;
#line 3816
  return (0);
}
}
#line 3820 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_flash_BEx(struct be_adapter *adapter , struct firmware  const  *fw ,
                        struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int img_hdrs_size ;
  struct device *dev ;
  struct flash_section_info *fsec ;
  int status ;
  int i ;
  int filehdr_size ;
  int num_comp ;
  struct flash_comp  const  *pflashcomp ;
  bool crc_match ;
  u8 const   *p ;
  struct flash_comp gen3_flash_types[10U] ;
  struct flash_comp gen2_flash_types[8U] ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 3824
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3825
  dev = & (adapter->pdev)->dev;
#line 3826
  fsec = (struct flash_section_info *)0;
#line 3832
  gen3_flash_types[0].offset = 2097152UL;
#line 3832
  gen3_flash_types[0].optype = 0;
#line 3832
  gen3_flash_types[0].size = 2097152;
#line 3832
  gen3_flash_types[0].img_type = 160;
#line 3832
  gen3_flash_types[1].offset = 262144UL;
#line 3832
  gen3_flash_types[1].optype = 1;
#line 3832
  gen3_flash_types[1].size = 1048576;
#line 3832
  gen3_flash_types[1].img_type = 224;
#line 3832
  gen3_flash_types[2].offset = 12582912UL;
#line 3832
  gen3_flash_types[2].optype = 2;
#line 3832
  gen3_flash_types[2].size = 524288;
#line 3832
  gen3_flash_types[2].img_type = 34;
#line 3832
  gen3_flash_types[3].offset = 13107200UL;
#line 3832
  gen3_flash_types[3].optype = 3;
#line 3832
  gen3_flash_types[3].size = 524288;
#line 3832
  gen3_flash_types[3].img_type = 32;
#line 3832
  gen3_flash_types[4].offset = 13631488UL;
#line 3832
  gen3_flash_types[4].optype = 8;
#line 3832
  gen3_flash_types[4].size = 524288;
#line 3832
  gen3_flash_types[4].img_type = 33;
#line 3832
  gen3_flash_types[5].offset = 4194304UL;
#line 3832
  gen3_flash_types[5].optype = 9;
#line 3832
  gen3_flash_types[5].size = 2097152;
#line 3832
  gen3_flash_types[5].img_type = 176;
#line 3832
  gen3_flash_types[6].offset = 6291456UL;
#line 3832
  gen3_flash_types[6].optype = 10;
#line 3832
  gen3_flash_types[6].size = 2097152;
#line 3832
  gen3_flash_types[6].img_type = 162;
#line 3832
  gen3_flash_types[7].offset = 8388608UL;
#line 3832
  gen3_flash_types[7].optype = 11;
#line 3832
  gen3_flash_types[7].size = 2097152;
#line 3832
  gen3_flash_types[7].img_type = 178;
#line 3832
  gen3_flash_types[8].offset = 15990784UL;
#line 3832
  gen3_flash_types[8].optype = 13;
#line 3832
  gen3_flash_types[8].size = 262144;
#line 3832
  gen3_flash_types[8].img_type = 16;
#line 3832
  gen3_flash_types[9].offset = 1310720UL;
#line 3832
  gen3_flash_types[9].optype = 99;
#line 3832
  gen3_flash_types[9].size = 262144;
#line 3832
  gen3_flash_types[9].img_type = 192;
#line 3855
  gen2_flash_types[0].offset = 1048576UL;
#line 3855
  gen2_flash_types[0].optype = 0;
#line 3855
  gen2_flash_types[0].size = 1310720;
#line 3855
  gen2_flash_types[0].img_type = 160;
#line 3855
  gen2_flash_types[1].offset = 0UL;
#line 3855
  gen2_flash_types[1].optype = 1;
#line 3855
  gen2_flash_types[1].size = 262144;
#line 3855
  gen2_flash_types[1].img_type = 224;
#line 3855
  gen2_flash_types[2].offset = 7340032UL;
#line 3855
  gen2_flash_types[2].optype = 2;
#line 3855
  gen2_flash_types[2].size = 262144;
#line 3855
  gen2_flash_types[2].img_type = 34;
#line 3855
  gen2_flash_types[3].offset = 7864320UL;
#line 3855
  gen2_flash_types[3].optype = 3;
#line 3855
  gen2_flash_types[3].size = 262144;
#line 3855
  gen2_flash_types[3].img_type = 32;
#line 3855
  gen2_flash_types[4].offset = 524288UL;
#line 3855
  gen2_flash_types[4].optype = 8;
#line 3855
  gen2_flash_types[4].size = 262144;
#line 3855
  gen2_flash_types[4].img_type = 33;
#line 3855
  gen2_flash_types[5].offset = 2359296UL;
#line 3855
  gen2_flash_types[5].optype = 9;
#line 3855
  gen2_flash_types[5].size = 1310720;
#line 3855
  gen2_flash_types[5].img_type = 176;
#line 3855
  gen2_flash_types[6].offset = 3670016UL;
#line 3855
  gen2_flash_types[6].optype = 10;
#line 3855
  gen2_flash_types[6].size = 1310720;
#line 3855
  gen2_flash_types[6].img_type = 162;
#line 3855
  gen2_flash_types[7].offset = 4980736UL;
#line 3855
  gen2_flash_types[7].optype = 11;
#line 3855
  gen2_flash_types[7].size = 1310720;
#line 3855
  gen2_flash_types[7].img_type = 178;
#line 3874
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3875
    pflashcomp = (struct flash_comp  const  *)(& gen3_flash_types);
#line 3876
    filehdr_size = 128;
#line 3877
    num_comp = 10;
  } else {
#line 3879
    pflashcomp = (struct flash_comp  const  *)(& gen2_flash_types);
#line 3880
    filehdr_size = 96;
#line 3881
    num_comp = 8;
  }
#line 3885
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 3886
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 3887
    dev_err((struct device  const  *)dev, "Invalid Cookie. FW image may be corrupted\n");
#line 3888
    return (-1);
  } else {

  }
#line 3890
  i = 0;
#line 3890
  goto ldv_56440;
  ldv_56439: 
#line 3891
  tmp = is_comp_in_ufi(adapter, fsec, (pflashcomp + (unsigned long )i)->img_type);
#line 3891
  if (tmp) {
#line 3891
    tmp___0 = 0;
  } else {
#line 3891
    tmp___0 = 1;
  }
#line 3891
  if (tmp___0) {
#line 3892
    goto ldv_56438;
  } else {

  }
#line 3894
  if ((int )(pflashcomp + (unsigned long )i)->optype == 13) {
#line 3894
    tmp___1 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)"3.102.148.0",
                     11UL);
#line 3894
    if (tmp___1 < 0) {
#line 3896
      goto ldv_56438;
    } else {

    }
  } else {

  }
#line 3898
  if ((int )(pflashcomp + (unsigned long )i)->optype == 99) {
#line 3898
    tmp___2 = phy_flashing_required(adapter);
#line 3898
    if (tmp___2) {
#line 3898
      tmp___3 = 0;
    } else {
#line 3898
      tmp___3 = 1;
    }
#line 3898
    if (tmp___3) {
#line 3900
      goto ldv_56438;
    } else {

    }
  } else {

  }
#line 3902
  if ((int )(pflashcomp + (unsigned long )i)->optype == 1) {
#line 3903
    status = be_check_flash_crc(adapter, fw->data, (u32 )(pflashcomp + (unsigned long )i)->offset,
                                (u32 )(pflashcomp + (unsigned long )i)->size, filehdr_size + img_hdrs_size,
                                1, & crc_match);
#line 3909
    if (status != 0) {
#line 3910
      dev_err((struct device  const  *)dev, "Could not get CRC for 0x%x region\n",
              (pflashcomp + (unsigned long )i)->optype);
#line 3913
      goto ldv_56438;
    } else {

    }
#line 3916
    if ((int )crc_match) {
#line 3917
      goto ldv_56438;
    } else {

    }
  } else {

  }
#line 3920
  p = fw->data + (((unsigned long )filehdr_size + (unsigned long )(pflashcomp + (unsigned long )i)->offset) + (unsigned long )img_hdrs_size);
#line 3922
  if ((unsigned long )(p + (unsigned long )(pflashcomp + (unsigned long )i)->size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3923
    return (-1);
  } else {

  }
#line 3925
  status = be_flash(adapter, p, flash_cmd, (pflashcomp + (unsigned long )i)->optype,
                    (pflashcomp + (unsigned long )i)->size);
#line 3927
  if (status != 0) {
#line 3928
    dev_err((struct device  const  *)dev, "Flashing section type 0x%x failed\n", (pflashcomp + (unsigned long )i)->img_type);
#line 3930
    return (status);
  } else {

  }
  ldv_56438: 
#line 3890
  i = i + 1;
  ldv_56440: ;
#line 3890
  if (i < num_comp) {
#line 3892
    goto ldv_56439;
  } else {

  }

#line 3933
  return (0);
}
}
#line 3936 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static u16 be_get_img_optype(struct flash_section_entry fsec_entry ) 
{ 
  u32 img_type ;
  u16 img_optype ;

  {
#line 3938
  img_type = fsec_entry.type;
#line 3939
  img_optype = fsec_entry.optype;
#line 3941
  if ((unsigned int )img_optype != 65535U) {
#line 3942
    return (img_optype);
  } else {

  }
#line 3944
  switch (img_type) {
  case 160U: 
#line 3946
  img_optype = 0U;
#line 3947
  goto ldv_56448;
  case 224U: 
#line 3949
  img_optype = 1U;
#line 3950
  goto ldv_56448;
  case 34U: 
#line 3952
  img_optype = 2U;
#line 3953
  goto ldv_56448;
  case 32U: 
#line 3955
  img_optype = 3U;
#line 3956
  goto ldv_56448;
  case 33U: 
#line 3958
  img_optype = 8U;
#line 3959
  goto ldv_56448;
  case 176U: 
#line 3961
  img_optype = 9U;
#line 3962
  goto ldv_56448;
  case 16U: 
#line 3964
  img_optype = 13U;
#line 3965
  goto ldv_56448;
  case 48U: 
#line 3967
  img_optype = 22U;
#line 3968
  goto ldv_56448;
  case 192U: 
#line 3970
  img_optype = 21U;
#line 3971
  goto ldv_56448;
  case 208U: 
#line 3973
  img_optype = 18U;
#line 3974
  goto ldv_56448;
  case 209U: 
#line 3976
  img_optype = 19U;
#line 3977
  goto ldv_56448;
  case 210U: 
#line 3979
  img_optype = 23U;
#line 3980
  goto ldv_56448;
  default: ;
#line 3982
  goto ldv_56448;
  }
  ldv_56448: ;
#line 3985
  return (img_optype);
}
}
#line 3988 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_flash_skyhawk(struct be_adapter *adapter , struct firmware  const  *fw ,
                            struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int img_hdrs_size ;
  struct device *dev ;
  struct flash_section_info *fsec ;
  u32 img_offset ;
  u32 img_size ;
  u32 img_type ;
  int status ;
  int i ;
  int filehdr_size ;
  bool crc_match ;
  bool old_fw_img ;
  u16 img_optype ;
  u8 const   *p ;

  {
#line 3992
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3993
  dev = & (adapter->pdev)->dev;
#line 3994
  fsec = (struct flash_section_info *)0;
#line 4001
  filehdr_size = 128;
#line 4002
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 4003
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 4004
    dev_err((struct device  const  *)dev, "Invalid Cookie. FW image may be corrupted\n");
#line 4005
    return (-1);
  } else {

  }
#line 4008
  i = 0;
#line 4008
  goto ldv_56483;
  ldv_56482: 
#line 4009
  img_offset = fsec->fsec_entry[i].offset;
#line 4010
  img_size = fsec->fsec_entry[i].pad_size;
#line 4011
  img_type = fsec->fsec_entry[i].type;
#line 4012
  img_optype = be_get_img_optype(fsec->fsec_entry[i]);
#line 4013
  old_fw_img = (unsigned int )fsec->fsec_entry[i].optype == 65535U;
#line 4015
  if ((unsigned int )img_optype == 65535U) {
#line 4016
    goto ldv_56480;
  } else {

  }
#line 4020
  if ((int )old_fw_img) {
#line 4021
    goto flash;
  } else {

  }
#line 4023
  status = be_check_flash_crc(adapter, fw->data, img_offset, img_size, filehdr_size + img_hdrs_size,
                              (int )img_optype, & crc_match);
#line 4033
  if ((status > 0 && ((unsigned int )status & 65535U) == 2U) || (status > 0 && ((unsigned int )status & 65535U) == 3U)) {
#line 4035
    dev_err((struct device  const  *)dev, "Flash incomplete. Reset the server\n");
#line 4036
    dev_err((struct device  const  *)dev, "Download FW image again after reset\n");
#line 4037
    return (-11);
  } else
#line 4038
  if (status != 0) {
#line 4039
    dev_err((struct device  const  *)dev, "Could not get CRC for 0x%x region\n", (int )img_optype);
#line 4041
    return (-14);
  } else {

  }
#line 4044
  if ((int )crc_match) {
#line 4045
    goto ldv_56480;
  } else {

  }
  flash: 
#line 4048
  p = fw->data + (((unsigned long )filehdr_size + (unsigned long )img_offset) + (unsigned long )img_hdrs_size);
#line 4049
  if ((unsigned long )(p + (unsigned long )img_size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 4050
    return (-1);
  } else {

  }
#line 4052
  status = be_flash(adapter, p, flash_cmd, (int )img_optype, (int )img_size);
#line 4056
  if ((int )old_fw_img && ((status > 0 && ((unsigned int )status & 65535U) == 3U) || ((unsigned int )img_optype == 23U && (status > 0 && ((unsigned int )status & 65535U) == 1U)))) {
#line 4060
    goto ldv_56480;
  } else
#line 4061
  if (status != 0) {
#line 4062
    dev_err((struct device  const  *)dev, "Flashing section type 0x%x failed\n", img_type);
#line 4064
    return (-14);
  } else {

  }
  ldv_56480: 
#line 4008
  i = i + 1;
  ldv_56483: ;
#line 4008
  if ((u32 )i < fsec->fsec_hdr.num_images) {
#line 4010
    goto ldv_56482;
  } else {

  }

#line 4067
  return (0);
}
}
#line 4070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int lancer_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct be_dma_mem flash_cmd ;
  u8 const   *data_ptr ;
  u8 *dest_image_ptr ;
  size_t image_size ;
  u32 chunk_size ;
  u32 data_written ;
  u32 offset ;
  int status ;
  u8 add_status ;
  u8 change_status ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 4076
  data_ptr = (u8 const   *)0U;
#line 4077
  dest_image_ptr = (u8 *)0U;
#line 4078
  image_size = 0UL;
#line 4079
  chunk_size = 0U;
#line 4080
  data_written = 0U;
#line 4081
  offset = 0U;
#line 4082
  status = 0;
#line 4083
  add_status = 0U;
#line 4086
  if (((unsigned long )fw->size & 3UL) != 0UL) {
#line 4087
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW Image not properly aligned. Length must be 4 byte aligned.\n");
#line 4090
    status = -22;
#line 4091
    goto lancer_fw_exit;
  } else {

  }
#line 4094
  flash_cmd.size = 32912U;
#line 4096
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, (struct dma_attrs *)0);
#line 4098
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 4099
    status = -12;
#line 4100
    goto lancer_fw_exit;
  } else {

  }
#line 4103
  dest_image_ptr = (u8 *)flash_cmd.va + 144U;
#line 4105
  image_size = fw->size;
#line 4106
  data_ptr = fw->data;
#line 4108
  goto ldv_56508;
  ldv_56507: 
#line 4109
  __min1 = (u32 )image_size;
#line 4109
  __min2 = 32768U;
#line 4109
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 4112
  __len = (size_t )chunk_size;
#line 4112
  __ret = __builtin_memcpy((void *)dest_image_ptr, (void const   *)data_ptr, __len);
#line 4114
  status = lancer_cmd_write_object(adapter, & flash_cmd, chunk_size, offset, "/prg",
                                   & data_written, & change_status, & add_status);
#line 4119
  if (status != 0) {
#line 4120
    goto ldv_56506;
  } else {

  }
#line 4122
  offset = offset + data_written;
#line 4123
  data_ptr = data_ptr + (unsigned long )data_written;
#line 4124
  image_size = image_size - (size_t )data_written;
  ldv_56508: ;
#line 4108
  if (image_size != 0UL) {
#line 4110
    goto ldv_56507;
  } else {

  }
  ldv_56506: ;
#line 4127
  if (status == 0) {
#line 4129
    status = lancer_cmd_write_object(adapter, & flash_cmd, 0U, offset, "/prg", & data_written,
                                     & change_status, & add_status);
  } else {

  }
#line 4136
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 (struct dma_attrs *)0);
#line 4138
  if (status != 0) {
#line 4139
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error. Status code: 0x%x Additional Status: 0x%x\n",
            status, (int )add_status);
#line 4143
    goto lancer_fw_exit;
  } else {

  }
#line 4146
  if ((unsigned int )change_status == 2U) {
#line 4147
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Resetting adapter to activate new FW\n");
#line 4149
    status = lancer_physdev_ctrl(adapter, 2U);
#line 4151
    if (status != 0) {
#line 4152
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter busy for FW reset.\nNew FW will not be active.\n");
#line 4155
      goto lancer_fw_exit;
    } else {

    }
  } else
#line 4157
  if ((unsigned int )change_status != 0U) {
#line 4158
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "System reboot required for new FW to be active\n");
  } else {

  }
#line 4162
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  lancer_fw_exit: ;
#line 4164
  return (status);
}
}
#line 4171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_get_ufi_type(struct be_adapter *adapter , struct flash_file_hdr_g3 *fhdr ) 
{ 


  {
#line 4174
  if ((unsigned long )fhdr == (unsigned long )((struct flash_file_hdr_g3 *)0)) {
#line 4175
    goto be_get_ufi_exit;
  } else {

  }
#line 4177
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (unsigned int )fhdr->build[0] == 52U) {
#line 4178
    return (4);
  } else
#line 4179
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )fhdr->build[0] == 51U) {
#line 4180
    if ((unsigned int )fhdr->asic_type_rev == 16U) {
#line 4181
      return (10);
    } else {
#line 4183
      return (3);
    }
  } else
#line 4184
  if (((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) && (unsigned int )fhdr->build[0] == 50U) {
#line 4185
    return (2);
  } else {

  }
  be_get_ufi_exit: 
#line 4188
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UFI and Interface are not compatible for flashing\n");
#line 4190
  return (-1);
}
}
#line 4193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct flash_file_hdr_g3 *fhdr3 ;
  struct image_hdr *img_hdr_ptr ;
  struct be_dma_mem flash_cmd ;
  u8 const   *p ;
  int status ;
  int i ;
  int num_imgs ;
  int ufi_type ;

  {
#line 4196
  img_hdr_ptr = (struct image_hdr *)0;
#line 4199
  status = 0;
#line 4199
  i = 0;
#line 4199
  num_imgs = 0;
#line 4199
  ufi_type = 0;
#line 4201
  flash_cmd.size = 32804U;
#line 4202
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, (struct dma_attrs *)0);
#line 4204
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 4205
    status = -12;
#line 4206
    goto be_fw_exit;
  } else {

  }
#line 4209
  p = fw->data;
#line 4210
  fhdr3 = (struct flash_file_hdr_g3 *)p;
#line 4212
  ufi_type = be_get_ufi_type(adapter, fhdr3);
#line 4214
  num_imgs = (int )fhdr3->num_imgs;
#line 4215
  i = 0;
#line 4215
  goto ldv_56532;
  ldv_56531: 
#line 4216
  img_hdr_ptr = (struct image_hdr *)(fw->data + ((unsigned long )i * 48UL + 128UL));
#line 4219
  if (img_hdr_ptr->imageid == 1U) {
#line 4220
    switch (ufi_type) {
    case 4: 
#line 4222
    status = be_flash_skyhawk(adapter, fw, & flash_cmd, num_imgs);
#line 4224
    goto ldv_56528;
    case 10: 
#line 4226
    status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
#line 4228
    goto ldv_56528;
    case 3: ;
#line 4231
    if ((unsigned int )adapter->asic_rev <= 15U) {
#line 4232
      status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
    } else {
#line 4236
      status = -1;
#line 4237
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Can\'t load BE3 UFI on BE3R\n");
    }
    }
    ldv_56528: ;
  } else {

  }
#line 4215
  i = i + 1;
  ldv_56532: ;
#line 4215
  if (i < num_imgs) {
#line 4217
    goto ldv_56531;
  } else {

  }

#line 4244
  if (ufi_type == 2) {
#line 4245
    status = be_flash_BEx(adapter, fw, & flash_cmd, 0);
  } else
#line 4246
  if (ufi_type == -1) {
#line 4247
    status = -1;
  } else {

  }
#line 4249
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 (struct dma_attrs *)0);
#line 4251
  if (status != 0) {
#line 4252
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error\n");
#line 4253
    goto be_fw_exit;
  } else {

  }
#line 4256
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  be_fw_exit: ;
#line 4259
  return (status);
}
}
#line 4262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) 
{ 
  struct firmware  const  *fw ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 4267
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 4267
  if (tmp) {
#line 4267
    tmp___0 = 0;
  } else {
#line 4267
    tmp___0 = 1;
  }
#line 4267
  if (tmp___0) {
#line 4268
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load not allowed (interface is down)\n");
#line 4270
    return (-1);
  } else {

  }
#line 4273
  status = request_firmware(& fw, (char const   *)fw_file, & (adapter->pdev)->dev);
#line 4274
  if (status != 0) {
#line 4275
    goto fw_exit;
  } else {

  }
#line 4277
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Flashing firmware file %s\n",
            fw_file);
#line 4279
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4280
    status = lancer_fw_download(adapter, fw);
  } else {
#line 4282
    status = be_fw_download(adapter, fw);
  }
#line 4284
  if (status == 0) {
#line 4285
    be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), (char *)(& adapter->fw_on_flash));
  } else {

  }
  fw_exit: 
#line 4289
  release_firmware(fw);
#line 4290
  return (status);
}
}
#line 4293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_ndo_bridge_setlink(struct net_device *dev , struct nlmsghdr *nlh ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct nlattr *attr ;
  struct nlattr *br_spec ;
  int rem ;
  int status ;
  u16 mode ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4295
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 4295
  adapter = (struct be_adapter *)tmp;
#line 4298
  status = 0;
#line 4299
  mode = 0U;
#line 4301
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 4302
    return (-95);
  } else {

  }
#line 4304
  br_spec = nlmsg_find_attr((struct nlmsghdr  const  *)nlh, 16, 26);
#line 4306
  tmp___0 = nla_data((struct nlattr  const  *)br_spec);
#line 4306
  attr = (struct nlattr *)tmp___0;
#line 4306
  rem = nla_len((struct nlattr  const  *)br_spec);
#line 4306
  goto ldv_56554;
  ldv_56553: 
#line 4307
  tmp___1 = nla_type((struct nlattr  const  *)attr);
#line 4307
  if (tmp___1 != 1) {
#line 4308
    goto ldv_56551;
  } else {

  }
#line 4310
  mode = nla_get_u16((struct nlattr  const  *)attr);
#line 4311
  if ((unsigned int )mode != 1U && (unsigned int )mode != 0U) {
#line 4312
    return (-22);
  } else {

  }
#line 4314
  status = be_cmd_set_hsw_config(adapter, 0, 0U, (int )((u16 )adapter->if_handle),
                                 (unsigned int )mode == 1U ? 3 : 2);
#line 4319
  if (status != 0) {
#line 4320
    goto err;
  } else {

  }
#line 4322
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "enabled switch mode: %s\n",
            (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
#line 4325
  return (status);
  ldv_56551: 
#line 4306
  attr = nla_next((struct nlattr  const  *)attr, & rem);
  ldv_56554: 
#line 4306
  tmp___2 = nla_ok((struct nlattr  const  *)attr, rem);
#line 4306
  if (tmp___2 != 0) {
#line 4308
    goto ldv_56553;
  } else {

  }

  err: 
#line 4328
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to set switch mode %s\n",
          (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
#line 4331
  return (status);
}
}
#line 4334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_ndo_bridge_getlink(struct sk_buff *skb , u32 pid , u32 seq , struct net_device *dev ,
                                 u32 filter_mask ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 hsw_mode ;
  int tmp___0 ;

  {
#line 4337
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 4337
  adapter = (struct be_adapter *)tmp;
#line 4338
  status = 0;
#line 4341
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 4342
    return (0);
  } else {

  }
#line 4345
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 4346
    hsw_mode = 2U;
  } else {
#line 4348
    status = be_cmd_get_hsw_config(adapter, (u16 *)0U, 0U, (int )((u16 )adapter->if_handle),
                                   & hsw_mode);
#line 4350
    if (status != 0) {
#line 4351
      return (0);
    } else {

    }
  }
#line 4354
  tmp___0 = ndo_dflt_bridge_getlink(skb, pid, seq, dev, (unsigned int )hsw_mode == 3U);
#line 4354
  return (tmp___0);
}
}
#line 4360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_add_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                              __be16 port ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int status ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 4363
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4363
  adapter = (struct be_adapter *)tmp;
#line 4364
  dev = & (adapter->pdev)->dev;
#line 4367
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 4368
    return;
  } else {

  }
#line 4370
  if ((adapter->flags & 4096U) != 0U) {
#line 4371
    tmp___0 = __fswab16((int )port);
#line 4371
    dev_warn((struct device  const  *)dev, "Cannot add UDP port %d for VxLAN offloads\n",
             (int )tmp___0);
#line 4373
    _dev_info((struct device  const  *)dev, "Only one UDP port supported for VxLAN offloads\n");
#line 4375
    return;
  } else {

  }
#line 4378
  status = be_cmd_manage_iface(adapter, (u32 )adapter->if_handle, 0);
#line 4380
  if (status != 0) {
#line 4381
    dev_warn((struct device  const  *)dev, "Failed to convert normal interface to tunnel\n");
#line 4382
    goto err;
  } else {

  }
#line 4385
  status = be_cmd_set_vxlan_port(adapter, (int )port);
#line 4386
  if (status != 0) {
#line 4387
    dev_warn((struct device  const  *)dev, "Failed to add VxLAN port\n");
#line 4388
    goto err;
  } else {

  }
#line 4390
  adapter->flags = adapter->flags | 4096U;
#line 4391
  adapter->vxlan_port = port;
#line 4393
  tmp___1 = __fswab16((int )port);
#line 4393
  _dev_info((struct device  const  *)dev, "Enabled VxLAN offloads for UDP port %d\n",
            (int )tmp___1);
#line 4395
  return;
  err: 
#line 4397
  be_disable_vxlan_offloads(adapter);
#line 4398
  return;
}
}
#line 4401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_del_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                              __be16 port ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 4404
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4404
  adapter = (struct be_adapter *)tmp;
#line 4406
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 4407
    return;
  } else {

  }
#line 4409
  if ((int )adapter->vxlan_port != (int )port) {
#line 4410
    return;
  } else {

  }
#line 4412
  be_disable_vxlan_offloads(adapter);
#line 4414
  tmp___0 = __fswab16((int )port);
#line 4414
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabled VxLAN offloads for UDP port %d\n",
            (int )tmp___0);
#line 4415
  return;
}
}
#line 4420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct net_device_ops  const  be_netdev_ops  = 
#line 4420
     {0, 0, & be_open, & be_close, & be_xmit, 0, 0, & be_set_rx_mode, & be_mac_addr_set,
    & eth_validate_addr, 0, 0, & be_change_mtu, 0, 0, & be_get_stats64, 0, & be_vlan_add_vid,
    & be_vlan_rem_vid, & be_netpoll, 0, 0, & be_busy_poll, & be_set_vf_mac, & be_set_vf_vlan,
    & be_set_vf_tx_rate, 0, & be_get_vf_config, & be_set_vf_link_state, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & be_ndo_bridge_setlink, & be_ndo_bridge_getlink,
    0, 0, 0, & be_add_vxlan_port, & be_del_vxlan_port, 0, 0, 0, 0};
#line 4450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_netdev_init(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 4452
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4452
  adapter = (struct be_adapter *)tmp;
#line 4454
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 4455
    netdev->hw_enc_features = netdev->hw_enc_features | 68222994ULL;
#line 4458
    netdev->hw_features = netdev->hw_features | 67108864ULL;
  } else {

  }
#line 4460
  netdev->hw_features = netdev->hw_features | 17180983443ULL;
#line 4463
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 4463
  if ((int )tmp___0) {
#line 4464
    netdev->hw_features = netdev->hw_features | 8589934592ULL;
  } else {

  }
#line 4466
  netdev->features = (netdev->features | netdev->hw_features) | 768ULL;
#line 4469
  netdev->vlan_features = netdev->vlan_features | 1114131ULL;
#line 4472
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 4474
  netdev->flags = netdev->flags | 4096U;
#line 4476
  netif_set_gso_max_size(netdev, 65521U);
#line 4478
  netdev->netdev_ops = & be_netdev_ops;
#line 4480
  netdev->ethtool_ops = & be_ethtool_ops;
#line 4481
  return;
}
}
#line 4483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_unmap_pci_bars(struct be_adapter *adapter ) 
{ 


  {
#line 4485
  if ((unsigned long )adapter->csr != (unsigned long )((u8 *)0U)) {
#line 4486
    pci_iounmap(adapter->pdev, (void *)adapter->csr);
  } else {

  }
#line 4487
  if ((unsigned long )adapter->db != (unsigned long )((u8 *)0U)) {
#line 4488
    pci_iounmap(adapter->pdev, (void *)adapter->db);
  } else {

  }
#line 4489
  return;
}
}
#line 4491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int db_bar(struct be_adapter *adapter ) 
{ 


  {
#line 4493
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (unsigned int )adapter->virtfn != 0U) {
#line 4494
    return (0);
  } else {
#line 4496
    return (4);
  }
}
}
#line 4499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_roce_map_pci_bars(struct be_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4501
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 4502
    adapter->roce_db.size = 4096U;
#line 4503
    tmp = db_bar(adapter);
#line 4503
    adapter->roce_db.io_addr = (adapter->pdev)->resource[tmp].start;
#line 4505
    tmp___5 = db_bar(adapter);
#line 4505
    if ((adapter->pdev)->resource[tmp___5].start != 0ULL) {
#line 4505
      tmp___3 = db_bar(adapter);
#line 4505
      tmp___4 = db_bar(adapter);
#line 4505
      adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
    } else {
#line 4505
      tmp___6 = db_bar(adapter);
#line 4505
      tmp___7 = db_bar(adapter);
#line 4505
      if ((adapter->pdev)->resource[tmp___6].end != (adapter->pdev)->resource[tmp___7].start) {
#line 4505
        tmp___3 = db_bar(adapter);
#line 4505
        tmp___4 = db_bar(adapter);
#line 4505
        adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
      } else {
#line 4505
        adapter->roce_db.total_size = 0U;
      }
    }
  } else {

  }
#line 4508
  return (0);
}
}
#line 4511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_map_pci_bars(struct be_adapter *adapter ) 
{ 
  u8 *addr ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 4515
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) && (unsigned int )adapter->virtfn == 0U) {
#line 4516
    tmp = pci_iomap(adapter->pdev, 2, 0UL);
#line 4516
    adapter->csr = (u8 *)tmp;
#line 4517
    if ((unsigned long )adapter->csr == (unsigned long )((u8 *)0U)) {
#line 4518
      return (-12);
    } else {

    }
  } else {

  }
#line 4521
  tmp___0 = db_bar(adapter);
#line 4521
  tmp___1 = pci_iomap(adapter->pdev, tmp___0, 0UL);
#line 4521
  addr = (u8 *)tmp___1;
#line 4522
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 4523
    goto pci_map_err;
  } else {

  }
#line 4524
  adapter->db = addr;
#line 4526
  be_roce_map_pci_bars(adapter);
#line 4527
  return (0);
  pci_map_err: 
#line 4530
  be_unmap_pci_bars(adapter);
#line 4531
  return (-12);
}
}
#line 4534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_ctrl_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 4536
  mem = & adapter->mbox_mem_alloced;
#line 4538
  be_unmap_pci_bars(adapter);
#line 4540
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 4541
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 4544
  mem = & adapter->rx_filter;
#line 4545
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 4546
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 4547
  return;
}
}
#line 4550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_ctrl_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  struct be_dma_mem *rx_filter ;
  u32 sli_intf ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 4552
  mbox_mem_alloc = & adapter->mbox_mem_alloced;
#line 4553
  mbox_mem_align = & adapter->mbox_mem;
#line 4554
  rx_filter = & adapter->rx_filter;
#line 4558
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 88, & sli_intf);
#line 4559
  adapter->sli_family = (sli_intf & 3840U) >> 8;
#line 4561
  adapter->virtfn = (unsigned int )((u8 )sli_intf) & 1U;
#line 4563
  status = be_map_pci_bars(adapter);
#line 4564
  if (status != 0) {
#line 4565
    goto done;
  } else {

  }
#line 4567
  mbox_mem_alloc->size = 288U;
#line 4568
  mbox_mem_alloc->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size,
                                       & mbox_mem_alloc->dma, 208U, (struct dma_attrs *)0);
#line 4572
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
#line 4573
    status = -12;
#line 4574
    goto unmap_pci_bars;
  } else {

  }
#line 4576
  mbox_mem_align->size = 272U;
#line 4577
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 4578
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 4579
  memset(mbox_mem_align->va, 0, 272UL);
#line 4581
  rx_filter->size = 424U;
#line 4582
  rx_filter->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )rx_filter->size,
                                      & rx_filter->dma, 208U);
#line 4585
  if ((unsigned long )rx_filter->va == (unsigned long )((void *)0)) {
#line 4586
    status = -12;
#line 4587
    goto free_mbox;
  } else {

  }
#line 4590
  __mutex_init(& adapter->mbox_lock, "&adapter->mbox_lock", & __key);
#line 4591
  spinlock_check(& adapter->mcc_lock);
#line 4591
  __raw_spin_lock_init(& adapter->mcc_lock.ldv_6347.rlock, "&(&adapter->mcc_lock)->rlock",
                       & __key___0);
#line 4592
  spinlock_check(& adapter->mcc_cq_lock);
#line 4592
  __raw_spin_lock_init(& adapter->mcc_cq_lock.ldv_6347.rlock, "&(&adapter->mcc_cq_lock)->rlock",
                       & __key___1);
#line 4594
  init_completion(& adapter->et_cmd_compl);
#line 4595
  pci_save_state(adapter->pdev);
#line 4596
  return (0);
  free_mbox: 
#line 4599
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size, mbox_mem_alloc->va,
                 mbox_mem_alloc->dma, (struct dma_attrs *)0);
  unmap_pci_bars: 
#line 4603
  be_unmap_pci_bars(adapter);
  done: ;
#line 4606
  return (status);
}
}
#line 4609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_stats_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4611
  cmd = & adapter->stats_cmd;
#line 4613
  if ((unsigned long )cmd->va != (unsigned long )((void *)0)) {
#line 4614
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd->size, cmd->va, cmd->dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 4615
  return;
}
}
#line 4618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_stats_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4620
  cmd = & adapter->stats_cmd;
#line 4622
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4623
    cmd->size = 672U;
  } else
#line 4624
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 4625
    cmd->size = 1076U;
  } else
#line 4626
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 4627
    cmd->size = 1864U;
  } else {
#line 4630
    cmd->size = 2696U;
  }
#line 4632
  cmd->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd->size, & cmd->dma,
                                208U);
#line 4634
  if ((unsigned long )cmd->va == (unsigned long )((void *)0)) {
#line 4635
    return (-1);
  } else {

  }
#line 4636
  return (0);
}
}
#line 4639 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_remove(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 4641
  tmp = pci_get_drvdata(pdev);
#line 4641
  adapter = (struct be_adapter *)tmp;
#line 4643
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 4644
    return;
  } else {

  }
#line 4646
  be_roce_dev_remove(adapter);
#line 4647
  be_intr_set(adapter, 0);
#line 4649
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4651
  ldv_unregister_netdev_40(adapter->netdev);
#line 4653
  be_clear(adapter);
#line 4656
  be_cmd_fw_clean(adapter);
#line 4658
  be_stats_cleanup(adapter);
#line 4660
  be_ctrl_cleanup(adapter);
#line 4662
  pci_disable_pcie_error_reporting(pdev);
#line 4664
  pci_release_regions(pdev);
#line 4665
  pci_disable_device(pdev);
#line 4667
  ldv_free_netdev_41(adapter->netdev);
#line 4668
  return;
}
}
#line 4670 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_get_initial_config(struct be_adapter *adapter ) 
{ 
  int status ;
  int level ;
  int tmp ;

  {
#line 4674
  status = be_cmd_get_cntl_attributes(adapter);
#line 4675
  if (status != 0) {
#line 4676
    return (status);
  } else {

  }
#line 4679
  adapter->be_get_temp_freq = 64;
#line 4681
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 4682
    level = be_cmd_get_fw_log_level(adapter);
#line 4683
    adapter->msg_enable = level <= 48 ? 8192U : 0U;
  } else {

  }
#line 4687
  tmp = netif_get_num_default_rss_queues();
#line 4687
  adapter->cfg_num_qs = (u16 )tmp;
#line 4688
  return (0);
}
}
#line 4691 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int lancer_recover_func(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 4693
  dev = & (adapter->pdev)->dev;
#line 4696
  status = lancer_test_and_set_rdy_state(adapter);
#line 4697
  if (status != 0) {
#line 4698
    goto err;
  } else {

  }
#line 4700
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 4700
  if ((int )tmp) {
#line 4701
    be_close(adapter->netdev);
  } else {

  }
#line 4703
  be_clear(adapter);
#line 4705
  be_clear_all_error(adapter);
#line 4707
  status = be_setup(adapter);
#line 4708
  if (status != 0) {
#line 4709
    goto err;
  } else {

  }
#line 4711
  tmp___0 = netif_running((struct net_device  const  *)adapter->netdev);
#line 4711
  if ((int )tmp___0) {
#line 4712
    status = be_open(adapter->netdev);
#line 4713
    if (status != 0) {
#line 4714
      goto err;
    } else {

    }
  } else {

  }
#line 4717
  dev_err((struct device  const  *)dev, "Adapter recovery successful\n");
#line 4718
  return (0);
  err: ;
#line 4720
  if (status == -11) {
#line 4721
    dev_err((struct device  const  *)dev, "Waiting for resource provisioning\n");
  } else {
#line 4723
    dev_err((struct device  const  *)dev, "Adapter recovery failed\n");
  }
#line 4725
  return (status);
}
}
#line 4728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_func_recovery_task(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int status ;
  unsigned long tmp ;

  {
#line 4731
  __mptr = (struct work_struct  const  *)work;
#line 4731
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb92b8UL;
#line 4732
  status = 0;
#line 4734
  be_detect_error(adapter);
#line 4736
  if ((int )adapter->hw_error && ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 4738
    rtnl_lock();
#line 4739
    netif_device_detach(adapter->netdev);
#line 4740
    rtnl_unlock();
#line 4742
    status = lancer_recover_func(adapter);
#line 4743
    if (status == 0) {
#line 4744
      netif_device_attach(adapter->netdev);
    } else {

    }
  } else {

  }
#line 4750
  if (status == 0 || status == -11) {
#line 4751
    tmp = msecs_to_jiffies(1000U);
#line 4751
    schedule_delayed_work(& adapter->func_recovery_work, tmp);
  } else {

  }
#line 4753
  return;
}
}
#line 4755 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_worker(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct be_rx_obj *rxo ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 4758
  __mptr = (struct work_struct  const  *)work;
#line 4758
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb93a0UL;
#line 4764
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 4764
  if (tmp) {
#line 4764
    tmp___0 = 0;
  } else {
#line 4764
    tmp___0 = 1;
  }
#line 4764
  if (tmp___0) {
#line 4765
    local_bh_disable();
#line 4766
    be_process_mcc(adapter);
#line 4767
    local_bh_enable();
#line 4768
    goto reschedule;
  } else {

  }
#line 4771
  if (! adapter->stats_cmd_sent) {
#line 4772
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4773
      lancer_cmd_get_pport_stats(adapter, & adapter->stats_cmd);
    } else {
#line 4776
      be_cmd_get_stats(adapter, & adapter->stats_cmd);
    }
  } else {

  }
#line 4779
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4779
    tmp___1 = MODULO((int )adapter->work_counter, (int )((u16 )adapter->be_get_temp_freq));
#line 4779
    if (tmp___1 == 0U) {
#line 4781
      be_cmd_get_die_temperature(adapter);
    } else {

    }
  } else {

  }
#line 4783
  i = 0;
#line 4783
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 4783
  goto ldv_56658;
  ldv_56657: ;
#line 4787
  if ((int )rxo->rx_post_starved) {
#line 4788
    be_post_rx_frags(rxo, 208U);
  } else {

  }
#line 4783
  i = i + 1;
#line 4783
  rxo = rxo + 1;
  ldv_56658: ;
#line 4783
  if ((int )adapter->num_rx_qs > i) {
#line 4785
    goto ldv_56657;
  } else {

  }
#line 4791
  be_eqd_update(adapter);
  reschedule: 
#line 4794
  adapter->work_counter = (u16 )((int )adapter->work_counter + 1);
#line 4795
  tmp___2 = msecs_to_jiffies(1000U);
#line 4795
  schedule_delayed_work(& adapter->work, tmp___2);
#line 4796
  return;
}
}
#line 4799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static bool be_reset_required(struct be_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 4801
  tmp = pci_num_vf(adapter->pdev);
#line 4801
  return (tmp == 0);
}
}
#line 4804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static char *mc_name(struct be_adapter *adapter ) 
{ 
  char *str ;

  {
#line 4806
  str = (char *)"";
#line 4808
  switch ((int )adapter->mc_type) {
  case 2: 
#line 4810
  str = (char *)"UMC";
#line 4811
  goto ldv_56668;
  case 3: 
#line 4813
  str = (char *)"FLEX10";
#line 4814
  goto ldv_56668;
  case 4: 
#line 4816
  str = (char *)"vNIC-1";
#line 4817
  goto ldv_56668;
  case 5: 
#line 4819
  str = (char *)"nPAR";
#line 4820
  goto ldv_56668;
  case 6: 
#line 4822
  str = (char *)"UFP";
#line 4823
  goto ldv_56668;
  case 7: 
#line 4825
  str = (char *)"vNIC-2";
#line 4826
  goto ldv_56668;
  default: 
#line 4828
  str = (char *)"";
  }
  ldv_56668: ;
#line 4831
  return (str);
}
}
#line 4834 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static char *func_name(struct be_adapter *adapter ) 
{ 


  {
#line 4836
  return ((unsigned int )adapter->virtfn == 0U ? (char *)"PF" : (char *)"VF");
}
}
#line 4839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_probe(struct pci_dev *pdev , struct pci_device_id  const  *pdev_id ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  char port_name ;
  void *tmp ;
  bool tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 4841
  status = 0;
#line 4846
  status = pci_enable_device(pdev);
#line 4847
  if (status != 0) {
#line 4848
    goto do_none;
  } else {

  }
#line 4850
  status = pci_request_regions(pdev, "be2net");
#line 4851
  if (status != 0) {
#line 4852
    goto disable_dev;
  } else {

  }
#line 4853
  pci_set_master(pdev);
#line 4855
  netdev = alloc_etherdev_mqs(1339648, 32U, 32U);
#line 4856
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 4857
    status = -12;
#line 4858
    goto rel_reg;
  } else {

  }
#line 4860
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4860
  adapter = (struct be_adapter *)tmp;
#line 4861
  adapter->pdev = pdev;
#line 4862
  pci_set_drvdata(pdev, (void *)adapter);
#line 4863
  adapter->netdev = netdev;
#line 4864
  netdev->dev.parent = & pdev->dev;
#line 4866
  status = dma_set_mask_and_coherent(& pdev->dev, 0xffffffffffffffffULL);
#line 4867
  if (status == 0) {
#line 4868
    netdev->features = netdev->features | 32ULL;
  } else {
#line 4870
    status = dma_set_mask_and_coherent(& pdev->dev, 4294967295ULL);
#line 4871
    if (status != 0) {
#line 4872
      dev_err((struct device  const  *)(& pdev->dev), "Could not set PCI DMA Mask\n");
#line 4873
      goto free_netdev;
    } else {

    }
  }
#line 4877
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4878
    status = pci_enable_pcie_error_reporting(pdev);
#line 4879
    if (status == 0) {
#line 4880
      _dev_info((struct device  const  *)(& pdev->dev), "PCIe error reporting enabled\n");
    } else {

    }
  } else {

  }
#line 4883
  status = be_ctrl_init(adapter);
#line 4884
  if (status != 0) {
#line 4885
    goto free_netdev;
  } else {

  }
#line 4888
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4889
    status = be_fw_wait_ready(adapter);
#line 4890
    if (status != 0) {
#line 4891
      goto ctrl_clean;
    } else {

    }
  } else {

  }
#line 4894
  tmp___0 = be_reset_required(adapter);
#line 4894
  if ((int )tmp___0) {
#line 4895
    status = be_cmd_reset_function(adapter);
#line 4896
    if (status != 0) {
#line 4897
      goto ctrl_clean;
    } else {

    }
#line 4900
    msleep(100U);
  } else {

  }
#line 4904
  be_intr_set(adapter, 1);
#line 4907
  status = be_cmd_fw_init(adapter);
#line 4908
  if (status != 0) {
#line 4909
    goto ctrl_clean;
  } else {

  }
#line 4911
  status = be_stats_init(adapter);
#line 4912
  if (status != 0) {
#line 4913
    goto ctrl_clean;
  } else {

  }
#line 4915
  status = be_get_initial_config(adapter);
#line 4916
  if (status != 0) {
#line 4917
    goto stats_clean;
  } else {

  }
#line 4919
  __init_work(& adapter->work.work, 0);
#line 4919
  __constr_expr_0.counter = 137438953408L;
#line 4919
  adapter->work.work.data = __constr_expr_0;
#line 4919
  lockdep_init_map(& adapter->work.work.lockdep_map, "(&(&adapter->work)->work)",
                   & __key, 0);
#line 4919
  INIT_LIST_HEAD(& adapter->work.work.entry);
#line 4919
  adapter->work.work.func = & be_worker;
#line 4919
  init_timer_key(& adapter->work.timer, 2U, "(&(&adapter->work)->timer)", & __key___0);
#line 4919
  adapter->work.timer.function = & delayed_work_timer_fn;
#line 4919
  adapter->work.timer.data = (unsigned long )(& adapter->work);
#line 4920
  __init_work(& adapter->func_recovery_work.work, 0);
#line 4920
  __constr_expr_1.counter = 137438953408L;
#line 4920
  adapter->func_recovery_work.work.data = __constr_expr_1;
#line 4920
  lockdep_init_map(& adapter->func_recovery_work.work.lockdep_map, "(&(&adapter->func_recovery_work)->work)",
                   & __key___1, 0);
#line 4920
  INIT_LIST_HEAD(& adapter->func_recovery_work.work.entry);
#line 4920
  adapter->func_recovery_work.work.func = & be_func_recovery_task;
#line 4920
  init_timer_key(& adapter->func_recovery_work.timer, 2U, "(&(&adapter->func_recovery_work)->timer)",
                 & __key___2);
#line 4920
  adapter->func_recovery_work.timer.function = & delayed_work_timer_fn;
#line 4920
  adapter->func_recovery_work.timer.data = (unsigned long )(& adapter->func_recovery_work);
#line 4921
  tmp___1 = 1U;
#line 4921
  adapter->tx_fc = tmp___1;
#line 4921
  adapter->rx_fc = tmp___1;
#line 4923
  status = be_setup(adapter);
#line 4924
  if (status != 0) {
#line 4925
    goto stats_clean;
  } else {

  }
#line 4927
  be_netdev_init(netdev);
#line 4928
  status = ldv_register_netdev_42(netdev);
#line 4929
  if (status != 0) {
#line 4930
    goto unsetup;
  } else {

  }
#line 4932
  be_roce_dev_add(adapter);
#line 4934
  tmp___2 = msecs_to_jiffies(1000U);
#line 4934
  schedule_delayed_work(& adapter->func_recovery_work, tmp___2);
#line 4937
  be_cmd_query_port_name(adapter, (u8 *)(& port_name));
#line 4939
  tmp___3 = mc_name(adapter);
#line 4939
  tmp___4 = func_name(adapter);
#line 4939
  tmp___5 = nic_name(pdev);
#line 4939
  _dev_info((struct device  const  *)(& pdev->dev), "%s: %s %s port %c\n", tmp___5,
            tmp___4, tmp___3, (int )port_name);
#line 4942
  return (0);
  unsetup: 
#line 4945
  be_clear(adapter);
  stats_clean: 
#line 4947
  be_stats_cleanup(adapter);
  ctrl_clean: 
#line 4949
  be_ctrl_cleanup(adapter);
  free_netdev: 
#line 4951
  ldv_free_netdev_43(netdev);
  rel_reg: 
#line 4953
  pci_release_regions(pdev);
  disable_dev: 
#line 4955
  pci_disable_device(pdev);
  do_none: 
#line 4957
  tmp___6 = nic_name(pdev);
#line 4957
  dev_err((struct device  const  *)(& pdev->dev), "%s initialization failed\n", tmp___6);
#line 4958
  return (status);
}
}
#line 4961 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  pci_power_t tmp___1 ;

  {
#line 4963
  tmp = pci_get_drvdata(pdev);
#line 4963
  adapter = (struct be_adapter *)tmp;
#line 4964
  netdev = adapter->netdev;
#line 4966
  if ((int )adapter->wol_en) {
#line 4967
    be_setup_wol(adapter, 1);
  } else {

  }
#line 4969
  be_intr_set(adapter, 0);
#line 4970
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4972
  netif_device_detach(netdev);
#line 4973
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4973
  if ((int )tmp___0) {
#line 4974
    rtnl_lock();
#line 4975
    be_close(netdev);
#line 4976
    rtnl_unlock();
  } else {

  }
#line 4978
  be_clear(adapter);
#line 4980
  pci_save_state(pdev);
#line 4981
  pci_disable_device(pdev);
#line 4982
  tmp___1 = pci_choose_state(pdev, state);
#line 4982
  pci_set_power_state(pdev, tmp___1);
#line 4983
  return (0);
}
}
#line 4986 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4988
  status = 0;
#line 4989
  tmp = pci_get_drvdata(pdev);
#line 4989
  adapter = (struct be_adapter *)tmp;
#line 4990
  netdev = adapter->netdev;
#line 4992
  netif_device_detach(netdev);
#line 4994
  status = pci_enable_device(pdev);
#line 4995
  if (status != 0) {
#line 4996
    return (status);
  } else {

  }
#line 4998
  pci_set_power_state(pdev, 0);
#line 4999
  pci_restore_state(pdev);
#line 5001
  status = be_fw_wait_ready(adapter);
#line 5002
  if (status != 0) {
#line 5003
    return (status);
  } else {

  }
#line 5005
  be_intr_set(adapter, 1);
#line 5007
  status = be_cmd_fw_init(adapter);
#line 5008
  if (status != 0) {
#line 5009
    return (status);
  } else {

  }
#line 5011
  be_setup(adapter);
#line 5012
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 5012
  if ((int )tmp___0) {
#line 5013
    rtnl_lock();
#line 5014
    be_open(netdev);
#line 5015
    rtnl_unlock();
  } else {

  }
#line 5018
  tmp___1 = msecs_to_jiffies(1000U);
#line 5018
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 5020
  netif_device_attach(netdev);
#line 5022
  if ((int )adapter->wol_en) {
#line 5023
    be_setup_wol(adapter, 0);
  } else {

  }
#line 5025
  return (0);
}
}
#line 5031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_shutdown(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 5033
  tmp = pci_get_drvdata(pdev);
#line 5033
  adapter = (struct be_adapter *)tmp;
#line 5035
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 5036
    return;
  } else {

  }
#line 5038
  cancel_delayed_work_sync(& adapter->work);
#line 5039
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 5041
  netif_device_detach(adapter->netdev);
#line 5043
  be_cmd_reset_function(adapter);
#line 5045
  pci_disable_device(pdev);
#line 5046
  return;
}
}
#line 5048 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static pci_ers_result_t be_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;

  {
#line 5051
  tmp = pci_get_drvdata(pdev);
#line 5051
  adapter = (struct be_adapter *)tmp;
#line 5052
  netdev = adapter->netdev;
#line 5054
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH error detected\n");
#line 5056
  if (! adapter->eeh_error) {
#line 5057
    adapter->eeh_error = 1;
#line 5059
    cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 5061
    rtnl_lock();
#line 5062
    netif_device_detach(netdev);
#line 5063
    tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 5063
    if ((int )tmp___0) {
#line 5064
      be_close(netdev);
    } else {

    }
#line 5065
    rtnl_unlock();
#line 5067
    be_clear(adapter);
  } else {

  }
#line 5070
  if (state == 3U) {
#line 5071
    return (4U);
  } else {

  }
#line 5073
  pci_disable_device(pdev);
#line 5081
  if (pdev->devfn == 0U) {
#line 5082
    ssleep(30U);
  } else {

  }
#line 5084
  return (3U);
}
}
#line 5087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static pci_ers_result_t be_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 5089
  tmp = pci_get_drvdata(pdev);
#line 5089
  adapter = (struct be_adapter *)tmp;
#line 5092
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH reset\n");
#line 5094
  status = pci_enable_device(pdev);
#line 5095
  if (status != 0) {
#line 5096
    return (4U);
  } else {

  }
#line 5098
  pci_set_master(pdev);
#line 5099
  pci_set_power_state(pdev, 0);
#line 5100
  pci_restore_state(pdev);
#line 5103
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Waiting for FW to be ready after EEH reset\n");
#line 5105
  status = be_fw_wait_ready(adapter);
#line 5106
  if (status != 0) {
#line 5107
    return (4U);
  } else {

  }
#line 5109
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 5110
  be_clear_all_error(adapter);
#line 5111
  return (5U);
}
}
#line 5114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_eeh_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 5116
  status = 0;
#line 5117
  tmp = pci_get_drvdata(pdev);
#line 5117
  adapter = (struct be_adapter *)tmp;
#line 5118
  netdev = adapter->netdev;
#line 5120
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume\n");
#line 5122
  pci_save_state(pdev);
#line 5124
  status = be_cmd_reset_function(adapter);
#line 5125
  if (status != 0) {
#line 5126
    goto err;
  } else {

  }
#line 5132
  be_intr_set(adapter, 1);
#line 5135
  status = be_cmd_fw_init(adapter);
#line 5136
  if (status != 0) {
#line 5137
    goto err;
  } else {

  }
#line 5139
  status = be_setup(adapter);
#line 5140
  if (status != 0) {
#line 5141
    goto err;
  } else {

  }
#line 5143
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 5143
  if ((int )tmp___0) {
#line 5144
    status = be_open(netdev);
#line 5145
    if (status != 0) {
#line 5146
      goto err;
    } else {

    }
  } else {

  }
#line 5149
  tmp___1 = msecs_to_jiffies(1000U);
#line 5149
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 5151
  netif_device_attach(netdev);
#line 5152
  return;
  err: 
#line 5154
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume failed\n");
#line 5155
  return;
}
}
#line 5157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct pci_error_handlers  const  be_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& be_eeh_err_detected),
    0, 0, & be_eeh_reset, 0, & be_eeh_resume};
#line 5163 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static struct pci_driver be_driver  = 
#line 5163
     {{0, 0}, "be2net", (struct pci_device_id  const  *)(& be_dev_ids), & be_probe,
    & be_remove, & be_suspend, 0, 0, & be_resume, & be_shutdown, 0, & be_eeh_handlers,
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                           {0, 0}}};
#line 5174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static int be_init_module(void) 
{ 
  int tmp ;

  {
#line 5176
  if (((unsigned int )rx_frag_size != 8192U && (unsigned int )rx_frag_size != 4096U) && (unsigned int )rx_frag_size != 2048U) {
#line 5178
    printk("\fbe2net : Module param rx_frag_size must be 2048/4096/8192. Using 2048\n");
#line 5181
    rx_frag_size = 2048U;
  } else {

  }
#line 5184
  tmp = __pci_register_driver(& be_driver, & __this_module, "be2net");
#line 5184
  return (tmp);
}
}
#line 5188 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
static void be_exit_module(void) 
{ 


  {
#line 5190
  pci_unregister_driver(& be_driver);
#line 5191
  return;
}
}
#line 5194
extern int ldv_ndo_uninit_6(void) ;
#line 5195
extern int ldv_probe_5(void) ;
#line 5196
extern int ldv_release_5(void) ;
#line 5197 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_2  ;
#line 5198
extern int ldv_ndo_init_6(void) ;
#line 5199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_5  ;
#line 5200 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_0  ;
#line 5201 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_4  ;
#line 5202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_1  ;
#line 5203
extern void ldv_initialize(void) ;
#line 5204
extern void ldv_check_final_state(void) ;
#line 5205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_3  ;
#line 5206
extern int ldv_suspend_5(void) ;
#line 5209 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_net_device_ops_6(void) 
{ 
  void *tmp ;

  {
#line 5210
  tmp = ldv_zalloc(3264UL);
#line 5210
  be_netdev_ops_group1 = (struct net_device *)tmp;
#line 5211
  return;
}
}
#line 5214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
#line 5215
  tmp = __VERIFIER_nondet_int();
#line 5215
  switch (tmp) {
  case 0: 
#line 5217
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
#line 5219
  goto ldv_56778;
  case 1: 
#line 5221
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
#line 5223
  goto ldv_56778;
  case 2: 
#line 5225
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
#line 5227
  goto ldv_56778;
  case 3: 
#line 5229
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
#line 5231
  goto ldv_56778;
  default: 
#line 5232
  ldv_stop();
  }
  ldv_56778: ;
#line 5234
  return;
}
}
#line 5238 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 5239
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
#line 5240
    ldv_irq_2_0 = 0;
#line 5241
    return;
  } else {

  }
#line 5243
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
#line 5244
    ldv_irq_2_1 = 0;
#line 5245
    return;
  } else {

  }
#line 5247
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
#line 5248
    ldv_irq_2_2 = 0;
#line 5249
    return;
  } else {

  }
#line 5251
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
#line 5252
    ldv_irq_2_3 = 0;
#line 5253
    return;
  } else {

  }
#line 5255
  return;
}
}
#line 5259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_initialize_pci_driver_4(void) 
{ 
  void *tmp ;

  {
#line 5260
  tmp = ldv_zalloc(2976UL);
#line 5260
  be_driver_group0 = (struct pci_dev *)tmp;
#line 5261
  return;
}
}
#line 5263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 5264
  if (ldv_irq_2_0 == 0) {
#line 5265
    ldv_irq_line_2_0 = line;
#line 5266
    ldv_irq_data_2_0 = data;
#line 5267
    ldv_irq_2_0 = 1;
#line 5268
    return;
  } else {

  }
#line 5270
  if (ldv_irq_2_1 == 0) {
#line 5271
    ldv_irq_line_2_1 = line;
#line 5272
    ldv_irq_data_2_1 = data;
#line 5273
    ldv_irq_2_1 = 1;
#line 5274
    return;
  } else {

  }
#line 5276
  if (ldv_irq_2_2 == 0) {
#line 5277
    ldv_irq_line_2_2 = line;
#line 5278
    ldv_irq_data_2_2 = data;
#line 5279
    ldv_irq_2_2 = 1;
#line 5280
    return;
  } else {

  }
#line 5282
  if (ldv_irq_2_3 == 0) {
#line 5283
    ldv_irq_line_2_3 = line;
#line 5284
    ldv_irq_data_2_3 = data;
#line 5285
    ldv_irq_2_3 = 1;
#line 5286
    return;
  } else {

  }
#line 5288
  return;
}
}
#line 5292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 5293
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 5294
    ldv_irq_1_0 = 0;
#line 5295
    return;
  } else {

  }
#line 5297
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 5298
    ldv_irq_1_1 = 0;
#line 5299
    return;
  } else {

  }
#line 5301
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 5302
    ldv_irq_1_2 = 0;
#line 5303
    return;
  } else {

  }
#line 5305
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 5306
    ldv_irq_1_3 = 0;
#line 5307
    return;
  } else {

  }
#line 5309
  return;
}
}
#line 5313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 5314
  if ((unsigned long )handler == (unsigned long )(& be_msix)) {
#line 5315
    return (1);
  } else {

  }
#line 5317
  return (0);
}
}
#line 5321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 5322
  if (ldv_irq_1_0 == 0) {
#line 5323
    ldv_irq_line_1_0 = line;
#line 5324
    ldv_irq_data_1_0 = data;
#line 5325
    ldv_irq_1_0 = 1;
#line 5326
    return;
  } else {

  }
#line 5328
  if (ldv_irq_1_1 == 0) {
#line 5329
    ldv_irq_line_1_1 = line;
#line 5330
    ldv_irq_data_1_1 = data;
#line 5331
    ldv_irq_1_1 = 1;
#line 5332
    return;
  } else {

  }
#line 5334
  if (ldv_irq_1_2 == 0) {
#line 5335
    ldv_irq_line_1_2 = line;
#line 5336
    ldv_irq_data_1_2 = data;
#line 5337
    ldv_irq_1_2 = 1;
#line 5338
    return;
  } else {

  }
#line 5340
  if (ldv_irq_1_3 == 0) {
#line 5341
    ldv_irq_line_1_3 = line;
#line 5342
    ldv_irq_data_1_3 = data;
#line 5343
    ldv_irq_1_3 = 1;
#line 5344
    return;
  } else {

  }
#line 5346
  return;
}
}
#line 5350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;

  {
#line 5352
  if (state != 0) {
#line 5353
    tmp = __VERIFIER_nondet_int();
#line 5353
    switch (tmp) {
    case 0: ;
#line 5355
    if (state == 1) {
#line 5356
      LDV_IN_INTERRUPT = 2;
#line 5357
      irq_retval = be_msix(line, data);
#line 5358
      LDV_IN_INTERRUPT = 1;
#line 5359
      return (state);
    } else {

    }
#line 5362
    goto ldv_56814;
    default: 
#line 5363
    ldv_stop();
    }
    ldv_56814: ;
  } else {

  }
#line 5366
  return (state);
}
}
#line 5371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;

  {
#line 5373
  if (state != 0) {
#line 5374
    tmp = __VERIFIER_nondet_int();
#line 5374
    switch (tmp) {
    case 0: ;
#line 5376
    if (state == 1) {
#line 5377
      LDV_IN_INTERRUPT = 2;
#line 5378
      irq_retval = be_intx(line, data);
#line 5379
      LDV_IN_INTERRUPT = 1;
#line 5380
      return (state);
    } else {

    }
#line 5383
    goto ldv_56825;
    default: 
#line 5384
    ldv_stop();
    }
    ldv_56825: ;
  } else {

  }
#line 5387
  return (state);
}
}
#line 5391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_initialize_pci_error_handlers_5(void) 
{ 
  void *tmp ;

  {
#line 5392
  tmp = ldv_zalloc(2976UL);
#line 5392
  be_eeh_handlers_group0 = (struct pci_dev *)tmp;
#line 5393
  return;
}
}
#line 5395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 5396
  tmp = __VERIFIER_nondet_int();
#line 5396
  switch (tmp) {
  case 0: 
#line 5398
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 5400
  goto ldv_56834;
  case 1: 
#line 5402
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 5404
  goto ldv_56834;
  case 2: 
#line 5406
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 5408
  goto ldv_56834;
  case 3: 
#line 5410
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 5412
  goto ldv_56834;
  default: 
#line 5413
  ldv_stop();
  }
  ldv_56834: ;
#line 5415
  return;
}
}
#line 5419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 5420
  if ((unsigned long )handler == (unsigned long )(& be_intx)) {
#line 5421
    return (1);
  } else {

  }
#line 5423
  return (0);
}
}
#line 5432
void ldv_main_exported_3(void) ;
#line 5436 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int main(void) 
{ 
  int ldvarg18 ;
  int tmp ;
  sa_family_t ldvarg11 ;
  struct ifla_vf_info *ldvarg20 ;
  void *tmp___0 ;
  u8 ldvarg7 ;
  u8 tmp___1 ;
  __be16 ldvarg23 ;
  void *ldvarg3 ;
  void *tmp___2 ;
  struct napi_struct *ldvarg12 ;
  void *tmp___3 ;
  u16 ldvarg8 ;
  u16 tmp___4 ;
  u8 *ldvarg1 ;
  void *tmp___5 ;
  struct sk_buff *ldvarg13 ;
  void *tmp___6 ;
  int ldvarg29 ;
  int tmp___7 ;
  __be16 ldvarg10 ;
  int ldvarg9 ;
  int tmp___8 ;
  struct nlmsghdr *ldvarg24 ;
  void *tmp___9 ;
  int ldvarg27 ;
  int tmp___10 ;
  __be16 ldvarg26 ;
  struct rtnl_link_stats64 *ldvarg0 ;
  void *tmp___11 ;
  __be16 ldvarg5 ;
  u32 ldvarg16 ;
  u32 tmp___12 ;
  sa_family_t ldvarg6 ;
  u32 ldvarg15 ;
  u32 tmp___13 ;
  int ldvarg21 ;
  int tmp___14 ;
  u16 ldvarg25 ;
  u16 tmp___15 ;
  u32 ldvarg17 ;
  u32 tmp___16 ;
  int ldvarg4 ;
  int tmp___17 ;
  struct sk_buff *ldvarg14 ;
  void *tmp___18 ;
  u16 ldvarg22 ;
  u16 tmp___19 ;
  int ldvarg19 ;
  int tmp___20 ;
  int ldvarg28 ;
  int tmp___21 ;
  int ldvarg2 ;
  int tmp___22 ;
  struct pci_device_id *ldvarg31 ;
  void *tmp___23 ;
  pm_message_t ldvarg30 ;
  enum pci_channel_state ldvarg55 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 5439
  tmp = __VERIFIER_nondet_int();
#line 5439
  ldvarg18 = tmp;
#line 5441
  tmp___0 = ldv_zalloc(60UL);
#line 5441
  ldvarg20 = (struct ifla_vf_info *)tmp___0;
#line 5442
  tmp___1 = __VERIFIER_nondet_u8();
#line 5442
  ldvarg7 = tmp___1;
#line 5444
  tmp___2 = ldv_zalloc(1UL);
#line 5444
  ldvarg3 = tmp___2;
#line 5445
  tmp___3 = ldv_zalloc(184UL);
#line 5445
  ldvarg12 = (struct napi_struct *)tmp___3;
#line 5446
  tmp___4 = __VERIFIER_nondet_u16();
#line 5446
  ldvarg8 = tmp___4;
#line 5447
  tmp___5 = ldv_zalloc(1UL);
#line 5447
  ldvarg1 = (u8 *)tmp___5;
#line 5448
  tmp___6 = ldv_zalloc(232UL);
#line 5448
  ldvarg13 = (struct sk_buff *)tmp___6;
#line 5449
  tmp___7 = __VERIFIER_nondet_int();
#line 5449
  ldvarg29 = tmp___7;
#line 5451
  tmp___8 = __VERIFIER_nondet_int();
#line 5451
  ldvarg9 = tmp___8;
#line 5452
  tmp___9 = ldv_zalloc(16UL);
#line 5452
  ldvarg24 = (struct nlmsghdr *)tmp___9;
#line 5453
  tmp___10 = __VERIFIER_nondet_int();
#line 5453
  ldvarg27 = tmp___10;
#line 5455
  tmp___11 = ldv_zalloc(184UL);
#line 5455
  ldvarg0 = (struct rtnl_link_stats64 *)tmp___11;
#line 5457
  tmp___12 = __VERIFIER_nondet_u32();
#line 5457
  ldvarg16 = tmp___12;
#line 5459
  tmp___13 = __VERIFIER_nondet_u32();
#line 5459
  ldvarg15 = tmp___13;
#line 5460
  tmp___14 = __VERIFIER_nondet_int();
#line 5460
  ldvarg21 = tmp___14;
#line 5461
  tmp___15 = __VERIFIER_nondet_u16();
#line 5461
  ldvarg25 = tmp___15;
#line 5462
  tmp___16 = __VERIFIER_nondet_u32();
#line 5462
  ldvarg17 = tmp___16;
#line 5463
  tmp___17 = __VERIFIER_nondet_int();
#line 5463
  ldvarg4 = tmp___17;
#line 5464
  tmp___18 = ldv_zalloc(232UL);
#line 5464
  ldvarg14 = (struct sk_buff *)tmp___18;
#line 5465
  tmp___19 = __VERIFIER_nondet_u16();
#line 5465
  ldvarg22 = tmp___19;
#line 5466
  tmp___20 = __VERIFIER_nondet_int();
#line 5466
  ldvarg19 = tmp___20;
#line 5467
  tmp___21 = __VERIFIER_nondet_int();
#line 5467
  ldvarg28 = tmp___21;
#line 5468
  tmp___22 = __VERIFIER_nondet_int();
#line 5468
  ldvarg2 = tmp___22;
#line 5469
  tmp___23 = ldv_zalloc(32UL);
#line 5469
  ldvarg31 = (struct pci_device_id *)tmp___23;
#line 5437
  ldv_initialize();
#line 5440
  memset((void *)(& ldvarg11), 0, 2UL);
#line 5443
  memset((void *)(& ldvarg23), 0, 2UL);
#line 5450
  memset((void *)(& ldvarg10), 0, 2UL);
#line 5454
  memset((void *)(& ldvarg26), 0, 2UL);
#line 5456
  memset((void *)(& ldvarg5), 0, 2UL);
#line 5458
  memset((void *)(& ldvarg6), 0, 2UL);
#line 5470
  memset((void *)(& ldvarg30), 0, 4UL);
#line 5471
  memset((void *)(& ldvarg55), 0, 4UL);
#line 5473
  ldv_state_variable_6 = 0;
#line 5474
  ldv_state_variable_4 = 0;
#line 5476
  ldv_state_variable_1 = 1;
#line 5477
  ref_cnt = 0;
#line 5478
  ldv_state_variable_0 = 1;
#line 5479
  ldv_state_variable_3 = 0;
#line 5481
  ldv_state_variable_2 = 1;
#line 5482
  ldv_state_variable_5 = 0;
  ldv_56944: 
#line 5484
  tmp___24 = __VERIFIER_nondet_int();
#line 5484
  switch (tmp___24) {
  case 0: ;
#line 5488
  if (ldv_state_variable_6 != 0) {
#line 5489
    tmp___25 = __VERIFIER_nondet_int();
#line 5489
    switch (tmp___25) {
    case 0: ;
#line 5492
    if (ldv_state_variable_6 == 1) {
#line 5494
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg29, ldvarg28, ldvarg27);
#line 5496
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5499
    if (ldv_state_variable_6 == 3) {
#line 5501
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg29, ldvarg28, ldvarg27);
#line 5503
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5506
    if (ldv_state_variable_6 == 2) {
#line 5508
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg29, ldvarg28, ldvarg27);
#line 5510
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5513
    goto ldv_56892;
    case 1: ;
#line 5516
    if (ldv_state_variable_6 == 1) {
#line 5518
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
#line 5520
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5523
    if (ldv_state_variable_6 == 3) {
#line 5525
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
#line 5527
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5530
    if (ldv_state_variable_6 == 2) {
#line 5532
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
#line 5534
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5537
    goto ldv_56892;
    case 2: ;
#line 5540
    if (ldv_state_variable_6 == 1) {
#line 5542
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg24);
#line 5544
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5547
    if (ldv_state_variable_6 == 3) {
#line 5549
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg24);
#line 5551
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5554
    if (ldv_state_variable_6 == 2) {
#line 5556
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg24);
#line 5558
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5561
    goto ldv_56892;
    case 3: ;
#line 5564
    if (ldv_state_variable_6 == 1) {
#line 5566
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg23, (int )ldvarg22);
#line 5568
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5571
    if (ldv_state_variable_6 == 3) {
#line 5573
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg23, (int )ldvarg22);
#line 5575
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5578
    if (ldv_state_variable_6 == 2) {
#line 5580
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg23, (int )ldvarg22);
#line 5582
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5585
    goto ldv_56892;
    case 4: ;
#line 5588
    if (ldv_state_variable_6 == 1) {
#line 5590
      be_get_vf_config(be_netdev_ops_group1, ldvarg21, ldvarg20);
#line 5592
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5595
    if (ldv_state_variable_6 == 3) {
#line 5597
      be_get_vf_config(be_netdev_ops_group1, ldvarg21, ldvarg20);
#line 5599
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5602
    if (ldv_state_variable_6 == 2) {
#line 5604
      be_get_vf_config(be_netdev_ops_group1, ldvarg21, ldvarg20);
#line 5606
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5609
    goto ldv_56892;
    case 5: ;
#line 5612
    if (ldv_state_variable_6 == 1) {
#line 5614
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg19, ldvarg18);
#line 5616
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5619
    if (ldv_state_variable_6 == 3) {
#line 5621
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg19, ldvarg18);
#line 5623
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5626
    if (ldv_state_variable_6 == 2) {
#line 5628
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg19, ldvarg18);
#line 5630
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5633
    goto ldv_56892;
    case 6: ;
#line 5636
    if (ldv_state_variable_6 == 1) {
#line 5638
      be_ndo_bridge_getlink(ldvarg14, ldvarg16, ldvarg15, be_netdev_ops_group1, ldvarg17);
#line 5640
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5643
    if (ldv_state_variable_6 == 3) {
#line 5645
      be_ndo_bridge_getlink(ldvarg14, ldvarg16, ldvarg15, be_netdev_ops_group1, ldvarg17);
#line 5647
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5650
    if (ldv_state_variable_6 == 2) {
#line 5652
      be_ndo_bridge_getlink(ldvarg14, ldvarg16, ldvarg15, be_netdev_ops_group1, ldvarg17);
#line 5654
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5657
    goto ldv_56892;
    case 7: ;
#line 5660
    if (ldv_state_variable_6 == 2) {
#line 5662
      ldv_retval_1 = be_open(be_netdev_ops_group1);
#line 5663
      if (ldv_retval_1 == 0) {
#line 5664
        ldv_state_variable_6 = 3;
      } else {

      }
    } else {

    }
#line 5668
    goto ldv_56892;
    case 8: ;
#line 5671
    if (ldv_state_variable_6 == 3) {
#line 5673
      be_xmit(ldvarg13, be_netdev_ops_group1);
#line 5675
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5678
    goto ldv_56892;
    case 9: ;
#line 5681
    if (ldv_state_variable_6 == 3) {
#line 5683
      be_close(be_netdev_ops_group1);
#line 5684
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5687
    goto ldv_56892;
    case 10: ;
#line 5690
    if (ldv_state_variable_6 == 1) {
#line 5692
      be_set_rx_mode(be_netdev_ops_group1);
#line 5694
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5697
    if (ldv_state_variable_6 == 3) {
#line 5699
      be_set_rx_mode(be_netdev_ops_group1);
#line 5701
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5704
    if (ldv_state_variable_6 == 2) {
#line 5706
      be_set_rx_mode(be_netdev_ops_group1);
#line 5708
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5711
    goto ldv_56892;
    case 11: ;
#line 5714
    if (ldv_state_variable_6 == 1) {
#line 5716
      eth_validate_addr(be_netdev_ops_group1);
#line 5718
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5721
    if (ldv_state_variable_6 == 3) {
#line 5723
      eth_validate_addr(be_netdev_ops_group1);
#line 5725
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5728
    if (ldv_state_variable_6 == 2) {
#line 5730
      eth_validate_addr(be_netdev_ops_group1);
#line 5732
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5735
    goto ldv_56892;
    case 12: ;
#line 5738
    if (ldv_state_variable_6 == 1) {
#line 5740
      be_busy_poll(ldvarg12);
#line 5742
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5745
    if (ldv_state_variable_6 == 3) {
#line 5747
      be_busy_poll(ldvarg12);
#line 5749
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5752
    if (ldv_state_variable_6 == 2) {
#line 5754
      be_busy_poll(ldvarg12);
#line 5756
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5759
    goto ldv_56892;
    case 13: ;
#line 5762
    if (ldv_state_variable_6 == 1) {
#line 5764
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg11, (int )ldvarg10);
#line 5766
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5769
    if (ldv_state_variable_6 == 3) {
#line 5771
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg11, (int )ldvarg10);
#line 5773
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5776
    if (ldv_state_variable_6 == 2) {
#line 5778
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg11, (int )ldvarg10);
#line 5780
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5783
    goto ldv_56892;
    case 14: ;
#line 5786
    if (ldv_state_variable_6 == 1) {
#line 5788
      be_netpoll(be_netdev_ops_group1);
#line 5790
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5793
    if (ldv_state_variable_6 == 3) {
#line 5795
      be_netpoll(be_netdev_ops_group1);
#line 5797
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5800
    if (ldv_state_variable_6 == 2) {
#line 5802
      be_netpoll(be_netdev_ops_group1);
#line 5804
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5807
    goto ldv_56892;
    case 15: ;
#line 5810
    if (ldv_state_variable_6 == 1) {
#line 5812
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg9, (int )ldvarg8, (int )ldvarg7);
#line 5814
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5817
    if (ldv_state_variable_6 == 3) {
#line 5819
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg9, (int )ldvarg8, (int )ldvarg7);
#line 5821
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5824
    if (ldv_state_variable_6 == 2) {
#line 5826
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg9, (int )ldvarg8, (int )ldvarg7);
#line 5828
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5831
    goto ldv_56892;
    case 16: ;
#line 5834
    if (ldv_state_variable_6 == 1) {
#line 5836
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
#line 5838
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5841
    if (ldv_state_variable_6 == 3) {
#line 5843
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
#line 5845
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5848
    if (ldv_state_variable_6 == 2) {
#line 5850
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
#line 5852
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5855
    goto ldv_56892;
    case 17: ;
#line 5858
    if (ldv_state_variable_6 == 3) {
#line 5860
      be_change_mtu(be_netdev_ops_group1, ldvarg4);
#line 5862
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5865
    if (ldv_state_variable_6 == 2) {
#line 5867
      be_change_mtu(be_netdev_ops_group1, ldvarg4);
#line 5869
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5872
    goto ldv_56892;
    case 18: ;
#line 5875
    if (ldv_state_variable_6 == 1) {
#line 5877
      be_mac_addr_set(be_netdev_ops_group1, ldvarg3);
#line 5879
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5882
    if (ldv_state_variable_6 == 3) {
#line 5884
      be_mac_addr_set(be_netdev_ops_group1, ldvarg3);
#line 5886
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5889
    if (ldv_state_variable_6 == 2) {
#line 5891
      be_mac_addr_set(be_netdev_ops_group1, ldvarg3);
#line 5893
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5896
    goto ldv_56892;
    case 19: ;
#line 5899
    if (ldv_state_variable_6 == 1) {
#line 5901
      be_set_vf_mac(be_netdev_ops_group1, ldvarg2, ldvarg1);
#line 5903
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5906
    if (ldv_state_variable_6 == 3) {
#line 5908
      be_set_vf_mac(be_netdev_ops_group1, ldvarg2, ldvarg1);
#line 5910
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5913
    if (ldv_state_variable_6 == 2) {
#line 5915
      be_set_vf_mac(be_netdev_ops_group1, ldvarg2, ldvarg1);
#line 5917
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5920
    goto ldv_56892;
    case 20: ;
#line 5923
    if (ldv_state_variable_6 == 1) {
#line 5925
      be_get_stats64(be_netdev_ops_group1, ldvarg0);
#line 5927
      ldv_state_variable_6 = 1;
    } else {

    }
#line 5930
    if (ldv_state_variable_6 == 3) {
#line 5932
      be_get_stats64(be_netdev_ops_group1, ldvarg0);
#line 5934
      ldv_state_variable_6 = 3;
    } else {

    }
#line 5937
    if (ldv_state_variable_6 == 2) {
#line 5939
      be_get_stats64(be_netdev_ops_group1, ldvarg0);
#line 5941
      ldv_state_variable_6 = 2;
    } else {

    }
#line 5944
    goto ldv_56892;
    case 21: ;
#line 5947
    if (ldv_state_variable_6 == 1) {
#line 5949
      ldv_retval_0 = ldv_ndo_init_6();
#line 5950
      if (ldv_retval_0 == 0) {
#line 5951
        ldv_state_variable_6 = 2;
#line 5952
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 5956
    goto ldv_56892;
    case 22: ;
#line 5959
    if (ldv_state_variable_6 == 2) {
#line 5961
      ldv_ndo_uninit_6();
#line 5962
      ldv_state_variable_6 = 1;
#line 5963
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5966
    goto ldv_56892;
    default: 
#line 5967
    ldv_stop();
    }
    ldv_56892: ;
  } else {

  }
#line 5971
  goto ldv_56916;
  case 1: ;
#line 5975
  if (ldv_state_variable_4 != 0) {
#line 5976
    tmp___26 = __VERIFIER_nondet_int();
#line 5976
    switch (tmp___26) {
    case 0: ;
#line 5979
    if (ldv_state_variable_4 == 1) {
#line 5981
      ldv_retval_4 = be_probe(be_driver_group0, (struct pci_device_id  const  *)ldvarg31);
#line 5983
      if (ldv_retval_4 == 0) {
#line 5984
        ldv_state_variable_4 = 2;
#line 5985
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 5989
    goto ldv_56919;
    case 1: ;
#line 5992
    if (ldv_state_variable_4 == 2) {
#line 5994
      ldv_retval_3 = be_suspend(be_driver_group0, ldvarg30);
#line 5996
      if (ldv_retval_3 == 0) {
#line 5997
        ldv_state_variable_4 = 3;
      } else {

      }
    } else {

    }
#line 6001
    goto ldv_56919;
    case 2: ;
#line 6004
    if (ldv_state_variable_4 == 3) {
#line 6006
      ldv_retval_2 = be_resume(be_driver_group0);
#line 6008
      if (ldv_retval_2 == 0) {
#line 6009
        ldv_state_variable_4 = 2;
      } else {

      }
    } else {

    }
#line 6013
    goto ldv_56919;
    case 3: ;
#line 6016
    if (ldv_state_variable_4 == 3) {
#line 6018
      be_shutdown(be_driver_group0);
#line 6020
      ldv_state_variable_4 = 4;
    } else {

    }
#line 6023
    if (ldv_state_variable_4 == 2) {
#line 6025
      be_shutdown(be_driver_group0);
#line 6027
      ldv_state_variable_4 = 4;
    } else {

    }
#line 6030
    goto ldv_56919;
    case 4: ;
#line 6033
    if (ldv_state_variable_4 == 4) {
#line 6035
      be_remove(be_driver_group0);
#line 6037
      ldv_state_variable_4 = 1;
#line 6038
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6041
    if (ldv_state_variable_4 == 3) {
#line 6043
      be_remove(be_driver_group0);
#line 6045
      ldv_state_variable_4 = 1;
#line 6046
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6049
    if (ldv_state_variable_4 == 2) {
#line 6051
      be_remove(be_driver_group0);
#line 6053
      ldv_state_variable_4 = 1;
#line 6054
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6057
    goto ldv_56919;
    default: 
#line 6058
    ldv_stop();
    }
    ldv_56919: ;
  } else {

  }
#line 6062
  goto ldv_56916;
  case 2: ;
#line 6066
  if (ldv_state_variable_1 != 0) {
#line 6067
    choose_interrupt_1();
  } else {

  }
#line 6070
  goto ldv_56916;
  case 3: ;
#line 6074
  if (ldv_state_variable_0 != 0) {
#line 6075
    tmp___27 = __VERIFIER_nondet_int();
#line 6075
    switch (tmp___27) {
    case 0: ;
#line 6078
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 6080
      be_exit_module();
#line 6081
      ldv_state_variable_0 = 3;
#line 6082
      goto ldv_final;
    } else {

    }
#line 6085
    goto ldv_56929;
    case 1: ;
#line 6088
    if (ldv_state_variable_0 == 1) {
#line 6090
      ldv_retval_5 = be_init_module();
#line 6091
      if (ldv_retval_5 != 0) {
#line 6092
        ldv_state_variable_0 = 3;
#line 6093
        goto ldv_final;
      } else {

      }
#line 6096
      if (ldv_retval_5 == 0) {
#line 6097
        ldv_state_variable_0 = 2;
#line 6098
        ldv_state_variable_5 = 1;
#line 6099
        ldv_initialize_pci_error_handlers_5();
#line 6100
        ldv_state_variable_3 = 1;
#line 6101
        ldv_initialize_ethtool_ops_3();
#line 6102
        ldv_state_variable_4 = 1;
#line 6103
        ldv_initialize_pci_driver_4();
      } else {

      }
    } else {

    }
#line 6107
    goto ldv_56929;
    default: 
#line 6108
    ldv_stop();
    }
    ldv_56929: ;
  } else {

  }
#line 6112
  goto ldv_56916;
  case 4: ;
#line 6116
  if (ldv_state_variable_3 != 0) {
#line 6117
    ldv_main_exported_3();
  } else {

  }
#line 6120
  goto ldv_56916;
  case 5: ;
#line 6124
  if (ldv_state_variable_2 != 0) {
#line 6125
    choose_interrupt_2();
  } else {

  }
#line 6128
  goto ldv_56916;
  case 6: ;
#line 6132
  if (ldv_state_variable_5 != 0) {
#line 6133
    tmp___28 = __VERIFIER_nondet_int();
#line 6133
    switch (tmp___28) {
    case 0: ;
#line 6136
    if (ldv_state_variable_5 == 3) {
#line 6138
      be_eeh_resume(be_eeh_handlers_group0);
#line 6140
      ldv_state_variable_5 = 2;
    } else {

    }
#line 6143
    goto ldv_56936;
    case 1: ;
#line 6146
    if (ldv_state_variable_5 == 1) {
#line 6148
      be_eeh_reset(be_eeh_handlers_group0);
#line 6150
      ldv_state_variable_5 = 1;
    } else {

    }
#line 6153
    if (ldv_state_variable_5 == 3) {
#line 6155
      be_eeh_reset(be_eeh_handlers_group0);
#line 6157
      ldv_state_variable_5 = 3;
    } else {

    }
#line 6160
    if (ldv_state_variable_5 == 2) {
#line 6162
      be_eeh_reset(be_eeh_handlers_group0);
#line 6164
      ldv_state_variable_5 = 2;
    } else {

    }
#line 6167
    goto ldv_56936;
    case 2: ;
#line 6170
    if (ldv_state_variable_5 == 1) {
#line 6172
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg55);
#line 6174
      ldv_state_variable_5 = 1;
    } else {

    }
#line 6177
    if (ldv_state_variable_5 == 3) {
#line 6179
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg55);
#line 6181
      ldv_state_variable_5 = 3;
    } else {

    }
#line 6184
    if (ldv_state_variable_5 == 2) {
#line 6186
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg55);
#line 6188
      ldv_state_variable_5 = 2;
    } else {

    }
#line 6191
    goto ldv_56936;
    case 3: ;
#line 6194
    if (ldv_state_variable_5 == 2) {
#line 6196
      ldv_suspend_5();
#line 6198
      ldv_state_variable_5 = 3;
    } else {

    }
#line 6201
    goto ldv_56936;
    case 4: ;
#line 6204
    if (ldv_state_variable_5 == 3) {
#line 6206
      ldv_release_5();
#line 6208
      ldv_state_variable_5 = 1;
#line 6209
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6212
    if (ldv_state_variable_5 == 2) {
#line 6214
      ldv_release_5();
#line 6216
      ldv_state_variable_5 = 1;
#line 6217
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6220
    goto ldv_56936;
    case 5: ;
#line 6223
    if (ldv_state_variable_5 == 1) {
#line 6225
      ldv_probe_5();
#line 6227
      ldv_state_variable_5 = 2;
#line 6228
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 6231
    goto ldv_56936;
    default: 
#line 6232
    ldv_stop();
    }
    ldv_56936: ;
  } else {

  }
#line 6236
  goto ldv_56916;
  default: 
#line 6237
  ldv_stop();
  }
  ldv_56916: ;
#line 6239
  goto ldv_56944;
  ldv_final: 
#line 6241
  ldv_check_final_state();
#line 6242
  return 0;
}
}
#line 6245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 6248
  ldv_spin_lock();
#line 6250
  ldv_spin_lock_1(lock);
#line 6251
  return;
}
}
#line 6253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 6256
  ldv_spin_lock();
#line 6258
  ldv_spin_lock_bh_2(lock);
#line 6259
  return;
}
}
#line 6280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 6283
  ldv_spin_unlock();
#line 6285
  ldv_spin_unlock_5(lock);
#line 6286
  return;
}
}
#line 6288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 6291
  ldv_spin_unlock();
#line 6293
  ldv_spin_unlock_bh_6(lock);
#line 6294
  return;
}
}
#line 6334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static struct page *alloc_pages(gfp_t flags , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 6337
  ldv_check_alloc_flags(flags);
#line 6339
  tmp = ldv_alloc_pages_11(flags, order);
#line 6339
  return (tmp);
}
}
#line 6358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 


  {
#line 6361
  ldv_check_alloc_flags(flags);
#line 6363
  ldv_kcalloc_14(n, size, flags);
#line 6364
  return ((void *)0);
}
}
#line 6372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 6375
  ldv_check_alloc_flags(flags);
#line 6377
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 6378
  return ((void *)0);
}
}
#line 6392 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) 
{ 


  {
#line 6395
  ldv_check_alloc_flags(flags);
#line 6397
  ldv_dma_zalloc_coherent_19(dev, size, dma_handle, flags);
#line 6398
  return ((void *)0);
}
}
#line 6416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 6419
  ldv_check_alloc_flags(flags);
#line 6421
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 6421
  return (tmp);
}
}
#line 6424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6427
  ldv_check_alloc_flags(flags);
#line 6429
  tmp = ldv_skb_share_check_23(skb, flags);
#line 6429
  return (tmp);
}
}
#line 6432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6435
  ldv_check_alloc_flags(flags);
#line 6437
  tmp = skb_clone(ldv_func_arg1, flags);
#line 6437
  return (tmp);
}
}
#line 6448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6451
  ldv_check_alloc_flags(flags);
#line 6453
  tmp = skb_copy(ldv_func_arg1, flags);
#line 6453
  return (tmp);
}
}
#line 6456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6459
  ldv_check_alloc_flags(flags);
#line 6461
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 6461
  return (tmp);
}
}
#line 6464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6467
  ldv_check_alloc_flags(flags);
#line 6469
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 6469
  return (tmp);
}
}
#line 6472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6475
  ldv_check_alloc_flags(flags);
#line 6477
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 6477
  return (tmp);
}
}
#line 6480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 6483
  ldv_check_alloc_flags(flags);
#line 6485
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 6485
  return (tmp);
}
}
#line 6488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 6491
  ldv_check_alloc_flags(flags);
#line 6493
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 6493
  return (tmp);
}
}
#line 6496 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 6499
  ldv_check_alloc_flags(flags);
#line 6501
  tmp = skb_clone(ldv_func_arg1, flags);
#line 6501
  return (tmp);
}
}
#line 6504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_kmem_cache_alloc_33(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 6507
  ldv_check_alloc_flags(flags);
#line 6509
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 6510
  return ((void *)0);
}
}
#line 6512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_vmalloc_34(unsigned long ldv_func_arg1 ) 
{ 


  {
#line 6515
  ldv_check_alloc_nonatomic();
#line 6517
  vmalloc(ldv_func_arg1);
#line 6518
  return ((void *)0);
}
}
#line 6520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int ldv_request_irq_35(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 6524
  tmp = request_irq(irq, handler, flags, name, dev);
#line 6524
  ldv_func_res = tmp;
#line 6526
  tmp___0 = reg_check_1(handler);
#line 6526
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 6527
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 6530
  return (ldv_func_res);
}
}
#line 6533 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_36(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 6536
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 6538
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 6539
  return;
}
}
#line 6541 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int ldv_request_irq_37(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 6545
  tmp = request_irq(irq, handler, flags, name, dev);
#line 6545
  ldv_func_res = tmp;
#line 6547
  tmp___0 = reg_check_1(handler);
#line 6547
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 6548
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 6551
  return (ldv_func_res);
}
}
#line 6554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_38(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 6557
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 6559
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 6560
  return;
}
}
#line 6562 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_39(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 6565
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 6567
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 6568
  return;
}
}
#line 6570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_unregister_netdev_40(struct net_device *dev ) 
{ 


  {
#line 6573
  unregister_netdev(dev);
#line 6575
  ldv_state_variable_6 = 0;
#line 6576
  return;
}
}
#line 6578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_netdev_41(struct net_device *dev ) 
{ 


  {
#line 6581
  free_netdev(dev);
#line 6583
  ldv_state_variable_6 = 0;
#line 6584
  return;
}
}
#line 6586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_register_netdev_42(struct net_device *dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 6590
  tmp = register_netdev(dev);
#line 6590
  ldv_func_res = tmp;
#line 6592
  ldv_state_variable_6 = 1;
#line 6593
  ldv_net_device_ops_6();
#line 6596
  return (ldv_func_res);
}
}
#line 6599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_netdev_43(struct net_device *dev ) 
{ 


  {
#line 6602
  free_netdev(dev);
#line 6604
  ldv_state_variable_6 = 0;
#line 6605
  return;
}
}
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 62 "./arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 301 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 310
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 142 "include/linux/mutex.h"
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 175
extern void mutex_unlock(struct mutex * ) ;
#line 91 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 70 "include/linux/vmalloc.h"
void *ldv_vmalloc_98(unsigned long ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_80(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 323
void *ldv_kmem_cache_alloc_97(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                        size, dma_handle, 32U, (struct dma_attrs *)0);
#line 19
  return (tmp);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 26
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
#line 27
  return;
}
}
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_96(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_90(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_94(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_95(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_91(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_92(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_93(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 75 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) ;
#line 142 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO___0(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 144
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 144
  if (tmp != 0L) {
#line 144
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (144), "i" (12UL));
    ldv_52764: ;
#line 144
    goto ldv_52764;
  } else {

  }
#line 145
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 153 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc___0(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 155
  tmp = MODULO___0((int )((unsigned int )*index + 1U), (int )limit);
#line 155
  *index = (u16 )tmp;
#line 156
  return;
}
}
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_index_node(struct be_queue_info *q , u16 index ) 
{ 


  {
#line 170
  return (q->dma_mem.va + (unsigned long )((int )index * (int )q->entry_size));
}
}
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 175
  index_inc___0(& q->head, (int )q->len);
#line 176
  return;
}
}
#line 178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_dec(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 180
  tmp = MODULO___0((int )((unsigned int )*index + 65535U), (int )limit);
#line 180
  *index = (u16 )tmp;
#line 181
  return;
}
}
#line 183 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 185
  index_inc___0(& q->tail, (int )q->len);
#line 186
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_error(struct be_adapter *adapter ) 
{ 


  {
#line 725
  return ((bool )(((int )adapter->eeh_error || (int )adapter->hw_error) || (int )adapter->fw_timeout));
}
}
#line 740 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_is_wol_excluded(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;

  {
#line 742
  pdev = adapter->pdev;
#line 744
  if ((unsigned int )adapter->virtfn != 0U) {
#line 745
    return (1);
  } else {

  }
#line 747
  switch ((int )pdev->subsystem_device) {
  case 58882: ;
  case 58946: ;
  case 58898: ;
  case 58962: ;
#line 752
  return (1);
  default: ;
#line 754
  return (0);
  }
}
}
#line 2046 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) ;
#line 2087
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) ;
#line 2089
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) ;
#line 2097
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) ;
#line 2108
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) ;
#line 2111
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) ;
#line 2113
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2115
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) ;
#line 2124
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) ;
#line 2125
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) ;
#line 2130
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) ;
#line 2136
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) ;
#line 2144
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) ;
#line 2146
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) ;
#line 2148
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) ;
#line 2152
int lancer_initiate_dump(struct be_adapter *adapter ) ;
#line 2153
bool dump_present(struct be_adapter *adapter ) ;
#line 2160
int be_cmd_set_profile_config(struct be_adapter *adapter , void *desc , int size ,
                              u8 version , u8 domain ) ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_cmd_priv_map cmd_priv_map[5U]  = {      {12U, 3U, 1800U}, 
        {37U, 1U, 1794U}, 
        {36U, 1U, 1800U}, 
        {18U, 3U, 1800U}, 
        {102U, 1U, 1800U}};
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static bool be_cmd_allowed(struct be_adapter *adapter , u8 opcode , u8 subsystem ) 
{ 
  int i ;
  int num_entries ;
  u32 cmd_privileges ;

  {
#line 134
  num_entries = 5;
#line 135
  cmd_privileges = adapter->cmd_privileges;
#line 137
  i = 0;
#line 137
  goto ldv_54867;
  ldv_54866: ;
#line 138
  if ((int )cmd_priv_map[i].opcode == (int )opcode && (int )cmd_priv_map[i].subsystem == (int )subsystem) {
#line 140
    if ((cmd_priv_map[i].priv_mask & cmd_privileges) == 0U) {
#line 141
      return (0);
    } else {

    }
  } else {

  }
#line 137
  i = i + 1;
  ldv_54867: ;
#line 137
  if (i < num_entries) {
#line 139
    goto ldv_54866;
  } else {

  }

#line 143
  return (1);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 148
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_mcc_notify(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;
  bool tmp ;

  {
#line 153
  mccq = & adapter->mcc_obj.q;
#line 154
  val = 0U;
#line 156
  tmp = be_error(adapter);
#line 156
  if ((int )tmp) {
#line 157
    return;
  } else {

  }
#line 159
  val = ((u32 )mccq->id & 2047U) | val;
#line 160
  val = val | 65536U;
#line 162
  __asm__  volatile   ("sfence": : : "memory");
#line 163
  iowrite32(val, (void *)adapter->db + 320U);
#line 164
  return;
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  u32 flags ;

  {
#line 173
  if (compl->flags != 0U) {
#line 174
    flags = compl->flags;
#line 175
    if ((int )flags < 0) {
#line 176
      compl->flags = flags;
#line 177
      return (1);
    } else {

    }
  } else {

  }
#line 180
  return (0);
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 186
  compl->flags = 0U;
#line 187
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0 , u32 tag1 ) 
{ 
  unsigned long addr ;

  {
#line 193
  addr = (unsigned long )tag1;
#line 194
  addr = (addr << 32UL) | (unsigned long )tag0;
#line 195
  return ((struct be_cmd_resp_hdr *)addr);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static bool be_skip_err_log(u8 opcode , u16 base_status , u16 addl_status ) 
{ 


  {
#line 200
  if ((((unsigned int )base_status == 66U || (unsigned int )base_status == 2U) || (unsigned int )addl_status == 74U) || ((unsigned int )opcode == 7U && ((unsigned int )base_status == 3U || (unsigned int )addl_status == 77U))) {
#line 206
    return (1);
  } else {
#line 208
    return (0);
  }
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_cmd_process(struct be_adapter *adapter , struct be_mcc_compl *compl ,
                                 struct be_cmd_resp_hdr *resp_hdr ) 
{ 
  enum mcc_base_status base_status ;
  u8 opcode ;
  u8 subsystem ;
  struct be_cmd_resp_get_cntl_addnl_attribs *resp ;

  {
#line 218
  base_status = compl->status != 0U ? (enum mcc_base_status )(compl->status & 65535U) : 0;
#line 219
  opcode = 0U;
#line 219
  subsystem = 0U;
#line 221
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 222
    opcode = resp_hdr->opcode;
#line 223
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 226
  if ((unsigned int )opcode == 18U && (unsigned int )subsystem == 11U) {
#line 228
    complete(& adapter->et_cmd_compl);
#line 229
    return;
  } else {

  }
#line 232
  if (((unsigned int )opcode == 7U || (unsigned int )opcode == 172U) && (unsigned int )subsystem == 1U) {
#line 235
    adapter->flash_status = compl->status;
#line 236
    complete(& adapter->et_cmd_compl);
#line 237
    return;
  } else {

  }
#line 240
  if ((((unsigned int )opcode == 4U || (unsigned int )opcode == 18U) && (unsigned int )subsystem == 3U) && (unsigned int )base_status == 0U) {
#line 244
    be_parse_stats(adapter);
#line 245
    adapter->stats_cmd_sent = 0;
#line 246
    return;
  } else {

  }
#line 249
  if ((unsigned int )opcode == 121U && (unsigned int )subsystem == 1U) {
#line 251
    if ((unsigned int )base_status == 0U) {
#line 252
      resp = (struct be_cmd_resp_get_cntl_addnl_attribs *)resp_hdr;
#line 254
      adapter->drv_stats.be_on_die_temperature = (u32 )resp->on_die_temperature;
    } else {
#line 257
      adapter->be_get_temp_freq = 0;
    }
#line 259
    return;
  } else {

  }
#line 261
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mcc_compl_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  enum mcc_base_status base_status ;
  enum mcc_addl_status addl_status ;
  struct be_cmd_resp_hdr *resp_hdr ;
  u8 opcode ;
  u8 subsystem ;
  bool tmp ;
  int tmp___0 ;

  {
#line 269
  opcode = 0U;
#line 269
  subsystem = 0U;
#line 273
  swap_dws((void *)compl, 4);
#line 275
  base_status = compl->status != 0U ? (enum mcc_base_status )(compl->status & 65535U) : 0;
#line 276
  addl_status = compl->status != 0U ? (enum mcc_addl_status )((compl->status >> 16) & 255U) : 0;
#line 278
  resp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);
#line 279
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 280
    opcode = resp_hdr->opcode;
#line 281
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 284
  be_async_cmd_process(adapter, compl, resp_hdr);
#line 286
  if ((unsigned int )base_status != 0U) {
#line 286
    tmp = be_skip_err_log((int )opcode, (int )((u16 )base_status), (int )((u16 )addl_status));
#line 286
    if (tmp) {
#line 286
      tmp___0 = 0;
    } else {
#line 286
      tmp___0 = 1;
    }
#line 286
    if (tmp___0) {
#line 289
      if ((unsigned int )base_status == 5U) {
#line 290
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF is not privileged to issue opcode %d-%d\n",
                 (int )opcode, (int )subsystem);
      } else {
#line 294
        dev_err((struct device  const  *)(& (adapter->pdev)->dev), "opcode %d-%d failed:status %d-%d\n",
                (int )opcode, (int )subsystem, (unsigned int )base_status, (unsigned int )addl_status);
      }
    } else {

    }
  } else {

  }
#line 299
  return ((int )compl->status);
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_link_state_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_link_state *evt ;

  {
#line 306
  evt = (struct be_async_event_link_state *)compl;
#line 310
  adapter->phy.link_speed = -1;
#line 317
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && ((int )evt->port_link_status & 2) == 0) {
#line 319
    return;
  } else {

  }
#line 324
  if ((int )adapter->flags & 1) {
#line 325
    be_link_status_update(adapter, (int )evt->port_link_status & 1);
  } else {

  }
#line 327
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_grp5_cos_priority_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_cos_priority *evt ;

  {
#line 333
  evt = (struct be_async_event_grp5_cos_priority *)compl;
#line 336
  if ((unsigned int )evt->valid != 0U) {
#line 337
    adapter->vlan_prio_bmap = evt->available_priority_bmap;
#line 338
    adapter->recommended_prio = (unsigned int )adapter->recommended_prio & 8191U;
#line 339
    adapter->recommended_prio = (int )((u16 )evt->reco_default_priority) << 13U;
  } else {

  }
#line 342
  return;
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_grp5_qos_speed_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_qos_link_speed *evt ;

  {
#line 348
  evt = (struct be_async_event_grp5_qos_link_speed *)compl;
#line 351
  if (adapter->phy.link_speed >= 0 && (u32 )evt->physical_port == adapter->port_num) {
#line 353
    adapter->phy.link_speed = (int )evt->qos_link_speed * 10;
  } else {

  }
#line 354
  return;
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_grp5_pvid_state_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_pvid_state *evt ;

  {
#line 360
  evt = (struct be_async_event_grp5_pvid_state *)compl;
#line 363
  if ((unsigned int )evt->enabled != 0U) {
#line 364
    adapter->pvid = (unsigned int )evt->tag & 4095U;
#line 365
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "LPVID: %d\n", (int )adapter->pvid);
  } else {
#line 367
    adapter->pvid = 0U;
  }
#line 368
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_grp5_evt_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  u8 event_type ;

  {
#line 374
  event_type = (u8 )(compl->flags >> 16);
#line 377
  switch ((int )event_type) {
  case 2: 
#line 379
  be_async_grp5_cos_priority_process(adapter, compl);
#line 380
  goto ldv_54938;
  case 1: 
#line 382
  be_async_grp5_qos_speed_process(adapter, compl);
#line 383
  goto ldv_54938;
  case 3: 
#line 385
  be_async_grp5_pvid_state_process(adapter, compl);
#line 386
  goto ldv_54938;
  default: 
#line 388
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown grp5 event 0x%x!\n",
           (int )event_type);
#line 390
  goto ldv_54938;
  }
  ldv_54938: ;
#line 393
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_async_dbg_evt_process(struct be_adapter *adapter , struct be_mcc_compl *cmp ) 
{ 
  u8 event_type ;
  struct be_async_event_qnq *evt ;

  {
#line 397
  event_type = 0U;
#line 398
  evt = (struct be_async_event_qnq *)cmp;
#line 400
  event_type = (u8 )(cmp->flags >> 16);
#line 403
  switch ((int )event_type) {
  case 1: ;
#line 405
  if ((unsigned int )evt->valid != 0U) {
#line 406
    adapter->qnq_vid = evt->vlan_tag;
  } else {

  }
#line 407
  adapter->flags = adapter->flags | 2048U;
#line 408
  goto ldv_54949;
  default: 
#line 410
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown debug event 0x%x!\n",
           (int )event_type);
#line 412
  goto ldv_54949;
  }
  ldv_54949: ;
#line 415
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static bool is_link_state_evt(u32 flags ) 
{ 


  {
#line 418
  return (((flags >> 8) & 255U) == 1U);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static bool is_grp5_evt(u32 flags ) 
{ 


  {
#line 424
  return (((flags >> 8) & 255U) == 5U);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static bool is_dbg_evt(u32 flags ) 
{ 


  {
#line 430
  return (((flags >> 8) & 255U) == 6U);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_mcc_event_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 437
  tmp___1 = is_link_state_evt(compl->flags);
#line 437
  if ((int )tmp___1) {
#line 438
    be_async_link_state_process(adapter, compl);
  } else {
#line 439
    tmp___0 = is_grp5_evt(compl->flags);
#line 439
    if ((int )tmp___0) {
#line 440
      be_async_grp5_evt_process(adapter, compl);
    } else {
#line 441
      tmp = is_dbg_evt(compl->flags);
#line 441
      if ((int )tmp) {
#line 442
        be_async_dbg_evt_process(adapter, compl);
      } else {

      }
    }
  }
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 447
  mcc_cq = & adapter->mcc_obj.cq;
#line 448
  tmp = queue_tail_node(mcc_cq);
#line 448
  compl = (struct be_mcc_compl *)tmp;
#line 450
  tmp___0 = be_mcc_compl_is_new(compl);
#line 450
  if ((int )tmp___0) {
#line 451
    queue_tail_inc___0(mcc_cq);
#line 452
    return (compl);
  } else {

  }
#line 454
  return ((struct be_mcc_compl *)0);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void be_async_mcc_enable(struct be_adapter *adapter ) 
{ 


  {
#line 459
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 461
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 1, 0);
#line 462
  adapter->mcc_obj.rearm_cq = 1;
#line 464
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void be_async_mcc_disable(struct be_adapter *adapter ) 
{ 


  {
#line 469
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 471
  adapter->mcc_obj.rearm_cq = 0;
#line 472
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 0, 0);
#line 474
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_process_mcc(struct be_adapter *adapter ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_mcc_obj *mcc_obj ;

  {
#line 480
  num = 0;
#line 480
  status = 0;
#line 481
  mcc_obj = & adapter->mcc_obj;
#line 483
  spin_lock(& adapter->mcc_cq_lock);
#line 485
  goto ldv_54983;
  ldv_54982: ;
#line 486
  if ((compl->flags & 1073741824U) != 0U) {
#line 487
    be_mcc_event_process(adapter, compl);
  } else
#line 488
  if ((compl->flags & 268435456U) != 0U) {
#line 489
    status = be_mcc_compl_process(adapter, compl);
#line 490
    atomic_dec(& mcc_obj->q.used);
  } else {

  }
#line 492
  be_mcc_compl_use(compl);
#line 493
  num = num + 1;
  ldv_54983: 
#line 485
  compl = be_mcc_compl_get(adapter);
#line 485
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 487
    goto ldv_54982;
  } else {

  }

#line 496
  if (num != 0) {
#line 497
    be_cq_notify(adapter, (int )mcc_obj->cq.id, (int )mcc_obj->rearm_cq, (int )((u16 )num));
  } else {

  }
#line 499
  spin_unlock(& adapter->mcc_cq_lock);
#line 500
  return (status);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mcc_wait_compl(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  bool tmp ;
  int tmp___0 ;

  {
#line 507
  status = 0;
#line 508
  mcc_obj = & adapter->mcc_obj;
#line 510
  i = 0;
#line 510
  goto ldv_54993;
  ldv_54992: 
#line 511
  tmp = be_error(adapter);
#line 511
  if ((int )tmp) {
#line 512
    return (-5);
  } else {

  }
#line 514
  local_bh_disable();
#line 515
  status = be_process_mcc(adapter);
#line 516
  local_bh_enable();
#line 518
  tmp___0 = atomic_read((atomic_t const   *)(& mcc_obj->q.used));
#line 518
  if (tmp___0 == 0) {
#line 519
    goto ldv_54991;
  } else {

  }
#line 520
  __const_udelay(429500UL);
#line 510
  i = i + 1;
  ldv_54993: ;
#line 510
  if (i <= 119999) {
#line 512
    goto ldv_54992;
  } else {

  }
  ldv_54991: ;
#line 522
  if (i == 120000) {
#line 523
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 524
    adapter->fw_timeout = 1;
#line 525
    return (-5);
  } else {

  }
#line 527
  return (status);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mcc_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_obj *mcc_obj ;
  u16 index ;
  struct be_cmd_resp_hdr *resp ;
  void *tmp ;

  {
#line 535
  mcc_obj = & adapter->mcc_obj;
#line 536
  index = mcc_obj->q.head;
#line 539
  index_dec(& index, (int )mcc_obj->q.len);
#line 540
  tmp = queue_index_node(& mcc_obj->q, (int )index);
#line 540
  wrb = (struct be_mcc_wrb *)tmp;
#line 542
  resp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);
#line 544
  be_mcc_notify(adapter);
#line 546
  status = be_mcc_wait_compl(adapter);
#line 547
  if (status == -5) {
#line 548
    goto out;
  } else {

  }
#line 550
  status = (int )resp->base_status | ((int )resp->addl_status << 16);
  out: ;
#line 554
  return (status);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mbox_db_ready_wait(struct be_adapter *adapter , void *db ) 
{ 
  int msecs ;
  u32 ready ;
  bool tmp ;

  {
#line 559
  msecs = 0;
  ldv_55010: 
#line 563
  tmp = be_error(adapter);
#line 563
  if ((int )tmp) {
#line 564
    return (-5);
  } else {

  }
#line 566
  ready = ioread32(db);
#line 567
  if (ready == 4294967295U) {
#line 568
    return (-1);
  } else {

  }
#line 570
  ready = ready & 1U;
#line 571
  if (ready != 0U) {
#line 572
    goto ldv_55009;
  } else {

  }
#line 574
  if (msecs > 4000) {
#line 575
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 576
    adapter->fw_timeout = 1;
#line 577
    be_detect_error(adapter);
#line 578
    return (-1);
  } else {

  }
#line 581
  msleep(1U);
#line 582
  msecs = msecs + 1;
#line 583
  goto ldv_55010;
  ldv_55009: ;
#line 585
  return (0);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mbox_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  bool tmp ;

  {
#line 595
  val = 0U;
#line 596
  db = (void *)adapter->db + 352U;
#line 597
  mbox_mem = & adapter->mbox_mem;
#line 598
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 599
  compl = & mbox->compl;
#line 602
  status = be_mbox_db_ready_wait(adapter, db);
#line 603
  if (status != 0) {
#line 604
    return (status);
  } else {

  }
#line 606
  val = val | 2U;
#line 608
  val = ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U) | val;
#line 609
  iowrite32(val, db);
#line 612
  status = be_mbox_db_ready_wait(adapter, db);
#line 613
  if (status != 0) {
#line 614
    return (status);
  } else {

  }
#line 616
  val = 0U;
#line 618
  val = ((unsigned int )(mbox_mem->dma >> 4) << 2) | val;
#line 619
  iowrite32(val, db);
#line 621
  status = be_mbox_db_ready_wait(adapter, db);
#line 622
  if (status != 0) {
#line 623
    return (status);
  } else {

  }
#line 626
  tmp = be_mcc_compl_is_new(compl);
#line 626
  if ((int )tmp) {
#line 627
    status = be_mcc_compl_process(adapter, & mbox->compl);
#line 628
    be_mcc_compl_use(compl);
#line 629
    if (status != 0) {
#line 630
      return (status);
    } else {

    }
  } else {
#line 632
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid mailbox completion\n");
#line 633
    return (-1);
  }
#line 635
  return (0);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static u16 be_POST_stage_get(struct be_adapter *adapter ) 
{ 
  u32 sem ;

  {
#line 642
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 643
    sem = ioread32((void *)adapter->csr + 172U);
  } else {
#line 645
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 148, & sem);
  }
#line 648
  return ((u16 )sem);
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int lancer_wait_ready(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  int status ;
  int i ;

  {
#line 655
  status = 0;
#line 657
  i = 0;
#line 657
  goto ldv_55032;
  ldv_55031: 
#line 658
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 659
  if ((sliport_status & 8388608U) != 0U) {
#line 660
    goto ldv_55030;
  } else {

  }
#line 662
  msleep(1000U);
#line 657
  i = i + 1;
  ldv_55032: ;
#line 657
  if (i <= 29) {
#line 659
    goto ldv_55031;
  } else {

  }
  ldv_55030: ;
#line 665
  if (i == 30) {
#line 666
    status = -1;
  } else {

  }
#line 668
  return (status);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static bool lancer_provisioning_error(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;

  {
#line 673
  sliport_status = 0U;
#line 673
  sliport_err1 = 0U;
#line 673
  sliport_err2 = 0U;
#line 674
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 675
  if ((int )sliport_status < 0) {
#line 676
    sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 677
    sliport_err2 = ioread32((void *)adapter->db + 1040U);
#line 679
    if (sliport_err1 == 2U && sliport_err2 == 9U) {
#line 681
      return (1);
    } else {

    }
  } else {

  }
#line 683
  return (0);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 sliport_status ;
  u32 err ;
  u32 reset_needed ;
  bool resource_error ;

  {
#line 692
  resource_error = lancer_provisioning_error(adapter);
#line 693
  if ((int )resource_error) {
#line 694
    return (-11);
  } else {

  }
#line 696
  status = lancer_wait_ready(adapter);
#line 697
  if (status == 0) {
#line 698
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 699
    err = sliport_status & 2147483648U;
#line 700
    reset_needed = sliport_status & 16777216U;
#line 701
    if (err != 0U && reset_needed != 0U) {
#line 702
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 706
      status = lancer_wait_ready(adapter);
#line 707
      sliport_status = ioread32((void *)adapter->db + 1028U);
#line 709
      sliport_status = sliport_status & 2164260864U;
#line 711
      if (status != 0 || sliport_status != 0U) {
#line 712
        status = -1;
      } else {

      }
    } else
#line 713
    if (err != 0U || reset_needed != 0U) {
#line 714
      status = -1;
    } else {

    }
  } else {

  }
#line 721
  resource_error = lancer_provisioning_error(adapter);
#line 722
  if ((int )resource_error) {
#line 723
    status = -11;
  } else {

  }
#line 725
  return (status);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_fw_wait_ready(struct be_adapter *adapter ) 
{ 
  u16 stage ;
  int status ;
  int timeout ;
  struct device *dev ;
  unsigned long tmp ;

  {
#line 731
  timeout = 0;
#line 732
  dev = & (adapter->pdev)->dev;
#line 734
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 735
    status = lancer_wait_ready(adapter);
#line 736
    return (status);
  } else {

  }
  ldv_55054: 
#line 740
  stage = be_POST_stage_get(adapter);
#line 741
  if ((unsigned int )stage == 49152U) {
#line 742
    return (0);
  } else {

  }
#line 744
  _dev_info((struct device  const  *)dev, "Waiting for POST, %ds elapsed\n", timeout);
#line 745
  tmp = msleep_interruptible(2000U);
#line 745
  if (tmp != 0UL) {
#line 746
    dev_err((struct device  const  *)dev, "Waiting for POST aborted\n");
#line 747
    return (-4);
  } else {

  }
#line 749
  timeout = timeout + 2;
#line 750
  if (timeout <= 59) {
#line 752
    goto ldv_55054;
  } else {

  }
#line 752
  dev_err((struct device  const  *)dev, "POST timeout; stage=0x%x\n", (int )stage);
#line 753
  return (-1);
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 759
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static void fill_wrb_tags(struct be_mcc_wrb *wrb , unsigned long addr ) 
{ 


  {
#line 764
  wrb->tag0 = (u32 )addr;
#line 765
  wrb->tag1 = (unsigned int )(addr >> 32UL);
#line 766
  return;
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem ,
                                   u8 opcode , int cmd_len , struct be_mcc_wrb *wrb ,
                                   struct be_dma_mem *mem ) 
{ 
  struct be_sge *sge ;

  {
#line 777
  req_hdr->opcode = opcode;
#line 778
  req_hdr->subsystem = subsystem;
#line 779
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 780
  req_hdr->version = 0U;
#line 781
  fill_wrb_tags(wrb, (unsigned long )req_hdr);
#line 782
  wrb->payload_length = (u32 )cmd_len;
#line 783
  if ((unsigned long )mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 784
    wrb->embedded = wrb->embedded | 8U;
#line 786
    sge = nonembedded_sgl(wrb);
#line 787
    sge->pa_hi = (unsigned int )(mem->dma >> 32ULL);
#line 788
    sge->pa_lo = (unsigned int )mem->dma;
#line 789
    sge->len = mem->size;
  } else {
#line 791
    wrb->embedded = wrb->embedded | 1U;
  }
#line 792
  swap_dws((void *)wrb, 8);
#line 793
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  unsigned int _min1 ;
  u32 _min2 ;
  u64 dma ;

  {
#line 798
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 798
  _min2 = max_pages;
#line 798
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 799
  dma = mem->dma;
#line 801
  i = 0;
#line 801
  goto ldv_55084;
  ldv_55083: 
#line 802
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 803
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 804
  dma = dma + 4096ULL;
#line 801
  i = i + 1;
  ldv_55084: ;
#line 801
  if (i < buf_pages) {
#line 803
    goto ldv_55083;
  } else {

  }

#line 808
  return;
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
__inline static struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_wrb *wrb ;

  {
#line 810
  mbox_mem = & adapter->mbox_mem;
#line 811
  wrb = & ((struct be_mcc_mailbox *)mbox_mem->va)->wrb;
#line 813
  memset((void *)wrb, 0, 256UL);
#line 814
  return (wrb);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int tmp ;
  void *tmp___0 ;

  {
#line 819
  mccq = & adapter->mcc_obj.q;
#line 822
  if (! mccq->created) {
#line 823
    return ((struct be_mcc_wrb *)0);
  } else {

  }
#line 825
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
#line 825
  if (tmp >= (int )mccq->len) {
#line 826
    return ((struct be_mcc_wrb *)0);
  } else {

  }
#line 828
  tmp___0 = queue_head_node(mccq);
#line 828
  wrb = (struct be_mcc_wrb *)tmp___0;
#line 829
  queue_head_inc___0(mccq);
#line 830
  atomic_inc(& mccq->used);
#line 831
  memset((void *)wrb, 0, 256UL);
#line 832
  return (wrb);
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static bool use_mcc(struct be_adapter *adapter ) 
{ 


  {
#line 837
  return (adapter->mcc_obj.q.created);
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_lock(struct be_adapter *adapter ) 
{ 
  int tmp ;
  bool tmp___0 ;

  {
#line 843
  tmp___0 = use_mcc(adapter);
#line 843
  if ((int )tmp___0) {
#line 844
    spin_lock_bh(& adapter->mcc_lock);
#line 845
    return (0);
  } else {
#line 847
    tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 847
    return (tmp);
  }
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_cmd_unlock(struct be_adapter *adapter ) 
{ 
  bool tmp ;

  {
#line 854
  tmp = use_mcc(adapter);
#line 854
  if ((int )tmp) {
#line 855
    spin_unlock_bh(& adapter->mcc_lock);
  } else {
#line 857
    return;
  }
#line 858
  return;
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  bool tmp ;
  size_t __len ;
  void *__ret ;
  void *tmp___0 ;

  {
#line 865
  tmp = use_mcc(adapter);
#line 865
  if ((int )tmp) {
#line 866
    dest_wrb = wrb_from_mccq(adapter);
#line 867
    if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 868
      return ((struct be_mcc_wrb *)0);
    } else {

    }
  } else {
#line 870
    dest_wrb = wrb_from_mbox(adapter);
  }
#line 873
  __len = 256UL;
#line 873
  if (__len > 63UL) {
#line 873
    __ret = __memcpy((void *)dest_wrb, (void const   *)wrb, __len);
  } else {
#line 873
    __ret = __builtin_memcpy((void *)dest_wrb, (void const   *)wrb, __len);
  }
#line 874
  if ((int )wrb->embedded & 1) {
#line 875
    tmp___0 = embedded_payload(wrb);
#line 875
    fill_wrb_tags(dest_wrb, (unsigned long )tmp___0);
  } else {

  }
#line 877
  return (dest_wrb);
}
}
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_notify_wait(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  int status ;
  bool tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 887
  status = be_cmd_lock(adapter);
#line 888
  if (status != 0) {
#line 889
    return (status);
  } else {

  }
#line 891
  dest_wrb = be_cmd_copy(adapter, wrb);
#line 892
  if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 893
    return (-16);
  } else {

  }
#line 895
  tmp = use_mcc(adapter);
#line 895
  if ((int )tmp) {
#line 896
    status = be_mcc_notify_wait(adapter);
  } else {
#line 898
    status = be_mbox_notify_wait(adapter);
  }
#line 900
  if (status == 0) {
#line 901
    __len = 256UL;
#line 901
    if (__len > 63UL) {
#line 901
      __ret = __memcpy((void *)wrb, (void const   *)dest_wrb, __len);
    } else {
#line 901
      __ret = __builtin_memcpy((void *)wrb, (void const   *)dest_wrb, __len);
    }
  } else {

  }
#line 903
  be_cmd_unlock(adapter);
#line 904
  return (status);
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_fw_init(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 915
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 916
    return (0);
  } else {

  }
#line 918
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 918
  if (tmp != 0) {
#line 919
    return (-1);
  } else {

  }
#line 921
  tmp___0 = wrb_from_mbox(adapter);
#line 921
  wrb = (u8 *)tmp___0;
#line 922
  tmp___1 = wrb;
#line 922
  wrb = wrb + 1;
#line 922
  *tmp___1 = 255U;
#line 923
  tmp___2 = wrb;
#line 923
  wrb = wrb + 1;
#line 923
  *tmp___2 = 18U;
#line 924
  tmp___3 = wrb;
#line 924
  wrb = wrb + 1;
#line 924
  *tmp___3 = 52U;
#line 925
  tmp___4 = wrb;
#line 925
  wrb = wrb + 1;
#line 925
  *tmp___4 = 255U;
#line 926
  tmp___5 = wrb;
#line 926
  wrb = wrb + 1;
#line 926
  *tmp___5 = 255U;
#line 927
  tmp___6 = wrb;
#line 927
  wrb = wrb + 1;
#line 927
  *tmp___6 = 86U;
#line 928
  tmp___7 = wrb;
#line 928
  wrb = wrb + 1;
#line 928
  *tmp___7 = 120U;
#line 929
  *wrb = 255U;
#line 931
  status = be_mbox_notify_wait(adapter);
#line 933
  mutex_unlock(& adapter->mbox_lock);
#line 934
  return (status);
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_fw_clean(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 945
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 946
    return (0);
  } else {

  }
#line 948
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 948
  if (tmp != 0) {
#line 949
    return (-1);
  } else {

  }
#line 951
  tmp___0 = wrb_from_mbox(adapter);
#line 951
  wrb = (u8 *)tmp___0;
#line 952
  tmp___1 = wrb;
#line 952
  wrb = wrb + 1;
#line 952
  *tmp___1 = 255U;
#line 953
  tmp___2 = wrb;
#line 953
  wrb = wrb + 1;
#line 953
  *tmp___2 = 170U;
#line 954
  tmp___3 = wrb;
#line 954
  wrb = wrb + 1;
#line 954
  *tmp___3 = 187U;
#line 955
  tmp___4 = wrb;
#line 955
  wrb = wrb + 1;
#line 955
  *tmp___4 = 255U;
#line 956
  tmp___5 = wrb;
#line 956
  wrb = wrb + 1;
#line 956
  *tmp___5 = 255U;
#line 957
  tmp___6 = wrb;
#line 957
  wrb = wrb + 1;
#line 957
  *tmp___6 = 204U;
#line 958
  tmp___7 = wrb;
#line 958
  wrb = wrb + 1;
#line 958
  *tmp___7 = 221U;
#line 959
  *wrb = 255U;
#line 961
  status = be_mbox_notify_wait(adapter);
#line 963
  mutex_unlock(& adapter->mbox_lock);
#line 964
  return (status);
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eq_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___5 ;

  {
#line 971
  q_mem = & eqo->q.dma_mem;
#line 972
  ver = 0;
#line 974
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 974
  if (tmp != 0) {
#line 975
    return (-1);
  } else {

  }
#line 977
  wrb = wrb_from_mbox(adapter);
#line 978
  tmp___0 = embedded_payload(wrb);
#line 978
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 980
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 13, 100, wrb, (struct be_dma_mem *)0);
#line 985
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 986
    ver = 2;
  } else {

  }
#line 988
  req->hdr.version = (u8 )ver;
#line 989
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 991
  tmp___1 = amap_mask(1U);
#line 991
  amap_set((void *)(& req->context), 0U, tmp___1, 29U, 1U);
#line 993
  tmp___2 = amap_mask(1U);
#line 993
  amap_set((void *)(& req->context), 0U, tmp___2, 31U, 0U);
#line 994
  tmp___3 = __ilog2_u32((unsigned int )eqo->q.len / 256U);
#line 994
  tmp___4 = amap_mask(3U);
#line 994
  amap_set((void *)(& req->context), 1U, tmp___4, 26U, (u32 )tmp___3);
#line 996
  swap_dws((void *)(& req->context), 16);
#line 998
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1000
  status = be_mbox_notify_wait(adapter);
#line 1001
  if (status == 0) {
#line 1002
    tmp___5 = embedded_payload(wrb);
#line 1002
    resp = (struct be_cmd_resp_eq_create *)tmp___5;
#line 1003
    eqo->q.id = resp->eq_id;
#line 1004
    eqo->msix_idx = ver == 2 ? (u8 )resp->msix_idx : eqo->idx;
#line 1006
    eqo->q.created = 1;
  } else {

  }
#line 1009
  mutex_unlock(& adapter->mbox_lock);
#line 1010
  return (status);
}
}
#line 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mac_query *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_mac_query *resp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 1021
  spin_lock_bh(& adapter->mcc_lock);
#line 1023
  wrb = wrb_from_mccq(adapter);
#line 1024
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1025
    status = -16;
#line 1026
    goto err;
  } else {

  }
#line 1028
  tmp = embedded_payload(wrb);
#line 1028
  req = (struct be_cmd_req_mac_query *)tmp;
#line 1030
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 1, 24, wrb, (struct be_dma_mem *)0);
#line 1033
  req->type = 1U;
#line 1034
  if ((int )permanent) {
#line 1035
    req->permanent = 1U;
  } else {
#line 1037
    req->if_id = (unsigned short )if_handle;
#line 1038
    req->pmac_id = pmac_id;
#line 1039
    req->permanent = 0U;
  }
#line 1042
  status = be_mcc_notify_wait(adapter);
#line 1043
  if (status == 0) {
#line 1044
    tmp___0 = embedded_payload(wrb);
#line 1044
    resp = (struct be_cmd_resp_mac_query *)tmp___0;
#line 1045
    __len = 6UL;
#line 1045
    if (__len > 63UL) {
#line 1045
      __ret = __memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr), __len);
    } else {
#line 1045
      __ret = __builtin_memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr),
                               __len);
    }
  } else {

  }
  err: 
#line 1049
  spin_unlock_bh(& adapter->mcc_lock);
#line 1050
  return (status);
}
}
#line 1054 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_add *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  struct be_cmd_resp_pmac_add *resp ;
  void *tmp___0 ;

  {
#line 1061
  spin_lock_bh(& adapter->mcc_lock);
#line 1063
  wrb = wrb_from_mccq(adapter);
#line 1064
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1065
    status = -16;
#line 1066
    goto err;
  } else {

  }
#line 1068
  tmp = embedded_payload(wrb);
#line 1068
  req = (struct be_cmd_req_pmac_add *)tmp;
#line 1070
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 59, 28, wrb, (struct be_dma_mem *)0);
#line 1074
  req->hdr.domain = (u8 )domain;
#line 1075
  req->if_id = if_id;
#line 1076
  __len = 6UL;
#line 1076
  if (__len > 63UL) {
#line 1076
    __ret = __memcpy((void *)(& req->mac_address), (void const   *)mac_addr, __len);
  } else {
#line 1076
    __ret = __builtin_memcpy((void *)(& req->mac_address), (void const   *)mac_addr,
                             __len);
  }
#line 1078
  status = be_mcc_notify_wait(adapter);
#line 1079
  if (status == 0) {
#line 1080
    tmp___0 = embedded_payload(wrb);
#line 1080
    resp = (struct be_cmd_resp_pmac_add *)tmp___0;
#line 1081
    *pmac_id = resp->pmac_id;
  } else {

  }
  err: 
#line 1085
  spin_unlock_bh(& adapter->mcc_lock);
#line 1087
  if (status == 5) {
#line 1088
    status = -1;
  } else {

  }
#line 1090
  return (status);
}
}
#line 1094 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_del *req ;
  int status ;
  void *tmp ;

  {
#line 1100
  if (pmac_id == -1) {
#line 1101
    return (0);
  } else {

  }
#line 1103
  spin_lock_bh(& adapter->mcc_lock);
#line 1105
  wrb = wrb_from_mccq(adapter);
#line 1106
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1107
    status = -16;
#line 1108
    goto err;
  } else {

  }
#line 1110
  tmp = embedded_payload(wrb);
#line 1110
  req = (struct be_cmd_req_pmac_del *)tmp;
#line 1112
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 60, 24, wrb, (struct be_dma_mem *)0);
#line 1115
  req->hdr.domain = (u8 )dom;
#line 1116
  req->if_id = if_id;
#line 1117
  req->pmac_id = (unsigned int )pmac_id;
#line 1119
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1122
  spin_unlock_bh(& adapter->mcc_lock);
#line 1123
  return (status);
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cq_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  int tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___15 ;

  {
#line 1132
  q_mem = & cq->dma_mem;
#line 1136
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1136
  if (tmp != 0) {
#line 1137
    return (-1);
  } else {

  }
#line 1139
  wrb = wrb_from_mbox(adapter);
#line 1140
  tmp___0 = embedded_payload(wrb);
#line 1140
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 1141
  ctxt = (void *)(& req->context);
#line 1143
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 12, 100, wrb, (struct be_dma_mem *)0);
#line 1147
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1149
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1150
    tmp___1 = amap_mask(2U);
#line 1150
    amap_set(ctxt, 0U, tmp___1, 12U, (u32 )coalesce_wm);
#line 1152
    tmp___2 = amap_mask(1U);
#line 1152
    amap_set(ctxt, 0U, tmp___2, 14U, (u32 )no_delay);
#line 1154
    tmp___3 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1154
    tmp___4 = amap_mask(2U);
#line 1154
    amap_set(ctxt, 0U, tmp___4, 27U, (u32 )tmp___3);
#line 1156
    tmp___5 = amap_mask(1U);
#line 1156
    amap_set(ctxt, 0U, tmp___5, 29U, 1U);
#line 1157
    tmp___6 = amap_mask(1U);
#line 1157
    amap_set(ctxt, 0U, tmp___6, 31U, 1U);
#line 1158
    tmp___7 = amap_mask(8U);
#line 1158
    amap_set(ctxt, 1U, tmp___7, 22U, (u32 )eq->id);
  } else {
#line 1160
    req->hdr.version = 2U;
#line 1161
    req->page_size = 1U;
#line 1166
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 1167
      tmp___8 = amap_mask(2U);
#line 1167
      amap_set(ctxt, 0U, tmp___8, 12U, (u32 )coalesce_wm);
    } else {

    }
#line 1169
    tmp___9 = amap_mask(1U);
#line 1169
    amap_set(ctxt, 0U, tmp___9, 14U, (u32 )no_delay);
#line 1171
    tmp___10 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1171
    tmp___11 = amap_mask(2U);
#line 1171
    amap_set(ctxt, 0U, tmp___11, 27U, (u32 )tmp___10);
#line 1173
    tmp___12 = amap_mask(1U);
#line 1173
    amap_set(ctxt, 0U, tmp___12, 29U, 1U);
#line 1174
    tmp___13 = amap_mask(1U);
#line 1174
    amap_set(ctxt, 0U, tmp___13, 31U, 1U);
#line 1175
    tmp___14 = amap_mask(16U);
#line 1175
    amap_set(ctxt, 1U, tmp___14, 0U, (u32 )eq->id);
  }
#line 1178
  swap_dws(ctxt, 16);
#line 1180
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1182
  status = be_mbox_notify_wait(adapter);
#line 1183
  if (status == 0) {
#line 1184
    tmp___15 = embedded_payload(wrb);
#line 1184
    resp = (struct be_cmd_resp_cq_create *)tmp___15;
#line 1185
    cq->id = resp->cq_id;
#line 1186
    cq->created = 1;
  } else {

  }
#line 1189
  mutex_unlock(& adapter->mbox_lock);
#line 1191
  return (status);
}
}
#line 1194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
#line 1196
  tmp = fls(q_len);
#line 1196
  len_encoded = (u32 )tmp;
#line 1197
  if (len_encoded == 16U) {
#line 1198
    len_encoded = 0U;
  } else {

  }
#line 1199
  return (len_encoded);
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_mccq_ext_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_ext_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___10 ;

  {
#line 1208
  q_mem = & mccq->dma_mem;
#line 1212
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1212
  if (tmp != 0) {
#line 1213
    return (-1);
  } else {

  }
#line 1215
  wrb = wrb_from_mbox(adapter);
#line 1216
  tmp___0 = embedded_payload(wrb);
#line 1216
  req = (struct be_cmd_req_mcc_ext_create *)tmp___0;
#line 1217
  ctxt = (void *)(& req->context);
#line 1219
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 90, 104, wrb, (struct be_dma_mem *)0);
#line 1223
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1224
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1225
    tmp___1 = amap_mask(1U);
#line 1225
    amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1226
    tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1226
    tmp___3 = amap_mask(4U);
#line 1226
    amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1228
    tmp___4 = amap_mask(10U);
#line 1228
    amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
  } else {
#line 1230
    req->hdr.version = 1U;
#line 1231
    req->cq_id = cq->id;
#line 1233
    tmp___5 = be_encoded_q_len((int )mccq->len);
#line 1233
    tmp___6 = amap_mask(4U);
#line 1233
    amap_set(ctxt, 0U, tmp___6, 16U, tmp___5);
#line 1235
    tmp___7 = amap_mask(1U);
#line 1235
    amap_set(ctxt, 1U, tmp___7, 31U, 1U);
#line 1236
    tmp___8 = amap_mask(16U);
#line 1236
    amap_set(ctxt, 0U, tmp___8, 0U, (u32 )cq->id);
#line 1238
    tmp___9 = amap_mask(1U);
#line 1238
    amap_set(ctxt, 2U, tmp___9, 0U, 1U);
  }
#line 1243
  req->async_event_bitmap[0] = 34U;
#line 1244
  req->async_event_bitmap[0] = req->async_event_bitmap[0] | 64U;
#line 1245
  swap_dws(ctxt, 16);
#line 1247
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1249
  status = be_mbox_notify_wait(adapter);
#line 1250
  if (status == 0) {
#line 1251
    tmp___10 = embedded_payload(wrb);
#line 1251
    resp = (struct be_cmd_resp_mcc_create *)tmp___10;
#line 1252
    mccq->id = resp->id;
#line 1253
    mccq->created = 1;
  } else {

  }
#line 1255
  mutex_unlock(& adapter->mbox_lock);
#line 1257
  return (status);
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_mccq_org_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
#line 1266
  q_mem = & mccq->dma_mem;
#line 1270
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1270
  if (tmp != 0) {
#line 1271
    return (-1);
  } else {

  }
#line 1273
  wrb = wrb_from_mbox(adapter);
#line 1274
  tmp___0 = embedded_payload(wrb);
#line 1274
  req = (struct be_cmd_req_mcc_create *)tmp___0;
#line 1275
  ctxt = (void *)(& req->context);
#line 1277
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 21, 100, wrb, (struct be_dma_mem *)0);
#line 1281
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1283
  tmp___1 = amap_mask(1U);
#line 1283
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1284
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1284
  tmp___3 = amap_mask(4U);
#line 1284
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1286
  tmp___4 = amap_mask(10U);
#line 1286
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1288
  swap_dws(ctxt, 16);
#line 1290
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1292
  status = be_mbox_notify_wait(adapter);
#line 1293
  if (status == 0) {
#line 1294
    tmp___5 = embedded_payload(wrb);
#line 1294
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1295
    mccq->id = resp->id;
#line 1296
    mccq->created = 1;
  } else {

  }
#line 1299
  mutex_unlock(& adapter->mbox_lock);
#line 1300
  return (status);
}
}
#line 1303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) 
{ 
  int status ;

  {
#line 1308
  status = be_cmd_mccq_ext_create(adapter, mccq, cq);
#line 1309
  if (status != 0 && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1310
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Upgrade to F/W ver 2.102.235.0 or newer to avoid conflicting priorities between NIC and FCoE traffic");
#line 1313
    status = be_cmd_mccq_org_create(adapter, mccq, cq);
  } else {

  }
#line 1315
  return (status);
}
}
#line 1318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_eth_tx_create *req ;
  struct be_queue_info *txq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  void *tmp ;
  u32 tmp___0 ;
  struct be_cmd_resp_eth_tx_create *resp ;
  void *tmp___1 ;

  {
#line 1320
  wrb.embedded = 0U;
#line 1320
  wrb.payload_length = 0U;
#line 1320
  wrb.tag0 = 0U;
#line 1320
  wrb.tag1 = 0U;
#line 1320
  wrb.rsvd = 0U;
#line 1320
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1320
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1322
  txq = & txo->q;
#line 1323
  cq = & txo->cq;
#line 1324
  q_mem = & txq->dma_mem;
#line 1325
  ver = 0;
#line 1327
  tmp = embedded_payload(& wrb);
#line 1327
  req = (struct be_cmd_req_eth_tx_create *)tmp;
#line 1328
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 7, 148, & wrb, (struct be_dma_mem *)0);
#line 1331
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1332
    req->hdr.version = 1U;
  } else
#line 1333
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1334
    if ((adapter->function_caps & 64U) != 0U) {
#line 1335
      req->hdr.version = 2U;
    } else {

    }
  } else {
#line 1337
    req->hdr.version = 2U;
  }
#line 1340
  if ((unsigned int )req->hdr.version != 0U) {
#line 1341
    req->if_id = (unsigned short )adapter->if_handle;
  } else {

  }
#line 1342
  req->num_pages = (u8 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1343
  req->ulp_num = 1U;
#line 1344
  req->type = 2U;
#line 1345
  req->cq_id = cq->id;
#line 1346
  tmp___0 = be_encoded_q_len((int )txq->len);
#line 1346
  req->queue_size = (u8 )tmp___0;
#line 1347
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1348
  ver = (int )req->hdr.version;
#line 1350
  status = be_cmd_notify_wait(adapter, & wrb);
#line 1351
  if (status == 0) {
#line 1352
    tmp___1 = embedded_payload(& wrb);
#line 1352
    resp = (struct be_cmd_resp_eth_tx_create *)tmp___1;
#line 1353
    txq->id = resp->cid;
#line 1354
    if (ver == 2) {
#line 1355
      txo->db_offset = resp->db_offset;
    } else {
#line 1357
      txo->db_offset = 96U;
    }
#line 1358
    txq->created = 1;
  } else {

  }
#line 1361
  return (status);
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eth_rx_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  void *tmp ;
  int tmp___0 ;
  struct be_cmd_resp_eth_rx_create *resp ;
  void *tmp___1 ;

  {
#line 1371
  q_mem = & rxq->dma_mem;
#line 1374
  spin_lock_bh(& adapter->mcc_lock);
#line 1376
  wrb = wrb_from_mccq(adapter);
#line 1377
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1378
    status = -16;
#line 1379
    goto err;
  } else {

  }
#line 1381
  tmp = embedded_payload(wrb);
#line 1381
  req = (struct be_cmd_req_eth_rx_create *)tmp;
#line 1383
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 8, 48, wrb, (struct be_dma_mem *)0);
#line 1386
  req->cq_id = cq_id;
#line 1387
  tmp___0 = fls((int )frag_size);
#line 1387
  req->frag_size = (unsigned int )((u8 )tmp___0) + 255U;
#line 1388
  req->num_pages = 2U;
#line 1389
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 2U, q_mem);
#line 1390
  req->interface_id = if_id;
#line 1391
  req->max_frame_size = 9018U;
#line 1392
  req->rss_queue = rss;
#line 1394
  status = be_mcc_notify_wait(adapter);
#line 1395
  if (status == 0) {
#line 1396
    tmp___1 = embedded_payload(wrb);
#line 1396
    resp = (struct be_cmd_resp_eth_rx_create *)tmp___1;
#line 1397
    rxq->id = resp->id;
#line 1398
    rxq->created = 1;
#line 1399
    *rss_id = resp->rss_id;
  } else {

  }
  err: 
#line 1403
  spin_unlock_bh(& adapter->mcc_lock);
#line 1404
  return (status);
}
}
#line 1410 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1415
  subsys = 0U;
#line 1415
  opcode = 0U;
#line 1418
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1418
  if (tmp != 0) {
#line 1419
    return (-1);
  } else {

  }
#line 1421
  wrb = wrb_from_mbox(adapter);
#line 1422
  tmp___0 = embedded_payload(wrb);
#line 1422
  req = (struct be_cmd_req_q_destroy *)tmp___0;
#line 1424
  switch (queue_type) {
  case 1: 
#line 1426
  subsys = 1U;
#line 1427
  opcode = 55U;
#line 1428
  goto ldv_55277;
  case 2: 
#line 1430
  subsys = 1U;
#line 1431
  opcode = 54U;
#line 1432
  goto ldv_55277;
  case 3: 
#line 1434
  subsys = 3U;
#line 1435
  opcode = 9U;
#line 1436
  goto ldv_55277;
  case 4: 
#line 1438
  subsys = 3U;
#line 1439
  opcode = 10U;
#line 1440
  goto ldv_55277;
  case 5: 
#line 1442
  subsys = 1U;
#line 1443
  opcode = 53U;
#line 1444
  goto ldv_55277;
  default: 
#line 1446
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"),
                       "i" (1446), "i" (12UL));
  ldv_55283: ;
#line 1446
  goto ldv_55283;
  }
  ldv_55277: 
#line 1449
  be_wrb_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20, wrb, (struct be_dma_mem *)0);
#line 1451
  req->id = q->id;
#line 1453
  status = be_mbox_notify_wait(adapter);
#line 1454
  q->created = 0;
#line 1456
  mutex_unlock(& adapter->mbox_lock);
#line 1457
  return (status);
}
}
#line 1461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1467
  spin_lock_bh(& adapter->mcc_lock);
#line 1469
  wrb = wrb_from_mccq(adapter);
#line 1470
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1471
    status = -16;
#line 1472
    goto err;
  } else {

  }
#line 1474
  tmp = embedded_payload(wrb);
#line 1474
  req = (struct be_cmd_req_q_destroy *)tmp;
#line 1476
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 10, 20, wrb, (struct be_dma_mem *)0);
#line 1478
  req->id = q->id;
#line 1480
  status = be_mcc_notify_wait(adapter);
#line 1481
  q->created = 0;
  err: 
#line 1484
  spin_unlock_bh(& adapter->mcc_lock);
#line 1485
  return (status);
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_if_create *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_if_create *resp ;
  void *tmp___0 ;

  {
#line 1494
  wrb.embedded = 0U;
#line 1494
  wrb.payload_length = 0U;
#line 1494
  wrb.tag0 = 0U;
#line 1494
  wrb.tag1 = 0U;
#line 1494
  wrb.rsvd = 0U;
#line 1494
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1494
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1498
  tmp = embedded_payload(& wrb);
#line 1498
  req = (struct be_cmd_req_if_create *)tmp;
#line 1499
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 50, 40, & wrb, (struct be_dma_mem *)0);
#line 1502
  req->hdr.domain = (u8 )domain;
#line 1503
  req->capability_flags = cap_flags;
#line 1504
  req->enable_flags = en_flags;
#line 1505
  req->pmac_invalid = 1U;
#line 1507
  status = be_cmd_notify_wait(adapter, & wrb);
#line 1508
  if (status == 0) {
#line 1509
    tmp___0 = embedded_payload(& wrb);
#line 1509
    resp = (struct be_cmd_resp_if_create *)tmp___0;
#line 1510
    *if_handle = resp->interface_id;
#line 1513
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )adapter->virtfn != 0U) {
#line 1514
      *(adapter->pmac_id) = resp->pmac_id;
    } else {

    }
  } else {

  }
#line 1516
  return (status);
}
}
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_if_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1526
  if (interface_id == -1) {
#line 1527
    return (0);
  } else {

  }
#line 1529
  spin_lock_bh(& adapter->mcc_lock);
#line 1531
  wrb = wrb_from_mccq(adapter);
#line 1532
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1533
    status = -16;
#line 1534
    goto err;
  } else {

  }
#line 1536
  tmp = embedded_payload(wrb);
#line 1536
  req = (struct be_cmd_req_if_destroy *)tmp;
#line 1538
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 51, 20, wrb, (struct be_dma_mem *)0);
#line 1541
  req->hdr.domain = (u8 )domain;
#line 1542
  req->interface_id = (unsigned int )interface_id;
#line 1544
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1546
  spin_unlock_bh(& adapter->mcc_lock);
#line 1547
  return (status);
}
}
#line 1554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  int status ;

  {
#line 1558
  status = 0;
#line 1560
  spin_lock_bh(& adapter->mcc_lock);
#line 1562
  wrb = wrb_from_mccq(adapter);
#line 1563
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1564
    status = -16;
#line 1565
    goto err;
  } else {

  }
#line 1567
  hdr = (struct be_cmd_req_hdr *)nonemb_cmd->va;
#line 1569
  be_wrb_cmd_hdr_prepare(hdr, 3, 4, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1574
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 1575
    hdr->version = 0U;
  } else {

  }
#line 1576
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 1577
    hdr->version = 1U;
  } else {
#line 1579
    hdr->version = 2U;
  }
#line 1581
  be_mcc_notify(adapter);
#line 1582
  adapter->stats_cmd_sent = 1;
  err: 
#line 1585
  spin_unlock_bh(& adapter->mcc_lock);
#line 1586
  return (status);
}
}
#line 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_pport_stats *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1596
  status = 0;
#line 1598
  tmp = be_cmd_allowed(adapter, 18, 3);
#line 1598
  if (tmp) {
#line 1598
    tmp___0 = 0;
  } else {
#line 1598
    tmp___0 = 1;
  }
#line 1598
  if (tmp___0) {
#line 1600
    return (-1);
  } else {

  }
#line 1602
  spin_lock_bh(& adapter->mcc_lock);
#line 1604
  wrb = wrb_from_mccq(adapter);
#line 1605
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1606
    status = -16;
#line 1607
    goto err;
  } else {

  }
#line 1609
  req = (struct lancer_cmd_req_pport_stats *)nonemb_cmd->va;
#line 1611
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 18, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1615
  req->cmd_params.params.pport_num = (unsigned short )adapter->hba_port_num;
#line 1616
  req->cmd_params.params.reset_stats = 0U;
#line 1618
  be_mcc_notify(adapter);
#line 1619
  adapter->stats_cmd_sent = 1;
  err: 
#line 1622
  spin_unlock_bh(& adapter->mcc_lock);
#line 1623
  return (status);
}
}
#line 1626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_mac_to_link_speed(int mac_speed ) 
{ 


  {
#line 1628
  switch (mac_speed) {
  case 0: ;
#line 1630
  return (0);
  case 1: ;
#line 1632
  return (10);
  case 2: ;
#line 1634
  return (100);
  case 3: ;
#line 1636
  return (1000);
  case 4: ;
#line 1638
  return (10000);
  case 5: ;
#line 1640
  return (20000);
  case 6: ;
#line 1642
  return (25000);
  case 7: ;
#line 1644
  return (40000);
  }
#line 1646
  return (0);
}
}
#line 1652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_link_status *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_link_status *resp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1659
  spin_lock_bh(& adapter->mcc_lock);
#line 1661
  if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1662
    *link_status = 0U;
  } else {

  }
#line 1664
  wrb = wrb_from_mccq(adapter);
#line 1665
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1666
    status = -16;
#line 1667
    goto err;
  } else {

  }
#line 1669
  tmp = embedded_payload(wrb);
#line 1669
  req = (struct be_cmd_req_link_status *)tmp;
#line 1671
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 5, 20, wrb, (struct be_dma_mem *)0);
#line 1676
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 1677
    req->hdr.version = 1U;
  } else {

  }
#line 1679
  req->hdr.domain = (u8 )dom;
#line 1681
  status = be_mcc_notify_wait(adapter);
#line 1682
  if (status == 0) {
#line 1683
    tmp___0 = embedded_payload(wrb);
#line 1683
    resp = (struct be_cmd_resp_link_status *)tmp___0;
#line 1684
    if ((unsigned long )link_speed != (unsigned long )((u16 *)0U)) {
#line 1685
      if ((unsigned int )resp->link_speed != 0U) {
#line 1685
        *link_speed = (unsigned int )resp->link_speed * 10U;
      } else {
#line 1685
        tmp___1 = be_mac_to_link_speed((int )resp->mac_speed);
#line 1685
        *link_speed = (u16 )tmp___1;
      }
#line 1689
      if ((unsigned int )resp->logical_link_status == 0U) {
#line 1690
        *link_speed = 0U;
      } else {

      }
    } else {

    }
#line 1692
    if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1693
      *link_status = resp->logical_link_status;
    } else {

    }
  } else {

  }
  err: 
#line 1697
  spin_unlock_bh(& adapter->mcc_lock);
#line 1698
  return (status);
}
}
#line 1702 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_die_temperature(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_cntl_addnl_attribs *req ;
  int status ;
  void *tmp ;

  {
#line 1706
  status = 0;
#line 1708
  spin_lock_bh(& adapter->mcc_lock);
#line 1710
  wrb = wrb_from_mccq(adapter);
#line 1711
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1712
    status = -16;
#line 1713
    goto err;
  } else {

  }
#line 1715
  tmp = embedded_payload(wrb);
#line 1715
  req = (struct be_cmd_req_get_cntl_addnl_attribs *)tmp;
#line 1717
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 121, 24, wrb, (struct be_dma_mem *)0);
#line 1721
  be_mcc_notify(adapter);
  err: 
#line 1724
  spin_unlock_bh(& adapter->mcc_lock);
#line 1725
  return (status);
}
}
#line 1729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fat *resp ;
  void *tmp___0 ;

  {
#line 1735
  spin_lock_bh(& adapter->mcc_lock);
#line 1737
  wrb = wrb_from_mccq(adapter);
#line 1738
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1739
    status = -16;
#line 1740
    goto err;
  } else {

  }
#line 1742
  tmp = embedded_payload(wrb);
#line 1742
  req = (struct be_cmd_req_get_fat *)tmp;
#line 1744
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, 36, wrb, (struct be_dma_mem *)0);
#line 1747
  req->fat_operation = 1U;
#line 1748
  status = be_mcc_notify_wait(adapter);
#line 1749
  if (status == 0) {
#line 1750
    tmp___0 = embedded_payload(wrb);
#line 1750
    resp = (struct be_cmd_resp_get_fat *)tmp___0;
#line 1751
    if ((unsigned long )log_size != (unsigned long )((u32 *)0U) && resp->log_size != 0U) {
#line 1752
      *log_size = resp->log_size - 4U;
    } else {

    }
  } else {

  }
  err: 
#line 1756
  spin_unlock_bh(& adapter->mcc_lock);
#line 1757
  return (status);
}
}
#line 1760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) 
{ 
  struct be_dma_mem get_fat_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  u32 offset ;
  u32 total_size ;
  u32 buf_size ;
  u32 log_offset ;
  u32 payload_len ;
  int status ;
  u32 _min1 ;
  unsigned int _min2 ;
  struct be_cmd_resp_get_fat *resp ;
  size_t __len ;
  void *__ret ;

  {
#line 1765
  offset = 0U;
#line 1766
  log_offset = 4U;
#line 1769
  if (buf_len == 0U) {
#line 1770
    return;
  } else {

  }
#line 1772
  total_size = buf_len;
#line 1774
  get_fat_cmd.size = 61476U;
#line 1775
  get_fat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_fat_cmd.size,
                                        & get_fat_cmd.dma);
#line 1778
  if ((unsigned long )get_fat_cmd.va == (unsigned long )((void *)0)) {
#line 1779
    status = -12;
#line 1780
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while retrieving FAT data\n");
#line 1782
    return;
  } else {

  }
#line 1785
  spin_lock_bh(& adapter->mcc_lock);
#line 1787
  goto ldv_55389;
  ldv_55388: 
#line 1788
  _min1 = total_size;
#line 1788
  _min2 = 61440U;
#line 1788
  buf_size = _min1 < _min2 ? _min1 : _min2;
#line 1789
  total_size = total_size - buf_size;
#line 1791
  wrb = wrb_from_mccq(adapter);
#line 1792
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1793
    status = -16;
#line 1794
    goto err;
  } else {

  }
#line 1796
  req = (struct be_cmd_req_get_fat *)get_fat_cmd.va;
#line 1798
  payload_len = buf_size + 36U;
#line 1799
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, (int )payload_len, wrb, & get_fat_cmd);
#line 1803
  req->fat_operation = 0U;
#line 1804
  req->read_log_offset = log_offset;
#line 1805
  req->read_log_length = buf_size;
#line 1806
  req->data_buffer_size = buf_size;
#line 1808
  status = be_mcc_notify_wait(adapter);
#line 1809
  if (status == 0) {
#line 1810
    resp = (struct be_cmd_resp_get_fat *)get_fat_cmd.va;
#line 1811
    __len = (size_t )resp->read_log_length;
#line 1811
    __ret = __builtin_memcpy(buf + (unsigned long )offset, (void const   *)(& resp->data_buffer),
                             __len);
  } else {
#line 1815
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FAT Table Retrieve error\n");
#line 1816
    goto err;
  }
#line 1818
  offset = offset + buf_size;
#line 1819
  log_offset = log_offset + buf_size;
  ldv_55389: ;
#line 1787
  if (total_size != 0U) {
#line 1789
    goto ldv_55388;
  } else {

  }

  err: 
#line 1822
  pci_free_consistent(adapter->pdev, (size_t )get_fat_cmd.size, get_fat_cmd.va, get_fat_cmd.dma);
#line 1824
  spin_unlock_bh(& adapter->mcc_lock);
#line 1825
  return;
}
}
#line 1828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fw_version *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fw_version *resp ;
  void *tmp___0 ;

  {
#line 1835
  spin_lock_bh(& adapter->mcc_lock);
#line 1837
  wrb = wrb_from_mccq(adapter);
#line 1838
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1839
    status = -16;
#line 1840
    goto err;
  } else {

  }
#line 1843
  tmp = embedded_payload(wrb);
#line 1843
  req = (struct be_cmd_req_get_fw_version *)tmp;
#line 1845
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 35, 80, wrb, (struct be_dma_mem *)0);
#line 1848
  status = be_mcc_notify_wait(adapter);
#line 1849
  if (status == 0) {
#line 1850
    tmp___0 = embedded_payload(wrb);
#line 1850
    resp = (struct be_cmd_resp_get_fw_version *)tmp___0;
#line 1851
    strcpy(fw_ver, (char const   *)(& resp->firmware_version_string));
#line 1852
    if ((unsigned long )fw_on_flash != (unsigned long )((char *)0)) {
#line 1853
      strcpy(fw_on_flash, (char const   *)(& resp->fw_on_flash_version_string));
    } else {

    }
  } else {

  }
  err: 
#line 1856
  spin_unlock_bh(& adapter->mcc_lock);
#line 1857
  return (status);
}
}
#line 1863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  int status ;
  int i ;
  void *tmp ;

  {
#line 1868
  status = 0;
#line 1870
  spin_lock_bh(& adapter->mcc_lock);
#line 1872
  wrb = wrb_from_mccq(adapter);
#line 1873
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1874
    status = -16;
#line 1875
    goto err;
  } else {

  }
#line 1877
  tmp = embedded_payload(wrb);
#line 1877
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 1879
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 41, 404, wrb, (struct be_dma_mem *)0);
#line 1883
  req->num_eq = (unsigned int )num;
#line 1884
  i = 0;
#line 1884
  goto ldv_55412;
  ldv_55411: 
#line 1885
  req->set_eqd[i].eq_id = (set_eqd + (unsigned long )i)->eq_id;
#line 1886
  req->set_eqd[i].phase = 0U;
#line 1887
  req->set_eqd[i].delay_multiplier = (set_eqd + (unsigned long )i)->delay_multiplier;
#line 1884
  i = i + 1;
  ldv_55412: ;
#line 1884
  if (i < num) {
#line 1886
    goto ldv_55411;
  } else {

  }
#line 1891
  be_mcc_notify(adapter);
  err: 
#line 1893
  spin_unlock_bh(& adapter->mcc_lock);
#line 1894
  return (status);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_vlan_config *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1905
  spin_lock_bh(& adapter->mcc_lock);
#line 1907
  wrb = wrb_from_mccq(adapter);
#line 1908
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1909
    status = -16;
#line 1910
    goto err;
  } else {

  }
#line 1912
  tmp = embedded_payload(wrb);
#line 1912
  req = (struct be_cmd_req_vlan_config *)tmp;
#line 1914
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 4, 148, wrb, (struct be_dma_mem *)0);
#line 1918
  req->interface_id = (u8 )if_id;
#line 1919
  req->untagged = (adapter->res.if_cap_flags & 32U) != 0U;
#line 1920
  req->num_vlan = (u8 )num;
#line 1921
  __len = (unsigned long )req->num_vlan * 2UL;
#line 1921
  __ret = __builtin_memcpy((void *)(& req->normal_vlan), (void const   *)vtag_array,
                           __len);
#line 1924
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1926
  spin_unlock_bh(& adapter->mcc_lock);
#line 1927
  return (status);
}
}
#line 1930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_dma_mem *mem ;
  struct be_cmd_req_rx_filter *req ;
  int status ;
  u32 tmp ;
  struct netdev_hw_addr *ha ;
  int i ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1933
  mem = & adapter->rx_filter;
#line 1934
  req = (struct be_cmd_req_rx_filter *)mem->va;
#line 1937
  spin_lock_bh(& adapter->mcc_lock);
#line 1939
  wrb = wrb_from_mccq(adapter);
#line 1940
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1941
    status = -16;
#line 1942
    goto err;
  } else {

  }
#line 1944
  memset((void *)req, 0, 424UL);
#line 1945
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 34, 424, wrb, mem);
#line 1949
  req->if_id = (unsigned int )adapter->if_handle;
#line 1950
  if ((flags & 256U) != 0U) {
#line 1951
    req->if_flags_mask = 648U;
#line 1954
    if (value == 1U) {
#line 1955
      req->if_flags = 648U;
    } else {

    }
  } else
#line 1959
  if ((flags & 512U) != 0U) {
#line 1960
    tmp = 512U;
#line 1960
    req->if_flags = tmp;
#line 1960
    req->if_flags_mask = tmp;
  } else
#line 1962
  if ((flags & 16U) != 0U) {
#line 1963
    req->if_flags_mask = 128U;
#line 1965
    if (value == 1U) {
#line 1966
      req->if_flags = 128U;
    } else {

    }
  } else {
#line 1970
    i = 0;
#line 1972
    tmp___0 = 4096U;
#line 1972
    req->if_flags = tmp___0;
#line 1972
    req->if_flags_mask = tmp___0;
#line 1978
    req->if_flags_mask = req->if_flags_mask | (adapter->res.if_cap_flags & 512U);
#line 1981
    req->mcast_num = (unsigned int )(adapter->netdev)->mc.count;
#line 1982
    __mptr = (struct list_head  const  *)(adapter->netdev)->mc.list.next;
#line 1982
    ha = (struct netdev_hw_addr *)__mptr;
#line 1982
    goto ldv_55447;
    ldv_55446: 
#line 1983
    __len = 6UL;
#line 1983
    if (__len > 63UL) {
#line 1983
      tmp___1 = i;
#line 1983
      i = i + 1;
#line 1983
      __ret = __memcpy((void *)(& req->mcast_mac[tmp___1].byte), (void const   *)(& ha->addr),
                       __len);
    } else {
#line 1983
      tmp___2 = i;
#line 1983
      i = i + 1;
#line 1983
      __ret = __builtin_memcpy((void *)(& req->mcast_mac[tmp___2].byte), (void const   *)(& ha->addr),
                               __len);
    }
#line 1982
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1982
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_55447: ;
#line 1982
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->mc.list)) {
#line 1984
      goto ldv_55446;
    } else {

    }

  }
#line 1986
  if ((req->if_flags_mask & adapter->res.if_cap_flags) != req->if_flags_mask) {
#line 1988
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Cannot set rx filter flags 0x%x\n",
             req->if_flags_mask);
#line 1991
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Interface is capable of 0x%x flags only\n",
             adapter->res.if_cap_flags);
  } else {

  }
#line 1995
  req->if_flags_mask = req->if_flags_mask & adapter->res.if_cap_flags;
#line 1997
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2000
  spin_unlock_bh(& adapter->mcc_lock);
#line 2001
  return (status);
}
}
#line 2005 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 2011
  tmp = be_cmd_allowed(adapter, 36, 1);
#line 2011
  if (tmp) {
#line 2011
    tmp___0 = 0;
  } else {
#line 2011
    tmp___0 = 1;
  }
#line 2011
  if (tmp___0) {
#line 2013
    return (-1);
  } else {

  }
#line 2015
  spin_lock_bh(& adapter->mcc_lock);
#line 2017
  wrb = wrb_from_mccq(adapter);
#line 2018
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2019
    status = -16;
#line 2020
    goto err;
  } else {

  }
#line 2022
  tmp___1 = embedded_payload(wrb);
#line 2022
  req = (struct be_cmd_req_set_flow_control *)tmp___1;
#line 2024
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 36, 20, wrb, (struct be_dma_mem *)0);
#line 2028
  req->tx_flow_control = (unsigned short )tx_fc;
#line 2029
  req->rx_flow_control = (unsigned short )rx_fc;
#line 2031
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2034
  spin_unlock_bh(& adapter->mcc_lock);
#line 2035
  return (status);
}
}
#line 2039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct be_cmd_resp_get_flow_control *resp ;
  void *tmp___2 ;

  {
#line 2045
  tmp = be_cmd_allowed(adapter, 37, 1);
#line 2045
  if (tmp) {
#line 2045
    tmp___0 = 0;
  } else {
#line 2045
    tmp___0 = 1;
  }
#line 2045
  if (tmp___0) {
#line 2047
    return (-1);
  } else {

  }
#line 2049
  spin_lock_bh(& adapter->mcc_lock);
#line 2051
  wrb = wrb_from_mccq(adapter);
#line 2052
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2053
    status = -16;
#line 2054
    goto err;
  } else {

  }
#line 2056
  tmp___1 = embedded_payload(wrb);
#line 2056
  req = (struct be_cmd_req_get_flow_control *)tmp___1;
#line 2058
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 37, 20, wrb, (struct be_dma_mem *)0);
#line 2062
  status = be_mcc_notify_wait(adapter);
#line 2063
  if (status == 0) {
#line 2064
    tmp___2 = embedded_payload(wrb);
#line 2064
    resp = (struct be_cmd_resp_get_flow_control *)tmp___2;
#line 2066
    *tx_fc = (u32 )resp->tx_flow_control;
#line 2067
    *rx_fc = (u32 )resp->rx_flow_control;
  } else {

  }
  err: 
#line 2071
  spin_unlock_bh(& adapter->mcc_lock);
#line 2072
  return (status);
}
}
#line 2076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_query_fw_cfg *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_query_fw_cfg *resp ;
  void *tmp___1 ;

  {
#line 2083
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2083
  if (tmp != 0) {
#line 2084
    return (-1);
  } else {

  }
#line 2086
  wrb = wrb_from_mbox(adapter);
#line 2087
  tmp___0 = embedded_payload(wrb);
#line 2087
  req = (struct be_cmd_req_query_fw_cfg *)tmp___0;
#line 2089
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 58, 140, wrb, (struct be_dma_mem *)0);
#line 2093
  status = be_mbox_notify_wait(adapter);
#line 2094
  if (status == 0) {
#line 2095
    tmp___1 = embedded_payload(wrb);
#line 2095
    resp = (struct be_cmd_resp_query_fw_cfg *)tmp___1;
#line 2096
    *port_num = resp->phys_port;
#line 2097
    *mode = resp->function_mode;
#line 2098
    *caps = resp->function_caps;
#line 2099
    *asic_rev = (unsigned int )((u16 )resp->asic_revision) & 255U;
  } else {

  }
#line 2102
  mutex_unlock(& adapter->mbox_lock);
#line 2103
  return (status);
}
}
#line 2107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_reset_function(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 2113
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2114
    status = lancer_wait_ready(adapter);
#line 2115
    if (status == 0) {
#line 2116
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 2118
      status = lancer_test_and_set_rdy_state(adapter);
    } else {

    }
#line 2120
    if (status != 0) {
#line 2121
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter in non recoverable error\n");
    } else {

    }
#line 2124
    return (status);
  } else {

  }
#line 2127
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2127
  if (tmp != 0) {
#line 2128
    return (-1);
  } else {

  }
#line 2130
  wrb = wrb_from_mbox(adapter);
#line 2131
  tmp___0 = embedded_payload(wrb);
#line 2131
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 2133
  be_wrb_cmd_hdr_prepare(req, 1, 61, 16, wrb, (struct be_dma_mem *)0);
#line 2137
  status = be_mbox_notify_wait(adapter);
#line 2139
  mutex_unlock(& adapter->mbox_lock);
#line 2140
  return (status);
}
}
#line 2143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size , u8 const   *rss_hkey ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_rss_config *req ;
  int status ;
  void *tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2150
  if ((adapter->res.if_cap_flags & 4U) == 0U) {
#line 2151
    return (0);
  } else {

  }
#line 2153
  spin_lock_bh(& adapter->mcc_lock);
#line 2155
  wrb = wrb_from_mccq(adapter);
#line 2156
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2157
    status = -16;
#line 2158
    goto err;
  } else {

  }
#line 2160
  tmp = embedded_payload(wrb);
#line 2160
  req = (struct be_cmd_req_rss_config *)tmp;
#line 2162
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 1, 196, wrb, (struct be_dma_mem *)0);
#line 2165
  req->if_id = (unsigned int )adapter->if_handle;
#line 2166
  req->enable_rss = (unsigned short )rss_hash_opts;
#line 2167
  tmp___0 = fls((int )table_size);
#line 2167
  req->cpu_table_size_log2 = (unsigned int )((unsigned short )tmp___0) - 1U;
#line 2169
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 2170
    req->hdr.version = 1U;
  } else {

  }
#line 2172
  __len = (size_t )table_size;
#line 2172
  __ret = __builtin_memcpy((void *)(& req->cpu_table), (void const   *)rsstable, __len);
#line 2173
  __len___0 = 40UL;
#line 2173
  if (__len___0 > 63UL) {
#line 2173
    __ret___0 = __memcpy((void *)(& req->hash), (void const   *)rss_hkey, __len___0);
  } else {
#line 2173
    __ret___0 = __builtin_memcpy((void *)(& req->hash), (void const   *)rss_hkey,
                                 __len___0);
  }
#line 2174
  swap_dws((void *)(& req->hash), 40);
#line 2176
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2178
  spin_unlock_bh(& adapter->mcc_lock);
#line 2179
  return (status);
}
}
#line 2183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_enable_disable_beacon *req ;
  int status ;
  void *tmp ;

  {
#line 2190
  spin_lock_bh(& adapter->mcc_lock);
#line 2192
  wrb = wrb_from_mccq(adapter);
#line 2193
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2194
    status = -16;
#line 2195
    goto err;
  } else {

  }
#line 2197
  tmp = embedded_payload(wrb);
#line 2197
  req = (struct be_cmd_req_enable_disable_beacon *)tmp;
#line 2199
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 69, 20, wrb, (struct be_dma_mem *)0);
#line 2203
  req->port_num = port_num;
#line 2204
  req->beacon_state = state;
#line 2205
  req->beacon_duration = bcn;
#line 2206
  req->status_duration = sts;
#line 2208
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2211
  spin_unlock_bh(& adapter->mcc_lock);
#line 2212
  return (status);
}
}
#line 2216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_beacon_state *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_beacon_state *resp ;
  void *tmp___0 ;

  {
#line 2222
  spin_lock_bh(& adapter->mcc_lock);
#line 2224
  wrb = wrb_from_mccq(adapter);
#line 2225
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2226
    status = -16;
#line 2227
    goto err;
  } else {

  }
#line 2229
  tmp = embedded_payload(wrb);
#line 2229
  req = (struct be_cmd_req_get_beacon_state *)tmp;
#line 2231
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 70, 20, wrb, (struct be_dma_mem *)0);
#line 2235
  req->port_num = port_num;
#line 2237
  status = be_mcc_notify_wait(adapter);
#line 2238
  if (status == 0) {
#line 2239
    tmp___0 = embedded_payload(wrb);
#line 2239
    resp = (struct be_cmd_resp_get_beacon_state *)tmp___0;
#line 2241
    *state = (u32 )resp->beacon_state;
  } else {

  }
  err: 
#line 2245
  spin_unlock_bh(& adapter->mcc_lock);
#line 2246
  return (status);
}
}
#line 2249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_write_object *req ;
  struct lancer_cmd_resp_write_object *resp ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;

  {
#line 2257
  ctxt = (void *)0;
#line 2260
  spin_lock_bh(& adapter->mcc_lock);
#line 2261
  adapter->flash_status = 0U;
#line 2263
  wrb = wrb_from_mccq(adapter);
#line 2264
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2265
    status = -16;
#line 2266
    goto err_unlock;
  } else {

  }
#line 2269
  tmp = embedded_payload(wrb);
#line 2269
  req = (struct lancer_cmd_req_write_object *)tmp;
#line 2271
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 172, 144, wrb, (struct be_dma_mem *)0);
#line 2276
  ctxt = (void *)(& req->context);
#line 2277
  tmp___0 = amap_mask(24U);
#line 2277
  amap_set(ctxt, 0U, tmp___0, 0U, data_size);
#line 2280
  if (data_size == 0U) {
#line 2281
    tmp___1 = amap_mask(1U);
#line 2281
    amap_set(ctxt, 0U, tmp___1, 31U, 1U);
  } else {
#line 2284
    tmp___2 = amap_mask(1U);
#line 2284
    amap_set(ctxt, 0U, tmp___2, 31U, 0U);
  }
#line 2287
  swap_dws(ctxt, 4);
#line 2288
  req->write_offset = data_offset;
#line 2289
  strcpy((char *)(& req->object_name), obj_name);
#line 2290
  req->descriptor_count = 1U;
#line 2291
  req->buf_len = data_size;
#line 2292
  req->addr_low = (unsigned int )cmd->dma + 144U;
#line 2295
  req->addr_high = (unsigned int )((cmd->dma + 144ULL) >> 32ULL);
#line 2298
  be_mcc_notify(adapter);
#line 2299
  spin_unlock_bh(& adapter->mcc_lock);
#line 2301
  tmp___3 = msecs_to_jiffies(60000U);
#line 2301
  tmp___4 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp___3);
#line 2301
  if (tmp___4 == 0UL) {
#line 2303
    status = -1;
  } else {
#line 2305
    status = (int )adapter->flash_status;
  }
#line 2307
  tmp___5 = embedded_payload(wrb);
#line 2307
  resp = (struct lancer_cmd_resp_write_object *)tmp___5;
#line 2308
  if (status == 0) {
#line 2309
    *data_written = resp->actual_write_len;
#line 2310
    *change_status = resp->change_status;
  } else {
#line 2312
    *addn_status = resp->additional_status;
  }
#line 2315
  return (status);
  err_unlock: 
#line 2318
  spin_unlock_bh(& adapter->mcc_lock);
#line 2319
  return (status);
}
}
#line 2322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_read_object *req ;
  struct lancer_cmd_resp_read_object *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2331
  spin_lock_bh(& adapter->mcc_lock);
#line 2333
  wrb = wrb_from_mccq(adapter);
#line 2334
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2335
    status = -16;
#line 2336
    goto err_unlock;
  } else {

  }
#line 2339
  tmp = embedded_payload(wrb);
#line 2339
  req = (struct lancer_cmd_req_read_object *)tmp;
#line 2341
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 171, 144, wrb, (struct be_dma_mem *)0);
#line 2346
  req->desired_read_len = data_size;
#line 2347
  req->read_offset = data_offset;
#line 2348
  strcpy((char *)(& req->object_name), obj_name);
#line 2349
  req->descriptor_count = 1U;
#line 2350
  req->buf_len = data_size;
#line 2351
  req->addr_low = (unsigned int )cmd->dma;
#line 2352
  req->addr_high = (unsigned int )(cmd->dma >> 32ULL);
#line 2354
  status = be_mcc_notify_wait(adapter);
#line 2356
  tmp___0 = embedded_payload(wrb);
#line 2356
  resp = (struct lancer_cmd_resp_read_object *)tmp___0;
#line 2357
  if (status == 0) {
#line 2358
    *data_read = resp->actual_read_len;
#line 2359
    *eof = resp->eof;
  } else {
#line 2361
    *addn_status = resp->additional_status;
  }
  err_unlock: 
#line 2365
  spin_unlock_bh(& adapter->mcc_lock);
#line 2366
  return (status);
}
}
#line 2369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_write_flashrom *req ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 2376
  spin_lock_bh(& adapter->mcc_lock);
#line 2377
  adapter->flash_status = 0U;
#line 2379
  wrb = wrb_from_mccq(adapter);
#line 2380
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2381
    status = -16;
#line 2382
    goto err_unlock;
  } else {

  }
#line 2384
  req = (struct be_cmd_write_flashrom *)cmd->va;
#line 2386
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 7, (int )cmd->size, wrb, cmd);
#line 2390
  req->params.op_type = flash_type;
#line 2391
  req->params.op_code = flash_opcode;
#line 2392
  req->params.data_buf_size = buf_size;
#line 2394
  be_mcc_notify(adapter);
#line 2395
  spin_unlock_bh(& adapter->mcc_lock);
#line 2397
  tmp = msecs_to_jiffies(40000U);
#line 2397
  tmp___0 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp);
#line 2397
  if (tmp___0 == 0UL) {
#line 2399
    status = -1;
  } else {
#line 2401
    status = (int )adapter->flash_status;
  }
#line 2403
  return (status);
  err_unlock: 
#line 2406
  spin_unlock_bh(& adapter->mcc_lock);
#line 2407
  return (status);
}
}
#line 2410 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , u16 optype ,
                         int offset ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_read_flash_crc *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2417
  spin_lock_bh(& adapter->mcc_lock);
#line 2419
  wrb = wrb_from_mccq(adapter);
#line 2420
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2421
    status = -16;
#line 2422
    goto err;
  } else {

  }
#line 2424
  tmp = embedded_payload(wrb);
#line 2424
  req = (struct be_cmd_read_flash_crc *)tmp;
#line 2426
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 6, 40, wrb, (struct be_dma_mem *)0);
#line 2430
  req->params.op_type = (unsigned int )optype;
#line 2431
  req->params.op_code = 4U;
#line 2432
  req->params.offset = (unsigned int )offset;
#line 2433
  req->params.data_buf_size = 4U;
#line 2435
  status = be_mcc_notify_wait(adapter);
#line 2436
  if (status == 0) {
#line 2437
    __len = 4UL;
#line 2437
    if (__len > 63UL) {
#line 2437
      __ret = __memcpy((void *)flashed_crc, (void const   *)(& req->crc), __len);
    } else {
#line 2437
      __ret = __builtin_memcpy((void *)flashed_crc, (void const   *)(& req->crc),
                               __len);
    }
  } else {

  }
  err: 
#line 2440
  spin_unlock_bh(& adapter->mcc_lock);
#line 2441
  return (status);
}
}
#line 2444 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config *req ;
  int status ;
  size_t __len ;
  void *__ret ;

  {
#line 2451
  spin_lock_bh(& adapter->mcc_lock);
#line 2453
  wrb = wrb_from_mccq(adapter);
#line 2454
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2455
    status = -16;
#line 2456
    goto err;
  } else {

  }
#line 2458
  req = (struct be_cmd_req_acpi_wol_magic_config *)nonemb_cmd->va;
#line 2460
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 604, wrb, nonemb_cmd);
#line 2463
  __len = 6UL;
#line 2463
  if (__len > 63UL) {
#line 2463
    __ret = __memcpy((void *)(& req->magic_mac), (void const   *)mac, __len);
  } else {
#line 2463
    __ret = __builtin_memcpy((void *)(& req->magic_mac), (void const   *)mac, __len);
  }
#line 2465
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2468
  spin_unlock_bh(& adapter->mcc_lock);
#line 2469
  return (status);
}
}
#line 2472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_lmode *req ;
  int status ;
  void *tmp ;

  {
#line 2479
  spin_lock_bh(& adapter->mcc_lock);
#line 2481
  wrb = wrb_from_mccq(adapter);
#line 2482
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2483
    status = -16;
#line 2484
    goto err;
  } else {

  }
#line 2487
  tmp = embedded_payload(wrb);
#line 2487
  req = (struct be_cmd_req_set_lmode *)tmp;
#line 2489
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 19, 20, wrb, (struct be_dma_mem *)0);
#line 2493
  req->src_port = port_num;
#line 2494
  req->dest_port = port_num;
#line 2495
  req->loopback_type = loopback_type;
#line 2496
  req->loopback_state = enable;
#line 2498
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2500
  spin_unlock_bh(& adapter->mcc_lock);
#line 2501
  return (status);
}
}
#line 2504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_loopback_test *req ;
  struct be_cmd_resp_loopback_test *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2513
  spin_lock_bh(& adapter->mcc_lock);
#line 2515
  wrb = wrb_from_mccq(adapter);
#line 2516
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2517
    status = -16;
#line 2518
    goto err;
  } else {

  }
#line 2521
  tmp = embedded_payload(wrb);
#line 2521
  req = (struct be_cmd_req_loopback_test *)tmp;
#line 2523
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 18, 48, wrb, (struct be_dma_mem *)0);
#line 2527
  req->hdr.timeout = 15U;
#line 2528
  req->pattern = pattern;
#line 2529
  req->src_port = port_num;
#line 2530
  req->dest_port = port_num;
#line 2531
  req->pkt_size = pkt_size;
#line 2532
  req->num_pkts = num_pkts;
#line 2533
  req->loopback_type = loopback_type;
#line 2535
  be_mcc_notify(adapter);
#line 2537
  spin_unlock_bh(& adapter->mcc_lock);
#line 2539
  wait_for_completion(& adapter->et_cmd_compl);
#line 2540
  tmp___0 = embedded_payload(wrb);
#line 2540
  resp = (struct be_cmd_resp_loopback_test *)tmp___0;
#line 2541
  status = (int )resp->status;
#line 2543
  return (status);
  err: 
#line 2545
  spin_unlock_bh(& adapter->mcc_lock);
#line 2546
  return (status);
}
}
#line 2549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_ddrdma_test *req ;
  int status ;
  int i ;
  int j ;
  struct be_cmd_resp_ddrdma_test *resp ;
  int tmp ;

  {
#line 2555
  j = 0;
#line 2557
  spin_lock_bh(& adapter->mcc_lock);
#line 2559
  wrb = wrb_from_mccq(adapter);
#line 2560
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2561
    status = -16;
#line 2562
    goto err;
  } else {

  }
#line 2564
  req = (struct be_cmd_req_ddrdma_test *)cmd->va;
#line 2565
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 17, (int )cmd->size, wrb, cmd);
#line 2569
  req->pattern = pattern;
#line 2570
  req->byte_count = byte_cnt;
#line 2571
  i = 0;
#line 2571
  goto ldv_55626;
  ldv_55625: 
#line 2572
  req->snd_buff[i] = (unsigned char )(pattern >> j * 8);
#line 2573
  j = j + 1;
#line 2574
  if (j > 7) {
#line 2575
    j = 0;
  } else {

  }
#line 2571
  i = i + 1;
  ldv_55626: ;
#line 2571
  if ((u32 )i < byte_cnt) {
#line 2573
    goto ldv_55625;
  } else {

  }
#line 2578
  status = be_mcc_notify_wait(adapter);
#line 2580
  if (status == 0) {
#line 2582
    resp = (struct be_cmd_resp_ddrdma_test *)cmd->va;
#line 2583
    tmp = memcmp((void const   *)(& resp->rcv_buff), (void const   *)(& req->snd_buff),
                 (size_t )byte_cnt);
#line 2583
    if (tmp != 0 || resp->snd_err != 0U) {
#line 2585
      status = -1;
    } else {

    }
  } else {

  }
  err: 
#line 2590
  spin_unlock_bh(& adapter->mcc_lock);
#line 2591
  return (status);
}
}
#line 2594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_seeprom_read *req ;
  int status ;

  {
#line 2601
  spin_lock_bh(& adapter->mcc_lock);
#line 2603
  wrb = wrb_from_mccq(adapter);
#line 2604
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2605
    status = -16;
#line 2606
    goto err;
  } else {

  }
#line 2608
  req = (struct be_cmd_req_seeprom_read *)nonemb_cmd->va;
#line 2610
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 30, 1040, wrb, nonemb_cmd);
#line 2614
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2617
  spin_unlock_bh(& adapter->mcc_lock);
#line 2618
  return (status);
}
}
#line 2621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_phy_info(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_phy_info *req ;
  struct be_dma_mem cmd ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  struct be_phy_info *resp_phy_info ;

  {
#line 2628
  tmp = be_cmd_allowed(adapter, 102, 1);
#line 2628
  if (tmp) {
#line 2628
    tmp___0 = 0;
  } else {
#line 2628
    tmp___0 = 1;
  }
#line 2628
  if (tmp___0) {
#line 2630
    return (-1);
  } else {

  }
#line 2632
  spin_lock_bh(& adapter->mcc_lock);
#line 2634
  wrb = wrb_from_mccq(adapter);
#line 2635
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2636
    status = -16;
#line 2637
    goto err;
  } else {

  }
#line 2639
  cmd.size = 40U;
#line 2640
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 2641
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2642
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 2643
    status = -12;
#line 2644
    goto err;
  } else {

  }
#line 2647
  req = (struct be_cmd_req_get_phy_info *)cmd.va;
#line 2649
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 102, 40, wrb, & cmd);
#line 2653
  status = be_mcc_notify_wait(adapter);
#line 2654
  if (status == 0) {
#line 2655
    resp_phy_info = (struct be_phy_info *)cmd.va + 16U;
#line 2657
    adapter->phy.phy_type = resp_phy_info->phy_type;
#line 2658
    adapter->phy.interface_type = resp_phy_info->interface_type;
#line 2660
    adapter->phy.auto_speeds_supported = resp_phy_info->auto_speeds_supported;
#line 2662
    adapter->phy.fixed_speeds_supported = resp_phy_info->fixed_speeds_supported;
#line 2664
    adapter->phy.misc_params = resp_phy_info->misc_params;
#line 2667
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 2668
      adapter->phy.fixed_speeds_supported = 12U;
    } else {

    }
  } else {

  }
#line 2673
  pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  err: 
#line 2675
  spin_unlock_bh(& adapter->mcc_lock);
#line 2676
  return (status);
}
}
#line 2679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_qos *req ;
  int status ;
  void *tmp ;

  {
#line 2685
  spin_lock_bh(& adapter->mcc_lock);
#line 2687
  wrb = wrb_from_mccq(adapter);
#line 2688
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2689
    status = -16;
#line 2690
    goto err;
  } else {

  }
#line 2693
  tmp = embedded_payload(wrb);
#line 2693
  req = (struct be_cmd_req_set_qos *)tmp;
#line 2695
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 28, 52, wrb, (struct be_dma_mem *)0);
#line 2698
  req->hdr.domain = (u8 )domain;
#line 2699
  req->valid_bits = 1U;
#line 2700
  req->max_bps_nic = bps;
#line 2702
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2705
  spin_unlock_bh(& adapter->mcc_lock);
#line 2706
  return (status);
}
}
#line 2709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cntl_attribs *req ;
  int status ;
  int payload_len ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct mgmt_controller_attrib *attribs ;
  struct be_dma_mem attribs_cmd ;
  int tmp ;

  {
#line 2715
  _max1 = 16UL;
#line 2715
  _max2 = 560UL;
#line 2715
  payload_len = (int )(_max1 > _max2 ? _max1 : _max2);
#line 2719
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2719
  if (tmp != 0) {
#line 2720
    return (-1);
  } else {

  }
#line 2722
  memset((void *)(& attribs_cmd), 0, 24UL);
#line 2723
  attribs_cmd.size = 560U;
#line 2724
  attribs_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )attribs_cmd.size,
                                        & attribs_cmd.dma);
#line 2726
  if ((unsigned long )attribs_cmd.va == (unsigned long )((void *)0)) {
#line 2727
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 2728
    status = -12;
#line 2729
    goto err;
  } else {

  }
#line 2732
  wrb = wrb_from_mbox(adapter);
#line 2733
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2734
    status = -16;
#line 2735
    goto err;
  } else {

  }
#line 2737
  req = (struct be_cmd_req_cntl_attribs *)attribs_cmd.va;
#line 2739
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 32, payload_len, wrb, & attribs_cmd);
#line 2743
  status = be_mbox_notify_wait(adapter);
#line 2744
  if (status == 0) {
#line 2745
    attribs = (struct mgmt_controller_attrib *)attribs_cmd.va + 16U;
#line 2746
    adapter->hba_port_num = attribs->hba_attribs.phy_port;
  } else {

  }
  err: 
#line 2750
  mutex_unlock(& adapter->mbox_lock);
#line 2751
  if ((unsigned long )attribs_cmd.va != (unsigned long )((void *)0)) {
#line 2752
    pci_free_consistent(adapter->pdev, (size_t )attribs_cmd.size, attribs_cmd.va,
                        attribs_cmd.dma);
  } else {

  }
#line 2754
  return (status);
}
}
#line 2758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_req_native_mode(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_func_cap *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_set_func_cap *resp ;
  void *tmp___1 ;

  {
#line 2764
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2764
  if (tmp != 0) {
#line 2765
    return (-1);
  } else {

  }
#line 2767
  wrb = wrb_from_mbox(adapter);
#line 2768
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2769
    status = -16;
#line 2770
    goto err;
  } else {

  }
#line 2773
  tmp___0 = embedded_payload(wrb);
#line 2773
  req = (struct be_cmd_req_set_func_cap *)tmp___0;
#line 2775
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 103, 236, wrb, (struct be_dma_mem *)0);
#line 2779
  req->valid_cap_flags = 6U;
#line 2781
  req->cap_flags = 4U;
#line 2783
  status = be_mbox_notify_wait(adapter);
#line 2784
  if (status == 0) {
#line 2785
    tmp___1 = embedded_payload(wrb);
#line 2785
    resp = (struct be_cmd_resp_set_func_cap *)tmp___1;
#line 2786
    adapter->be3_native = (resp->cap_flags & 4U) != 0U;
#line 2788
    if (! adapter->be3_native) {
#line 2789
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "adapter not in advanced mode\n");
    } else {

    }
  } else {

  }
  err: 
#line 2793
  mutex_unlock(& adapter->mbox_lock);
#line 2794
  return (status);
}
}
#line 2798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fn_privileges *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fn_privileges *resp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2805
  spin_lock_bh(& adapter->mcc_lock);
#line 2807
  wrb = wrb_from_mccq(adapter);
#line 2808
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2809
    status = -16;
#line 2810
    goto err;
  } else {

  }
#line 2813
  tmp = embedded_payload(wrb);
#line 2813
  req = (struct be_cmd_req_get_fn_privileges *)tmp;
#line 2815
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 170, 20, wrb, (struct be_dma_mem *)0);
#line 2819
  req->hdr.domain = (u8 )domain;
#line 2821
  status = be_mcc_notify_wait(adapter);
#line 2822
  if (status == 0) {
#line 2823
    tmp___0 = embedded_payload(wrb);
#line 2823
    resp = (struct be_cmd_resp_get_fn_privileges *)tmp___0;
#line 2825
    *privilege = resp->privilege_mask;
#line 2830
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 2830
      tmp___1 = be_is_mc(adapter);
#line 2830
      if ((int )tmp___1) {
#line 2830
        if ((unsigned int )adapter->virtfn == 0U) {
#line 2832
          *privilege = 1792U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  err: 
#line 2836
  spin_unlock_bh(& adapter->mcc_lock);
#line 2837
  return (status);
}
}
#line 2841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_fn_privileges *req ;
  int status ;
  void *tmp ;

  {
#line 2848
  spin_lock_bh(& adapter->mcc_lock);
#line 2850
  wrb = wrb_from_mccq(adapter);
#line 2851
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2852
    status = -16;
#line 2853
    goto err;
  } else {

  }
#line 2856
  tmp = embedded_payload(wrb);
#line 2856
  req = (struct be_cmd_req_set_fn_privileges *)tmp;
#line 2857
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 100, 24, wrb, (struct be_dma_mem *)0);
#line 2860
  req->hdr.domain = (u8 )domain;
#line 2861
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2862
    req->privileges_lancer = privileges;
  } else {
#line 2864
    req->privileges = privileges;
  }
#line 2866
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2868
  spin_unlock_bh(& adapter->mcc_lock);
#line 2869
  return (status);
}
}
#line 2876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_mac_list *req ;
  int status ;
  int mac_count ;
  struct be_dma_mem get_mac_list_cmd ;
  int i ;
  struct be_cmd_resp_get_mac_list *resp ;
  size_t __len ;
  void *__ret ;
  struct get_list_macaddr *mac_entry ;
  u16 mac_addr_size ;
  u32 mac_id ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2887
  memset((void *)(& get_mac_list_cmd), 0, 24UL);
#line 2888
  get_mac_list_cmd.size = 548U;
#line 2889
  get_mac_list_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size,
                                             & get_mac_list_cmd.dma);
#line 2893
  if ((unsigned long )get_mac_list_cmd.va == (unsigned long )((void *)0)) {
#line 2894
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure during GET_MAC_LIST\n");
#line 2896
    return (-12);
  } else {

  }
#line 2899
  spin_lock_bh(& adapter->mcc_lock);
#line 2901
  wrb = wrb_from_mccq(adapter);
#line 2902
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2903
    status = -16;
#line 2904
    goto out;
  } else {

  }
#line 2907
  req = (struct be_cmd_req_get_mac_list *)get_mac_list_cmd.va;
#line 2909
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 147, (int )get_mac_list_cmd.size, wrb, & get_mac_list_cmd);
#line 2912
  req->hdr.domain = domain;
#line 2913
  req->mac_type = 1U;
#line 2914
  if ((int )*pmac_id_valid) {
#line 2915
    req->mac_id = *pmac_id;
#line 2916
    req->iface_id = (unsigned short )if_handle;
#line 2917
    req->perm_override = 0U;
  } else {
#line 2919
    req->perm_override = 1U;
  }
#line 2922
  status = be_mcc_notify_wait(adapter);
#line 2923
  if (status == 0) {
#line 2924
    resp = (struct be_cmd_resp_get_mac_list *)get_mac_list_cmd.va;
#line 2927
    if ((int )*pmac_id_valid) {
#line 2928
      __len = 6UL;
#line 2928
      if (__len > 63UL) {
#line 2928
        __ret = __memcpy((void *)mac, (void const   *)(& resp->macid_macaddr.mac_addr_id.macaddr),
                         __len);
      } else {
#line 2928
        __ret = __builtin_memcpy((void *)mac, (void const   *)(& resp->macid_macaddr.mac_addr_id.macaddr),
                                 __len);
      }
#line 2930
      goto out;
    } else {

    }
#line 2933
    mac_count = (int )resp->true_mac_count + (int )resp->pseudo_mac_count;
#line 2939
    i = 0;
#line 2939
    goto ldv_55719;
    ldv_55718: 
#line 2944
    mac_entry = (struct get_list_macaddr *)(& resp->macaddr_list) + (unsigned long )i;
#line 2945
    mac_addr_size = mac_entry->mac_addr_size;
#line 2949
    if ((unsigned int )mac_addr_size == 4U) {
#line 2950
      *pmac_id_valid = 1;
#line 2951
      mac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;
#line 2952
      *pmac_id = mac_id;
#line 2953
      goto out;
    } else {

    }
#line 2939
    i = i + 1;
    ldv_55719: ;
#line 2939
    if (i < mac_count) {
#line 2941
      goto ldv_55718;
    } else {

    }
#line 2957
    *pmac_id_valid = 0;
#line 2958
    __len___0 = 6UL;
#line 2958
    if (__len___0 > 63UL) {
#line 2958
      __ret___0 = __memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
                           __len___0);
    } else {
#line 2958
      __ret___0 = __builtin_memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
                                   __len___0);
    }
  } else {

  }
  out: 
#line 2963
  spin_unlock_bh(& adapter->mcc_lock);
#line 2964
  pci_free_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size, get_mac_list_cmd.va,
                      get_mac_list_cmd.dma);
#line 2966
  return (status);
}
}
#line 2969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2973
  if (! active) {
#line 2974
    be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle, (int )((u8 )domain));
  } else {

  }
#line 2976
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 2977
    tmp = be_cmd_mac_addr_query(adapter, mac, 0, if_handle, curr_pmac_id);
#line 2977
    return (tmp);
  } else {
#line 2981
    tmp___0 = be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle,
                                       (int )((u8 )domain));
#line 2981
    return (tmp___0);
  }
}
}
#line 2986 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) 
{ 
  int status ;
  bool pmac_valid ;

  {
#line 2989
  pmac_valid = 0;
#line 2991
  memset((void *)mac, 0, 6UL);
#line 2993
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 2994
    if ((unsigned int )adapter->virtfn == 0U) {
#line 2995
      status = be_cmd_mac_addr_query(adapter, mac, 1, 0U, 0U);
    } else {
#line 2998
      status = be_cmd_mac_addr_query(adapter, mac, 0, (u32 )adapter->if_handle, 0U);
    }
  } else {
#line 3001
    status = be_cmd_get_mac_from_list(adapter, mac, & pmac_valid, (u32 *)0U, (u32 )adapter->if_handle,
                                      0);
  }
#line 3005
  return (status);
}
}
#line 3009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_mac_list *req ;
  int status ;
  struct be_dma_mem cmd ;
  size_t __len ;
  void *__ret ;

  {
#line 3017
  memset((void *)(& cmd), 0, 24UL);
#line 3018
  cmd.size = 404U;
#line 3019
  cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma, 208U,
                           (struct dma_attrs *)0);
#line 3021
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3022
    return (-12);
  } else {

  }
#line 3024
  spin_lock_bh(& adapter->mcc_lock);
#line 3026
  wrb = wrb_from_mccq(adapter);
#line 3027
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3028
    status = -16;
#line 3029
    goto err;
  } else {

  }
#line 3032
  req = (struct be_cmd_req_set_mac_list *)cmd.va;
#line 3033
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 148, 404, wrb, & cmd);
#line 3037
  req->hdr.domain = (u8 )domain;
#line 3038
  req->mac_count = mac_count;
#line 3039
  if ((unsigned int )mac_count != 0U) {
#line 3040
    __len = (size_t )((int )mac_count * 6);
#line 3040
    __ret = __builtin_memcpy((void *)(& req->mac), (void const   *)mac_array, __len);
  } else {

  }
#line 3042
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3045
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3046
  spin_unlock_bh(& adapter->mcc_lock);
#line 3047
  return (status);
}
}
#line 3054 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) 
{ 
  bool active_mac ;
  u8 old_mac[6U] ;
  u32 pmac_id ;
  int status ;
  int tmp ;

  {
#line 3056
  active_mac = 0;
#line 3061
  status = be_cmd_get_mac_from_list(adapter, (u8 *)(& old_mac), & active_mac, & pmac_id,
                                    (u32 )if_id, (int )((u8 )dom));
#line 3064
  if (status == 0 && (int )active_mac) {
#line 3065
    be_cmd_pmac_del(adapter, (u32 )if_id, (int )pmac_id, dom);
  } else {

  }
#line 3067
  tmp = be_cmd_set_mac_list(adapter, mac, (unsigned long )mac != (unsigned long )((u8 *)0U),
                            dom);
#line 3067
  return (tmp);
}
}
#line 3070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_hsw_config *req ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
#line 3078
  spin_lock_bh(& adapter->mcc_lock);
#line 3080
  wrb = wrb_from_mccq(adapter);
#line 3081
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3082
    status = -16;
#line 3083
    goto err;
  } else {

  }
#line 3086
  tmp = embedded_payload(wrb);
#line 3086
  req = (struct be_cmd_req_set_hsw_config *)tmp;
#line 3087
  ctxt = (void *)(& req->context);
#line 3089
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 153, 36, wrb, (struct be_dma_mem *)0);
#line 3093
  req->hdr.domain = (u8 )domain;
#line 3094
  tmp___0 = amap_mask(16U);
#line 3094
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 3095
  if ((unsigned int )pvid != 0U) {
#line 3096
    tmp___1 = amap_mask(1U);
#line 3096
    amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 3097
    tmp___2 = amap_mask(16U);
#line 3097
    amap_set(ctxt, 1U, tmp___2, 16U, (u32 )pvid);
  } else {

  }
#line 3099
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned int )hsw_mode != 0U) {
#line 3100
    tmp___3 = amap_mask(16U);
#line 3100
    amap_set(ctxt, 0U, tmp___3, 0U, (u32 )adapter->hba_port_num);
#line 3102
    tmp___4 = amap_mask(1U);
#line 3102
    amap_set(ctxt, 0U, tmp___4, 31U, 1U);
#line 3103
    tmp___5 = amap_mask(3U);
#line 3103
    amap_set(ctxt, 1U, tmp___5, 6U, (u32 )hsw_mode);
  } else {

  }
#line 3107
  swap_dws((void *)(& req->context), 20);
#line 3108
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3111
  spin_unlock_bh(& adapter->mcc_lock);
#line 3112
  return (status);
}
}
#line 3116 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_hsw_config *req ;
  void *ctxt ;
  int status ;
  u16 vid ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  struct be_cmd_resp_get_hsw_config *resp ;
  void *tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;

  {
#line 3125
  spin_lock_bh(& adapter->mcc_lock);
#line 3127
  wrb = wrb_from_mccq(adapter);
#line 3128
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3129
    status = -16;
#line 3130
    goto err;
  } else {

  }
#line 3133
  tmp = embedded_payload(wrb);
#line 3133
  req = (struct be_cmd_req_get_hsw_config *)tmp;
#line 3134
  ctxt = (void *)(& req->context);
#line 3136
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 152, 20, wrb, (struct be_dma_mem *)0);
#line 3140
  req->hdr.domain = (u8 )domain;
#line 3141
  tmp___0 = amap_mask(16U);
#line 3141
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 3143
  tmp___1 = amap_mask(1U);
#line 3143
  amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 3145
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned long )mode != (unsigned long )((u8 *)0U)) {
#line 3146
    tmp___2 = amap_mask(16U);
#line 3146
    amap_set(ctxt, 0U, tmp___2, 0U, (u32 )adapter->hba_port_num);
#line 3148
    tmp___3 = amap_mask(1U);
#line 3148
    amap_set(ctxt, 0U, tmp___3, 31U, 1U);
  } else {

  }
#line 3150
  swap_dws((void *)(& req->context), 4);
#line 3152
  status = be_mcc_notify_wait(adapter);
#line 3153
  if (status == 0) {
#line 3154
    tmp___4 = embedded_payload(wrb);
#line 3154
    resp = (struct be_cmd_resp_get_hsw_config *)tmp___4;
#line 3156
    swap_dws((void *)(& resp->context), 16);
#line 3157
    tmp___5 = amap_mask(16U);
#line 3157
    tmp___6 = amap_get((void *)(& resp->context), 0U, tmp___5, 16U);
#line 3157
    vid = (u16 )tmp___6;
#line 3159
    if ((unsigned long )pvid != (unsigned long )((u16 *)0U)) {
#line 3160
      *pvid = vid;
    } else {

    }
#line 3161
    if ((unsigned long )mode != (unsigned long )((u8 *)0U)) {
#line 3162
      tmp___7 = amap_mask(3U);
#line 3162
      tmp___8 = amap_get((void *)(& resp->context), 0U, tmp___7, 6U);
#line 3162
      *mode = (u8 )tmp___8;
    } else {

    }
  } else {

  }
  err: 
#line 3167
  spin_unlock_bh(& adapter->mcc_lock);
#line 3168
  return (status);
}
}
#line 3171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config_v1 *req ;
  int status ;
  struct be_dma_mem cmd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct be_cmd_resp_acpi_wol_magic_config_v1 *resp ;

  {
#line 3175
  status = 0;
#line 3178
  tmp = be_cmd_allowed(adapter, 12, 3);
#line 3178
  if (tmp) {
#line 3178
    tmp___0 = 0;
  } else {
#line 3178
    tmp___0 = 1;
  }
#line 3178
  if (tmp___0) {
#line 3180
    return (-1);
  } else {

  }
#line 3182
  tmp___1 = be_is_wol_excluded(adapter);
#line 3182
  if ((int )tmp___1) {
#line 3183
    return (status);
  } else {

  }
#line 3185
  tmp___2 = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3185
  if (tmp___2 != 0) {
#line 3186
    return (-1);
  } else {

  }
#line 3188
  memset((void *)(& cmd), 0, 24UL);
#line 3189
  cmd.size = 1204U;
#line 3190
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 3191
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3192
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 3193
    status = -12;
#line 3194
    goto err;
  } else {

  }
#line 3197
  wrb = wrb_from_mbox(adapter);
#line 3198
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3199
    status = -16;
#line 3200
    goto err;
  } else {

  }
#line 3203
  req = (struct be_cmd_req_acpi_wol_magic_config_v1 *)cmd.va;
#line 3205
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 1204, wrb, & cmd);
#line 3209
  req->hdr.version = 1U;
#line 3210
  req->query_options = 2U;
#line 3212
  status = be_mbox_notify_wait(adapter);
#line 3213
  if (status == 0) {
#line 3215
    resp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;
#line 3217
    adapter->wol_cap = resp->wol_settings;
#line 3218
    if ((int )adapter->wol_cap & 1) {
#line 3219
      adapter->wol_en = 1;
    } else {

    }
  } else {

  }
  err: 
#line 3222
  mutex_unlock(& adapter->mbox_lock);
#line 3223
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3224
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 3225
  return (status);
}
}
#line 3229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int i ;
  int j ;
  u32 num_modes ;

  {
#line 3236
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3237
  extfat_cmd.size = 2844U;
#line 3238
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
#line 3240
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 3241
    return (-12);
  } else {

  }
#line 3243
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 3244
  if (status != 0) {
#line 3245
    goto err;
  } else {

  }
#line 3247
  cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3249
  i = 0;
#line 3249
  goto ldv_55812;
  ldv_55811: 
#line 3250
  num_modes = cfgs->module[i].num_modes;
#line 3251
  j = 0;
#line 3251
  goto ldv_55809;
  ldv_55808: ;
#line 3252
  if ((unsigned int )cfgs->module[i].trace_lvl[j].mode == 0U) {
#line 3253
    cfgs->module[i].trace_lvl[j].dbg_lvl = level;
  } else {

  }
#line 3251
  j = j + 1;
  ldv_55809: ;
#line 3251
  if ((u32 )j < num_modes) {
#line 3253
    goto ldv_55808;
  } else {

  }
#line 3249
  i = i + 1;
  ldv_55812: ;
#line 3249
  if ((u32 )i < cfgs->num_modules) {
#line 3251
    goto ldv_55811;
  } else {

  }
#line 3258
  status = be_cmd_set_ext_fat_capabilites(adapter, & extfat_cmd, cfgs);
  err: 
#line 3260
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
#line 3262
  return (status);
}
}
#line 3265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int j ;
  int level ;

  {
#line 3270
  level = 0;
#line 3272
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3273
  extfat_cmd.size = 2844U;
#line 3274
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
#line 3277
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 3278
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%s: Memory allocation failure\n",
            "be_cmd_get_fw_log_level");
#line 3280
    goto err;
  } else {

  }
#line 3283
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 3284
  if (status == 0) {
#line 3285
    cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3287
    j = 0;
#line 3287
    goto ldv_55825;
    ldv_55824: ;
#line 3288
    if ((unsigned int )cfgs->module[0].trace_lvl[j].mode == 0U) {
#line 3289
      level = (int )cfgs->module[0].trace_lvl[j].dbg_lvl;
    } else {

    }
#line 3287
    j = j + 1;
    ldv_55825: ;
#line 3287
    if ((u32 )j < cfgs->module[0].num_modes) {
#line 3289
      goto ldv_55824;
    } else {

    }

  } else {

  }
#line 3292
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
  err: ;
#line 3295
  return (level);
}
}
#line 3298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_ext_fat_caps *req ;
  int status ;
  int tmp ;

  {
#line 3305
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3305
  if (tmp != 0) {
#line 3306
    return (-1);
  } else {

  }
#line 3308
  wrb = wrb_from_mbox(adapter);
#line 3309
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3310
    status = -16;
#line 3311
    goto err;
  } else {

  }
#line 3314
  req = (struct be_cmd_req_get_ext_fat_caps *)cmd->va;
#line 3315
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 125, (int )cmd->size, wrb, cmd);
#line 3318
  req->parameter_type = 1U;
#line 3320
  status = be_mbox_notify_wait(adapter);
  err: 
#line 3322
  mutex_unlock(& adapter->mbox_lock);
#line 3323
  return (status);
}
}
#line 3326 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ext_fat_caps *req ;
  int status ;
  size_t __len ;
  void *__ret ;

  {
#line 3334
  spin_lock_bh(& adapter->mcc_lock);
#line 3336
  wrb = wrb_from_mccq(adapter);
#line 3337
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3338
    status = -16;
#line 3339
    goto err;
  } else {

  }
#line 3342
  req = (struct be_cmd_req_set_ext_fat_caps *)cmd->va;
#line 3343
  __len = 2828UL;
#line 3343
  if (__len > 63UL) {
#line 3343
    __ret = __memcpy((void *)(& req->set_params), (void const   *)configs, __len);
  } else {
#line 3343
    __ret = __builtin_memcpy((void *)(& req->set_params), (void const   *)configs,
                             __len);
  }
#line 3344
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 126, (int )cmd->size, wrb, cmd);
#line 3348
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3350
  spin_unlock_bh(& adapter->mcc_lock);
#line 3351
  return (status);
}
}
#line 3354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_port_name *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_port_name *resp ;
  void *tmp___0 ;

  {
#line 3360
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3361
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
#line 3362
    return (0);
  } else {

  }
#line 3365
  spin_lock_bh(& adapter->mcc_lock);
#line 3367
  wrb = wrb_from_mccq(adapter);
#line 3368
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3369
    status = -16;
#line 3370
    goto err;
  } else {

  }
#line 3373
  tmp = embedded_payload(wrb);
#line 3373
  req = (struct be_cmd_req_get_port_name *)tmp;
#line 3375
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 77, 20, wrb, (struct be_dma_mem *)0);
#line 3378
  req->hdr.version = 1U;
#line 3380
  status = be_mcc_notify_wait(adapter);
#line 3381
  if (status == 0) {
#line 3382
    tmp___0 = embedded_payload(wrb);
#line 3382
    resp = (struct be_cmd_resp_get_port_name *)tmp___0;
#line 3383
    *port_name = resp->port_name[(int )adapter->hba_port_num];
  } else {
#line 3385
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
  }
  err: 
#line 3388
  spin_unlock_bh(& adapter->mcc_lock);
#line 3389
  return (status);
}
}
#line 3392 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_nic_res_desc *be_get_nic_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  int i ;

  {
#line 3394
  hdr = (struct be_res_desc_hdr *)buf;
#line 3397
  i = 0;
#line 3397
  goto ldv_55863;
  ldv_55862: ;
#line 3398
  if ((unsigned int )hdr->desc_type == 65U || (unsigned int )hdr->desc_type == 81U) {
#line 3400
    return ((struct be_nic_res_desc *)hdr);
  } else {

  }
#line 3402
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3403
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3397
  i = i + 1;
  ldv_55863: ;
#line 3397
  if ((u32 )i < desc_count) {
#line 3399
    goto ldv_55862;
  } else {

  }

#line 3405
  return ((struct be_nic_res_desc *)0);
}
}
#line 3408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_pcie_res_desc *be_get_pcie_desc(u8 devfn , u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  struct be_pcie_res_desc *pcie ;
  int i ;

  {
#line 3411
  hdr = (struct be_res_desc_hdr *)buf;
#line 3415
  i = 0;
#line 3415
  goto ldv_55874;
  ldv_55873: ;
#line 3416
  if ((unsigned int )hdr->desc_type == 64U || (unsigned int )hdr->desc_type == 80U) {
#line 3418
    pcie = (struct be_pcie_res_desc *)hdr;
#line 3419
    if ((int )pcie->pf_num == (int )devfn) {
#line 3420
      return (pcie);
    } else {

    }
  } else {

  }
#line 3423
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3424
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3415
  i = i + 1;
  ldv_55874: ;
#line 3415
  if ((u32 )i < desc_count) {
#line 3417
    goto ldv_55873;
  } else {

  }

#line 3426
  return ((struct be_pcie_res_desc *)0);
}
}
#line 3429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static struct be_port_res_desc *be_get_port_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  int i ;

  {
#line 3431
  hdr = (struct be_res_desc_hdr *)buf;
#line 3434
  i = 0;
#line 3434
  goto ldv_55883;
  ldv_55882: ;
#line 3435
  if ((unsigned int )hdr->desc_type == 85U) {
#line 3436
    return ((struct be_port_res_desc *)hdr);
  } else {

  }
#line 3438
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3439
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3434
  i = i + 1;
  ldv_55883: ;
#line 3434
  if ((u32 )i < desc_count) {
#line 3436
    goto ldv_55882;
  } else {

  }

#line 3441
  return ((struct be_port_res_desc *)0);
}
}
#line 3444 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static void be_copy_nic_desc(struct be_resources *res , struct be_nic_res_desc *desc ) 
{ 


  {
#line 3447
  res->max_uc_mac = desc->unicast_mac_count;
#line 3448
  res->max_vlans = desc->vlan_count;
#line 3449
  res->max_mcast_mac = desc->mcast_mac_count;
#line 3450
  res->max_tx_qs = desc->txq_count;
#line 3451
  res->max_rss_qs = desc->rssq_count;
#line 3452
  res->max_rx_qs = desc->rq_count;
#line 3453
  res->max_evt_qs = desc->eq_count;
#line 3455
  res->if_cap_flags = desc->cap_flags & 7100U;
#line 3458
  if ((unsigned int )res->max_rss_qs != 0U && (int )res->max_rss_qs == (int )res->max_rx_qs) {
#line 3459
    res->max_rss_qs = (unsigned int )res->max_rss_qs + 65535U;
  } else {

  }
#line 3460
  return;
}
}
#line 3463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_func_config *req ;
  int status ;
  struct be_dma_mem cmd ;
  int tmp ;
  struct be_cmd_resp_get_func_config *resp ;
  u32 desc_count ;
  struct be_nic_res_desc *desc ;

  {
#line 3470
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3470
  if (tmp != 0) {
#line 3471
    return (-1);
  } else {

  }
#line 3473
  memset((void *)(& cmd), 0, 24UL);
#line 3474
  cmd.size = 23252U;
#line 3475
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 3476
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3477
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 3478
    status = -12;
#line 3479
    goto err;
  } else {

  }
#line 3482
  wrb = wrb_from_mbox(adapter);
#line 3483
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3484
    status = -16;
#line 3485
    goto err;
  } else {

  }
#line 3488
  req = (struct be_cmd_req_get_func_config *)cmd.va;
#line 3490
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 160, (int )cmd.size, wrb, & cmd);
#line 3494
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3495
    req->hdr.version = 1U;
  } else {

  }
#line 3497
  status = be_mbox_notify_wait(adapter);
#line 3498
  if (status == 0) {
#line 3499
    resp = (struct be_cmd_resp_get_func_config *)cmd.va;
#line 3500
    desc_count = resp->desc_count;
#line 3503
    desc = be_get_nic_desc((u8 *)(& resp->func_param), desc_count);
#line 3504
    if ((unsigned long )desc == (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3505
      status = -22;
#line 3506
      goto err;
    } else {

    }
#line 3509
    adapter->pf_number = desc->pf_num;
#line 3510
    be_copy_nic_desc(res, desc);
  } else {

  }
  err: 
#line 3513
  mutex_unlock(& adapter->mbox_lock);
#line 3514
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3515
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 3516
  return (status);
}
}
#line 3520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_get_profile_config_mbox(struct be_adapter *adapter , u8 domain ,
                                          struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;
  int tmp ;

  {
#line 3527
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3527
  if (tmp != 0) {
#line 3528
    return (-1);
  } else {

  }
#line 3529
  wrb = wrb_from_mbox(adapter);
#line 3531
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3532
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3536
  req->type = 2U;
#line 3537
  req->hdr.domain = domain;
#line 3538
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3539
    req->hdr.version = 1U;
  } else {

  }
#line 3541
  status = be_mbox_notify_wait(adapter);
#line 3543
  mutex_unlock(& adapter->mbox_lock);
#line 3544
  return (status);
}
}
#line 3548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int be_cmd_get_profile_config_mccq(struct be_adapter *adapter , u8 domain ,
                                          struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;

  {
#line 3555
  spin_lock_bh(& adapter->mcc_lock);
#line 3557
  wrb = wrb_from_mccq(adapter);
#line 3558
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3559
    status = -16;
#line 3560
    goto err;
  } else {

  }
#line 3563
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3564
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3568
  req->type = 2U;
#line 3569
  req->hdr.domain = domain;
#line 3570
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3571
    req->hdr.version = 1U;
  } else {

  }
#line 3573
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3576
  spin_unlock_bh(& adapter->mcc_lock);
#line 3577
  return (status);
}
}
#line 3581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 domain ) 
{ 
  struct be_cmd_resp_get_profile_config *resp ;
  struct be_pcie_res_desc *pcie ;
  struct be_port_res_desc *port ;
  struct be_nic_res_desc *nic ;
  struct be_queue_info *mccq ;
  struct be_dma_mem cmd ;
  u32 desc_count ;
  int status ;

  {
#line 3588
  mccq = & adapter->mcc_obj.q;
#line 3593
  memset((void *)(& cmd), 0, 24UL);
#line 3594
  cmd.size = 23252U;
#line 3595
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 3596
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3597
    return (-12);
  } else {

  }
#line 3599
  if (! mccq->created) {
#line 3600
    status = be_cmd_get_profile_config_mbox(adapter, (int )domain, & cmd);
  } else {
#line 3602
    status = be_cmd_get_profile_config_mccq(adapter, (int )domain, & cmd);
  }
#line 3603
  if (status != 0) {
#line 3604
    goto err;
  } else {

  }
#line 3606
  resp = (struct be_cmd_resp_get_profile_config *)cmd.va;
#line 3607
  desc_count = resp->desc_count;
#line 3609
  pcie = be_get_pcie_desc((int )((u8 )(adapter->pdev)->devfn), (u8 *)(& resp->func_param),
                          desc_count);
#line 3611
  if ((unsigned long )pcie != (unsigned long )((struct be_pcie_res_desc *)0)) {
#line 3612
    res->max_vfs = pcie->num_vfs;
  } else {

  }
#line 3614
  port = be_get_port_desc((u8 *)(& resp->func_param), desc_count);
#line 3615
  if ((unsigned long )port != (unsigned long )((struct be_port_res_desc *)0)) {
#line 3616
    adapter->mc_type = port->mc_type;
  } else {

  }
#line 3618
  nic = be_get_nic_desc((u8 *)(& resp->func_param), desc_count);
#line 3619
  if ((unsigned long )nic != (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3620
    be_copy_nic_desc(res, nic);
  } else {

  }
  err: ;
#line 3623
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3624
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 3625
  return (status);
}
}
#line 3628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_profile_config(struct be_adapter *adapter , void *desc , int size ,
                              u8 version , u8 domain ) 
{ 
  struct be_cmd_req_set_profile_config *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 3635
  spin_lock_bh(& adapter->mcc_lock);
#line 3637
  wrb = wrb_from_mccq(adapter);
#line 3638
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3639
    status = -16;
#line 3640
    goto err;
  } else {

  }
#line 3643
  tmp = embedded_payload(wrb);
#line 3643
  req = (struct be_cmd_req_set_profile_config *)tmp;
#line 3644
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 165, 112, wrb, (struct be_dma_mem *)0);
#line 3647
  req->hdr.version = version;
#line 3648
  req->hdr.domain = domain;
#line 3649
  req->desc_count = 1U;
#line 3650
  __len = (size_t )size;
#line 3650
  __ret = __builtin_memcpy((void *)(& req->desc), (void const   *)desc, __len);
#line 3652
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3654
  spin_unlock_bh(& adapter->mcc_lock);
#line 3655
  return (status);
}
}
#line 3659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void be_reset_nic_desc(struct be_nic_res_desc *nic ) 
{ 


  {
#line 3661
  memset((void *)nic, 0, 88UL);
#line 3662
  nic->unicast_mac_count = 65535U;
#line 3663
  nic->mcc_count = 65535U;
#line 3664
  nic->vlan_count = 65535U;
#line 3665
  nic->mcast_mac_count = 65535U;
#line 3666
  nic->txq_count = 65535U;
#line 3667
  nic->rq_count = 65535U;
#line 3668
  nic->rssq_count = 65535U;
#line 3669
  nic->lro_count = 65535U;
#line 3670
  nic->cq_count = 65535U;
#line 3671
  nic->toe_conn_count = 65535U;
#line 3672
  nic->eq_count = 65535U;
#line 3673
  nic->iface_count = 65535U;
#line 3674
  nic->link_param = 255U;
#line 3675
  nic->channel_id_param = 61440U;
#line 3676
  nic->acpi_params = 255U;
#line 3677
  nic->wol_param = 15U;
#line 3678
  nic->tunnel_iface_count = 65535U;
#line 3679
  nic->direct_tenant_iface_count = 65535U;
#line 3680
  nic->bw_max = 4294967295U;
#line 3681
  return;
}
}
#line 3683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_config_qos(struct be_adapter *adapter , u32 max_rate , u16 link_speed ,
                      u8 domain ) 
{ 
  struct be_nic_res_desc nic_desc ;
  u32 bw_percent ;
  u16 version ;
  int tmp ;
  int tmp___0 ;

  {
#line 3688
  version = 0U;
#line 3690
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3691
    tmp = be_cmd_set_qos(adapter, max_rate / 10U, (u32 )domain);
#line 3691
    return (tmp);
  } else {

  }
#line 3693
  be_reset_nic_desc(& nic_desc);
#line 3694
  nic_desc.pf_num = adapter->pf_number;
#line 3695
  nic_desc.vf_num = domain;
#line 3696
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 3697
    nic_desc.hdr.desc_type = 65U;
#line 3698
    nic_desc.hdr.desc_len = 72U;
#line 3699
    nic_desc.flags = 208U;
#line 3701
    nic_desc.bw_max = max_rate / 10U;
  } else {
#line 3703
    version = 1U;
#line 3704
    nic_desc.hdr.desc_type = 81U;
#line 3705
    nic_desc.hdr.desc_len = 88U;
#line 3706
    nic_desc.flags = 192U;
#line 3707
    bw_percent = max_rate != 0U ? (max_rate * 100U) / (u32 )link_speed : 100U;
#line 3708
    nic_desc.bw_max = bw_percent;
  }
#line 3711
  tmp___0 = be_cmd_set_profile_config(adapter, (void *)(& nic_desc), (int )nic_desc.hdr.desc_len,
                                      (int )((u8 )version), (int )domain);
#line 3711
  return (tmp___0);
}
}
#line 3716 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_manage_iface(struct be_adapter *adapter , u32 iface , u8 op ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_manage_iface_filters *req ;
  int status ;
  void *tmp ;

  {
#line 3722
  if (iface == 4294967295U) {
#line 3723
    return (-1);
  } else {

  }
#line 3725
  spin_lock_bh(& adapter->mcc_lock);
#line 3727
  wrb = wrb_from_mccq(adapter);
#line 3728
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3729
    status = -16;
#line 3730
    goto err;
  } else {

  }
#line 3732
  tmp = embedded_payload(wrb);
#line 3732
  req = (struct be_cmd_req_manage_iface_filters *)tmp;
#line 3734
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 193, 52, wrb, (struct be_dma_mem *)0);
#line 3737
  req->op = op;
#line 3738
  req->target_iface_id = iface;
#line 3740
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3742
  spin_unlock_bh(& adapter->mcc_lock);
#line 3743
  return (status);
}
}
#line 3746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_vxlan_port(struct be_adapter *adapter , __be16 port ) 
{ 
  struct be_port_res_desc port_desc ;
  __u16 tmp ;
  int tmp___0 ;

  {
#line 3750
  memset((void *)(& port_desc), 0, 88UL);
#line 3751
  port_desc.hdr.desc_type = 85U;
#line 3752
  port_desc.hdr.desc_len = 88U;
#line 3753
  port_desc.flags = 192U;
#line 3754
  port_desc.link_num = adapter->hba_port_num;
#line 3755
  if ((unsigned int )port != 0U) {
#line 3756
    port_desc.nv_flags = 23U;
#line 3758
    tmp = __fswab16((int )port);
#line 3758
    port_desc.nv_port = tmp;
  } else {
#line 3760
    port_desc.nv_flags = 1U;
#line 3761
    port_desc.nv_port = 0U;
  }
#line 3764
  tmp___0 = be_cmd_set_profile_config(adapter, (void *)(& port_desc), 88, 1, 0);
#line 3764
  return (tmp___0);
}
}
#line 3768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_iface_list *req ;
  struct be_cmd_resp_get_iface_list *resp ;
  int status ;
  void *tmp ;

  {
#line 3776
  spin_lock_bh(& adapter->mcc_lock);
#line 3778
  wrb = wrb_from_mccq(adapter);
#line 3779
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3780
    status = -16;
#line 3781
    goto err;
  } else {

  }
#line 3783
  tmp = embedded_payload(wrb);
#line 3783
  req = (struct be_cmd_req_get_iface_list *)tmp;
#line 3785
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 194, 32, wrb, (struct be_dma_mem *)0);
#line 3788
  req->hdr.domain = (unsigned int )((u8 )vf_num) + 1U;
#line 3790
  status = be_mcc_notify_wait(adapter);
#line 3791
  if (status == 0) {
#line 3792
    resp = (struct be_cmd_resp_get_iface_list *)req;
#line 3793
    vf_cfg->if_handle = (int )resp->if_desc.if_id;
  } else {

  }
  err: 
#line 3797
  spin_unlock_bh(& adapter->mcc_lock);
#line 3798
  return (status);
}
}
#line 3801 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static int lancer_wait_idle(struct be_adapter *adapter ) 
{ 
  u32 reg_val ;
  int status ;
  int i ;

  {
#line 3805
  status = 0;
#line 3807
  i = 0;
#line 3807
  goto ldv_55990;
  ldv_55989: 
#line 3808
  reg_val = ioread32((void *)adapter->db + 1044U);
#line 3809
  if ((reg_val & 1073741824U) == 0U) {
#line 3810
    goto ldv_55988;
  } else {

  }
#line 3812
  ssleep(1U);
#line 3807
  i = i + 1;
  ldv_55990: ;
#line 3807
  if (i <= 29) {
#line 3809
    goto ldv_55989;
  } else {

  }
  ldv_55988: ;
#line 3815
  if (i == 30) {
#line 3816
    status = -1;
  } else {

  }
#line 3818
  return (status);
}
}
#line 3821 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) 
{ 
  int status ;

  {
#line 3823
  status = 0;
#line 3825
  status = lancer_wait_idle(adapter);
#line 3826
  if (status != 0) {
#line 3827
    return (status);
  } else {

  }
#line 3829
  iowrite32(mask, (void *)adapter->db + 1044U);
#line 3831
  return (status);
}
}
#line 3835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
bool dump_present(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;

  {
#line 3837
  sliport_status = 0U;
#line 3839
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 3840
  return ((sliport_status & 33554432U) != 0U);
}
}
#line 3843 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int lancer_initiate_dump(struct be_adapter *adapter ) 
{ 
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3848
  status = lancer_physdev_ctrl(adapter, 6U);
#line 3850
  if (status < 0) {
#line 3851
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware reset failed\n");
#line 3852
    return (status);
  } else {

  }
#line 3855
  status = lancer_wait_idle(adapter);
#line 3856
  if (status != 0) {
#line 3857
    return (status);
  } else {

  }
#line 3859
  tmp = dump_present(adapter);
#line 3859
  if (tmp) {
#line 3859
    tmp___0 = 0;
  } else {
#line 3859
    tmp___0 = 1;
  }
#line 3859
  if (tmp___0) {
#line 3860
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Dump image not present\n");
#line 3861
    return (-1);
  } else {

  }
#line 3864
  return (0);
}
}
#line 3868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_enable_disable_vf *req ;
  int status ;
  void *tmp ;

  {
#line 3874
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3875
    return (0);
  } else {

  }
#line 3877
  spin_lock_bh(& adapter->mcc_lock);
#line 3879
  wrb = wrb_from_mccq(adapter);
#line 3880
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3881
    status = -16;
#line 3882
    goto err;
  } else {

  }
#line 3885
  tmp = embedded_payload(wrb);
#line 3885
  req = (struct be_cmd_enable_disable_vf *)tmp;
#line 3887
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 196, 20, wrb, (struct be_dma_mem *)0);
#line 3891
  req->hdr.domain = domain;
#line 3892
  req->enable = 1U;
#line 3893
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3895
  spin_unlock_bh(& adapter->mcc_lock);
#line 3896
  return (status);
}
}
#line 3899 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_intr_set *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 3905
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3905
  if (tmp != 0) {
#line 3906
    return (-1);
  } else {

  }
#line 3908
  wrb = wrb_from_mbox(adapter);
#line 3910
  tmp___0 = embedded_payload(wrb);
#line 3910
  req = (struct be_cmd_req_intr_set *)tmp___0;
#line 3912
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 89, 20, wrb, (struct be_dma_mem *)0);
#line 3916
  req->intr_enabled = (u8 )intr_enable;
#line 3918
  status = be_mbox_notify_wait(adapter);
#line 3920
  mutex_unlock(& adapter->mbox_lock);
#line 3921
  return (status);
}
}
#line 3925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) 
{ 
  struct be_cmd_req_get_active_profile *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_get_active_profile *resp ;
  void *tmp___1 ;

  {
#line 3931
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3931
  if (tmp != 0) {
#line 3932
    return (-1);
  } else {

  }
#line 3934
  wrb = wrb_from_mbox(adapter);
#line 3935
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3936
    status = -16;
#line 3937
    goto err;
  } else {

  }
#line 3940
  tmp___0 = embedded_payload(wrb);
#line 3940
  req = (struct be_cmd_req_get_active_profile *)tmp___0;
#line 3942
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 167, 20, wrb, (struct be_dma_mem *)0);
#line 3946
  status = be_mbox_notify_wait(adapter);
#line 3947
  if (status == 0) {
#line 3948
    tmp___1 = embedded_payload(wrb);
#line 3948
    resp = (struct be_cmd_resp_get_active_profile *)tmp___1;
#line 3950
    *profile_id = resp->active_profile_id;
  } else {

  }
  err: 
#line 3954
  mutex_unlock(& adapter->mbox_lock);
#line 3955
  return (status);
}
}
#line 3958 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_cmd_set_logical_link_config(struct be_adapter *adapter , int link_state , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ll_link *req ;
  int status ;
  void *tmp ;

  {
#line 3965
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 3966
    return (0);
  } else {

  }
#line 3968
  spin_lock_bh(& adapter->mcc_lock);
#line 3970
  wrb = wrb_from_mccq(adapter);
#line 3971
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3972
    status = -16;
#line 3973
    goto err;
  } else {

  }
#line 3976
  tmp = embedded_payload(wrb);
#line 3976
  req = (struct be_cmd_req_set_ll_link *)tmp;
#line 3978
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 80, 20, wrb, (struct be_dma_mem *)0);
#line 3982
  req->hdr.version = 1U;
#line 3983
  req->hdr.domain = domain;
#line 3985
  if (link_state == 1) {
#line 3986
    req->link_config = req->link_config | 1U;
  } else {

  }
#line 3988
  if (link_state == 0) {
#line 3989
    req->link_config = req->link_config | 256U;
  } else {

  }
#line 3991
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3993
  spin_unlock_bh(& adapter->mcc_lock);
#line 3994
  return (status);
}
}
#line 3997 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  struct be_cmd_req_hdr *req ;
  struct be_cmd_resp_hdr *resp ;
  int status ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 4000
  tmp = netdev_priv((struct net_device  const  *)netdev_handle);
#line 4000
  adapter = (struct be_adapter *)tmp;
#line 4002
  hdr = (struct be_cmd_req_hdr *)wrb_payload;
#line 4007
  spin_lock_bh(& adapter->mcc_lock);
#line 4009
  wrb = wrb_from_mccq(adapter);
#line 4010
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4011
    status = -16;
#line 4012
    goto err;
  } else {

  }
#line 4014
  tmp___0 = embedded_payload(wrb);
#line 4014
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 4015
  tmp___1 = embedded_payload(wrb);
#line 4015
  resp = (struct be_cmd_resp_hdr *)tmp___1;
#line 4017
  be_wrb_cmd_hdr_prepare(req, (int )hdr->subsystem, (int )hdr->opcode, wrb_payload_size,
                         wrb, (struct be_dma_mem *)0);
#line 4019
  __len = (size_t )wrb_payload_size;
#line 4019
  __ret = __builtin_memcpy((void *)req, (void const   *)wrb_payload, __len);
#line 4020
  swap_dws((void *)req, wrb_payload_size);
#line 4022
  status = be_mcc_notify_wait(adapter);
#line 4023
  if ((unsigned long )cmd_status != (unsigned long )((u16 *)0U)) {
#line 4024
    *cmd_status = (u16 )status;
  } else {

  }
#line 4025
  if ((unsigned long )ext_status != (unsigned long )((u16 *)0U)) {
#line 4026
    *ext_status = 0U;
  } else {

  }
#line 4027
  __len___0 = (unsigned long )resp->response_length + 16UL;
#line 4027
  __ret___0 = __builtin_memcpy(wrb_payload, (void const   *)resp, __len___0);
#line 4028
  swap_dws(wrb_payload, (int )(resp->response_length + 16U));
  err: 
#line 4030
  spin_unlock_bh(& adapter->mcc_lock);
#line 4031
  return (status);
}
}
#line 4033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
static char const   __kstrtab_be_roce_mcc_cmd[16U]  = 
#line 4033
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'm',      'c',      'c',      '_', 
        'c',      'm',      'd',      '\000'};
#line 4033
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd ;
#line 4033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd  =    {(unsigned long )(& be_roce_mcc_cmd), (char const   *)(& __kstrtab_be_roce_mcc_cmd)};
#line 4162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void *ldv_kmem_cache_alloc_80(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 4165
  ldv_check_alloc_flags(flags);
#line 4167
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 4168
  return ((void *)0);
}
}
#line 4206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4209
  ldv_check_alloc_flags(flags);
#line 4211
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4211
  return (tmp);
}
}
#line 4222 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4225
  ldv_check_alloc_flags(flags);
#line 4227
  tmp = skb_clone(ldv_func_arg1, flags);
#line 4227
  return (tmp);
}
}
#line 4238 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv_skb_copy_90(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4241
  ldv_check_alloc_flags(flags);
#line 4243
  tmp = skb_copy(ldv_func_arg1, flags);
#line 4243
  return (tmp);
}
}
#line 4246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_91(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4249
  ldv_check_alloc_flags(flags);
#line 4251
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4251
  return (tmp);
}
}
#line 4254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_92(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4257
  ldv_check_alloc_flags(flags);
#line 4259
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4259
  return (tmp);
}
}
#line 4262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_93(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4265
  ldv_check_alloc_flags(flags);
#line 4267
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4267
  return (tmp);
}
}
#line 4270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int ldv_pskb_expand_head_94(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4273
  ldv_check_alloc_flags(flags);
#line 4275
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4275
  return (tmp);
}
}
#line 4278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
int ldv_pskb_expand_head_95(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4281
  ldv_check_alloc_flags(flags);
#line 4283
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4283
  return (tmp);
}
}
#line 4286 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
struct sk_buff *ldv_skb_clone_96(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4289
  ldv_check_alloc_flags(flags);
#line 4291
  tmp = skb_clone(ldv_func_arg1, flags);
#line 4291
  return (tmp);
}
}
#line 4294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void *ldv_kmem_cache_alloc_97(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 4297
  ldv_check_alloc_flags(flags);
#line 4299
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 4300
  return ((void *)0);
}
}
#line 4302 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void *ldv_vmalloc_98(unsigned long ldv_func_arg1 ) 
{ 


  {
#line 4305
  ldv_check_alloc_nonatomic();
#line 4307
  vmalloc(ldv_func_arg1);
#line 4308
  return ((void *)0);
}
}
#line 391 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 70 "include/linux/vmalloc.h"
void *ldv_vmalloc_144(unsigned long ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_126(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 323
void *ldv_kmem_cache_alloc_143(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 806 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 809
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 810
    return ((char const   *)dev->init_name);
  } else {

  }
#line 812
  tmp = kobject_name(& dev->kobj);
#line 812
  return (tmp);
}
}
#line 1439 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1441
  tmp = dev_name(& pdev->dev);
#line 1441
  return (tmp);
}
}
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_134(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_142(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_136(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_132(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_140(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_141(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_138(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_139(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 113 "include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 117
  ep->speed = (unsigned short )speed;
#line 118
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 119
  return;
}
}
#line 121 "include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 123
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 65 "include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 2686 "include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2688
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
#line 2688
  return (tmp == 0);
}
}
#line 1995 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool check_privilege(struct be_adapter *adapter , u32 flags ) 
{ 


  {
#line 1997
  return ((adapter->cmd_privileges & flags) != 0U);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static struct be_ethtool_stat  const  et_stats[37U]  = 
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
  {      {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2,
      4, 36}, 
        {{'r', 'x', '_', 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', '_', 's', 'y',
       'm', 'b', 'o', 'l', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2, 4, 40}, 
        {{'r', 'x', '_', 'p', 'a', 'u', 's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's',
       '\000'}, 2, 4, 44}, 
        {{'r', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', '_', 'f', 'r', 'a', 'm',
       'e', 's', '\000'}, 2, 4, 52}, 
        {{'r', 'x', '_', 'i', 'n', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r', 'r',
       'o', 'r', 's', '\000'}, 2, 4, 56}, 
        {{'r', 'x', '_', 'o', 'u', 't', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 2, 4, 60}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 't', 'o', 'o', '_', 'l', 'o',
       'n', 'g', '\000'}, 2, 4, 64}, 
        {{'r', 'x', '_', 'a', 'd', 'd', 'r', 'e', 's', 's', '_', 'f', 'i', 'l', 't',
       'e', 'r', 'e', 'd', '\000'}, 2, 4, 68}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'm', 'a', 'l', 'l', '\000'}, 2, 4, 72}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'h', 'o', 'r', 't', '\000'}, 2, 4, 76}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'h', 'e', 'a', 'd',
       'e', 'r', '_', 't', 'o', 'o', '_', 's', 'm', 'a', 'l', 'l', '\000'}, 2, 4,
      80}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'c', 'p', '_',
       'l', 'e', 'n', 'g', 't', 'h', '\000'}, 2, 4, 84}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'r', 'u', 'n', 't',
       '\000'}, 2, 4, 88}, 
        {{'r', 'x', 'p', 'p', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 116}, 
        {{'r', 'x', '_', 'i', 'n', 'p', 'u', 't', '_', 'f', 'i', 'f', 'o', '_', 'o',
       'v', 'e', 'r', 'f', 'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4,
      120}, 
        {{'r', 'x', '_', 'i', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm', '_',
       'e', 'r', 'r', 's', '\000'}, 2, 4, 92}, 
        {{'r', 'x', '_', 't', 'c', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 96}, 
        {{'r', 'x', '_', 'u', 'd', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 100}, 
        {{'t', 'x', '_', 'p', 'a', 'u', 's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 104}, 
        {{'t', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', 'f', 'r', 'a', 'm', 'e',
       's', '\000'}, 2, 4, 112}, 
        {{'r', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 48}, 
        {{'t', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 108}, 
        {{'p', 'm', 'e', 'm', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 124}, 
        {{'j', 'a', 'b', 'b', 'e', 'r', '_', 'e', 'v', 'e', 'n', 't', 's', '\000'}, 2,
      4, 128}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'p', 'b', 'u',
       'f', '\000'}, 2, 4, 8}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'e', 'r', 'x',
       '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 't', 'p', 'r',
       'e', '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 20}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 't', 'o', 'o', '_', 'm', 'a',
       'n', 'y', '_', 'f', 'r', 'a', 'g', 's', '\000'}, 2, 4, 24}, 
        {{'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'd', '_', 'p', 'a', 'c', 'k', 'e',
       't', 's', '\000'}, 2, 4, 28}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'm', 't', 'u', '\000'}, 2, 4,
      32}, 
        {{'e', 't', 'h', '_', 'r', 'e', 'd', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 2,
      4, 4}, 
        {{'b', 'e', '_', 'o', 'n', '_', 'd', 'i', 'e', '_', 't', 'e', 'm', 'p', 'e',
       'r', 'a', 't', 'u', 'r', 'e', '\000'}, 2, 4, 0}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'l',
       's', 'd', '\000'}, 2, 4, 132}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'm',
       's', 'd', '\000'}, 2, 4, 136}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 140}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'p', 'a', 'y', 'l',
       'o', 'a', 'd', '_', 'l', 'e', 'n', '\000'}, 2, 4, 144}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'c', 'r', 'c', '\000'},
      2, 4, 148}};
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static struct be_ethtool_stat  const  et_rx_stats[8U]  = 
#line 207
  {      {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 1, 8, 0}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '\000'}, 1, 8, 8}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 1, 4, 28}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '_', 'e', 'r', 'r', '\000'}, 1, 4,
      36}, 
        {{'r', 'x', '_', 'm', 'c', 'a', 's', 't', '_', 'p', 'k', 't', 's', '\000'}, 1,
      4, 32}, 
        {{'r', 'x', '_', 'p', 'o', 's', 't', '_', 'f', 'a', 'i', 'l', '\000'}, 1, 4,
      24}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 's', 'k', 'b',
       's', '\000'}, 1, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'f', 'r', 'a',
       'g', 's', '\000'}, 1, 4, 20}};
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static struct be_ethtool_stat  const  et_tx_stats[7U]  = {      {{'t', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 0, 8, 32}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'k', 't', 's', '\000'}, 0, 8, 8}, 
        {{'t', 'x', '_', 'r', 'e', 'q', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 'w', 'r', 'b', 's', '\000'}, 0, 8, 24}, 
        {{'t', 'x', '_', 's', 't', 'o', 'p', 's', '\000'}, 0, 4, 48}, 
        {{'t', 'x', '_', 'd', 'r', 'v', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 0, 4,
      52}};
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static char const   et_self_tests[5U][32U]  = { {        'M',        'A',        'C',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'P',        'H',        'Y',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'E',        'x',        't',        'e', 
            'r',        'n',        'a',        'l', 
            ' ',        'L',        'o',        'o', 
            'p',        'b',        'a',        'c', 
            'k',        ' ',        't',        'e', 
            's',        't',        '\000'}, 
   {        'D',        'D',        'R',        ' ', 
            'D',        'M',        'A',        ' ', 
            't',        'e',        's',        't', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}};
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 263
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 263
  adapter = (struct be_adapter *)tmp;
#line 265
  strlcpy((char *)(& drvinfo->driver), "be2net", 32UL);
#line 266
  strlcpy((char *)(& drvinfo->version), "10.2u", 32UL);
#line 267
  tmp___0 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)(& adapter->fw_on_flash),
                   32UL);
#line 267
  if (tmp___0 == 0) {
#line 268
    strlcpy((char *)(& drvinfo->fw_version), (char const   *)(& adapter->fw_ver),
            32UL);
  } else {
#line 271
    snprintf((char *)(& drvinfo->fw_version), 32UL, "%s [%s]", (char *)(& adapter->fw_ver),
             (char *)(& adapter->fw_on_flash));
  }
#line 274
  tmp___1 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 274
  strlcpy((char *)(& drvinfo->bus_info), tmp___1, 32UL);
#line 276
  drvinfo->testinfo_len = 0U;
#line 277
  drvinfo->regdump_len = 0U;
#line 278
  drvinfo->eedump_len = 0U;
#line 279
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 lancer_cmd_get_file_len(struct be_adapter *adapter , u8 *file_name ) 
{ 
  u32 data_read ;
  u32 eof ;
  u8 addn_status ;
  struct be_dma_mem data_len_cmd ;
  int status ;

  {
#line 283
  data_read = 0U;
#line 288
  memset((void *)(& data_len_cmd), 0, 24UL);
#line 290
  status = lancer_cmd_read_object(adapter, & data_len_cmd, 0U, 0U, (char const   *)file_name,
                                  & data_read, & eof, & addn_status);
#line 294
  return (data_read);
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int lancer_cmd_read_file(struct be_adapter *adapter , u8 *file_name , u32 buf_len ,
                                void *buf ) 
{ 
  struct be_dma_mem read_cmd ;
  u32 read_len ;
  u32 total_read_len ;
  u32 chunk_size ;
  u32 eof ;
  u8 addn_status ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 301
  read_len = 0U;
#line 301
  total_read_len = 0U;
#line 302
  eof = 0U;
#line 304
  status = 0;
#line 306
  read_cmd.size = 32768U;
#line 307
  read_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )read_cmd.size, & read_cmd.dma);
#line 310
  if ((unsigned long )read_cmd.va == (unsigned long )((void *)0)) {
#line 311
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while reading dump\n");
#line 313
    return (-12);
  } else {

  }
#line 316
  goto ldv_54905;
  ldv_54904: 
#line 317
  __min1 = buf_len - total_read_len;
#line 317
  __min2 = 32768U;
#line 317
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 319
  chunk_size = (chunk_size + 3U) & 4294967292U;
#line 320
  status = lancer_cmd_read_object(adapter, & read_cmd, chunk_size, total_read_len,
                                  (char const   *)file_name, & read_len, & eof, & addn_status);
#line 323
  if (status == 0) {
#line 324
    __len = (size_t )read_len;
#line 324
    __ret = __builtin_memcpy(buf + (unsigned long )total_read_len, (void const   *)read_cmd.va,
                             __len);
#line 325
    total_read_len = total_read_len + read_len;
#line 326
    eof = eof & 2147483648U;
  } else {
#line 328
    status = -5;
#line 329
    goto ldv_54903;
  }
  ldv_54905: ;
#line 316
  if (total_read_len < buf_len && eof == 0U) {
#line 318
    goto ldv_54904;
  } else {

  }
  ldv_54903: 
#line 332
  pci_free_consistent(adapter->pdev, (size_t )read_cmd.size, read_cmd.va, read_cmd.dma);
#line 335
  return (status);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_reg_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u32 log_size ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 340
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 340
  adapter = (struct be_adapter *)tmp;
#line 341
  log_size = 0U;
#line 343
  tmp___0 = check_privilege(adapter, 1792U);
#line 343
  if (tmp___0) {
#line 343
    tmp___1 = 0;
  } else {
#line 343
    tmp___1 = 1;
  }
#line 343
  if (tmp___1) {
#line 344
    return (0);
  } else {

  }
#line 346
  if ((unsigned int )adapter->virtfn == 0U) {
#line 347
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 348
      log_size = lancer_cmd_get_file_len(adapter, (u8 *)"/dbg/dump.bin");
    } else {
#line 351
      be_cmd_get_reg_len(adapter, & log_size);
    }
  } else {

  }
#line 353
  return ((int )log_size);
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_regs(struct net_device *netdev , struct ethtool_regs *regs , void *buf ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 359
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 359
  adapter = (struct be_adapter *)tmp;
#line 361
  if ((unsigned int )adapter->virtfn == 0U) {
#line 362
    memset(buf, 0, (size_t )regs->len);
#line 363
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 364
      lancer_cmd_read_file(adapter, (u8 *)"/dbg/dump.bin", regs->len, buf);
    } else {
#line 367
      be_cmd_get_regs(adapter, regs->len, buf);
    }
  } else {

  }
#line 369
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;

  {
#line 374
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 374
  adapter = (struct be_adapter *)tmp;
#line 375
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 378
  et->rx_coalesce_usecs = aic->prev_eqd;
#line 379
  et->rx_coalesce_usecs_high = aic->max_eqd;
#line 380
  et->rx_coalesce_usecs_low = aic->min_eqd;
#line 382
  et->tx_coalesce_usecs = aic->prev_eqd;
#line 383
  et->tx_coalesce_usecs_high = aic->max_eqd;
#line 384
  et->tx_coalesce_usecs_low = aic->min_eqd;
#line 386
  et->use_adaptive_rx_coalesce = (__u32 )aic->enable;
#line 387
  et->use_adaptive_tx_coalesce = (__u32 )aic->enable;
#line 389
  return (0);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  int i ;
  __u32 _min1 ;
  unsigned int _min2 ;
  __u32 _min1___0 ;
  u32 _min2___0 ;
  __u32 _min1___1 ;
  u32 _min2___1 ;
  u32 _max1 ;
  u32 _max2 ;

  {
#line 398
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 398
  adapter = (struct be_adapter *)tmp;
#line 399
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 403
  i = 0;
#line 403
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 403
  goto ldv_54944;
  ldv_54943: 
#line 404
  aic->enable = et->use_adaptive_rx_coalesce != 0U;
#line 405
  _min1 = et->rx_coalesce_usecs_high;
#line 405
  _min2 = 128U;
#line 405
  aic->max_eqd = _min1 < _min2 ? _min1 : _min2;
#line 406
  _min1___0 = et->rx_coalesce_usecs_low;
#line 406
  _min2___0 = aic->max_eqd;
#line 406
  aic->min_eqd = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 407
  _min1___1 = et->rx_coalesce_usecs;
#line 407
  _min2___1 = aic->max_eqd;
#line 407
  aic->et_eqd = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 408
  _max1 = aic->et_eqd;
#line 408
  _max2 = aic->min_eqd;
#line 408
  aic->et_eqd = _max1 > _max2 ? _max1 : _max2;
#line 409
  aic = aic + 1;
#line 403
  i = i + 1;
#line 403
  eqo = eqo + 1;
  ldv_54944: ;
#line 403
  if ((int )adapter->num_evt_qs > i) {
#line 405
    goto ldv_54943;
  } else {

  }

#line 412
  return (0);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                 uint64_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  void *p ;
  unsigned int i ;
  unsigned int j ;
  unsigned int base ;
  unsigned int start ;
  struct be_rx_stats *stats___0 ;
  bool tmp___0 ;
  struct be_tx_stats *stats___1 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 418
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 418
  adapter = (struct be_adapter *)tmp;
#line 422
  base = 0U;
#line 424
  i = 0U;
#line 424
  goto ldv_54962;
  ldv_54961: 
#line 425
  p = (void *)(& adapter->drv_stats) + (unsigned long )et_stats[i].offset;
#line 426
  *(data + (unsigned long )i) = (uint64_t )*((u32 *)p);
#line 424
  i = i + 1U;
  ldv_54962: ;
#line 424
  if (i <= 36U) {
#line 426
    goto ldv_54961;
  } else {

  }
#line 428
  base = base + 37U;
#line 430
  j = 0U;
#line 430
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 430
  goto ldv_54977;
  ldv_54976: 
#line 431
  stats___0 = & rxo->stats;
  ldv_54967: 
#line 434
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___0->sync));
#line 435
  *(data + (unsigned long )base) = stats___0->rx_bytes;
#line 436
  *(data + (unsigned long )(base + 1U)) = stats___0->rx_pkts;
#line 437
  tmp___0 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___0->sync),
                                      start);
#line 437
  if ((int )tmp___0) {
#line 439
    goto ldv_54967;
  } else {

  }
#line 439
  i = 2U;
#line 439
  goto ldv_54972;
  ldv_54971: 
#line 440
  p = (void *)stats___0 + (unsigned long )et_rx_stats[i].offset;
#line 441
  *(data + (unsigned long )(base + i)) = (uint64_t )*((u32 *)p);
#line 439
  i = i + 1U;
  ldv_54972: ;
#line 439
  if (i <= 7U) {
#line 441
    goto ldv_54971;
  } else {

  }
#line 443
  base = base + 8U;
#line 430
  j = j + 1U;
#line 430
  rxo = rxo + 1;
  ldv_54977: ;
#line 430
  if ((unsigned int )adapter->num_rx_qs > j) {
#line 432
    goto ldv_54976;
  } else {

  }
#line 446
  j = 0U;
#line 446
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )j;
#line 446
  goto ldv_54992;
  ldv_54991: 
#line 447
  stats___1 = & txo->stats;
  ldv_54980: 
#line 450
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___1->sync_compl));
#line 451
  *(data + (unsigned long )base) = stats___1->tx_compl;
#line 452
  tmp___1 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___1->sync_compl),
                                      start);
#line 452
  if ((int )tmp___1) {
#line 454
    goto ldv_54980;
  } else {

  }

  ldv_54987: 
#line 455
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___1->sync));
#line 456
  i = 1U;
#line 456
  goto ldv_54985;
  ldv_54984: 
#line 457
  p = (void *)stats___1 + (unsigned long )et_tx_stats[i].offset;
#line 458
  *(data + (unsigned long )(base + i)) = et_tx_stats[i].size == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
#line 456
  i = i + 1U;
  ldv_54985: ;
#line 456
  if (i <= 6U) {
#line 458
    goto ldv_54984;
  } else {

  }
#line 462
  tmp___2 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___1->sync),
                                      start);
#line 462
  if ((int )tmp___2) {
#line 464
    goto ldv_54987;
  } else {

  }
#line 463
  base = base + 7U;
#line 446
  j = j + 1U;
#line 446
  txo = txo + 1;
  ldv_54992: ;
#line 446
  if ((unsigned int )adapter->num_tx_qs > j) {
#line 448
    goto ldv_54991;
  } else {

  }

#line 453
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_stat_strings(struct net_device *netdev , uint32_t stringset , uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 470
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 470
  adapter = (struct be_adapter *)tmp;
#line 473
  switch (stringset) {
  case 1U: 
#line 475
  i = 0;
#line 475
  goto ldv_55009;
  ldv_55008: 
#line 476
  __len = 32UL;
#line 476
  if (__len > 63UL) {
#line 476
    __ret = __memcpy((void *)data, (void const   *)(& et_stats[i].desc), __len);
  } else {
#line 476
    __ret = __builtin_memcpy((void *)data, (void const   *)(& et_stats[i].desc), __len);
  }
#line 477
  data = data + 32UL;
#line 475
  i = i + 1;
  ldv_55009: ;
#line 475
  if ((unsigned int )i <= 36U) {
#line 477
    goto ldv_55008;
  } else {

  }
#line 479
  i = 0;
#line 479
  goto ldv_55017;
  ldv_55016: 
#line 480
  j = 0;
#line 480
  goto ldv_55014;
  ldv_55013: 
#line 481
  sprintf((char *)data, "rxq%d: %s", i, (char const   *)(& et_rx_stats[j].desc));
#line 483
  data = data + 32UL;
#line 480
  j = j + 1;
  ldv_55014: ;
#line 480
  if ((unsigned int )j <= 7U) {
#line 482
    goto ldv_55013;
  } else {

  }
#line 479
  i = i + 1;
  ldv_55017: ;
#line 479
  if ((int )adapter->num_rx_qs > i) {
#line 481
    goto ldv_55016;
  } else {

  }
#line 486
  i = 0;
#line 486
  goto ldv_55025;
  ldv_55024: 
#line 487
  j = 0;
#line 487
  goto ldv_55022;
  ldv_55021: 
#line 488
  sprintf((char *)data, "txq%d: %s", i, (char const   *)(& et_tx_stats[j].desc));
#line 490
  data = data + 32UL;
#line 487
  j = j + 1;
  ldv_55022: ;
#line 487
  if ((unsigned int )j <= 6U) {
#line 489
    goto ldv_55021;
  } else {

  }
#line 486
  i = i + 1;
  ldv_55025: ;
#line 486
  if ((int )adapter->num_tx_qs > i) {
#line 488
    goto ldv_55024;
  } else {

  }

#line 493
  goto ldv_55027;
  case 0U: 
#line 495
  i = 0;
#line 495
  goto ldv_55035;
  ldv_55034: 
#line 496
  __len___0 = 32UL;
#line 496
  if (__len___0 > 63UL) {
#line 496
    __ret___0 = __memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i,
                         __len___0);
  } else {
#line 496
    __ret___0 = __builtin_memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i,
                                 __len___0);
  }
#line 497
  data = data + 32UL;
#line 495
  i = i + 1;
  ldv_55035: ;
#line 495
  if ((unsigned int )i <= 4U) {
#line 497
    goto ldv_55034;
  } else {

  }

#line 499
  goto ldv_55027;
  }
  ldv_55027: ;
#line 502
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_sset_count(struct net_device *netdev , int stringset ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 505
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 505
  adapter = (struct be_adapter *)tmp;
#line 507
  switch (stringset) {
  case 0: ;
#line 509
  return (5);
  case 1: ;
#line 511
  return ((int )(((unsigned int )adapter->num_rx_qs * 8U + (unsigned int )adapter->num_tx_qs * 7U) + 37U));
  default: ;
#line 515
  return (-22);
  }
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 be_get_port_type(u32 phy_type , u32 dac_cable_len ) 
{ 
  u32 port ;

  {
#line 523
  switch (phy_type) {
  case 7U: ;
  case 8U: ;
  case 9U: 
#line 527
  port = 0U;
#line 528
  goto ldv_55061;
  case 3U: 
#line 530
  port = dac_cable_len != 0U ? 5U : 3U;
#line 531
  goto ldv_55061;
  case 1U: ;
  case 2U: 
#line 534
  port = 3U;
#line 535
  goto ldv_55061;
  case 6U: 
#line 537
  port = 0U;
#line 538
  goto ldv_55061;
  default: 
#line 540
  port = 255U;
  }
  ldv_55061: ;
#line 543
  return (port);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 convert_to_et_setting(u32 if_type , u32 if_speeds ) 
{ 
  u32 val ;

  {
#line 548
  val = 0U;
#line 550
  switch (if_type) {
  case 7U: ;
  case 8U: ;
  case 9U: 
#line 554
  val = val | 128U;
#line 555
  if ((if_speeds & 4U) != 0U) {
#line 556
    val = val | 32U;
  } else {

  }
#line 557
  if ((if_speeds & 2U) != 0U) {
#line 558
    val = val | 8U;
  } else {

  }
#line 559
  if ((int )if_speeds & 1) {
#line 560
    val = val | 2U;
  } else {

  }
#line 561
  goto ldv_55075;
  case 5U: 
#line 563
  val = val | 65536U;
#line 564
  if ((if_speeds & 4U) != 0U) {
#line 565
    val = val | 131072U;
  } else {

  }
#line 566
  if ((if_speeds & 8U) != 0U) {
#line 567
    val = val | 262144U;
  } else {

  }
#line 568
  goto ldv_55075;
  case 4U: 
#line 570
  val = val | 589824U;
#line 572
  goto ldv_55075;
  case 3U: ;
  case 1U: ;
  case 2U: 
#line 576
  val = val | 1024U;
#line 577
  if ((if_speeds & 8U) != 0U) {
#line 578
    val = val | 4096U;
  } else {

  }
#line 579
  if ((if_speeds & 4U) != 0U) {
#line 580
    val = val | 32U;
  } else {

  }
#line 581
  goto ldv_55075;
  case 6U: 
#line 583
  val = val | 128U;
#line 584
  if ((if_speeds & 8U) != 0U) {
#line 585
    val = val | 4096U;
  } else {

  }
#line 586
  if ((if_speeds & 4U) != 0U) {
#line 587
    val = val | 32U;
  } else {

  }
#line 588
  if ((if_speeds & 2U) != 0U) {
#line 589
    val = val | 8U;
  } else {

  }
#line 590
  goto ldv_55075;
  default: 
#line 592
  val = val | 128U;
  }
  ldv_55075: ;
#line 595
  return (val);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
bool be_pause_supported(struct be_adapter *adapter ) 
{ 


  {
#line 600
  return ((bool )((unsigned int )adapter->phy.interface_type != 3U && (unsigned int )adapter->phy.interface_type != 1U));
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 link_status ;
  u16 link_speed ;
  int status ;
  u32 auto_speeds ;
  u32 fixed_speeds ;
  u32 dac_cable_len ;
  u16 interface_type ;
  u32 tmp___0 ;
  bool tmp___1 ;
  __u32 tmp___2 ;
  bool tmp___3 ;

  {
#line 607
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 607
  adapter = (struct be_adapter *)tmp;
#line 609
  link_speed = 0U;
#line 616
  if (adapter->phy.link_speed < 0) {
#line 617
    status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
#line 619
    if (status == 0) {
#line 620
      be_link_status_update(adapter, (int )link_status);
    } else {

    }
#line 621
    ethtool_cmd_speed_set(ecmd, (__u32 )link_speed);
#line 623
    status = be_cmd_get_phy_info(adapter);
#line 624
    if (status == 0) {
#line 625
      interface_type = adapter->phy.interface_type;
#line 626
      auto_speeds = (u32 )adapter->phy.auto_speeds_supported;
#line 627
      fixed_speeds = (u32 )adapter->phy.fixed_speeds_supported;
#line 628
      dac_cable_len = adapter->phy.dac_cable_len;
#line 630
      ecmd->supported = convert_to_et_setting((u32 )interface_type, auto_speeds | fixed_speeds);
#line 634
      ecmd->advertising = convert_to_et_setting((u32 )interface_type, auto_speeds);
#line 638
      tmp___0 = be_get_port_type((u32 )interface_type, dac_cable_len);
#line 638
      ecmd->port = (__u8 )tmp___0;
#line 641
      if ((unsigned int )adapter->phy.auto_speeds_supported != 0U) {
#line 642
        ecmd->supported = ecmd->supported | 64U;
#line 643
        ecmd->autoneg = 1U;
#line 644
        ecmd->advertising = ecmd->advertising | 64U;
      } else {

      }
#line 647
      ecmd->supported = ecmd->supported | 8192U;
#line 648
      tmp___1 = be_pause_supported(adapter);
#line 648
      if ((int )tmp___1) {
#line 649
        ecmd->advertising = ecmd->advertising | 8192U;
      } else {

      }
#line 651
      switch ((int )adapter->phy.interface_type) {
      case 4: ;
      case 5: 
#line 654
      ecmd->transceiver = 0U;
#line 655
      goto ldv_55100;
      default: 
#line 657
      ecmd->transceiver = 1U;
#line 658
      goto ldv_55100;
      }
      ldv_55100: ;
    } else {
#line 661
      ecmd->port = 255U;
#line 662
      ecmd->autoneg = 0U;
#line 663
      ecmd->transceiver = 2U;
    }
#line 667
    tmp___2 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 667
    adapter->phy.link_speed = (int )tmp___2;
#line 668
    adapter->phy.port_type = ecmd->port;
#line 669
    adapter->phy.transceiver = ecmd->transceiver;
#line 670
    adapter->phy.autoneg = ecmd->autoneg;
#line 671
    adapter->phy.advertising = ecmd->advertising;
#line 672
    adapter->phy.supported = ecmd->supported;
  } else {
#line 674
    ethtool_cmd_speed_set(ecmd, (__u32 )adapter->phy.link_speed);
#line 675
    ecmd->port = adapter->phy.port_type;
#line 676
    ecmd->transceiver = adapter->phy.transceiver;
#line 677
    ecmd->autoneg = adapter->phy.autoneg;
#line 678
    ecmd->advertising = adapter->phy.advertising;
#line 679
    ecmd->supported = adapter->phy.supported;
  }
#line 682
  tmp___3 = netif_carrier_ok((struct net_device  const  *)netdev);
#line 682
  ecmd->duplex = (int )tmp___3 ? 1U : 255U;
#line 683
  ecmd->phy_address = (__u8 )adapter->port_num;
#line 685
  return (0);
}
}
#line 688 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 691
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 691
  adapter = (struct be_adapter *)tmp;
#line 693
  tmp___0 = (__u32 )adapter->rx_obj[0].q.len;
#line 693
  ring->rx_pending = tmp___0;
#line 693
  ring->rx_max_pending = tmp___0;
#line 694
  tmp___1 = (__u32 )adapter->tx_obj[0].q.len;
#line 694
  ring->tx_pending = tmp___1;
#line 694
  ring->tx_max_pending = tmp___1;
#line 695
  return;
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 700
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 700
  adapter = (struct be_adapter *)tmp;
#line 702
  be_cmd_get_flow_control(adapter, & ecmd->tx_pause, & ecmd->rx_pause);
#line 703
  ecmd->autoneg = (__u32 )adapter->phy.fc_autoneg;
#line 704
  return;
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 709
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 709
  adapter = (struct be_adapter *)tmp;
#line 712
  if (ecmd->autoneg != (__u32 )adapter->phy.fc_autoneg) {
#line 713
    return (-22);
  } else {

  }
#line 714
  adapter->tx_fc = ecmd->tx_pause;
#line 715
  adapter->rx_fc = ecmd->rx_pause;
#line 717
  status = be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
#line 719
  if (status != 0) {
#line 720
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Pause param set failed.\n");
  } else {

  }
#line 722
  return (status);
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 728
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 728
  adapter = (struct be_adapter *)tmp;
#line 730
  switch ((unsigned int )state) {
  case 1U: 
#line 732
  be_cmd_get_beacon_state(adapter, (int )adapter->hba_port_num, & adapter->beacon_state);
#line 734
  return (1);
  case 2U: 
#line 737
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 1);
#line 739
  goto ldv_55125;
  case 3U: 
#line 742
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 0);
#line 744
  goto ldv_55125;
  case 0U: 
#line 747
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, (int )((u8 )adapter->beacon_state));
  }
  ldv_55125: ;
#line 751
  return (0);
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_dump(struct net_device *netdev , struct ethtool_dump *dump ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int status ;
  bool tmp___0 ;

  {
#line 756
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 756
  adapter = (struct be_adapter *)tmp;
#line 757
  dev = & (adapter->pdev)->dev;
#line 760
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 761
    dev_err((struct device  const  *)dev, "FW dump not supported\n");
#line 762
    return (-95);
  } else {

  }
#line 765
  tmp___0 = dump_present(adapter);
#line 765
  if ((int )tmp___0) {
#line 766
    dev_err((struct device  const  *)dev, "Previous dump not cleared, not forcing dump\n");
#line 767
    return (0);
  } else {

  }
#line 770
  switch (dump->flag) {
  case 1U: 
#line 772
  status = lancer_initiate_dump(adapter);
#line 773
  if (status == 0) {
#line 774
    _dev_info((struct device  const  *)dev, "F/w dump initiated successfully\n");
  } else {

  }
#line 775
  goto ldv_55136;
  default: 
#line 777
  dev_err((struct device  const  *)dev, "Invalid dump level: 0x%x\n", dump->flag);
#line 778
  return (-22);
  }
  ldv_55136: ;
#line 780
  return (status);
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 785
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 785
  adapter = (struct be_adapter *)tmp;
#line 787
  if ((int )adapter->wol_cap & 1) {
#line 788
    wol->supported = wol->supported | 32U;
#line 789
    if ((int )adapter->wol_en) {
#line 790
      wol->wolopts = wol->wolopts | 32U;
    } else {

    }
  } else {
#line 792
    wol->wolopts = 0U;
  }
#line 794
  memset((void *)(& wol->sopass), 0, 6UL);
#line 795
  return;
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 799
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 799
  adapter = (struct be_adapter *)tmp;
#line 801
  if ((wol->wolopts & 4294967263U) != 0U) {
#line 802
    return (-95);
  } else {

  }
#line 804
  if (((int )adapter->wol_cap & 1) == 0) {
#line 805
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "WOL not supported\n");
#line 806
    return (-95);
  } else {

  }
#line 809
  if ((wol->wolopts & 32U) != 0U) {
#line 810
    adapter->wol_en = 1;
  } else {
#line 812
    adapter->wol_en = 0;
  }
#line 814
  return (0);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_test_ddr_dma(struct be_adapter *adapter ) 
{ 
  int ret ;
  int i ;
  struct be_dma_mem ddrdma_cmd ;
  u64 pattern[2U] ;

  {
#line 821
  pattern[0] = 6510615555426900570ULL;
#line 821
  pattern[1] = 0xa5a5a5a5a5a5a5a5ULL;
#line 825
  ddrdma_cmd.size = 8224U;
#line 826
  ddrdma_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size,
                                  & ddrdma_cmd.dma, 208U, (struct dma_attrs *)0);
#line 828
  if ((unsigned long )ddrdma_cmd.va == (unsigned long )((void *)0)) {
#line 829
    return (-12);
  } else {

  }
#line 831
  i = 0;
#line 831
  goto ldv_55157;
  ldv_55156: 
#line 832
  ret = be_cmd_ddr_dma_test(adapter, pattern[i], 4096U, & ddrdma_cmd);
#line 834
  if (ret != 0) {
#line 835
    goto err;
  } else {

  }
#line 831
  i = i + 1;
  ldv_55157: ;
#line 831
  if (i <= 1) {
#line 833
    goto ldv_55156;
  } else {

  }

  err: 
#line 839
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size, ddrdma_cmd.va,
                 ddrdma_cmd.dma, (struct dma_attrs *)0);
#line 841
  return (ret);
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u64 be_loopback_test(struct be_adapter *adapter , u8 loopback_type , u64 *status ) 
{ 
  int tmp ;

  {
#line 847
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, (int )loopback_type, 1);
#line 848
  tmp = be_cmd_loopback_test(adapter, (u32 )adapter->hba_port_num, (u32 )loopback_type,
                             1500U, 2U, 2748ULL);
#line 848
  *status = (u64 )tmp;
#line 850
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, 255, 1);
#line 851
  return (*status);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_self_test(struct net_device *netdev , struct ethtool_test *test , u64 *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 link_status ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  int tmp___3 ;

  {
#line 857
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 857
  adapter = (struct be_adapter *)tmp;
#line 859
  link_status = 0U;
#line 861
  if ((adapter->function_caps & 64U) != 0U) {
#line 862
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Self test not supported\n");
#line 863
    test->flags = test->flags | 2U;
#line 864
    return;
  } else {

  }
#line 867
  memset((void *)data, 0, 40UL);
#line 869
  if ((int )test->flags & 1) {
#line 870
    tmp___0 = be_loopback_test(adapter, 0, data);
#line 870
    if (tmp___0 != 0ULL) {
#line 871
      test->flags = test->flags | 2U;
    } else {

    }
#line 873
    tmp___1 = be_loopback_test(adapter, 1, data + 1UL);
#line 873
    if (tmp___1 != 0ULL) {
#line 874
      test->flags = test->flags | 2U;
    } else {

    }
#line 876
    if ((test->flags & 4U) != 0U) {
#line 877
      tmp___2 = be_loopback_test(adapter, 2, data + 2UL);
#line 877
      if (tmp___2 != 0ULL) {
#line 879
        test->flags = test->flags | 2U;
      } else {

      }
#line 880
      test->flags = test->flags | 8U;
    } else {

    }
  } else {

  }
#line 884
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 884
    tmp___3 = be_test_ddr_dma(adapter);
#line 884
    if (tmp___3 != 0) {
#line 885
      *(data + 3UL) = 1ULL;
#line 886
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
#line 889
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
#line 890
  if (status != 0) {
#line 891
    test->flags = test->flags | 2U;
#line 892
    *(data + 4UL) = 0xffffffffffffffffULL;
  } else
#line 893
  if ((unsigned int )link_status == 0U) {
#line 894
    test->flags = test->flags | 2U;
#line 895
    *(data + 4UL) = 1ULL;
  } else {

  }
#line 897
  return;
}
}
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_do_flash(struct net_device *netdev , struct ethtool_flash *efl ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 901
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 901
  adapter = (struct be_adapter *)tmp;
#line 903
  tmp___0 = be_load_fw(adapter, (u8 *)(& efl->data));
#line 903
  return (tmp___0);
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
#line 908
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 908
  adapter = (struct be_adapter *)tmp;
#line 910
  tmp___0 = check_privilege(adapter, 1792U);
#line 910
  if (tmp___0) {
#line 910
    tmp___1 = 0;
  } else {
#line 910
    tmp___1 = 1;
  }
#line 910
  if (tmp___1) {
#line 911
    return (0);
  } else {

  }
#line 913
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 914
    if ((unsigned int )adapter->virtfn == 0U) {
#line 915
      tmp___2 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_pf.vpd");
#line 915
      return ((int )tmp___2);
    } else {
#line 918
      tmp___3 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_vf.vpd");
#line 918
      return ((int )tmp___3);
    }
  } else {
#line 921
    return (1024);
  }
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_read_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                          uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_dma_mem eeprom_cmd ;
  struct be_cmd_resp_seeprom_read *resp ;
  int status ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 928
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 928
  adapter = (struct be_adapter *)tmp;
#line 933
  if (eeprom->len == 0U) {
#line 934
    return (-22);
  } else {

  }
#line 936
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 937
    if ((unsigned int )adapter->virtfn == 0U) {
#line 938
      tmp___0 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_pf.vpd", eeprom->len,
                                     (void *)data);
#line 938
      return (tmp___0);
    } else {
#line 941
      tmp___1 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_vf.vpd", eeprom->len,
                                     (void *)data);
#line 941
      return (tmp___1);
    }
  } else {

  }
#line 945
  eeprom->magic = (__u32 )(((int )(adapter->pdev)->device << 16) | 6562);
#line 947
  memset((void *)(& eeprom_cmd), 0, 24UL);
#line 948
  eeprom_cmd.size = 1040U;
#line 949
  eeprom_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size,
                                  & eeprom_cmd.dma, 208U, (struct dma_attrs *)0);
#line 952
  if ((unsigned long )eeprom_cmd.va == (unsigned long )((void *)0)) {
#line 953
    return (-12);
  } else {

  }
#line 955
  status = be_cmd_get_seeprom_data(adapter, & eeprom_cmd);
#line 957
  if (status == 0) {
#line 958
    resp = (struct be_cmd_resp_seeprom_read *)eeprom_cmd.va;
#line 959
    __len = (size_t )eeprom->len;
#line 959
    __ret = __builtin_memcpy((void *)data, (void const   *)(& resp->seeprom_data) + (unsigned long )eeprom->offset,
                             __len);
  } else {

  }
#line 961
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size, eeprom_cmd.va,
                 eeprom_cmd.dma, (struct dma_attrs *)0);
#line 964
  return (status);
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 be_get_msg_level(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 969
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 969
  adapter = (struct be_adapter *)tmp;
#line 971
  return (adapter->msg_enable);
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_set_msg_level(struct net_device *netdev , u32 level ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 976
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 976
  adapter = (struct be_adapter *)tmp;
#line 978
  if (adapter->msg_enable == level) {
#line 979
    return;
  } else {

  }
#line 981
  if (((adapter->msg_enable ^ level) & 8192U) != 0U) {
#line 982
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 983
      be_cmd_set_fw_log_level(adapter, (level & 8192U) != 0U ? 48U : 64U);
    } else {

    }
  } else {

  }
#line 986
  adapter->msg_enable = level;
#line 988
  return;
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u64 be_get_rss_hash_opts(struct be_adapter *adapter , u64 flow_type ) 
{ 
  u64 data ;

  {
#line 993
  data = 0ULL;
#line 995
  switch (flow_type) {
  case 1ULL: ;
#line 997
  if ((int )adapter->rss_info.rss_flags & 1) {
#line 998
    data = data | 48ULL;
  } else {

  }
#line 999
  if ((adapter->rss_info.rss_flags & 2ULL) != 0ULL) {
#line 1000
    data = data | 192ULL;
  } else {

  }
#line 1001
  goto ldv_55210;
  case 2ULL: ;
#line 1003
  if ((int )adapter->rss_info.rss_flags & 1) {
#line 1004
    data = data | 48ULL;
  } else {

  }
#line 1005
  if ((adapter->rss_info.rss_flags & 16ULL) != 0ULL) {
#line 1006
    data = data | 192ULL;
  } else {

  }
#line 1007
  goto ldv_55210;
  case 5ULL: ;
#line 1009
  if ((adapter->rss_info.rss_flags & 4ULL) != 0ULL) {
#line 1010
    data = data | 48ULL;
  } else {

  }
#line 1011
  if ((adapter->rss_info.rss_flags & 8ULL) != 0ULL) {
#line 1012
    data = data | 192ULL;
  } else {

  }
#line 1013
  goto ldv_55210;
  case 6ULL: ;
#line 1015
  if ((adapter->rss_info.rss_flags & 4ULL) != 0ULL) {
#line 1016
    data = data | 48ULL;
  } else {

  }
#line 1017
  if ((adapter->rss_info.rss_flags & 32ULL) != 0ULL) {
#line 1018
    data = data | 192ULL;
  } else {

  }
#line 1019
  goto ldv_55210;
  }
  ldv_55210: ;
#line 1022
  return (data);
}
}
#line 1025 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1028
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1028
  adapter = (struct be_adapter *)tmp;
#line 1030
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1030
  if (tmp___0) {
#line 1030
    tmp___1 = 0;
  } else {
#line 1030
    tmp___1 = 1;
  }
#line 1030
  if (tmp___1) {
#line 1031
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::get_rxnfc: RX flow hashing is disabled\n");
#line 1033
    return (-22);
  } else {

  }
#line 1036
  switch (cmd->cmd) {
  case 41U: 
#line 1038
  cmd->data = be_get_rss_hash_opts(adapter, (u64 )cmd->flow_type);
#line 1039
  goto ldv_55221;
  case 45U: 
#line 1041
  cmd->data = (__u64 )((int )adapter->num_rx_qs + -1);
#line 1042
  goto ldv_55221;
  default: ;
#line 1044
  return (-22);
  }
  ldv_55221: ;
#line 1047
  return (0);
}
}
#line 1050 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_rss_hash_opts(struct be_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_rx_obj *rxo ;
  int status ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  u32 rss_flags ;
  bool tmp ;

  {
#line 1054
  status = 0;
#line 1056
  rss_flags = (u32 )adapter->rss_info.rss_flags;
#line 1058
  if (cmd->data != 48ULL && cmd->data != 240ULL) {
#line 1060
    return (-22);
  } else {

  }
#line 1062
  switch (cmd->flow_type) {
  case 1U: ;
#line 1064
  if (cmd->data == 48ULL) {
#line 1065
    rss_flags = rss_flags & 4294967293U;
  } else
#line 1066
  if (cmd->data == 240ULL) {
#line 1067
    rss_flags = rss_flags | 3U;
  } else {

  }
#line 1069
  goto ldv_55235;
  case 5U: ;
#line 1071
  if (cmd->data == 48ULL) {
#line 1072
    rss_flags = rss_flags & 4294967287U;
  } else
#line 1073
  if (cmd->data == 240ULL) {
#line 1074
    rss_flags = rss_flags | 12U;
  } else {

  }
#line 1076
  goto ldv_55235;
  case 2U: ;
#line 1078
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1080
    return (-22);
  } else {

  }
#line 1082
  if (cmd->data == 48ULL) {
#line 1083
    rss_flags = rss_flags & 4294967279U;
  } else
#line 1084
  if (cmd->data == 240ULL) {
#line 1085
    rss_flags = rss_flags | 17U;
  } else {

  }
#line 1087
  goto ldv_55235;
  case 6U: ;
#line 1089
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1091
    return (-22);
  } else {

  }
#line 1093
  if (cmd->data == 48ULL) {
#line 1094
    rss_flags = rss_flags & 4294967263U;
  } else
#line 1095
  if (cmd->data == 240ULL) {
#line 1096
    rss_flags = rss_flags | 36U;
  } else {

  }
#line 1098
  goto ldv_55235;
  default: ;
#line 1100
  return (-22);
  }
  ldv_55235: ;
#line 1103
  if ((u64 )rss_flags == adapter->rss_info.rss_flags) {
#line 1104
    return (status);
  } else {

  }
#line 1106
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1106
  if ((int )tmp) {
#line 1107
    j = 0;
#line 1107
    goto ldv_55244;
    ldv_55243: 
#line 1108
    i = 0;
#line 1108
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 1108
    goto ldv_55242;
    ldv_55241: ;
#line 1109
    if (j + i > 127) {
#line 1110
      goto ldv_55240;
    } else {

    }
#line 1111
    rsstable[j + i] = rxo->rss_id;
#line 1108
    i = i + 1;
#line 1108
    rxo = rxo + 1;
    ldv_55242: ;
#line 1108
    if ((int )adapter->num_rx_qs + -1 > i) {
#line 1110
      goto ldv_55241;
    } else {

    }
    ldv_55240: 
#line 1107
    j = ((int )adapter->num_rx_qs + -1) + j;
    ldv_55244: ;
#line 1107
    if (j <= 127) {
#line 1109
      goto ldv_55243;
    } else {

    }

  } else {

  }
#line 1116
  status = be_cmd_rss_config(adapter, (u8 *)(& adapter->rss_info.rsstable), rss_flags,
                             128, (u8 const   *)(& adapter->rss_info.rss_hkey));
#line 1118
  if (status == 0) {
#line 1119
    adapter->rss_info.rss_flags = (u64 )rss_flags;
  } else {

  }
#line 1121
  return (status);
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1126
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1126
  adapter = (struct be_adapter *)tmp;
#line 1127
  status = 0;
#line 1129
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1129
  if (tmp___0) {
#line 1129
    tmp___1 = 0;
  } else {
#line 1129
    tmp___1 = 1;
  }
#line 1129
  if (tmp___1) {
#line 1130
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::set_rxnfc: RX flow hashing is disabled\n");
#line 1132
    return (-22);
  } else {

  }
#line 1135
  switch (cmd->cmd) {
  case 42U: 
#line 1137
  status = be_set_rss_hash_opts(adapter, cmd);
#line 1138
  goto ldv_55253;
  default: ;
#line 1140
  return (-22);
  }
  ldv_55253: ;
#line 1143
  return (status);
}
}
#line 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static void be_get_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 tmp___0 ;

  {
#line 1149
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1149
  adapter = (struct be_adapter *)tmp;
#line 1151
  ch->combined_count = (__u32 )adapter->num_evt_qs;
#line 1152
  tmp___0 = be_max_qs(adapter);
#line 1152
  ch->max_combined = (__u32 )tmp___0;
#line 1153
  return;
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 tmp___0 ;
  int tmp___1 ;

  {
#line 1158
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1158
  adapter = (struct be_adapter *)tmp;
#line 1160
  if (((ch->rx_count != 0U || ch->tx_count != 0U) || ch->other_count != 0U) || ch->combined_count == 0U) {
#line 1162
    return (-22);
  } else {
#line 1160
    tmp___0 = be_max_qs(adapter);
#line 1160
    if (ch->combined_count > (__u32 )tmp___0) {
#line 1162
      return (-22);
    } else {

    }
  }
#line 1164
  adapter->cfg_num_qs = (u16 )ch->combined_count;
#line 1166
  tmp___1 = be_update_queues(adapter);
#line 1166
  return (tmp___1);
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 be_get_rxfh_indir_size(struct net_device *netdev ) 
{ 


  {
#line 1171
  return (128U);
}
}
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static u32 be_get_rxfh_key_size(struct net_device *netdev ) 
{ 


  {
#line 1176
  return (40U);
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_get_rxfh(struct net_device *netdev , u32 *indir , u8 *hkey ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  struct rss_info *rss ;
  size_t __len ;
  void *__ret ;

  {
#line 1181
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1181
  adapter = (struct be_adapter *)tmp;
#line 1183
  rss = & adapter->rss_info;
#line 1185
  if ((unsigned long )indir != (unsigned long )((u32 *)0U)) {
#line 1186
    i = 0;
#line 1186
    goto ldv_55280;
    ldv_55279: 
#line 1187
    *(indir + (unsigned long )i) = (u32 )rss->rss_queue[i];
#line 1186
    i = i + 1;
    ldv_55280: ;
#line 1186
    if (i <= 127) {
#line 1188
      goto ldv_55279;
    } else {

    }

  } else {

  }
#line 1190
  if ((unsigned long )hkey != (unsigned long )((u8 *)0U)) {
#line 1191
    __len = 40UL;
#line 1191
    if (__len > 63UL) {
#line 1191
      __ret = __memcpy((void *)hkey, (void const   *)(& rss->rss_hkey), __len);
    } else {
#line 1191
      __ret = __builtin_memcpy((void *)hkey, (void const   *)(& rss->rss_hkey), __len);
    }
  } else {

  }
#line 1193
  return (0);
}
}
#line 1196 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
static int be_set_rxfh(struct net_device *netdev , u32 const   *indir , u8 const   *hkey ) 
{ 
  int rc ;
  int i ;
  int j ;
  struct be_adapter *adapter ;
  void *tmp ;
  u8 rsstable[128U] ;
  struct be_rx_obj *rxo ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1199
  rc = 0;
#line 1200
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1200
  adapter = (struct be_adapter *)tmp;
#line 1203
  if ((unsigned long )indir != (unsigned long )((u32 const   *)0U)) {
#line 1205
    i = 0;
#line 1205
    goto ldv_55297;
    ldv_55296: 
#line 1206
    j = (int )*(indir + (unsigned long )i);
#line 1207
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 1208
    rsstable[i] = rxo->rss_id;
#line 1209
    adapter->rss_info.rss_queue[i] = (u8 )j;
#line 1205
    i = i + 1;
    ldv_55297: ;
#line 1205
    if (i <= 127) {
#line 1207
      goto ldv_55296;
    } else {

    }

  } else {
#line 1212
    __len = 128UL;
#line 1212
    if (__len > 63UL) {
#line 1212
      __ret = __memcpy((void *)(& rsstable), (void const   *)(& adapter->rss_info.rsstable),
                       __len);
    } else {
#line 1212
      __ret = __builtin_memcpy((void *)(& rsstable), (void const   *)(& adapter->rss_info.rsstable),
                               __len);
    }
  }
#line 1216
  if ((unsigned long )hkey == (unsigned long )((u8 const   *)0U)) {
#line 1217
    hkey = (u8 const   *)(& adapter->rss_info.rss_hkey);
  } else {

  }
#line 1219
  rc = be_cmd_rss_config(adapter, (u8 *)(& rsstable), (u32 )adapter->rss_info.rss_flags,
                         128, hkey);
#line 1222
  if (rc != 0) {
#line 1223
    adapter->rss_info.rss_flags = 0ULL;
#line 1224
    return (-5);
  } else {

  }
#line 1226
  __len___0 = 40UL;
#line 1226
  if (__len___0 > 63UL) {
#line 1226
    __ret___0 = __memcpy((void *)(& adapter->rss_info.rss_hkey), (void const   *)hkey,
                         __len___0);
  } else {
#line 1226
    __ret___0 = __builtin_memcpy((void *)(& adapter->rss_info.rss_hkey), (void const   *)hkey,
                                 __len___0);
  }
#line 1227
  __len___1 = 128UL;
#line 1227
  if (__len___1 > 63UL) {
#line 1227
    __ret___1 = __memcpy((void *)(& adapter->rss_info.rsstable), (void const   *)(& rsstable),
                         __len___1);
  } else {
#line 1227
    __ret___1 = __builtin_memcpy((void *)(& adapter->rss_info.rsstable), (void const   *)(& rsstable),
                                 __len___1);
  }
#line 1229
  return (0);
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct ethtool_ops  const  be_ethtool_ops  = 
#line 1232
     {& be_get_settings, 0, & be_get_drvinfo, & be_get_reg_len, & be_get_regs, & be_get_wol,
    & be_set_wol, & be_get_msg_level, & be_set_msg_level, 0, & ethtool_op_get_link,
    & be_get_eeprom_len, & be_read_eeprom, 0, & be_get_coalesce, & be_set_coalesce,
    & be_get_ringparam, 0, & be_get_pauseparam, & be_set_pauseparam, & be_self_test,
    & be_get_stat_strings, & be_set_phys_id, & be_get_ethtool_stats, 0, 0, 0, 0, & be_get_sset_count,
    & be_get_rxnfc, & be_set_rxnfc, & be_do_flash, 0, & be_get_rxfh_key_size, & be_get_rxfh_indir_size,
    & be_get_rxfh, & be_set_rxfh, & be_get_channels, & be_set_channels, 0, 0, & be_set_dump,
    0, 0, 0, 0, 0};
#line 1267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void ldv_initialize_ethtool_ops_3(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 1268
  tmp = ldv_zalloc(36UL);
#line 1268
  be_ethtool_ops_group4 = (struct ethtool_channels *)tmp;
#line 1269
  tmp___0 = ldv_zalloc(20UL);
#line 1269
  be_ethtool_ops_group0 = (struct ethtool_wolinfo *)tmp___0;
#line 1270
  tmp___1 = ldv_zalloc(92UL);
#line 1270
  be_ethtool_ops_group2 = (struct ethtool_coalesce *)tmp___1;
#line 1271
  tmp___2 = ldv_zalloc(192UL);
#line 1271
  be_ethtool_ops_group1 = (struct ethtool_rxnfc *)tmp___2;
#line 1272
  tmp___3 = ldv_zalloc(16UL);
#line 1272
  be_ethtool_ops_group3 = (struct ethtool_pauseparam *)tmp___3;
#line 1273
  tmp___4 = ldv_zalloc(3264UL);
#line 1273
  be_ethtool_ops_group5 = (struct net_device *)tmp___4;
#line 1274
  return;
}
}
#line 1276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  void *ldvarg47 ;
  void *tmp ;
  u8 *ldvarg34 ;
  void *tmp___0 ;
  u32 *ldvarg52 ;
  void *tmp___1 ;
  struct ethtool_dump *ldvarg54 ;
  void *tmp___2 ;
  struct ethtool_regs *ldvarg48 ;
  void *tmp___3 ;
  u32 ldvarg33 ;
  u32 tmp___4 ;
  u32 ldvarg38 ;
  u32 tmp___5 ;
  struct ethtool_eeprom *ldvarg35 ;
  void *tmp___6 ;
  u8 *ldvarg45 ;
  void *tmp___7 ;
  enum ethtool_phys_id_state ldvarg44 ;
  struct ethtool_cmd *ldvarg40 ;
  void *tmp___8 ;
  u64 *ldvarg36 ;
  void *tmp___9 ;
  struct ethtool_drvinfo *ldvarg53 ;
  void *tmp___10 ;
  struct ethtool_test *ldvarg37 ;
  void *tmp___11 ;
  u32 *ldvarg46 ;
  void *tmp___12 ;
  u64 *ldvarg50 ;
  void *tmp___13 ;
  struct ethtool_ringparam *ldvarg49 ;
  void *tmp___14 ;
  u8 *ldvarg42 ;
  void *tmp___15 ;
  u32 *ldvarg43 ;
  void *tmp___16 ;
  int ldvarg41 ;
  int tmp___17 ;
  u8 *ldvarg32 ;
  void *tmp___18 ;
  struct ethtool_stats *ldvarg51 ;
  void *tmp___19 ;
  struct ethtool_flash *ldvarg39 ;
  void *tmp___20 ;
  int tmp___21 ;

  {
#line 1277
  tmp = ldv_zalloc(1UL);
#line 1277
  ldvarg47 = tmp;
#line 1278
  tmp___0 = ldv_zalloc(1UL);
#line 1278
  ldvarg34 = (u8 *)tmp___0;
#line 1279
  tmp___1 = ldv_zalloc(4UL);
#line 1279
  ldvarg52 = (u32 *)tmp___1;
#line 1280
  tmp___2 = ldv_zalloc(16UL);
#line 1280
  ldvarg54 = (struct ethtool_dump *)tmp___2;
#line 1281
  tmp___3 = ldv_zalloc(12UL);
#line 1281
  ldvarg48 = (struct ethtool_regs *)tmp___3;
#line 1282
  tmp___4 = __VERIFIER_nondet_u32();
#line 1282
  ldvarg33 = tmp___4;
#line 1283
  tmp___5 = __VERIFIER_nondet_u32();
#line 1283
  ldvarg38 = tmp___5;
#line 1284
  tmp___6 = ldv_zalloc(16UL);
#line 1284
  ldvarg35 = (struct ethtool_eeprom *)tmp___6;
#line 1285
  tmp___7 = ldv_zalloc(1UL);
#line 1285
  ldvarg45 = (u8 *)tmp___7;
#line 1287
  tmp___8 = ldv_zalloc(44UL);
#line 1287
  ldvarg40 = (struct ethtool_cmd *)tmp___8;
#line 1288
  tmp___9 = ldv_zalloc(8UL);
#line 1288
  ldvarg36 = (u64 *)tmp___9;
#line 1289
  tmp___10 = ldv_zalloc(196UL);
#line 1289
  ldvarg53 = (struct ethtool_drvinfo *)tmp___10;
#line 1290
  tmp___11 = ldv_zalloc(16UL);
#line 1290
  ldvarg37 = (struct ethtool_test *)tmp___11;
#line 1291
  tmp___12 = ldv_zalloc(4UL);
#line 1291
  ldvarg46 = (u32 *)tmp___12;
#line 1292
  tmp___13 = ldv_zalloc(8UL);
#line 1292
  ldvarg50 = (u64 *)tmp___13;
#line 1293
  tmp___14 = ldv_zalloc(36UL);
#line 1293
  ldvarg49 = (struct ethtool_ringparam *)tmp___14;
#line 1294
  tmp___15 = ldv_zalloc(1UL);
#line 1294
  ldvarg42 = (u8 *)tmp___15;
#line 1295
  tmp___16 = ldv_zalloc(4UL);
#line 1295
  ldvarg43 = (u32 *)tmp___16;
#line 1296
  tmp___17 = __VERIFIER_nondet_int();
#line 1296
  ldvarg41 = tmp___17;
#line 1297
  tmp___18 = ldv_zalloc(1UL);
#line 1297
  ldvarg32 = (u8 *)tmp___18;
#line 1298
  tmp___19 = ldv_zalloc(8UL);
#line 1298
  ldvarg51 = (struct ethtool_stats *)tmp___19;
#line 1299
  tmp___20 = ldv_zalloc(136UL);
#line 1299
  ldvarg39 = (struct ethtool_flash *)tmp___20;
#line 1286
  memset((void *)(& ldvarg44), 0, 4UL);
#line 1301
  tmp___21 = __VERIFIER_nondet_int();
#line 1301
  switch (tmp___21) {
  case 0: ;
#line 1304
  if (ldv_state_variable_3 == 1) {
#line 1306
    be_set_dump(be_ethtool_ops_group5, ldvarg54);
#line 1308
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1311
  goto ldv_55339;
  case 1: ;
#line 1314
  if (ldv_state_variable_3 == 1) {
#line 1316
    be_get_drvinfo(be_ethtool_ops_group5, ldvarg53);
#line 1318
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1321
  goto ldv_55339;
  case 2: ;
#line 1324
  if (ldv_state_variable_3 == 1) {
#line 1326
    be_set_pauseparam(be_ethtool_ops_group5, be_ethtool_ops_group3);
#line 1328
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1331
  goto ldv_55339;
  case 3: ;
#line 1334
  if (ldv_state_variable_3 == 1) {
#line 1336
    be_set_rxnfc(be_ethtool_ops_group5, be_ethtool_ops_group1);
#line 1338
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1341
  goto ldv_55339;
  case 4: ;
#line 1344
  if (ldv_state_variable_3 == 1) {
#line 1346
    be_get_rxnfc(be_ethtool_ops_group5, be_ethtool_ops_group1, ldvarg52);
#line 1348
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1351
  goto ldv_55339;
  case 5: ;
#line 1354
  if (ldv_state_variable_3 == 1) {
#line 1356
    be_get_ethtool_stats(be_ethtool_ops_group5, ldvarg51, ldvarg50);
#line 1358
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1361
  goto ldv_55339;
  case 6: ;
#line 1364
  if (ldv_state_variable_3 == 1) {
#line 1366
    be_get_coalesce(be_ethtool_ops_group5, be_ethtool_ops_group2);
#line 1368
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1371
  goto ldv_55339;
  case 7: ;
#line 1374
  if (ldv_state_variable_3 == 1) {
#line 1376
    be_get_ringparam(be_ethtool_ops_group5, ldvarg49);
#line 1378
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1381
  goto ldv_55339;
  case 8: ;
#line 1384
  if (ldv_state_variable_3 == 1) {
#line 1386
    be_get_regs(be_ethtool_ops_group5, ldvarg48, ldvarg47);
#line 1388
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1391
  goto ldv_55339;
  case 9: ;
#line 1394
  if (ldv_state_variable_3 == 1) {
#line 1396
    be_set_rxfh(be_ethtool_ops_group5, (u32 const   *)ldvarg46, (u8 const   *)ldvarg45);
#line 1398
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1401
  goto ldv_55339;
  case 10: ;
#line 1404
  if (ldv_state_variable_3 == 1) {
#line 1406
    be_set_phys_id(be_ethtool_ops_group5, ldvarg44);
#line 1408
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1411
  goto ldv_55339;
  case 11: ;
#line 1414
  if (ldv_state_variable_3 == 1) {
#line 1416
    be_get_pauseparam(be_ethtool_ops_group5, be_ethtool_ops_group3);
#line 1418
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1421
  goto ldv_55339;
  case 12: ;
#line 1424
  if (ldv_state_variable_3 == 1) {
#line 1426
    be_set_channels(be_ethtool_ops_group5, be_ethtool_ops_group4);
#line 1428
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1431
  goto ldv_55339;
  case 13: ;
#line 1434
  if (ldv_state_variable_3 == 1) {
#line 1436
    be_get_rxfh(be_ethtool_ops_group5, ldvarg43, ldvarg42);
#line 1438
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1441
  goto ldv_55339;
  case 14: ;
#line 1444
  if (ldv_state_variable_3 == 1) {
#line 1446
    be_get_sset_count(be_ethtool_ops_group5, ldvarg41);
#line 1448
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1451
  goto ldv_55339;
  case 15: ;
#line 1454
  if (ldv_state_variable_3 == 1) {
#line 1456
    be_get_settings(be_ethtool_ops_group5, ldvarg40);
#line 1458
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1461
  goto ldv_55339;
  case 16: ;
#line 1464
  if (ldv_state_variable_3 == 1) {
#line 1466
    be_get_rxfh_indir_size(be_ethtool_ops_group5);
#line 1468
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1471
  goto ldv_55339;
  case 17: ;
#line 1474
  if (ldv_state_variable_3 == 1) {
#line 1476
    be_set_coalesce(be_ethtool_ops_group5, be_ethtool_ops_group2);
#line 1478
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1481
  goto ldv_55339;
  case 18: ;
#line 1484
  if (ldv_state_variable_3 == 1) {
#line 1486
    be_set_wol(be_ethtool_ops_group5, be_ethtool_ops_group0);
#line 1488
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1491
  goto ldv_55339;
  case 19: ;
#line 1494
  if (ldv_state_variable_3 == 1) {
#line 1496
    be_do_flash(be_ethtool_ops_group5, ldvarg39);
#line 1498
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1501
  goto ldv_55339;
  case 20: ;
#line 1504
  if (ldv_state_variable_3 == 1) {
#line 1506
    be_set_msg_level(be_ethtool_ops_group5, ldvarg38);
#line 1508
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1511
  goto ldv_55339;
  case 21: ;
#line 1514
  if (ldv_state_variable_3 == 1) {
#line 1516
    be_get_eeprom_len(be_ethtool_ops_group5);
#line 1518
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1521
  goto ldv_55339;
  case 22: ;
#line 1524
  if (ldv_state_variable_3 == 1) {
#line 1526
    be_self_test(be_ethtool_ops_group5, ldvarg37, ldvarg36);
#line 1528
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1531
  goto ldv_55339;
  case 23: ;
#line 1534
  if (ldv_state_variable_3 == 1) {
#line 1536
    be_read_eeprom(be_ethtool_ops_group5, ldvarg35, ldvarg34);
#line 1538
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1541
  goto ldv_55339;
  case 24: ;
#line 1544
  if (ldv_state_variable_3 == 1) {
#line 1546
    be_get_stat_strings(be_ethtool_ops_group5, ldvarg33, ldvarg32);
#line 1548
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1551
  goto ldv_55339;
  case 25: ;
#line 1554
  if (ldv_state_variable_3 == 1) {
#line 1556
    be_get_wol(be_ethtool_ops_group5, be_ethtool_ops_group0);
#line 1558
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1561
  goto ldv_55339;
  case 26: ;
#line 1564
  if (ldv_state_variable_3 == 1) {
#line 1566
    be_get_msg_level(be_ethtool_ops_group5);
#line 1568
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1571
  goto ldv_55339;
  case 27: ;
#line 1574
  if (ldv_state_variable_3 == 1) {
#line 1576
    be_get_reg_len(be_ethtool_ops_group5);
#line 1578
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1581
  goto ldv_55339;
  case 28: ;
#line 1584
  if (ldv_state_variable_3 == 1) {
#line 1586
    be_get_rxfh_key_size(be_ethtool_ops_group5);
#line 1588
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1591
  goto ldv_55339;
  case 29: ;
#line 1594
  if (ldv_state_variable_3 == 1) {
#line 1596
    be_get_channels(be_ethtool_ops_group5, be_ethtool_ops_group4);
#line 1598
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1601
  goto ldv_55339;
  case 30: ;
#line 1604
  if (ldv_state_variable_3 == 1) {
#line 1606
    ethtool_op_get_link(be_ethtool_ops_group5);
#line 1608
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1611
  goto ldv_55339;
  default: 
#line 1612
  ldv_stop();
  }
  ldv_55339: ;
#line 1616
  return;
}
}
#line 1744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void *ldv_kmem_cache_alloc_126(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1747
  ldv_check_alloc_flags(flags);
#line 1749
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1750
  return ((void *)0);
}
}
#line 1788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
int ldv_pskb_expand_head_132(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1791
  ldv_check_alloc_flags(flags);
#line 1793
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1793
  return (tmp);
}
}
#line 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv_skb_clone_134(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1807
  ldv_check_alloc_flags(flags);
#line 1809
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1809
  return (tmp);
}
}
#line 1820 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv_skb_copy_136(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1823
  ldv_check_alloc_flags(flags);
#line 1825
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1825
  return (tmp);
}
}
#line 1828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1831
  ldv_check_alloc_flags(flags);
#line 1833
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1833
  return (tmp);
}
}
#line 1836 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_138(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1839
  ldv_check_alloc_flags(flags);
#line 1841
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1841
  return (tmp);
}
}
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_139(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1847
  ldv_check_alloc_flags(flags);
#line 1849
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1849
  return (tmp);
}
}
#line 1852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
int ldv_pskb_expand_head_140(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1855
  ldv_check_alloc_flags(flags);
#line 1857
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1857
  return (tmp);
}
}
#line 1860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
int ldv_pskb_expand_head_141(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1863
  ldv_check_alloc_flags(flags);
#line 1865
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1865
  return (tmp);
}
}
#line 1868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
struct sk_buff *ldv_skb_clone_142(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1871
  ldv_check_alloc_flags(flags);
#line 1873
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1873
  return (tmp);
}
}
#line 1876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void *ldv_kmem_cache_alloc_143(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1879
  ldv_check_alloc_flags(flags);
#line 1881
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1882
  return ((void *)0);
}
}
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void *ldv_vmalloc_144(unsigned long ldv_func_arg1 ) 
{ 


  {
#line 1887
  ldv_check_alloc_nonatomic();
#line 1889
  vmalloc(ldv_func_arg1);
#line 1890
  return ((void *)0);
}
}
#line 47 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 139 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 70 "include/linux/vmalloc.h"
void *ldv_vmalloc_190(unsigned long ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_172(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 323
void *ldv_kmem_cache_alloc_189(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_180(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_188(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_182(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_178(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_186(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_187(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_183(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_184(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2748 "include/linux/netdevice.h"
__inline static bool netif_oper_up(struct net_device  const  *dev ) 
{ 


  {
#line 2750
  return ((bool )((unsigned int )((unsigned char )dev->operstate) == 6U || (unsigned int )((unsigned char )dev->operstate) == 0U));
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_register_driver(struct ocrdma_driver *drv ) ;
#line 72
void be_roce_unregister_driver(struct ocrdma_driver *drv ) ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static struct ocrdma_driver *ocrdma_drv  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static struct list_head be_adapter_list  =    {& be_adapter_list, & be_adapter_list};
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static struct mutex be_adapter_list_lock  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "be_adapter_list_lock.wait_lock",
                                                           0, 0UL}}}}, {& be_adapter_list_lock.wait_list,
                                                                        & be_adapter_list_lock.wait_list},
    0, 0, (void *)(& be_adapter_list_lock), {0, {0, 0}, "be_adapter_list_lock", 0,
                                             0UL}};
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static void _be_roce_dev_add(struct be_adapter *adapter ) 
{ 
  struct be_dev_info dev_info ;
  int i ;
  int num_vec ;
  struct pci_dev *pdev ;
  size_t __len ;
  void *__ret ;
  int _min1 ;
  int _min2 ;

  {
#line 110
  pdev = adapter->pdev;
#line 112
  if ((unsigned long )ocrdma_drv == (unsigned long )((struct ocrdma_driver *)0)) {
#line 113
    return;
  } else {

  }
#line 115
  if (ocrdma_drv->be_abi_version != 1U) {
#line 116
    dev_warn((struct device  const  *)(& pdev->dev), "Cannot initialize RoCE due to ocrdma ABI mismatch\n");
#line 117
    return;
  } else {

  }
#line 120
  if ((unsigned int )pdev->device == 1824U) {
#line 122
    if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 123
      return;
    } else {

    }
#line 125
    dev_info.dpp_unmapped_addr = pdev->resource[2].start;
#line 126
    dev_info.dpp_unmapped_len = pdev->resource[2].start != 0ULL || pdev->resource[2].end != pdev->resource[2].start ? ((u32 )pdev->resource[2].end - (u32 )pdev->resource[2].start) + 1U : 0U;
  } else {
#line 128
    dev_info.dpp_unmapped_addr = 0ULL;
#line 129
    dev_info.dpp_unmapped_len = 0U;
  }
#line 131
  dev_info.pdev = adapter->pdev;
#line 132
  dev_info.db = adapter->db;
#line 133
  dev_info.unmapped_db = adapter->roce_db.io_addr;
#line 134
  dev_info.db_page_size = adapter->roce_db.size;
#line 135
  dev_info.db_total_size = adapter->roce_db.total_size;
#line 136
  dev_info.netdev = adapter->netdev;
#line 137
  __len = 6UL;
#line 137
  if (__len > 63UL) {
#line 137
    __ret = __memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
                     __len);
  } else {
#line 137
    __ret = __builtin_memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
                             __len);
  }
#line 138
  dev_info.dev_family = adapter->sli_family;
#line 139
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 143
    num_vec = (int )((u32 )adapter->num_msix_vec + adapter->num_msix_roce_vec);
#line 144
    dev_info.intr_mode = 0;
#line 145
    _min1 = num_vec;
#line 145
    _min2 = 32;
#line 145
    dev_info.msix.num_vectors = _min1 < _min2 ? _min1 : _min2;
#line 150
    dev_info.msix.start_vector = (int )adapter->num_evt_qs;
#line 151
    i = 0;
#line 151
    goto ldv_54875;
    ldv_54874: 
#line 152
    dev_info.msix.vector_list[i] = adapter->msix_entries[i].vector;
#line 151
    i = i + 1;
    ldv_54875: ;
#line 151
    if (dev_info.msix.num_vectors > i) {
#line 153
      goto ldv_54874;
    } else {

    }

  } else {
#line 156
    dev_info.msix.num_vectors = 0;
#line 157
    dev_info.intr_mode = 1;
  }
#line 159
  adapter->ocrdma_dev = (*(ocrdma_drv->add))(& dev_info);
#line 160
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void be_roce_dev_add(struct be_adapter *adapter ) 
{ 


  {
#line 164
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 165
    INIT_LIST_HEAD(& adapter->entry);
#line 166
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 167
    list_add_tail(& adapter->entry, & be_adapter_list);
#line 173
    _be_roce_dev_add(adapter);
#line 174
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 176
  return;
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static void _be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 180
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )ocrdma_drv->remove != (unsigned long )((void (*)(struct ocrdma_dev * ))0)) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 181
    (*(ocrdma_drv->remove))(adapter->ocrdma_dev);
  } else {

  }
#line 182
  adapter->ocrdma_dev = (struct ocrdma_dev *)0;
#line 183
  return;
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 187
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 188
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 189
    _be_roce_dev_remove(adapter);
#line 190
    list_del(& adapter->entry);
#line 191
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 193
  return;
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static void _be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 197
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 199
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 0U);
  } else {

  }
#line 200
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 204
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 205
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 206
    _be_roce_dev_open(adapter);
#line 207
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 209
  return;
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static void _be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 213
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 215
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 1U);
  } else {

  }
#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 220
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 221
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 222
    _be_roce_dev_close(adapter);
#line 223
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 225
  return;
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
int be_roce_register_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct net_device *netdev ;
  bool tmp ;
  bool tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 231
  mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 232
  if ((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0)) {
#line 233
    mutex_unlock(& be_adapter_list_lock);
#line 234
    return (-22);
  } else {

  }
#line 236
  ocrdma_drv = drv;
#line 237
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 237
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb9138UL;
#line 237
  goto ldv_54908;
  ldv_54907: 
#line 239
  _be_roce_dev_add(dev);
#line 240
  netdev = dev->netdev;
#line 241
  tmp = netif_running((struct net_device  const  *)netdev);
#line 241
  if ((int )tmp) {
#line 241
    tmp___0 = netif_oper_up((struct net_device  const  *)netdev);
#line 241
    if ((int )tmp___0) {
#line 242
      _be_roce_dev_open(dev);
    } else {

    }
  } else {

  }
#line 237
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 237
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb9138UL;
  ldv_54908: ;
#line 237
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 239
    goto ldv_54907;
  } else {

  }
#line 244
  mutex_unlock(& be_adapter_list_lock);
#line 245
  return (0);
}
}
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static char const   __kstrtab_be_roce_register_driver[24U]  = 
#line 247
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'r',      'e',      'g',      'i', 
        's',      't',      'e',      'r', 
        '_',      'd',      'r',      'i', 
        'v',      'e',      'r',      '\000'};
#line 247
struct kernel_symbol  const  __ksymtab_be_roce_register_driver ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct kernel_symbol  const  __ksymtab_be_roce_register_driver  =    {(unsigned long )(& be_roce_register_driver), (char const   *)(& __kstrtab_be_roce_register_driver)};
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void be_roce_unregister_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 253
  mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 254
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 254
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb9138UL;
#line 254
  goto ldv_54926;
  ldv_54925: ;
#line 255
  if ((unsigned long )dev->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 256
    _be_roce_dev_remove(dev);
  } else {

  }
#line 254
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 254
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb9138UL;
  ldv_54926: ;
#line 254
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 256
    goto ldv_54925;
  } else {

  }
#line 258
  ocrdma_drv = (struct ocrdma_driver *)0;
#line 259
  mutex_unlock(& be_adapter_list_lock);
#line 260
  return;
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
static char const   __kstrtab_be_roce_unregister_driver[26U]  = 
#line 261
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'u',      'n',      'r',      'e', 
        'g',      'i',      's',      't', 
        'e',      'r',      '_',      'd', 
        'r',      'i',      'v',      'e', 
        'r',      '\000'};
#line 261
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver ;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver  =    {(unsigned long )(& be_roce_unregister_driver), (char const   *)(& __kstrtab_be_roce_unregister_driver)};
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void *ldv_kmem_cache_alloc_172(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 393
  ldv_check_alloc_flags(flags);
#line 395
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 396
  return ((void *)0);
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
int ldv_pskb_expand_head_178(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 439
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 439
  return (tmp);
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv_skb_clone_180(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 453
  ldv_check_alloc_flags(flags);
#line 455
  tmp = skb_clone(ldv_func_arg1, flags);
#line 455
  return (tmp);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv_skb_copy_182(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 469
  ldv_check_alloc_flags(flags);
#line 471
  tmp = skb_copy(ldv_func_arg1, flags);
#line 471
  return (tmp);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_183(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 477
  ldv_check_alloc_flags(flags);
#line 479
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 479
  return (tmp);
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_184(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 485
  ldv_check_alloc_flags(flags);
#line 487
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 487
  return (tmp);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 493
  ldv_check_alloc_flags(flags);
#line 495
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 495
  return (tmp);
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
int ldv_pskb_expand_head_186(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 501
  ldv_check_alloc_flags(flags);
#line 503
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 503
  return (tmp);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
int ldv_pskb_expand_head_187(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 509
  ldv_check_alloc_flags(flags);
#line 511
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 511
  return (tmp);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
struct sk_buff *ldv_skb_clone_188(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 517
  ldv_check_alloc_flags(flags);
#line 519
  tmp = skb_clone(ldv_func_arg1, flags);
#line 519
  return (tmp);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void *ldv_kmem_cache_alloc_189(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 525
  ldv_check_alloc_flags(flags);
#line 527
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 528
  return ((void *)0);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void *ldv_vmalloc_190(unsigned long ldv_func_arg1 ) 
{ 


  {
#line 533
  ldv_check_alloc_nonatomic();
#line 535
  vmalloc(ldv_func_arg1);
#line 536
  return ((void *)0);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9912/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
