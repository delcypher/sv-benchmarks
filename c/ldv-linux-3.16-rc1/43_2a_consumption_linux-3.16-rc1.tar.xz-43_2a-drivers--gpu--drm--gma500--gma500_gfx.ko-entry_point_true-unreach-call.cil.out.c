extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 163 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 168 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 327 "./arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 433 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct llist_node;
#line 105 "include/linux/debugobjects.h"
struct llist_head {
   struct llist_node *first ;
};
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 72 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 167 "./arch/x86/include/asm/fixmap.h"
struct notifier_block;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 37 "include/linux/kmod.h"
struct cred;
#line 24 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14006_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14010_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_14011_135 {
   struct __anonstruct_ldv_14006_136 ldv_14006 ;
   struct __anonstruct_ldv_14010_137 ldv_14010 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14011_135 ldv_14011 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14120_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14126_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14136_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14138_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14136_144 ldv_14136 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14140_142 {
   union __anonunion_ldv_14138_143 ldv_14138 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14142_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14140_142 ldv_14140 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14143_139 {
   union __anonunion_ldv_14126_140 ldv_14126 ;
   union __anonunion_ldv_14142_141 ldv_14142 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14150_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14155_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14150_146 ldv_14150 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14161_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 ldv_14120 ;
   struct __anonstruct_ldv_14143_139 ldv_14143 ;
   union __anonunion_ldv_14155_145 ldv_14155 ;
   union __anonunion_ldv_14161_147 ldv_14161 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14524_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14524_153 ldv_14524 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14668_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14668_154 ldv_14668 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15343_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15343_155 ldv_15343 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15963_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_15969_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_15970_156 {
   struct __anonstruct_ldv_15963_157 ldv_15963 ;
   struct __anonstruct_ldv_15969_158 ldv_15969 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15970_156 ldv_15970 ;
};
#line 15 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
struct fb_var_screeninfo;
#line 24
struct drm_connector;
#line 25
struct fb_info;
#line 26
struct drm_encoder;
#line 27
struct gma_clock_t;
#line 28
struct drm_device;
#line 37
struct drm_crtc;
#line 38
struct drm_file;
#line 61
struct drm_framebuffer;
#line 68
struct drm_display_mode;
#line 103
struct i2c_adapter;
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 461 "include/linux/rculist.h"
struct hlist_bl_node;
#line 461 "include/linux/rculist.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_19470_160 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_19471_159 {
   struct __anonstruct_ldv_19470_160 ldv_19470 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_19471_159 ldv_19471 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct_ldv_19495_162 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion_ldv_19497_161 {
   struct __anonstruct_ldv_19495_162 ldv_19495 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_19497_161 ldv_19497 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_163 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_163 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_19858_165 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_19860_164 {
   struct __anonstruct_ldv_19858_165 ldv_19858 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_19860_164 ldv_19860 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 435
struct pid_namespace;
#line 435 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct iovec;
#line 62
struct kiocb;
#line 63
struct pipe_inode_info;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_167 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_167 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_20659_168 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_20659_168 ldv_20659 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382
struct backing_dev_info;
#line 383 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_21074_171 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_21094_172 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_21111_173 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_21074_171 ldv_21074 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_21094_172 ldv_21094 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_21111_173 ldv_21111 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_174 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_174 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836
struct files_struct;
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_176 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_175 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_176 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_175 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 6 "./include/uapi/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "./include/uapi/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "./include/uapi/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "./include/uapi/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "./include/uapi/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 16 "./include/uapi/linux/termios.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 34 "include/linux/cdev.h"
struct tty_struct;
#line 35
struct tty_driver;
#line 36
struct serial_icounter_struct;
#line 37 "include/linux/cdev.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 289 "include/linux/tty_driver.h"
struct proc_dir_entry;
#line 289
struct tty_port;
#line 289 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 356 "include/linux/tty_driver.h"
struct ld_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   unsigned int wait_readers ;
   struct list_head read_wait ;
   struct list_head write_wait ;
   struct lockdep_map dep_map ;
};
#line 170 "include/linux/tty_ldisc.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  ) ;
   void (*fasync)(struct tty_struct * , int  ) ;
   int (*receive_buf2)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   struct module *owner ;
   int refcount ;
};
#line 220 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   struct tty_struct *tty ;
};
#line 225 "include/linux/tty_ldisc.h"
union __anonunion_ldv_23735_177 {
   struct tty_buffer *next ;
   struct llist_node free ;
};
#line 225 "include/linux/tty_ldisc.h"
struct tty_buffer {
   union __anonunion_ldv_23735_177 ldv_23735 ;
   int used ;
   int size ;
   int commit ;
   int read ;
   int flags ;
   unsigned long data[0U] ;
};
#line 59 "include/linux/tty.h"
struct tty_bufhead {
   struct tty_buffer *head ;
   struct work_struct work ;
   struct mutex lock ;
   atomic_t priority ;
   struct tty_buffer sentinel ;
   struct llist_head free ;
   atomic_t mem_used ;
   int mem_limit ;
   struct tty_buffer *tail ;
};
#line 71
struct signal_struct;
#line 72 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 197 "include/linux/tty.h"
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   unsigned char low_latency : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 222 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct ld_semaphore ldisc_sem ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex throttle_mutex ;
   struct rw_semaphore termios_rwsem ;
   struct mutex winsize_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   int flow_change ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned char closing : 1 ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 377
struct class;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 479 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 628
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "./arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct device_node;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_181 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_181 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_183 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_184 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_186 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_187 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_182 {
   int _pad[28U] ;
   struct __anonstruct__kill_183 _kill ;
   struct __anonstruct__timer_184 _timer ;
   struct __anonstruct__rt_185 _rt ;
   struct __anonstruct__sigchld_186 _sigchld ;
   struct __anonstruct__sigfault_187 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_182 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct key_type;
#line 40 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26888_192 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_26896_193 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_26909_195 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26910_194 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_26909_195 ldv_26909 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_196 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_198 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26925_197 {
   union __anonunion_payload_198 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_26888_192 ldv_26888 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_26896_193 ldv_26896 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_26910_194 ldv_26910 ;
   union __anonunion_type_data_196 type_data ;
   union __anonunion_ldv_26925_197 ldv_26925 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct reclaim_state;
#line 779 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1061 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 42 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 783 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 335 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
};
#line 381 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_bus_recovery_info * ) ;
   void (*unprepare_recovery)(struct i2c_bus_recovery_info * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 420 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
};
#line 578 "include/linux/i2c.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 176 "include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 192 "include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 279 "include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 335 "include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 348 "include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 357 "include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
#line 369 "include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 385 "include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 399
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 411
struct backlight_device;
#line 412 "include/uapi/linux/fb.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 65 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 84 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct list_head entry ;
   struct device dev ;
   bool fb_bl_on[32U] ;
   int use_count ;
};
#line 169 "include/linux/backlight.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 61 "include/linux/fb.h"
struct fb_videomode;
#line 61 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 170 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 181 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
#line 210 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
#line 221 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
#line 309 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
#line 325 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 337 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 346 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 357 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 366 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
#line 385 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 504 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 505 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
   bool skip_vt_switch ;
};
#line 762 "include/linux/fb.h"
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 76 "include/linux/file.h"
struct mfd_cell;
#line 77 "include/linux/file.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 69 "include/linux/io.h"
struct hotplug_slot;
#line 69 "include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 109 "include/linux/pci.h"
typedef int pci_power_t;
#line 136 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 137
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 162 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 185 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 242
struct pcie_link_state;
#line 243
struct pci_vpd;
#line 244
struct pci_sriov;
#line 245
struct pci_ats;
#line 246
struct pci_driver;
#line 246 "include/linux/pci.h"
union __anonunion_ldv_30516_200 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 246 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_30516_200 ldv_30516 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 436
struct pci_ops;
#line 436
struct msi_chip;
#line 436 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 553 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 574 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 588 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 598 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 631 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1153 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1831 "include/linux/pci.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 1836 "include/linux/pci.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 44 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 58
struct agp_bridge_data;
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "./include/uapi/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 75 "./include/uapi/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 110 "./include/uapi/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
#line 173
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5
} ;
#line 182
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
#line 323 "./include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
};
#line 485 "./include/uapi/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 514 "./include/uapi/drm/drm_mode.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 808 "./include/uapi/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 90 "./include/uapi/drm/drm_sarea.h"
struct drm_mm;
#line 90 "./include/uapi/drm/drm_sarea.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long color ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
#line 75 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_color ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned long scan_hit_end ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
   void (*color_adjust)(struct drm_mm_node * , unsigned long  , unsigned long * ,
                        unsigned long * ) ;
};
#line 39 "include/drm/drm_vma_manager.h"
struct drm_vma_offset_node {
   rwlock_t vm_lock ;
   struct drm_mm_node vm_node ;
   struct rb_node vm_rb ;
   struct rb_root vm_files ;
};
#line 46 "include/drm/drm_vma_manager.h"
struct drm_vma_offset_manager {
   rwlock_t vm_lock ;
   struct rb_root vm_addr_space_rb ;
   struct drm_mm vm_addr_space_mm ;
};
#line 46 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 264 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
#line 268 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
   char const   *name ;
};
#line 316 "include/drm/drmP.h"
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   int list ;
   int dev_priv_size ;
   void *dev_private ;
};
#line 348 "include/drm/drmP.h"
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
#line 360 "include/drm/drmP.h"
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
#line 366 "include/drm/drmP.h"
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
#line 380 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
#line 390 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 396
struct drm_minor;
#line 396
struct drm_master;
#line 396 "include/drm/drmP.h"
struct drm_file {
   unsigned char always_authenticated : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char is_master : 1 ;
   unsigned char stereo_allowed : 1 ;
   unsigned char universal_planes : 1 ;
   struct pid *pid ;
   kuid_t uid ;
   drm_magic_t magic ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   struct drm_master *master ;
   struct list_head fbs ;
   struct mutex fbs_lock ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 460 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 482 "include/drm/drmP.h"
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   int flags ;
};
#line 507 "include/drm/drmP.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 525 "include/drm/drmP.h"
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
#line 536 "include/drm/drmP.h"
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 541 "include/drm/drmP.h"
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
#line 596
struct dma_buf;
#line 596
struct dma_buf_attachment;
#line 596 "include/drm/drmP.h"
struct drm_gem_object {
   struct kref refcount ;
   unsigned int handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_vma_offset_node vma_node ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   struct dma_buf *dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 54 "include/linux/hdmi.h"
enum hdmi_picture_aspect {
    HDMI_PICTURE_ASPECT_NONE = 0,
    HDMI_PICTURE_ASPECT_4_3 = 1,
    HDMI_PICTURE_ASPECT_16_9 = 2
} ;
#line 287 "include/linux/hdmi.h"
struct ww_class {
   atomic_long_t stamp ;
   struct lock_class_key acquire_key ;
   struct lock_class_key mutex_key ;
   char const   *acquire_name ;
   char const   *mutex_name ;
};
#line 26 "include/linux/ww_mutex.h"
struct ww_mutex;
#line 26 "include/linux/ww_mutex.h"
struct ww_acquire_ctx {
   struct task_struct *task ;
   unsigned long stamp ;
   unsigned int acquired ;
   unsigned int done_acquire ;
   struct ww_class *ww_class ;
   struct ww_mutex *contending_lock ;
   struct lockdep_map dep_map ;
   unsigned int deadlock_inject_interval ;
   unsigned int deadlock_inject_countdown ;
};
#line 43 "include/linux/ww_mutex.h"
struct ww_mutex {
   struct mutex base ;
   struct ww_acquire_ctx *ctx ;
   struct ww_class *ww_class ;
};
#line 377
struct drm_modeset_lock;
#line 378 "include/linux/ww_mutex.h"
struct drm_modeset_acquire_ctx {
   struct ww_acquire_ctx ww_ctx ;
   struct drm_modeset_lock *contended ;
   struct list_head locked ;
};
#line 57 "include/drm/drm_modeset_lock.h"
struct drm_modeset_lock {
   struct ww_mutex mutex ;
   struct list_head head ;
};
#line 124
struct drm_mode_set;
#line 125
struct drm_object_properties;
#line 126 "include/drm/drm_modeset_lock.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
#line 61 "include/drm/drm_crtc.h"
struct drm_object_properties {
   int count ;
   uint32_t ids[24U] ;
   uint64_t values[24U] ;
};
#line 77
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 84
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_NO_STEREO = 35,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 126 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int crtc_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
   enum hdmi_picture_aspect picture_aspect_ratio ;
};
#line 148 "include/drm/drm_modes.h"
struct drm_cmdline_mode {
   bool specified ;
   bool refresh_specified ;
   bool bpp_specified ;
   int xres ;
   int yres ;
   int bpp ;
   int refresh ;
   bool rb ;
   bool interlace ;
   bool cvt ;
   bool margins ;
   enum drm_connector_force force ;
};
#line 235
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 241
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 250 "include/drm/drm_modes.h"
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 edid_hdmi_dc_modes ;
   u8 cea_rev ;
};
#line 129 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
#line 150 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 186 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
#line 199 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct drm_device *dev ;
   struct list_head enum_blob_list ;
};
#line 215
struct drm_pending_vblank_event;
#line 216
struct drm_plane;
#line 217
struct drm_bridge;
#line 218 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_set2)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                      uint32_t  , int32_t  , int32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ,
                    uint32_t  ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
};
#line 285 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_modeset_lock mutex ;
   struct drm_mode_object base ;
   struct drm_plane *primary ;
   struct drm_plane *cursor ;
   struct drm_framebuffer *old_fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   bool invert_dimensions ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   int framedur_ns ;
   int linedur_ns ;
   int pixeldur_ns ;
   void *helper_private ;
   struct drm_object_properties properties ;
};
#line 365 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
#line 403 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
#line 415 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   char *name ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_bridge *bridge ;
   struct drm_encoder_funcs  const  *funcs ;
   void *helper_private ;
};
#line 450 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device *kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   char *name ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   bool stereo_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
   unsigned int bad_edid_counter ;
};
#line 549 "include/drm/drm_crtc.h"
struct drm_plane_funcs {
   int (*update_plane)(struct drm_plane * , struct drm_crtc * , struct drm_framebuffer * ,
                       int  , int  , unsigned int  , unsigned int  , uint32_t  , uint32_t  ,
                       uint32_t  , uint32_t  ) ;
   int (*disable_plane)(struct drm_plane * ) ;
   void (*destroy)(struct drm_plane * ) ;
   int (*set_property)(struct drm_plane * , struct drm_property * , uint64_t  ) ;
};
#line 569
enum drm_plane_type {
    DRM_PLANE_TYPE_OVERLAY = 0,
    DRM_PLANE_TYPE_PRIMARY = 1,
    DRM_PLANE_TYPE_CURSOR = 2
} ;
#line 575 "include/drm/drm_crtc.h"
struct drm_plane {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t possible_crtcs ;
   uint32_t *format_types ;
   uint32_t format_count ;
   struct drm_crtc *crtc ;
   struct drm_framebuffer *fb ;
   struct drm_plane_funcs  const  *funcs ;
   struct drm_object_properties properties ;
   enum drm_plane_type type ;
};
#line 610 "include/drm/drm_crtc.h"
struct drm_bridge_funcs {
   bool (*mode_fixup)(struct drm_bridge * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   void (*disable)(struct drm_bridge * ) ;
   void (*post_disable)(struct drm_bridge * ) ;
   void (*mode_set)(struct drm_bridge * , struct drm_display_mode * , struct drm_display_mode * ) ;
   void (*pre_enable)(struct drm_bridge * ) ;
   void (*enable)(struct drm_bridge * ) ;
   void (*destroy)(struct drm_bridge * ) ;
};
#line 634 "include/drm/drm_crtc.h"
struct drm_bridge {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_bridge_funcs  const  *funcs ;
   void *driver_private ;
};
#line 652 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 680 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
#line 695 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t num_bridges ;
   uint32_t *id_list ;
};
#line 718 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct drm_modeset_lock connection_mutex ;
   struct drm_modeset_acquire_ctx *acquire_ctx ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   struct mutex fb_lock ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_bridge ;
   struct list_head bridge_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_overlay_plane ;
   int num_total_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   bool poll_running ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *plane_type_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
   bool async_page_flip ;
   uint32_t cursor_width ;
   uint32_t cursor_height ;
};
#line 1153 "include/drm/drm_crtc.h"
struct drm_master {
   struct kref refcount ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 710 "include/drm/drmP.h"
struct drm_bus {
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
};
#line 729 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , unsigned int  , int * ,
                               int * , ktime_t * , ktime_t * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   int (*gem_prime_pin)(struct drm_gem_object * ) ;
   void (*gem_prime_unpin)(struct drm_gem_object * ) ;
   struct sg_table *(*gem_prime_get_sg_table)(struct drm_gem_object * ) ;
   struct drm_gem_object *(*gem_prime_import_sg_table)(struct drm_device * , size_t  ,
                                                       struct sg_table * ) ;
   void *(*gem_prime_vmap)(struct drm_gem_object * ) ;
   void (*gem_prime_vunmap)(struct drm_gem_object * , void * ) ;
   int (*gem_prime_mmap)(struct drm_gem_object * , struct vm_area_struct * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc  const  *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   struct drm_bus *bus ;
   struct list_head legacy_dev_list ;
};
#line 997 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   struct device *kdev ;
   struct drm_device *dev ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct drm_mode_group mode_group ;
};
#line 1016 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 1023 "include/drm/drmP.h"
struct drm_vblank_crtc {
   struct drm_device *dev ;
   wait_queue_head_t queue ;
   struct timeval time[2U] ;
   struct timer_list disable_timer ;
   atomic_t count ;
   atomic_t refcount ;
   u32 last ;
   u32 last_wait ;
   unsigned int inmodeset ;
   int crtc ;
   bool enabled ;
};
#line 1038
struct usb_device;
#line 1038 "include/drm/drmP.h"
struct drm_device {
   struct list_head legacy_dev_list ;
   int if_version ;
   struct kref ref ;
   struct device *dev ;
   struct drm_driver *driver ;
   void *dev_private ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_minor *render ;
   atomic_t unplugged ;
   struct inode *anon_inode ;
   char *unique ;
   struct mutex struct_mutex ;
   struct mutex master_mutex ;
   int open_count ;
   spinlock_t buf_lock ;
   int buf_use ;
   atomic_t buf_alloc ;
   struct list_head filelist ;
   struct list_head maplist ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   struct drm_device_dma *dma ;
   bool irq_enabled ;
   int irq ;
   long volatile   context_flag ;
   int last_context ;
   bool vblank_disable_allowed ;
   struct drm_vblank_crtc *vblank ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   struct drm_agp_head *agp ;
   struct pci_dev *pdev ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_mode_config mode_config ;
   struct mutex object_name_lock ;
   struct idr object_name_idr ;
   struct drm_vma_offset_manager *vma_offset_manager ;
   int switch_power_state ;
};
#line 1663 "include/drm/drmP.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
#line 54 "include/linux/i2c-algo-bit.h"
enum mode_set_atomic {
    LEAVE_ATOMIC_MODE_SET = 0,
    ENTER_ATOMIC_MODE_SET = 1
} ;
#line 59 "include/linux/i2c-algo-bit.h"
struct drm_crtc_helper_funcs {
   void (*dpms)(struct drm_crtc * , int  ) ;
   void (*prepare)(struct drm_crtc * ) ;
   void (*commit)(struct drm_crtc * ) ;
   bool (*mode_fixup)(struct drm_crtc * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   int (*mode_set)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ,
                   int  , int  , struct drm_framebuffer * ) ;
   int (*mode_set_base)(struct drm_crtc * , int  , int  , struct drm_framebuffer * ) ;
   int (*mode_set_base_atomic)(struct drm_crtc * , struct drm_framebuffer * , int  ,
                               int  , enum mode_set_atomic  ) ;
   void (*load_lut)(struct drm_crtc * ) ;
   void (*disable)(struct drm_crtc * ) ;
};
#line 272 "include/linux/pm_runtime.h"
struct gma_clock_t {
   int n ;
   int m1 ;
   int m2 ;
   int p1 ;
   int p2 ;
   int dot ;
   int vco ;
   int m ;
   int p ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_range_t {
   int min ;
   int max ;
};
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_p2_t {
   int dot_limit ;
   int p2_slow ;
   int p2_fast ;
};
#line 47 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_limit_t {
   struct gma_range_t dot ;
   struct gma_range_t vco ;
   struct gma_range_t n ;
   struct gma_range_t m ;
   struct gma_range_t m1 ;
   struct gma_range_t m2 ;
   struct gma_range_t p ;
   struct gma_range_t p1 ;
   struct gma_p2_t p2 ;
   bool (*find_pll)(struct gma_limit_t  const  * , struct drm_crtc * , int  , int  ,
                    struct gma_clock_t * ) ;
};
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gma_display.h"
struct gma_clock_funcs {
   void (*clock)(int  , struct gma_clock_t * ) ;
   struct gma_limit_t  const  *(*limit)(struct drm_crtc * , int  ) ;
   bool (*pll_is_valid)(struct drm_crtc * , struct gma_limit_t  const  * , struct gma_clock_t * ) ;
};
#line 86 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_mode_device {
   size_t (*bo_offset)(struct drm_device * , void * ) ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *panel_fixed_mode2 ;
   struct drm_display_mode *vbt_mode ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 110 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_i2c_chan {
   struct drm_device *drm_dev ;
   u32 reg ;
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   u8 slave_addr ;
};
#line 164
struct gtt_range;
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct child_device_config {
   u16 handle ;
   u16 device_type ;
   u8 device_id[10U] ;
   u16 addin_offset ;
   u8 dvo_port ;
   u8 i2c_pin ;
   u8 slave_addr ;
   u8 ddc_pin ;
   u16 edid_ptr ;
   u8 dvo_cfg ;
   u8 dvo2_port ;
   u8 i2c2_pin ;
   u8 slave2_addr ;
   u8 ddc2_pin ;
   u8 capabilities ;
   u8 dvo_wiring ;
   u8 dvo2_wiring ;
   u16 extended_type ;
   u8 dvo_function ;
};
#line 260 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_backlight {
   unsigned char type : 2 ;
   unsigned char pol : 1 ;
   unsigned char gpio : 3 ;
   unsigned char gmbus : 2 ;
   u16 freq ;
   u8 minbrightness ;
   u8 i2caddr ;
   u8 brightnesscmd ;
};
#line 440 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct edp_power_seq {
   u16 t1_t3 ;
   u16 t8 ;
   u16 t9 ;
   u16 t10 ;
   u16 t11_t12 ;
};
#line 482 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct psb_gtt {
   uint32_t gatt_start ;
   uint32_t mmu_gatt_start ;
   uint32_t gtt_start ;
   uint32_t gtt_phys_start ;
   unsigned int gtt_pages ;
   unsigned int gatt_pages ;
   unsigned long stolen_size ;
   unsigned long vram_stolen_size ;
   struct rw_semaphore sem ;
};
#line 41 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gtt.h"
struct gtt_range {
   struct resource resource ;
   u32 offset ;
   struct drm_gem_object gem ;
   int in_gart ;
   bool stolen ;
   bool mmapping ;
   struct page **pages ;
   int npage ;
   int roll ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/opregion.h"
struct oaktrail_timing_info {
   u16 pixel_clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_offset_hi : 2 ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   unsigned char height_mm_hi : 4 ;
   unsigned char width_mm_hi : 4 ;
   u8 hborder ;
   u8 vborder ;
   unsigned char unknown0 : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char vsync_positive : 1 ;
   unsigned char separate_sync : 2 ;
   unsigned char stereo : 1 ;
   unsigned char unknown6 : 1 ;
   unsigned char interlaced : 1 ;
};
#line 199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_gct_data {
   u8 bpi ;
   u8 pt ;
   struct oaktrail_timing_info DTD ;
   u32 Panel_Port_Control ;
   u32 PP_On_Sequencing ;
   u32 PP_Off_Sequencing ;
   u32 PP_Cycle_Delay ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 211
struct hdmi_i2c_dev;
#line 211 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_hdmi_dev {
   struct pci_dev *dev ;
   void *regs ;
   unsigned int mmio ;
   unsigned int mmio_len ;
   int dpms_mode ;
   struct hdmi_i2c_dev *i2c_dev ;
   u32 saveDPLL_CTRL ;
   u32 saveDPLL_DIV_CTRL ;
   u32 saveDPLL_ADJUST ;
   u32 saveDPLL_UPDATE ;
   u32 saveDPLL_CLK_ENABLE ;
   u32 savePCH_HTOTAL_B ;
   u32 savePCH_HBLANK_B ;
   u32 savePCH_HSYNC_B ;
   u32 savePCH_VTOTAL_B ;
   u32 savePCH_VBLANK_B ;
   u32 savePCH_VSYNC_B ;
   u32 savePCH_PIPEBCONF ;
   u32 savePCH_PIPEBSRC ;
};
#line 256
struct psb_mmu_pd;
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct psb_mmu_driver {
   struct rw_semaphore sem ;
   spinlock_t lock ;
   atomic_t needs_tlbflush ;
   atomic_t *msvdx_mmu_invaldc ;
   struct psb_mmu_pd *default_pd ;
   uint32_t bif_ctrl ;
   int has_clflush ;
   int clflush_add ;
   unsigned long clflush_mask ;
   struct drm_device *dev ;
};
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pt {
   struct psb_mmu_pd *pd ;
   uint32_t index ;
   uint32_t count ;
   struct page *p ;
   uint32_t *v ;
};
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pd {
   struct psb_mmu_driver *driver ;
   int hw_context ;
   struct psb_mmu_pt **tables ;
   struct page *p ;
   struct page *dummy_pt ;
   struct page *dummy_page ;
   uint32_t pd_mask ;
   uint32_t invalid_pde ;
   uint32_t invalid_pte ;
};
#line 96
struct opregion_header;
#line 97
struct opregion_acpi;
#line 98
struct opregion_swsci;
#line 99
struct opregion_asle;
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_intel_opregion {
   struct opregion_header *header ;
   struct opregion_acpi *acpi ;
   struct opregion_swsci *swsci ;
   struct opregion_asle *asle ;
   void *vbt ;
   u32 *lid_state ;
   struct work_struct asle_work ;
};
#line 258 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct sdvo_device_mapping {
   u8 initialized ;
   u8 dvo_port ;
   u8 slave_addr ;
   u8 dvo_wiring ;
   u8 i2c_pin ;
   u8 i2c_speed ;
   u8 ddc_pin ;
};
#line 268 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct intel_gmbus {
   struct i2c_adapter adapter ;
   struct i2c_adapter *force_bit ;
   u32 reg0 ;
};
#line 274 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_offset {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 surf ;
   u32 addr ;
   u32 base ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette ;
};
#line 301 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_pipe {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 base ;
   u32 surf ;
   u32 addr ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette[256U] ;
};
#line 335 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_state {
   uint32_t saveVCLK_DIVISOR_VGA0 ;
   uint32_t saveVCLK_DIVISOR_VGA1 ;
   uint32_t saveVCLK_POST_DIV ;
   uint32_t saveVGACNTRL ;
   uint32_t saveADPA ;
   uint32_t saveLVDS ;
   uint32_t saveDVOA ;
   uint32_t saveDVOB ;
   uint32_t saveDVOC ;
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t saveCLOCKGATING ;
   uint32_t saveDSPARB ;
   uint32_t savePFIT_AUTO_RATIOS ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_DIVISOR ;
   uint32_t saveBCLRPAT_A ;
   uint32_t saveBCLRPAT_B ;
   uint32_t savePERF_MODE ;
   uint32_t saveDSPFW1 ;
   uint32_t saveDSPFW2 ;
   uint32_t saveDSPFW3 ;
   uint32_t saveDSPFW4 ;
   uint32_t saveDSPFW5 ;
   uint32_t saveDSPFW6 ;
   uint32_t saveCHICKENBIT ;
   uint32_t saveDSPACURSOR_CTRL ;
   uint32_t saveDSPBCURSOR_CTRL ;
   uint32_t saveDSPACURSOR_BASE ;
   uint32_t saveDSPBCURSOR_BASE ;
   uint32_t saveDSPACURSOR_POS ;
   uint32_t saveDSPBCURSOR_POS ;
   uint32_t saveOV_OVADD ;
   uint32_t saveOV_OGAMC0 ;
   uint32_t saveOV_OGAMC1 ;
   uint32_t saveOV_OGAMC2 ;
   uint32_t saveOV_OGAMC3 ;
   uint32_t saveOV_OGAMC4 ;
   uint32_t saveOV_OGAMC5 ;
   uint32_t saveOVC_OVADD ;
   uint32_t saveOVC_OGAMC0 ;
   uint32_t saveOVC_OGAMC1 ;
   uint32_t saveOVC_OGAMC2 ;
   uint32_t saveOVC_OGAMC3 ;
   uint32_t saveOVC_OGAMC4 ;
   uint32_t saveOVC_OGAMC5 ;
   uint32_t saveHISTOGRAM_INT_CONTROL_REG ;
   uint32_t saveHISTOGRAM_LOGIC_CONTROL_REG ;
   uint32_t savePWM_CONTROL_LOGIC ;
};
#line 394 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct medfield_state {
   uint32_t saveMIPI ;
   uint32_t saveMIPI_C ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveHDMIPHYMISCCTL ;
   uint32_t saveHDMIB_CONTROL ;
};
#line 404 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct cdv_state {
   uint32_t saveDSPCLK_GATE_D ;
   uint32_t saveRAMCLK_GATE_D ;
   uint32_t saveDSPARB ;
   uint32_t saveDSPFW[6U] ;
   uint32_t saveADPA ;
   uint32_t savePP_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveLVDS ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_CYCLE ;
   uint32_t saveVGACNTRL ;
   uint32_t saveIER ;
   uint32_t saveIMR ;
   u8 saveLBB ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
union __anonunion_ldv_40416_211 {
   struct psb_state psb ;
   struct medfield_state mdfld ;
   struct cdv_state cdv ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_save_area {
   struct psb_pipe pipe[3U] ;
   uint32_t saveBSM ;
   uint32_t saveVBT ;
   union __anonunion_ldv_40416_211 ldv_40416 ;
   uint32_t saveBLC_PWM_CTL2 ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 436
struct psb_ops;
#line 437
struct psb_gtt_mm;
#line 437 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct __anonstruct_edp_212 {
   int rate ;
   int lanes ;
   int preemphasis ;
   int vswing ;
   bool initialized ;
   bool support ;
   int bpp ;
   struct edp_power_seq pps ;
};
#line 437 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_psb_private {
   struct drm_device *dev ;
   struct pci_dev *aux_pdev ;
   struct psb_ops  const  *ops ;
   struct psb_offset  const  *regmap ;
   struct child_device_config *child_dev ;
   int child_dev_num ;
   struct psb_gtt gtt ;
   struct psb_gtt_mm *gtt_mm ;
   struct page *scratch_page ;
   u32 *gtt_map ;
   uint32_t stolen_base ;
   u8 *vram_addr ;
   unsigned long vram_stolen_size ;
   int gtt_initialized ;
   u16 gmch_ctrl ;
   u32 pge_ctl ;
   struct mutex gtt_mutex ;
   struct resource *gtt_mem ;
   struct psb_mmu_driver *mmu ;
   struct psb_mmu_pd *pf_pd ;
   uint8_t *sgx_reg ;
   uint8_t *vdc_reg ;
   uint8_t *aux_reg ;
   uint32_t gatt_free_offset ;
   uint32_t vdc_irq_mask ;
   uint32_t pipestat[3U] ;
   spinlock_t irqmask_lock ;
   bool suspended ;
   bool display_power ;
   int display_count ;
   struct psb_intel_mode_device mode_dev ;
   bool modeset ;
   struct drm_crtc *plane_to_crtc_mapping[3U] ;
   struct drm_crtc *pipe_to_crtc_mapping[3U] ;
   uint32_t num_pipe ;
   uint32_t ospm_base ;
   u32 fuse_reg_value ;
   u32 video_device_fuse ;
   uint8_t platform_rev_id ;
   struct intel_gmbus *gmbus ;
   uint8_t *gmbus_reg ;
   int crt_ddc_pin ;
   struct sdvo_device_mapping sdvo_mappings[2U] ;
   u32 hotplug_supported_mask ;
   struct drm_property *broadcast_rgb_property ;
   struct drm_property *force_audio_property ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *lfp_lvds_vbt_mode ;
   struct drm_display_mode *sdvo_lvds_vbt_mode ;
   struct bdb_lvds_backlight *lvds_bl ;
   struct psb_intel_i2c_chan *lvds_i2c_bus ;
   unsigned char int_tv_support : 1 ;
   unsigned char lvds_dither : 1 ;
   unsigned char lvds_vbt : 1 ;
   unsigned char int_crt_support : 1 ;
   unsigned char lvds_use_ssc : 1 ;
   int lvds_ssc_freq ;
   bool is_lvds_on ;
   bool is_mipi_on ;
   u32 mipi_ctrl_display ;
   unsigned int core_freq ;
   uint32_t iLVDS_enable ;
   int rpm_enabled ;
   bool has_gct ;
   struct oaktrail_gct_data gct_data ;
   struct oaktrail_hdmi_dev *hdmi_priv ;
   struct psb_save_area regs ;
   uint32_t msi_addr ;
   uint32_t msi_data ;
   struct work_struct hotplug_work ;
   spinlock_t lid_lock ;
   struct timer_list lid_timer ;
   struct psb_intel_opregion opregion ;
   u32 lid_last_state ;
   uint32_t apm_reg ;
   uint16_t apm_base ;
   struct backlight_device *backlight_device ;
   struct drm_property *backlight_property ;
   bool backlight_enabled ;
   int backlight_level ;
   uint32_t blc_adj1 ;
   uint32_t blc_adj2 ;
   void *fbdev ;
   spinlock_t lock_2d ;
   int brightness ;
   int brightness_adjusted ;
   bool dsr_enable ;
   u32 dsr_fb_update ;
   bool dpi_panel_on[3U] ;
   void *dsi_configs[2U] ;
   u32 bpp ;
   u32 bpp2 ;
   u32 pipeconf[3U] ;
   u32 dspcntr[3U] ;
   int mdfld_panel_id ;
   bool dplla_96mhz ;
   struct __anonstruct_edp_212 edp ;
   uint8_t panel_type ;
};
#line 618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_ops {
   char const   *name ;
   unsigned char accel_2d : 1 ;
   int pipes ;
   int crtcs ;
   int sgx_offset ;
   int hdmi_mask ;
   int lvds_mask ;
   int sdvo_mask ;
   int cursor_needs_phys ;
   struct drm_crtc_helper_funcs  const  *crtc_helper ;
   struct drm_crtc_funcs  const  *crtc_funcs ;
   struct gma_clock_funcs  const  *clock_funcs ;
   int (*chip_setup)(struct drm_device * ) ;
   void (*chip_teardown)(struct drm_device * ) ;
   void (*errata)(struct drm_device * ) ;
   int (*output_init)(struct drm_device * ) ;
   int (*hotplug)(struct drm_device * ) ;
   void (*hotplug_enable)(struct drm_device * , bool  ) ;
   void (*init_pm)(struct drm_device * ) ;
   int (*save_regs)(struct drm_device * ) ;
   int (*restore_regs)(struct drm_device * ) ;
   int (*power_up)(struct drm_device * ) ;
   int (*power_down)(struct drm_device * ) ;
   void (*update_wm)(struct drm_device * , struct drm_crtc * ) ;
   void (*disable_sr)(struct drm_device * ) ;
   void (*lvds_bl_power)(struct drm_device * , bool  ) ;
   int i2c_bus ;
};
#line 894
struct drm_fb_helper;
#line 895 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_fb_helper_crtc {
   struct drm_mode_set mode_set ;
   struct drm_display_mode *desired_mode ;
};
#line 41 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_surface_size {
   u32 fb_width ;
   u32 fb_height ;
   u32 surface_width ;
   u32 surface_height ;
   u32 surface_bpp ;
   u32 surface_depth ;
};
#line 50 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_funcs {
   void (*gamma_set)(struct drm_crtc * , u16  , u16  , u16  , int  ) ;
   void (*gamma_get)(struct drm_crtc * , u16 * , u16 * , u16 * , int  ) ;
   int (*fb_probe)(struct drm_fb_helper * , struct drm_fb_helper_surface_size * ) ;
   bool (*initial_config)(struct drm_fb_helper * , struct drm_fb_helper_crtc ** ,
                          struct drm_display_mode ** , bool * , int  , int  ) ;
};
#line 74 "include/drm/drm_fb_helper.h"
struct drm_fb_helper_connector {
   struct drm_connector *connector ;
   struct drm_cmdline_mode cmdline_mode ;
};
#line 82 "include/drm/drm_fb_helper.h"
struct drm_fb_helper {
   struct drm_framebuffer *fb ;
   struct drm_device *dev ;
   int crtc_count ;
   struct drm_fb_helper_crtc *crtc_info ;
   int connector_count ;
   struct drm_fb_helper_connector **connector_info ;
   struct drm_fb_helper_funcs *funcs ;
   struct fb_info *fbdev ;
   u32 pseudo_palette[17U] ;
   struct list_head kernel_fb_list ;
   bool delayed_hotplug ;
};
#line 129 "include/drm/drm_fb_helper.h"
struct psb_framebuffer {
   struct drm_framebuffer base ;
   struct address_space *addr_space ;
   struct fb_info *fbdev ;
   struct gtt_range *gtt ;
};
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/framebuffer.h"
struct psb_fbdev {
   struct drm_fb_helper psb_fb_helper ;
   struct psb_framebuffer pfb ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 705 "./arch/x86/include/asm/paravirt_types.h"
struct cpuinfo_x86;
#line 219 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 76 "./arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[11U] ;
   char x86_vendor_id[16U] ;
   char x86_model_id[64U] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_encoder {
   struct drm_encoder base ;
   int type ;
   bool needs_tv_clock ;
   void (*hot_plug)(struct gma_encoder * ) ;
   int crtc_mask ;
   int clone_mask ;
   u32 ddi_select ;
   void *dev_priv ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
#line 139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_connector {
   struct drm_connector base ;
   struct gma_encoder *encoder ;
};
#line 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_crtc_state {
   uint32_t saveDSPCNTR ;
   uint32_t savePIPECONF ;
   uint32_t savePIPESRC ;
   uint32_t saveDPLL ;
   uint32_t saveFP0 ;
   uint32_t saveFP1 ;
   uint32_t saveHTOTAL ;
   uint32_t saveHBLANK ;
   uint32_t saveHSYNC ;
   uint32_t saveVTOTAL ;
   uint32_t saveVBLANK ;
   uint32_t saveVSYNC ;
   uint32_t saveDSPSTRIDE ;
   uint32_t saveDSPSIZE ;
   uint32_t saveDSPPOS ;
   uint32_t saveDSPBASE ;
   uint32_t savePalette[256U] ;
};
#line 164
struct psb_intel_framebuffer;
#line 164 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct gma_crtc {
   struct drm_crtc base ;
   int pipe ;
   int plane ;
   uint32_t cursor_addr ;
   struct gtt_range *cursor_gt ;
   u8 lut_r[256U] ;
   u8 lut_g[256U] ;
   u8 lut_b[256U] ;
   u8 lut_adj[256U] ;
   struct psb_intel_framebuffer *fbdev_fb ;
   struct drm_mode_set mode_set ;
   struct drm_gem_object *cursor_obj ;
   struct drm_display_mode saved_mode ;
   struct drm_display_mode saved_adjusted_mode ;
   struct psb_intel_mode_device *mode_dev ;
   u32 mode_flags ;
   bool active ;
   struct psb_intel_crtc_state *crtc_state ;
   struct gma_clock_funcs  const  *clock_funcs ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 32 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state;
#line 1663 "include/drm/drmP.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 112 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 120 "include/linux/swap.h"
struct swap_extent {
   struct list_head list ;
   unsigned long start_page ;
   unsigned long nr_pages ;
   sector_t start_block ;
};
#line 156 "include/linux/swap.h"
struct swap_cluster_info {
   unsigned int data : 24 ;
   unsigned char flags ;
};
#line 198 "include/linux/swap.h"
struct percpu_cluster {
   struct swap_cluster_info index ;
   unsigned int next ;
};
#line 210 "include/linux/swap.h"
struct swap_info_struct {
   unsigned long flags ;
   short prio ;
   struct plist_node list ;
   struct plist_node avail_list ;
   signed char type ;
   unsigned int max ;
   unsigned char *swap_map ;
   struct swap_cluster_info *cluster_info ;
   struct swap_cluster_info free_cluster_head ;
   struct swap_cluster_info free_cluster_tail ;
   unsigned int lowest_bit ;
   unsigned int highest_bit ;
   unsigned int pages ;
   unsigned int inuse_pages ;
   unsigned int cluster_next ;
   unsigned int cluster_nr ;
   struct percpu_cluster *percpu_cluster ;
   struct swap_extent *curr_swap_extent ;
   struct swap_extent first_swap_extent ;
   struct block_device *bdev ;
   struct file *swap_file ;
   unsigned int old_block_size ;
   unsigned long *frontswap_map ;
   atomic_t frontswap_pages ;
   spinlock_t lock ;
   struct work_struct discard_work ;
   struct swap_cluster_info discard_cluster_head ;
   struct swap_cluster_info discard_cluster_tail ;
};
#line 475 "include/linux/swap.h"
union __anonunion_v_208 {
   short preferred_node ;
   nodemask_t nodes ;
};
#line 475 "include/linux/swap.h"
union __anonunion_w_209 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
#line 475 "include/linux/swap.h"
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_208 v ;
   union __anonunion_w_209 w ;
};
#line 197 "include/linux/mempolicy.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 611 "include/drm/drm_dp_helper.h"
struct vbt_header {
   u8 signature[20U] ;
   u16 version ;
   u16 header_size ;
   u16 vbt_size ;
   u8 vbt_checksum ;
   u8 reserved0 ;
   u32 bdb_offset ;
   u32 aim_offset[4U] ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_header {
   u8 signature[16U] ;
   u16 version ;
   u16 header_size ;
   u16 bdb_size ;
};
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_general_features {
   unsigned char panel_fitting : 2 ;
   unsigned char flexaim : 1 ;
   unsigned char msg_enable : 1 ;
   unsigned char clear_screen : 3 ;
   unsigned char color_flip : 1 ;
   unsigned char download_ext_vbt : 1 ;
   unsigned char enable_ssc : 1 ;
   unsigned char ssc_freq : 1 ;
   unsigned char enable_lfp_on_override : 1 ;
   unsigned char disable_ssc_ddt : 1 ;
   unsigned char rsvd8 : 3 ;
   unsigned char disable_smooth_vision : 1 ;
   unsigned char single_dvi : 1 ;
   unsigned char rsvd9 : 6 ;
   u8 legacy_monitor_detect ;
   unsigned char int_crt_support : 1 ;
   unsigned char int_tv_support : 1 ;
   unsigned char int_efp_support : 1 ;
   unsigned char dp_ssc_enb : 1 ;
   unsigned char dp_ssc_freq : 1 ;
   unsigned char rsvd11 : 3 ;
};
#line 217 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_general_definitions {
   u8 crt_ddc_gmbus_pin ;
   unsigned char dpms_acpi : 1 ;
   unsigned char skip_boot_crt_detect : 1 ;
   unsigned char dpms_aim : 1 ;
   unsigned char rsvd1 : 5 ;
   u8 boot_display[2U] ;
   u8 child_dev_size ;
   struct child_device_config devices[0U] ;
};
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_options {
   u8 panel_type ;
   u8 rsvd1 ;
   unsigned char pfit_mode : 2 ;
   unsigned char pfit_text_mode_enhanced : 1 ;
   unsigned char pfit_gfx_mode_enhanced : 1 ;
   unsigned char pfit_ratio_auto : 1 ;
   unsigned char pixel_dither : 1 ;
   unsigned char lvds_edid : 1 ;
   unsigned char rsvd2 : 1 ;
   u8 rsvd4 ;
};
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_fp_timing {
   u16 x_res ;
   u16 y_res ;
   u32 lvds_reg ;
   u32 lvds_reg_val ;
   u32 pp_on_reg ;
   u32 pp_on_reg_val ;
   u32 pp_off_reg ;
   u32 pp_off_reg_val ;
   u32 pp_cycle_reg ;
   u32 pp_cycle_reg_val ;
   u32 pfit_reg ;
   u32 pfit_reg_val ;
   u16 terminator ;
};
#line 304 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_dvo_timing {
   u16 clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_off_lo ;
   u8 hsync_pulse_width ;
   unsigned char vsync_pulse_width : 4 ;
   unsigned char vsync_off : 4 ;
   unsigned char rsvd0 : 6 ;
   unsigned char hsync_off_hi : 2 ;
   u8 h_image ;
   u8 v_image ;
   u8 max_hv ;
   u8 h_border ;
   u8 v_border ;
   unsigned char rsvd1 : 3 ;
   unsigned char digital : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd2 : 1 ;
};
#line 332 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct lvds_pnp_id {
   u16 mfg_name ;
   u16 product_code ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
};
#line 340 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_lfp_data_entry {
   struct lvds_fp_timing fp_timing ;
   struct lvds_dvo_timing dvo_timing ;
   struct lvds_pnp_id pnp_id ;
};
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_lvds_lfp_data {
   struct bdb_lvds_lfp_data_entry data[16U] ;
};
#line 379 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_sdvo_lvds_options {
   u8 panel_backlight ;
   u8 h40_set_panel_type ;
   u8 panel_type ;
   u8 ssc_clk_freq ;
   u16 als_low_trip ;
   u16 als_high_trip ;
   u8 sclalarcoeff_tab_row_num ;
   u8 sclalarcoeff_tab_row_size ;
   u8 coefficient[8U] ;
   u8 panel_misc_bits_1 ;
   u8 panel_misc_bits_2 ;
   u8 panel_misc_bits_3 ;
   u8 panel_misc_bits_4 ;
};
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_driver_features {
   unsigned char boot_dev_algorithm : 1 ;
   unsigned char block_display_switch : 1 ;
   unsigned char allow_display_switch : 1 ;
   unsigned char hotplug_dvo : 1 ;
   unsigned char dual_view_zoom : 1 ;
   unsigned char int15h_hook : 1 ;
   unsigned char sprite_in_clone : 1 ;
   unsigned char primary_lfp_id : 1 ;
   u16 boot_mode_x ;
   u16 boot_mode_y ;
   u8 boot_mode_bpp ;
   u8 boot_mode_refresh ;
   unsigned char enable_lfp_primary : 1 ;
   unsigned char selective_mode_pruning : 1 ;
   unsigned char dual_frequency : 1 ;
   unsigned char render_clock_freq : 1 ;
   unsigned char nt_clone_support : 1 ;
   unsigned char power_scheme_ui : 1 ;
   unsigned char sprite_display_assign : 1 ;
   unsigned char cui_aspect_scaling : 1 ;
   unsigned char preserve_aspect_ratio : 1 ;
   unsigned char sdvo_device_power_down : 1 ;
   unsigned char crt_hotplug : 1 ;
   unsigned char lvds_config : 2 ;
   unsigned char tv_hotplug : 1 ;
   unsigned char hdmi_config : 2 ;
   unsigned char static_display : 1 ;
   unsigned char reserved2 : 7 ;
   u16 legacy_crt_max_x ;
   u16 legacy_crt_max_y ;
   u8 legacy_crt_max_refresh ;
   u8 hdmi_termination ;
   u8 custom_vbt_version ;
};
#line 465 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct edp_link_params {
   unsigned char rate : 4 ;
   unsigned char lanes : 4 ;
   unsigned char preemphasis : 4 ;
   unsigned char vswing : 4 ;
};
#line 472 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
struct bdb_edp {
   struct edp_power_seq power_seqs[16U] ;
   u32 color_depth ;
   u32 sdrrs_msa_timing_delay ;
   struct edp_link_params link_params[16U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
struct intel_gpio {
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   struct drm_psb_private *dev_priv ;
   u32 reg ;
};
#line 43 "./arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
#line 81 "./arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 84 "./arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
#line 391 "./arch/x86/include/asm/pgtable_types.h"
struct tss_struct;
#line 102 "./arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
#line 206 "./arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
#line 253 "./arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long stack[64U] ;
};
#line 75 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 80 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 85 "include/drm/drm_crtc_helper.h"
struct drm_encoder_helper_funcs {
   void (*dpms)(struct drm_encoder * , int  ) ;
   void (*save)(struct drm_encoder * ) ;
   void (*restore)(struct drm_encoder * ) ;
   bool (*mode_fixup)(struct drm_encoder * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   void (*prepare)(struct drm_encoder * ) ;
   void (*commit)(struct drm_encoder * ) ;
   void (*mode_set)(struct drm_encoder * , struct drm_display_mode * , struct drm_display_mode * ) ;
   struct drm_crtc *(*get_crtc)(struct drm_encoder * ) ;
   enum drm_connector_status (*detect)(struct drm_encoder * , struct drm_connector * ) ;
   void (*disable)(struct drm_encoder * ) ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 113 "include/drm/drm_crtc_helper.h"
struct drm_connector_helper_funcs {
   int (*get_modes)(struct drm_connector * ) ;
   enum drm_mode_status (*mode_valid)(struct drm_connector * , struct drm_display_mode * ) ;
   struct drm_encoder *(*best_encoder)(struct drm_connector * ) ;
};
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct psb_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 941 "include/drm/drm_crtc.h"
struct edid;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 1663 "include/drm/drmP.h"
struct est_timings {
   u8 t1 ;
   u8 t2 ;
   u8 mfg_rsvd ;
};
#line 42 "include/drm/drm_edid.h"
struct std_timing {
   u8 hsize ;
   u8 vfreq_aspect ;
};
#line 55 "include/drm/drm_edid.h"
struct detailed_pixel_timing {
   u8 hactive_lo ;
   u8 hblank_lo ;
   u8 hactive_hblank_hi ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   u8 vactive_vblank_hi ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   u8 vsync_offset_pulse_width_lo ;
   u8 hsync_vsync_offset_pulse_width_hi ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   u8 width_height_mm_hi ;
   u8 hborder ;
   u8 vborder ;
   u8 misc ;
};
#line 81 "include/drm/drm_edid.h"
struct detailed_data_string {
   u8 str[13U] ;
};
#line 86 "include/drm/drm_edid.h"
struct __anonstruct_gtf2_206 {
   u8 reserved ;
   u8 hfreq_start_khz ;
   u8 c ;
   __le16 m ;
   u8 k ;
   u8 j ;
};
#line 86 "include/drm/drm_edid.h"
struct __anonstruct_cvt_207 {
   u8 version ;
   u8 data1 ;
   u8 data2 ;
   u8 supported_aspects ;
   u8 flags ;
   u8 supported_scalings ;
   u8 preferred_refresh ;
};
#line 86 "include/drm/drm_edid.h"
union __anonunion_formula_205 {
   struct __anonstruct_gtf2_206 gtf2 ;
   struct __anonstruct_cvt_207 cvt ;
};
#line 86 "include/drm/drm_edid.h"
struct detailed_data_monitor_range {
   u8 min_vfreq ;
   u8 max_vfreq ;
   u8 min_hfreq_khz ;
   u8 max_hfreq_khz ;
   u8 pixel_clock_mhz ;
   u8 flags ;
   union __anonunion_formula_205 formula ;
};
#line 114 "include/drm/drm_edid.h"
struct detailed_data_wpindex {
   u8 white_yx_lo ;
   u8 white_x_hi ;
   u8 white_y_hi ;
   u8 gamma ;
};
#line 128 "include/drm/drm_edid.h"
struct cvt_timing {
   u8 code[3U] ;
};
#line 132 "include/drm/drm_edid.h"
union __anonunion_data_208 {
   struct detailed_data_string str ;
   struct detailed_data_monitor_range range ;
   struct detailed_data_wpindex color ;
   struct std_timing timings[6U] ;
   struct cvt_timing cvt[4U] ;
};
#line 132 "include/drm/drm_edid.h"
struct detailed_non_pixel {
   u8 pad1 ;
   u8 type ;
   u8 pad2 ;
   union __anonunion_data_208 data ;
};
#line 147 "include/drm/drm_edid.h"
union __anonunion_data_209 {
   struct detailed_pixel_timing pixel_data ;
   struct detailed_non_pixel other_data ;
};
#line 147 "include/drm/drm_edid.h"
struct detailed_timing {
   __le16 pixel_clock ;
   union __anonunion_data_209 data ;
};
#line 165 "include/drm/drm_edid.h"
struct edid {
   u8 header[8U] ;
   u8 mfg_id[2U] ;
   u8 prod_code[2U] ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
   u8 version ;
   u8 revision ;
   u8 input ;
   u8 width_cm ;
   u8 height_cm ;
   u8 gamma ;
   u8 features ;
   u8 red_green_lo ;
   u8 black_white_lo ;
   u8 red_x ;
   u8 red_y ;
   u8 green_x ;
   u8 green_y ;
   u8 blue_x ;
   u8 blue_y ;
   u8 white_x ;
   u8 white_y ;
   struct est_timings established_timings ;
   struct std_timing standard_timings[8U] ;
   struct detailed_timing detailed_timings[4U] ;
   u8 extensions ;
   u8 checksum ;
};
#line 894 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct psb_intel_sdvo_caps {
   u8 vendor_id ;
   u8 device_id ;
   u8 device_rev_id ;
   u8 sdvo_version_major ;
   u8 sdvo_version_minor ;
   unsigned char sdvo_inputs_mask : 2 ;
   unsigned char smooth_scaling : 1 ;
   unsigned char sharp_scaling : 1 ;
   unsigned char up_scaling : 1 ;
   unsigned char down_scaling : 1 ;
   unsigned char stall_support : 1 ;
   unsigned char pad : 1 ;
   u16 output_flags ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct __anonstruct_part1_217 {
   u16 clock ;
   u8 h_active ;
   u8 h_blank ;
   u8 h_high ;
   u8 v_active ;
   u8 v_blank ;
   u8 v_high ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct __anonstruct_part2_218 {
   u8 h_sync_off ;
   u8 h_sync_width ;
   u8 v_sync_off_width ;
   u8 sync_off_width_high ;
   u8 dtd_flags ;
   u8 sdvo_flags ;
   u8 v_sync_off_high ;
   u8 reserved ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_dtd {
   struct __anonstruct_part1_217 part1 ;
   struct __anonstruct_part2_218 part2 ;
};
#line 93 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_pixel_clock_range {
   u16 min ;
   u16 max ;
};
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_preferred_input_timing_args {
   u16 clock ;
   u16 width ;
   u16 height ;
   unsigned char interlace : 1 ;
   unsigned char scaled : 1 ;
   unsigned char pad : 6 ;
};
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_get_trained_inputs_response {
   unsigned char input0_trained : 1 ;
   unsigned char input1_trained : 1 ;
   unsigned char pad : 6 ;
};
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_in_out_map {
   u16 in0 ;
   u16 in1 ;
};
#line 218 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_set_target_input_args {
   unsigned char target_1 : 1 ;
   unsigned char pad : 7 ;
};
#line 231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_tv_format {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_23 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_24 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_25 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_29 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_30 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_60 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_59 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_60 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_50 : 1 ;
   unsigned char hdtv_std_smpte_293m_480p_59 : 1 ;
   unsigned char hdtv_std_smpte_170m_480i_59 : 1 ;
   unsigned char hdtv_std_iturbt601_576i_50 : 1 ;
   unsigned char hdtv_std_iturbt601_576p_50 : 1 ;
   unsigned char hdtv_std_eia_7702a_480i_60 : 1 ;
   unsigned char hdtv_std_eia_7702a_480p_60 : 1 ;
   unsigned char pad : 3 ;
};
#line 369 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_sdtv_resolution_request {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char pad : 5 ;
};
#line 579 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_enhancements_reply {
   unsigned char flicker_filter : 1 ;
   unsigned char flicker_filter_adaptive : 1 ;
   unsigned char flicker_filter_2d : 1 ;
   unsigned char saturation : 1 ;
   unsigned char hue : 1 ;
   unsigned char brightness : 1 ;
   unsigned char contrast : 1 ;
   unsigned char overscan_h : 1 ;
   unsigned char overscan_v : 1 ;
   unsigned char hpos : 1 ;
   unsigned char vpos : 1 ;
   unsigned char sharpness : 1 ;
   unsigned char dot_crawl : 1 ;
   unsigned char dither : 1 ;
   unsigned char tv_chroma_filter : 1 ;
   unsigned char tv_luma_filter : 1 ;
};
#line 670 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_sdvo_regs.h"
struct psb_intel_sdvo_encode {
   u8 dvi_rev ;
   u8 hdmi_rev ;
};
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
struct psb_intel_sdvo {
   struct gma_encoder base ;
   struct i2c_adapter *i2c ;
   u8 slave_addr ;
   struct i2c_adapter ddc ;
   int sdvo_reg ;
   uint16_t controlled_output ;
   struct psb_intel_sdvo_caps caps ;
   int pixel_clock_min ;
   int pixel_clock_max ;
   uint16_t attached_output ;
   uint32_t color_range ;
   bool is_tv ;
   int tv_format_index ;
   bool is_hdmi ;
   bool has_hdmi_monitor ;
   bool has_hdmi_audio ;
   bool is_lvds ;
   struct drm_display_mode *sdvo_lvds_fixed_mode ;
   uint8_t ddc_bus ;
   struct psb_intel_sdvo_dtd input_dtd ;
   uint32_t saveSDVO ;
};
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
struct psb_intel_sdvo_connector {
   struct gma_connector base ;
   uint16_t output_flag ;
   int force_audio ;
   u8 tv_format_supported[19U] ;
   int format_supported_num ;
   struct drm_property *tv_format ;
   struct drm_property *left ;
   struct drm_property *right ;
   struct drm_property *top ;
   struct drm_property *bottom ;
   struct drm_property *hpos ;
   struct drm_property *vpos ;
   struct drm_property *contrast ;
   struct drm_property *saturation ;
   struct drm_property *hue ;
   struct drm_property *sharpness ;
   struct drm_property *flicker_filter ;
   struct drm_property *flicker_filter_adaptive ;
   struct drm_property *flicker_filter_2d ;
   struct drm_property *tv_chroma_filter ;
   struct drm_property *tv_luma_filter ;
   struct drm_property *dot_crawl ;
   struct drm_property *brightness ;
   u32 left_margin ;
   u32 right_margin ;
   u32 top_margin ;
   u32 bottom_margin ;
   u32 max_hscan ;
   u32 max_vscan ;
   u32 max_hpos ;
   u32 cur_hpos ;
   u32 max_vpos ;
   u32 cur_vpos ;
   u32 cur_brightness ;
   u32 max_brightness ;
   u32 cur_contrast ;
   u32 max_contrast ;
   u32 cur_saturation ;
   u32 max_saturation ;
   u32 cur_hue ;
   u32 max_hue ;
   u32 cur_sharpness ;
   u32 max_sharpness ;
   u32 cur_flicker_filter ;
   u32 max_flicker_filter ;
   u32 cur_flicker_filter_adaptive ;
   u32 max_flicker_filter_adaptive ;
   u32 cur_flicker_filter_2d ;
   u32 max_flicker_filter_2d ;
   u32 cur_tv_chroma_filter ;
   u32 max_tv_chroma_filter ;
   u32 cur_tv_luma_filter ;
   u32 max_tv_luma_filter ;
   u32 cur_dot_crawl ;
   u32 max_dot_crawl ;
};
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
struct _sdvo_cmd_name {
   u8 cmd ;
   char const   *name ;
};
#line 2717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
union __anonunion_enhancements_227 {
   struct psb_intel_sdvo_enhancements_reply reply ;
   uint16_t response ;
};
#line 259 "include/linux/timer.h"
enum hrtimer_restart;
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r10_timing_info {
   u16 pixel_clock ;
   unsigned char hactive_lo ;
   unsigned char hactive_hi : 4 ;
   unsigned char hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hsync_offset_lo ;
   unsigned char hsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_lo ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd_1 : 3 ;
   u8 vactive_lo ;
   unsigned char vactive_hi : 4 ;
   unsigned char vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char rsvd_2 : 3 ;
};
#line 78 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_panel_descriptor_v1 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u32 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 92 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct oaktrail_panel_descriptor_v2 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u8 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u16 Panel_MIPI_Display_Descriptor ;
};
#line 122 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_panelrx_205 {
   unsigned char NumberOfLanes : 2 ;
   unsigned char MaxLaneFreq : 3 ;
   unsigned char SupportedVideoTransferMode : 2 ;
   unsigned char HSClkBehavior : 1 ;
   unsigned char DuoDisplaySupport : 1 ;
   unsigned char ECC_ChecksumCapabilities : 1 ;
   unsigned char BidirectionalCommunication : 1 ;
   unsigned char Rsvd : 5 ;
};
#line 122 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union oaktrail_panel_rx {
   struct __anonstruct_panelrx_205 panelrx ;
   u16 panel_receiver ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_PD_207 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union __anonunion_ldv_39025_206 {
   struct __anonstruct_PD_207 PD ;
   u8 PanelDescriptor ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r0 {
   union __anonunion_ldv_39025_206 ldv_39025 ;
   struct oaktrail_panel_descriptor_v1 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct __anonstruct_PD_209 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
union __anonunion_ldv_39036_208 {
   struct __anonstruct_PD_209 PD ;
   u8 PanelDescriptor ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r1 {
   union __anonunion_ldv_39036_208 ldv_39036 ;
   struct oaktrail_panel_descriptor_v2 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
#line 189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
struct gct_r10 {
   struct gct_r10_timing_info DTD ;
   u16 Panel_MIPI_Display_Descriptor ;
   u16 Panel_MIPI_Receiver_Descriptor ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u32 MIPI_Ctlr_Init_ptr ;
   u32 MIPI_Panel_Init_ptr ;
};
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
struct mid_vbt_header {
   u32 signature ;
   u8 revision ;
};
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
struct vbt_r0 {
   struct mid_vbt_header vbt_header ;
   u8 size ;
   u8 checksum ;
};
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
struct vbt_r10 {
   struct mid_vbt_header vbt_header ;
   u8 checksum ;
   u16 size ;
   u8 panel_count ;
   u8 primary_panel_idx ;
   u8 secondary_panel_idx ;
   u8 __reserved[5U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 161 "include/acpi/actypes.h"
typedef u64 acpi_size;
#line 162 "include/acpi/actypes.h"
typedef u64 acpi_io_address;
#line 163 "include/acpi/actypes.h"
typedef u64 acpi_physical_address;
#line 430 "include/acpi/actypes.h"
typedef void *acpi_handle;
#line 626 "include/acpi/actypes.h"
typedef u32 acpi_object_type;
#line 876 "include/acpi/actypes.h"
struct __anonstruct_integer_182 {
   acpi_object_type type ;
   u64 value ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_string_183 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_buffer_184 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_package_185 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_reference_186 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_processor_187 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};
#line 876 "include/acpi/actypes.h"
struct __anonstruct_power_resource_188 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};
#line 876 "include/acpi/actypes.h"
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_182 integer ;
   struct __anonstruct_string_183 string ;
   struct __anonstruct_buffer_184 buffer ;
   struct __anonstruct_package_185 package ;
   struct __anonstruct_reference_186 reference ;
   struct __anonstruct_processor_187 processor ;
   struct __anonstruct_power_resource_188 power_resource ;
};
#line 109 "include/acpi/acpi_bus.h"
struct acpi_driver;
#line 110 "include/acpi/acpi_bus.h"
struct acpi_hotplug_profile {
   struct kobject kobj ;
   int (*scan_dependent)(struct acpi_device * ) ;
   bool enabled ;
   bool demand_offline ;
};
#line 131 "include/acpi/acpi_bus.h"
struct acpi_scan_handler {
   struct acpi_device_id  const  *ids ;
   struct list_head list_node ;
   bool (*match)(char * , struct acpi_device_id  const  ** ) ;
   int (*attach)(struct acpi_device * , struct acpi_device_id  const  * ) ;
   void (*detach)(struct acpi_device * ) ;
   void (*bind)(struct device * ) ;
   void (*unbind)(struct device * ) ;
   struct acpi_hotplug_profile hotplug ;
};
#line 141 "include/acpi/acpi_bus.h"
struct acpi_hotplug_context {
   struct acpi_device *self ;
   int (*notify)(struct acpi_device * , u32  ) ;
   void (*uevent)(struct acpi_device * , u32  ) ;
   void (*fixup)(struct acpi_device * ) ;
};
#line 162 "include/acpi/acpi_bus.h"
struct acpi_device_ops {
   int (*add)(struct acpi_device * ) ;
   int (*remove)(struct acpi_device * ) ;
   void (*notify)(struct acpi_device * , u32  ) ;
};
#line 168 "include/acpi/acpi_bus.h"
struct acpi_driver {
   char name[80U] ;
   char class[80U] ;
   struct acpi_device_id  const  *ids ;
   unsigned int flags ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};
#line 180 "include/acpi/acpi_bus.h"
struct acpi_device_status {
   unsigned char present : 1 ;
   unsigned char enabled : 1 ;
   unsigned char show_in_ui : 1 ;
   unsigned char functional : 1 ;
   unsigned char battery_present : 1 ;
   unsigned int reserved : 27 ;
};
#line 196 "include/acpi/acpi_bus.h"
struct acpi_device_flags {
   unsigned char dynamic_status : 1 ;
   unsigned char removable : 1 ;
   unsigned char ejectable : 1 ;
   unsigned char power_manageable : 1 ;
   unsigned char match_driver : 1 ;
   unsigned char initialized : 1 ;
   unsigned char visited : 1 ;
   unsigned char no_hotplug : 1 ;
   unsigned char hotplug_notify : 1 ;
   unsigned char is_dock_station : 1 ;
   unsigned int reserved : 22 ;
};
#line 212 "include/acpi/acpi_bus.h"
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};
#line 223 "include/acpi/acpi_bus.h"
typedef char acpi_bus_id[8U];
#line 224 "include/acpi/acpi_bus.h"
typedef unsigned long acpi_bus_address;
#line 225 "include/acpi/acpi_bus.h"
typedef char acpi_device_name[40U];
#line 226 "include/acpi/acpi_bus.h"
typedef char acpi_device_class[20U];
#line 232 "include/acpi/acpi_bus.h"
struct acpi_pnp_type {
   unsigned char hardware_id : 1 ;
   unsigned char bus_address : 1 ;
   unsigned char platform_id : 1 ;
   unsigned int reserved : 29 ;
};
#line 239 "include/acpi/acpi_bus.h"
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   struct acpi_pnp_type type ;
   acpi_bus_address bus_address ;
   char *unique_id ;
   struct list_head ids ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
   union acpi_object *str_obj ;
   unsigned long sun ;
};
#line 255 "include/acpi/acpi_bus.h"
struct acpi_device_power_flags {
   unsigned char explicit_get : 1 ;
   unsigned char power_resources : 1 ;
   unsigned char inrush_current : 1 ;
   unsigned char power_removed : 1 ;
   unsigned char ignore_parent : 1 ;
   unsigned char dsw_present : 1 ;
   unsigned int reserved : 26 ;
};
#line 269 "include/acpi/acpi_bus.h"
struct __anonstruct_flags_206 {
   unsigned char valid : 1 ;
   unsigned char os_accessible : 1 ;
   unsigned char explicit_set : 1 ;
   unsigned char reserved : 6 ;
};
#line 269 "include/acpi/acpi_bus.h"
struct acpi_device_power_state {
   struct __anonstruct_flags_206 flags ;
   int power ;
   int latency ;
   struct list_head resources ;
};
#line 281 "include/acpi/acpi_bus.h"
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[5U] ;
};
#line 287 "include/acpi/acpi_bus.h"
struct acpi_device_perf_flags {
   u8 reserved ;
};
#line 293 "include/acpi/acpi_bus.h"
struct __anonstruct_flags_207 {
   unsigned char valid : 1 ;
   unsigned char reserved : 7 ;
};
#line 293 "include/acpi/acpi_bus.h"
struct acpi_device_perf_state {
   struct __anonstruct_flags_207 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};
#line 303 "include/acpi/acpi_bus.h"
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};
#line 310 "include/acpi/acpi_bus.h"
struct acpi_device_wakeup_flags {
   unsigned char valid : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char notifier_present : 1 ;
};
#line 317 "include/acpi/acpi_bus.h"
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   u64 gpe_number ;
   u64 sleep_state ;
   struct list_head resources ;
   struct acpi_device_wakeup_flags flags ;
   int prepare_count ;
};
#line 333 "include/acpi/acpi_bus.h"
struct acpi_device {
   int device_type ;
   acpi_handle handle ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct list_head del_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_scan_handler *handler ;
   struct acpi_hotplug_context *hp ;
   struct acpi_driver *driver ;
   void *driver_data ;
   struct device dev ;
   unsigned int physical_node_count ;
   struct list_head physical_node_list ;
   struct mutex physical_node_lock ;
   void (*remove)(struct acpi_device * ) ;
};
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct opregion_header {
   u8 signature[16U] ;
   u32 size ;
   u32 opregion_ver ;
   u8 bios_ver[32U] ;
   u8 vbios_ver[16U] ;
   u8 driver_ver[16U] ;
   u32 mboxes ;
   u8 reserved[164U] ;
};
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
struct opregion_acpi {
   u32 drdy ;
   u32 csts ;
   u32 cevt ;
   u8 rsvd1[20U] ;
   u32 didl[8U] ;
   u32 cpdl[8U] ;
   u32 cadl[8U] ;
   u32 nadl[8U] ;
   u32 aslp ;
   u32 tidx ;
   u32 chpd ;
   u32 clid ;
   u32 cdck ;
   u32 sxsw ;
   u32 evts ;
   u32 cnot ;
   u32 nrdy ;
   u8 rsvd2[60U] ;
};
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
struct opregion_swsci {

};
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
struct opregion_asle {
   u32 ardy ;
   u32 aslc ;
   u32 tche ;
   u32 alsi ;
   u32 bclp ;
   u32 pfit ;
   u32 cblv ;
   u16 bclm[20U] ;
   u32 cpfm ;
   u32 epfm ;
   u8 plut[74U] ;
   u32 pfmb ;
   u8 rsvd[102U] ;
};
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct mdfld_hdmi_i2c;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct mid_intel_hdmi_priv {
   u32 hdmi_reg ;
   u32 save_HDMIB ;
   bool has_hdmi_sink ;
   bool has_hdmi_audio ;
   bool hdmi_device_connected ;
   struct mdfld_hdmi_i2c *i2c_bus ;
   struct i2c_adapter *hdmi_i2c_adapter ;
   struct drm_device *dev ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct cdv_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct i2c_algo_dp_aux_data {
   bool running ;
   u16 address ;
   int (*aux_ch)(struct i2c_adapter * , int  , uint8_t  , uint8_t * ) ;
};
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_reg.h"
struct cdv_intel_dp {
   uint32_t output_reg ;
   uint32_t DP ;
   uint8_t link_configuration[9U] ;
   bool has_audio ;
   int force_audio ;
   uint32_t color_range ;
   uint8_t link_bw ;
   uint8_t lane_count ;
   uint8_t dpcd[4U] ;
   struct gma_encoder *encoder ;
   struct i2c_adapter adapter ;
   struct i2c_algo_dp_aux_data algo ;
   uint8_t train_set[4U] ;
   uint8_t link_status[6U] ;
   int panel_power_up_delay ;
   int panel_power_down_delay ;
   int panel_power_cycle_delay ;
   int backlight_on_delay ;
   int backlight_off_delay ;
   struct drm_display_mode *panel_fixed_mode ;
   bool panel_on ;
};
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
struct ddi_regoff {
   uint32_t PreEmph1 ;
   uint32_t PreEmph2 ;
   uint32_t VSwing1 ;
   uint32_t VSwing2 ;
   uint32_t VSwing3 ;
   uint32_t VSwing4 ;
   uint32_t VSwing5 ;
};
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
struct cdv_intel_dp_m_n {
   uint32_t tu ;
   uint32_t gmch_m ;
   uint32_t gmch_n ;
   uint32_t link_m ;
   uint32_t link_n ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 894 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct intel_range {
   int min ;
   int max ;
};
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
struct oaktrail_hdmi_limit {
   struct intel_range vco ;
   struct intel_range np ;
   struct intel_range nr ;
   struct intel_range nf ;
};
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
struct oaktrail_hdmi_clock {
   int np ;
   int nr ;
   int nf ;
   int dot ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 894 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct hdmi_i2c_dev {
   struct i2c_adapter *adap ;
   struct mutex i2c_lock ;
   struct completion complete ;
   int status ;
   struct i2c_msg *msg ;
   int buf_offset ;
};
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14126_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
long ldv__builtin_expect(long exp , long c ) ;
#line 2 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 689 "./arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 691
  __asm__  volatile   ("rep; nop": : : "memory");
#line 692
  return;
}
}
#line 694 "./arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
#line 696
  rep_nop();
#line 697
  return;
}
}
#line 43 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 372 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_8(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 374
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
#line 375
  return;
}
}
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 316 "include/linux/slab.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 600 "include/linux/fb.h"
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
#line 52 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/power.h"
bool gma_power_begin(struct drm_device *dev , bool force_on ) ;
#line 53
void gma_power_end(struct drm_device *dev ) ;
#line 702 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) ;
#line 704
int psbfb_sync(struct fb_info *info ) ;
#line 705
void psb_spank(struct drm_psb_private *dev_priv ) ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void psb_spank(struct drm_psb_private *dev_priv ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 273
  iowrite32(127U, (void *)dev_priv->sgx_reg + 128U);
#line 277
  ioread32((void *)dev_priv->sgx_reg + 128U);
#line 279
  msleep(1U);
#line 281
  iowrite32(0U, (void *)dev_priv->sgx_reg + 128U);
#line 282
  __asm__  volatile   ("sfence": : : "memory");
#line 283
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 283
  iowrite32(tmp | 16U, (void *)dev_priv->sgx_reg + 3072U);
#line 285
  __asm__  volatile   ("sfence": : : "memory");
#line 286
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 288
  msleep(1U);
#line 289
  tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 289
  iowrite32(tmp___0 & 4294967279U, (void *)dev_priv->sgx_reg + 3072U);
#line 291
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 292
  iowrite32(dev_priv->gtt.gatt_start, (void *)dev_priv->sgx_reg + 3208U);
#line 293
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
static int psb_2d_wait_available(struct drm_psb_private *dev_priv , unsigned int size ) 
{ 
  uint32_t avail ;
  unsigned int tmp ;
  unsigned long t ;

  {
#line 306
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 306
  avail = tmp;
#line 307
  t = (unsigned long )jiffies + 250UL;
#line 309
  goto ldv_40901;
  ldv_40900: 
#line 310
  avail = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 311
  if ((long )(t - (unsigned long )jiffies) < 0L) {
#line 312
    psb_spank(dev_priv);
#line 313
    return (-5);
  } else {

  }
  ldv_40901: ;
#line 309
  if (avail < size) {
#line 311
    goto ldv_40900;
  } else {

  }

#line 316
  return (0);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
static int psbfb_2d_submit(struct drm_psb_private *dev_priv , uint32_t *cmdbuf , unsigned int size ) 
{ 
  int ret ;
  int i ;
  unsigned int submit_size ;
  unsigned long flags ;
  uint32_t *tmp ;

  {
#line 331
  ret = 0;
#line 336
  ldv_spin_lock();
#line 337
  goto ldv_40917;
  ldv_40916: 
#line 338
  submit_size = 96U < size ? 96U : size;
#line 339
  size = size - submit_size;
#line 340
  ret = psb_2d_wait_available(dev_priv, submit_size);
#line 341
  if (ret != 0) {
#line 342
    goto ldv_40912;
  } else {

  }
#line 344
  submit_size = submit_size << 2;
#line 346
  i = 0;
#line 346
  goto ldv_40914;
  ldv_40913: 
#line 347
  tmp = cmdbuf;
#line 347
  cmdbuf = cmdbuf + 1;
#line 347
  iowrite32(*tmp, (void *)dev_priv->sgx_reg + (unsigned long )(i + 16384));
#line 346
  i = i + 4;
  ldv_40914: ;
#line 346
  if ((unsigned int )i < submit_size) {
#line 348
    goto ldv_40913;
  } else {

  }
#line 349
  ioread32((void *)(dev_priv->sgx_reg + ((unsigned long )(i + 16384) + 0xfffffffffffffffcUL)));
  ldv_40917: ;
#line 337
  if (size != 0U) {
#line 339
    goto ldv_40916;
  } else {

  }
  ldv_40912: 
#line 351
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
#line 352
  return (ret);
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
static u32 psb_accel_2d_copy_direction(int xdir , int ydir ) 
{ 


  {
#line 366
  if (xdir < 0) {
#line 367
    return (ydir < 0 ? 8388608U : 16777216U);
  } else {
#line 370
    return (ydir < 0 ? 25165824U : 0U);
  }
}
}
#line 392 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
static int psb_accel_2d_copy(struct drm_psb_private *dev_priv , uint32_t src_offset ,
                             uint32_t src_stride , uint32_t src_format , uint32_t dst_offset ,
                             uint32_t dst_stride , uint32_t dst_format , uint16_t src_x ,
                             uint16_t src_y , uint16_t dst_x , uint16_t dst_y , uint16_t size_x ,
                             uint16_t size_y ) 
{ 
  uint32_t blit_cmd ;
  uint32_t buffer[10U] ;
  uint32_t *buf ;
  uint32_t direction ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  int tmp___9 ;

  {
#line 405
  buf = (uint32_t *)(& buffer);
#line 407
  direction = psb_accel_2d_copy_direction((int )src_x - (int )dst_x, (int )src_y - (int )dst_y);
#line 410
  if (direction == 8388608U || direction == 16777216U) {
#line 412
    src_x = (unsigned int )((int )size_x + (int )src_x) + 65535U;
#line 413
    dst_x = (unsigned int )((int )size_x + (int )dst_x) + 65535U;
  } else {

  }
#line 415
  if (direction == 8388608U || direction == 25165824U) {
#line 417
    src_y = (unsigned int )((int )size_y + (int )src_y) + 65535U;
#line 418
    dst_y = (unsigned int )((int )size_y + (int )dst_y) + 65535U;
  } else {

  }
#line 421
  blit_cmd = direction | 2147601612U;
#line 428
  tmp = buf;
#line 428
  buf = buf + 1;
#line 428
  *tmp = 1879048192U;
#line 429
  tmp___0 = buf;
#line 429
  buf = buf + 1;
#line 429
  *tmp___0 = (dst_format | dst_stride) | 2684354560U;
#line 432
  tmp___1 = buf;
#line 432
  buf = buf + 1;
#line 432
  *tmp___1 = dst_offset;
#line 433
  tmp___2 = buf;
#line 433
  buf = buf + 1;
#line 433
  *tmp___2 = (src_format | src_stride) | 2415919104U;
#line 436
  tmp___3 = buf;
#line 436
  buf = buf + 1;
#line 436
  *tmp___3 = src_offset;
#line 437
  tmp___4 = buf;
#line 437
  buf = buf + 1;
#line 437
  *tmp___4 = (uint32_t )((((int )src_x << 12) | 805306368) | (int )src_y);
#line 440
  tmp___5 = buf;
#line 440
  buf = buf + 1;
#line 440
  *tmp___5 = blit_cmd;
#line 441
  tmp___6 = buf;
#line 441
  buf = buf + 1;
#line 441
  *tmp___6 = (uint32_t )(((int )dst_x << 12) | (int )dst_y);
#line 444
  tmp___7 = buf;
#line 444
  buf = buf + 1;
#line 444
  *tmp___7 = (uint32_t )(((int )size_x << 12) | (int )size_y);
#line 447
  tmp___8 = buf;
#line 447
  buf = buf + 1;
#line 447
  *tmp___8 = 4026531840U;
#line 449
  tmp___9 = psbfb_2d_submit(dev_priv, (uint32_t *)(& buffer), (unsigned int )(((long )buf - (long )(& buffer)) / 4L));
#line 449
  return (tmp___9);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
static void psbfb_copyarea_accel(struct fb_info *info , struct fb_copyarea  const  *a ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_framebuffer *fb ;
  struct drm_psb_private *dev_priv ;
  uint32_t offset ;
  uint32_t stride ;
  uint32_t src_format ;
  uint32_t dst_format ;
  bool tmp ;
  int tmp___0 ;

  {
#line 462
  fbdev = (struct psb_fbdev *)info->par;
#line 463
  psbfb = & fbdev->pfb;
#line 464
  dev = psbfb->base.dev;
#line 465
  fb = fbdev->psb_fb_helper.fb;
#line 466
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 472
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 473
    return;
  } else {

  }
#line 475
  offset = (psbfb->gtt)->offset;
#line 476
  stride = fb->pitches[0];
#line 478
  switch (fb->depth) {
  case 8U: 
#line 480
  src_format = 196608U;
#line 481
  dst_format = 196608U;
#line 482
  goto ldv_40955;
  case 15U: 
#line 484
  src_format = 262144U;
#line 485
  dst_format = 262144U;
#line 486
  goto ldv_40955;
  case 16U: 
#line 488
  src_format = 327680U;
#line 489
  dst_format = 327680U;
#line 490
  goto ldv_40955;
  case 24U: ;
  case 32U: 
#line 494
  src_format = 393216U;
#line 495
  dst_format = 393216U;
#line 496
  goto ldv_40955;
  default: 
#line 499
  cfb_copyarea(info, a);
#line 500
  return;
  }
  ldv_40955: 
#line 503
  tmp = gma_power_begin(dev, 0);
#line 503
  if (tmp) {
#line 503
    tmp___0 = 0;
  } else {
#line 503
    tmp___0 = 1;
  }
#line 503
  if (tmp___0) {
#line 504
    cfb_copyarea(info, a);
#line 505
    return;
  } else {

  }
#line 507
  psb_accel_2d_copy(dev_priv, offset, stride, src_format, offset, stride, dst_format,
                    (int )((uint16_t )a->sx), (int )((uint16_t )a->sy), (int )((uint16_t )a->dx),
                    (int )((uint16_t )a->dy), (int )((uint16_t )a->width), (int )((uint16_t )a->height));
#line 511
  gma_power_end(dev);
#line 512
  return;
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ 
  long tmp ;

  {
#line 525
  tmp = ldv__builtin_expect(info->state != 0U, 0L);
#line 525
  if (tmp != 0L) {
#line 526
    return;
  } else {

  }
#line 529
  if (((unsigned int )region->width == 8U || (unsigned int )region->height == 8U) || (info->flags & 2) != 0) {
#line 531
    return;
  } else {

  }
#line 533
  psbfb_copyarea_accel(info, region);
#line 534
  return;
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
int psbfb_sync(struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned long _end___0 ;
  int busy ;
  unsigned long flags ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 545
  fbdev = (struct psb_fbdev *)info->par;
#line 546
  psbfb = & fbdev->pfb;
#line 547
  dev = psbfb->base.dev;
#line 548
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 549
  _end___0 = (unsigned long )jiffies + 250UL;
#line 550
  busy = 0;
#line 553
  ldv_spin_lock();
#line 558
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 558
  if (tmp == 128U) {
#line 558
    tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 558
    if ((tmp___0 & 16777216U) == 0U) {
#line 560
      goto out;
    } else {

    }
  } else {

  }
  ldv_40982: 
#line 563
  tmp___1 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 563
  busy = tmp___1 != 128U;
#line 564
  cpu_relax();
#line 565
  if (busy != 0 && (long )((unsigned long )jiffies - _end___0) < 0L) {
#line 567
    goto ldv_40982;
  } else {

  }

#line 567
  if (busy != 0) {
#line 568
    tmp___2 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 568
    busy = tmp___2 != 128U;
  } else {

  }
#line 569
  if (busy != 0) {
#line 570
    goto out;
  } else {

  }
  ldv_40990: 
#line 573
  tmp___3 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 573
  busy = (tmp___3 & 16777216U) != 0U;
#line 575
  cpu_relax();
#line 576
  if (busy != 0 && (long )((unsigned long )jiffies - _end___0) < 0L) {
#line 578
    goto ldv_40990;
  } else {

  }

#line 577
  if (busy != 0) {
#line 578
    tmp___4 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 578
    busy = (tmp___4 & 16777216U) != 0U;
  } else {

  }
  out: 
#line 582
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
#line 583
  return (busy != 0 ? -16 : 0);
}
}
#line 645 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 648
  ldv_spin_unlock();
#line 650
  ldv_spin_unlock_irqrestore_8(lock, flags);
#line 651
  return;
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/accel_2d.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 716
  ldv_check_alloc_flags(flags);
#line 718
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 719
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_36(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 718 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
int gma_backlight_init(struct drm_device *dev ) ;
#line 719
void gma_backlight_exit(struct drm_device *dev ) ;
#line 720
void gma_backlight_disable(struct drm_device *dev ) ;
#line 721
void gma_backlight_enable(struct drm_device *dev ) ;
#line 722
void gma_backlight_set(struct drm_device *dev , int v ) ;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void gma_backlight_enable(struct drm_device *dev ) 
{ 


  {
#line 259
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void gma_backlight_disable(struct drm_device *dev ) 
{ 


  {
#line 271
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void gma_backlight_set(struct drm_device *dev , int v ) 
{ 


  {
#line 283
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
int gma_backlight_init(struct drm_device *dev ) 
{ 


  {
#line 300
  return (0);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void gma_backlight_exit(struct drm_device *dev ) 
{ 


  {
#line 306
  return;
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/backlight.o.c.prepared"
void *ldv_kmem_cache_alloc_36(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 446
  ldv_check_alloc_flags(flags);
#line 448
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 449
  return ((void *)0);
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 53 "include/linux/dynamic_debug.h"
extern int __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                             , ...) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 55 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 62
extern char *strcpy(char * , char const   * ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 25
  return ((void *)error);
}
}
#line 147 "./arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 boot_cpu_data ;
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 27
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5646;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5646;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5646;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5646;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5646: ;
#line 177
  return (__ret);
}
}
#line 194 "./arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  ldv_5675: 
#line 199
  tmp = ldv__builtin_expect(c == u, 0L);
#line 199
  if (tmp != 0L) {
#line 200
    goto ldv_5674;
  } else {

  }
#line 201
  old = atomic_cmpxchg(v, c, c + a);
#line 202
  tmp___0 = ldv__builtin_expect(old == c, 1L);
#line 202
  if (tmp___0 != 0L) {
#line 203
    goto ldv_5674;
  } else {

  }
#line 204
  c = old;
#line 205
  goto ldv_5675;
  ldv_5674: ;
#line 206
  return (c);
}
}
#line 51 "include/linux/atomic.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int tmp ;

  {
#line 53
  tmp = __atomic_add_unless(v, a, u);
#line 53
  return (tmp != u);
}
}
#line 139 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 175
extern void mutex_unlock(struct mutex * ) ;
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 319
void *ldv_kmem_cache_alloc_56(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern u16 __VERIFIER_nondet_u16(void) ;
#line 25
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
struct fb_var_screeninfo *psbfb_roll_ops_group0 ;
#line 25
struct fb_info *psbfb_ops_group0 ;
#line 35
int ldv_state_variable_54 ;
#line 37
struct drm_crtc *psb_fb_helper_funcs_group0 ;
#line 42
int ldv_state_variable_51 ;
#line 44
struct drm_device *psb_mode_funcs_group0 ;
#line 51
int ref_cnt ;
#line 62
int ldv_state_variable_55 ;
#line 84
int ldv_state_variable_56 ;
#line 89
int ldv_state_variable_52 ;
#line 93
struct drm_framebuffer *psb_fb_funcs_group0 ;
#line 100
struct fb_info *psbfb_roll_ops_group1 ;
#line 102
struct vm_area_struct *psbfb_vm_ops_group0 ;
#line 129
struct fb_info *psbfb_unaccel_ops_group0 ;
#line 144
int ldv_state_variable_57 ;
#line 150
int ldv_state_variable_53 ;
#line 166
void ldv_initialize_fb_ops_55(void) ;
#line 181
void ldv_initialize_vm_operations_struct_56(void) ;
#line 187
void ldv_initialize_fb_ops_54(void) ;
#line 189
void ldv_initialize_drm_mode_config_funcs_51(void) ;
#line 190
void ldv_initialize_drm_fb_helper_funcs_52(void) ;
#line 192
void ldv_initialize_drm_framebuffer_funcs_57(void) ;
#line 214
void ldv_initialize_fb_ops_53(void) ;
#line 1960 "include/linux/mm.h"
extern int vm_insert_mixed(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 1042 "include/linux/device.h"
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 509 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ 
  struct apertures_struct *a ;
  void *tmp ;

  {
#line 510
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
#line 510
  a = (struct apertures_struct *)tmp;
#line 512
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
#line 513
    return ((struct apertures_struct *)0);
  } else {

  }
#line 514
  a->count = max_num;
#line 515
  return (a);
}
}
#line 599
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
#line 601
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
#line 615
extern int unregister_framebuffer(struct fb_info * ) ;
#line 686
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
#line 687
extern void framebuffer_release(struct fb_info * ) ;
#line 753
extern int fb_alloc_cmap(struct fb_cmap * , int  , int  ) ;
#line 755
extern void fb_dealloc_cmap(struct fb_cmap * ) ;
#line 846 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 864 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 867
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 867
  return (tmp);
}
}
#line 945 "include/drm/drm_crtc.h"
extern void drm_mode_config_init(struct drm_device * ) ;
#line 947
extern void drm_mode_config_cleanup(struct drm_device * ) ;
#line 974
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
#line 982
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
#line 983
extern void drm_framebuffer_unregister_private(struct drm_framebuffer * ) ;
#line 998
extern struct drm_property *drm_property_create_range(struct drm_device * , int  ,
                                                      char const   * , uint64_t  ,
                                                      uint64_t  ) ;
#line 1012
extern int drm_mode_create_scaling_mode_property(struct drm_device * ) ;
#line 1046
extern uint32_t drm_mode_legacy_fb_format(uint32_t  , uint32_t  ) ;
#line 1096
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
#line 1525 "include/drm/drmP.h"
extern void drm_gem_object_free(struct kref * ) ;
#line 1528
extern void drm_gem_private_object_init(struct drm_device * , struct drm_gem_object * ,
                                        size_t  ) ;
#line 1545 "include/drm/drmP.h"
__inline static void drm_gem_object_unreference(struct drm_gem_object *obj ) 
{ 


  {
#line 1547
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 1548
    kref_put(& obj->refcount, & drm_gem_object_free);
  } else {

  }
#line 1549
  return;
}
}
#line 1552 "include/drm/drmP.h"
__inline static void drm_gem_object_unreference_unlocked(struct drm_gem_object *obj ) 
{ 
  struct drm_device *dev ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1554
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 1554
    tmp___1 = atomic_add_unless(& obj->refcount.refcount, -1, 1);
#line 1554
    if (tmp___1 == 0) {
#line 1555
      dev = obj->dev;
#line 1557
      mutex_lock_nested(& dev->struct_mutex, 0U);
#line 1558
      tmp = atomic_dec_and_test(& obj->refcount.refcount);
#line 1558
      tmp___0 = ldv__builtin_expect(tmp != 0, 1L);
#line 1558
      if (tmp___0 != 0L) {
#line 1559
        drm_gem_object_free(& obj->refcount);
      } else {

      }
#line 1560
      mutex_unlock(& dev->struct_mutex);
    } else {

    }
  } else {

  }
#line 1562
  return;
}
}
#line 1567
extern int drm_gem_handle_create(struct drm_file * , struct drm_gem_object * , u32 * ) ;
#line 1581
extern struct drm_gem_object *drm_gem_object_lookup(struct drm_device * , struct drm_file * ,
                                                    u32  ) ;
#line 100 "include/drm/drm_fb_helper.h"
extern int drm_fb_helper_init(struct drm_device * , struct drm_fb_helper * , int  ,
                              int  ) ;
#line 103
extern void drm_fb_helper_fini(struct drm_fb_helper * ) ;
#line 104
extern int drm_fb_helper_blank(int  , struct fb_info * ) ;
#line 107
extern int drm_fb_helper_set_par(struct fb_info * ) ;
#line 108
extern int drm_fb_helper_check_var(struct fb_var_screeninfo * , struct fb_info * ) ;
#line 112
extern void drm_fb_helper_fill_var(struct fb_info * , struct drm_fb_helper * , uint32_t  ,
                                   uint32_t  ) ;
#line 114
extern void drm_fb_helper_fill_fix(struct fb_info * , uint32_t  , uint32_t  ) ;
#line 119
extern int drm_fb_helper_hotplug_event(struct drm_fb_helper * ) ;
#line 120
extern bool drm_fb_helper_initial_config(struct drm_fb_helper * , int  ) ;
#line 121
extern int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper * ) ;
#line 128 "include/drm/drm_crtc_helper.h"
extern void drm_helper_disable_unused_functions(struct drm_device * ) ;
#line 141
extern void drm_helper_mode_fill_fb_struct(struct drm_framebuffer * , struct drm_mode_fb_cmd2 * ) ;
#line 173
extern void drm_kms_helper_poll_fini(struct drm_device * ) ;
#line 212 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) ;
#line 233 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static struct gma_encoder *gma_attached_encoder(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 236
  __mptr = (struct drm_connector  const  *)connector;
#line 236
  return (((struct gma_connector *)__mptr)->encoder);
}
}
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gtt.h"
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed , u32 align ) ;
#line 59
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) ;
#line 62
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) ;
#line 713 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_modeset_init(struct drm_device *dev ) ;
#line 714
void psb_modeset_cleanup(struct drm_device *dev ) ;
#line 715
int psb_fbdev_init(struct drm_device *dev ) ;
#line 44 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/framebuffer.h"
int gma_connector_clones(struct drm_device *dev , int type_mask ) ;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) ;
#line 264
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) ;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct drm_framebuffer_funcs  const  psb_fb_funcs  =    {& psb_user_framebuffer_destroy, & psb_user_framebuffer_create_handle, 0};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                           unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct drm_framebuffer *fb ;
  uint32_t v ;

  {
#line 279
  fbdev = (struct psb_fbdev *)info->par;
#line 280
  fb = fbdev->psb_fb_helper.fb;
#line 283
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 284
    return (-12);
  } else {

  }
#line 286
  if (regno > 255U) {
#line 287
    return (1);
  } else {

  }
#line 289
  red = (((red << (int )info->var.red.length) - red) + 32767U) >> 16;
#line 290
  blue = (((blue << (int )info->var.blue.length) - blue) + 32767U) >> 16;
#line 291
  green = (((green << (int )info->var.green.length) - green) + 32767U) >> 16;
#line 292
  transp = (((transp << (int )info->var.transp.length) - transp) + 32767U) >> 16;
#line 294
  v = (((red << (int )info->var.red.offset) | (green << (int )info->var.green.offset)) | (blue << (int )info->var.blue.offset)) | (transp << (int )info->var.transp.offset);
#line 299
  if (regno <= 15U) {
#line 300
    switch (fb->bits_per_pixel) {
    case 16: 
#line 302
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
#line 303
    goto ldv_40932;
    case 24: ;
    case 32: 
#line 306
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
#line 307
    goto ldv_40932;
    }
    ldv_40932: ;
  } else {

  }
#line 311
  return (0);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_pan(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  int pages ;

  {
#line 316
  fbdev = (struct psb_fbdev *)info->par;
#line 317
  psbfb = & fbdev->pfb;
#line 318
  dev = psbfb->base.dev;
#line 325
  if ((psbfb->gtt)->npage != 0) {
#line 328
    pages = (int )(info->fix.line_length >> 12);
#line 329
    psb_gtt_roll(dev, psbfb->gtt, (int )(var->yoffset * (__u32 )pages));
  } else {

  }
#line 331
  return (0);
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_vm_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int page_num ;
  int i ;
  unsigned long address ;
  int ret ;
  unsigned long pfn ;
  unsigned long phys_addr ;
  pgprot_t __constr_expr_0 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 336
  psbfb = (struct psb_framebuffer *)vma->vm_private_data;
#line 337
  dev = psbfb->base.dev;
#line 338
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 344
  phys_addr = (unsigned long )dev_priv->stolen_base + (unsigned long )(psbfb->gtt)->offset;
#line 347
  page_num = (int )((vma->vm_end - vma->vm_start) >> 12);
#line 348
  address = (unsigned long )vmf->virtual_address - (vmf->pgoff << 12);
#line 350
  if ((unsigned int )boot_cpu_data.x86 > 3U) {
#line 350
    __constr_expr_0.pgprot = vma->vm_page_prot.pgprot | 16UL;
#line 350
    vma->vm_page_prot = __constr_expr_0;
  } else {
#line 350
    vma->vm_page_prot = vma->vm_page_prot;
  }
#line 352
  i = 0;
#line 352
  goto ldv_40959;
  ldv_40958: 
#line 353
  pfn = phys_addr >> 12;
#line 355
  ret = vm_insert_mixed(vma, address, pfn);
#line 356
  tmp___0 = ldv__builtin_expect(ret == -16, 0L);
#line 356
  if (tmp___0 != 0L) {
#line 357
    goto ldv_40957;
  } else {
#line 356
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 356
    if (tmp___1 != 0L) {
#line 356
      tmp___2 = ldv__builtin_expect(i > 0, 0L);
#line 356
      if (tmp___2 != 0L) {
#line 356
        tmp___3 = 1;
      } else {
#line 356
        tmp___3 = 0;
      }
    } else {
#line 356
      tmp___3 = 0;
    }
#line 356
    if (tmp___3 != 0) {
#line 357
      goto ldv_40957;
    } else {
#line 358
      tmp = ldv__builtin_expect(ret != 0, 0L);
#line 358
      if (tmp != 0L) {
#line 359
        ret = ret == -12 ? 1 : 2;
#line 360
        return (ret);
      } else {

      }
    }
  }
#line 362
  address = address + 4096UL;
#line 363
  phys_addr = phys_addr + 4096UL;
#line 352
  i = i + 1;
  ldv_40959: ;
#line 352
  if (i < page_num) {
#line 354
    goto ldv_40958;
  } else {

  }
  ldv_40957: ;
#line 365
  return (256);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psbfb_vm_open(struct vm_area_struct *vma ) 
{ 


  {
#line 370
  return;
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psbfb_vm_close(struct vm_area_struct *vma ) 
{ 


  {
#line 374
  return;
}
}
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct vm_operations_struct  const  psbfb_vm_ops  = 
#line 376
     {& psbfb_vm_open, & psbfb_vm_close, & psbfb_vm_fault, 0, 0, 0, 0, 0, 0, 0, 0};
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_mmap(struct fb_info *info , struct vm_area_struct *vma ) 
{ 
  struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;

  {
#line 384
  fbdev = (struct psb_fbdev *)info->par;
#line 385
  psbfb = & fbdev->pfb;
#line 387
  if (vma->vm_pgoff != 0UL) {
#line 388
    return (-22);
  } else {

  }
#line 389
  if (vma->vm_pgoff > 4503599627370495UL) {
#line 390
    return (-22);
  } else {

  }
#line 392
  if ((unsigned long )psbfb->addr_space == (unsigned long )((struct address_space *)0)) {
#line 393
    psbfb->addr_space = (vma->vm_file)->f_mapping;
  } else {

  }
#line 399
  vma->vm_ops = & psbfb_vm_ops;
#line 400
  vma->vm_private_data = (void *)psbfb;
#line 401
  vma->vm_flags = vma->vm_flags | 335822848UL;
#line 402
  return (0);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_ioctl(struct fb_info *info , unsigned int cmd , unsigned long arg ) 
{ 


  {
#line 408
  return (-25);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct fb_ops psbfb_ops  = 
#line 411
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & psbfb_copyarea,
    & cfb_imageblit, 0, 0, & psbfb_sync, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0,
    0};
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct fb_ops psbfb_roll_ops  = 
#line 425
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, & psbfb_pan, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct fb_ops psbfb_unaccel_ops  = 
#line 439
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psb_framebuffer_init(struct drm_device *dev , struct psb_framebuffer *fb ,
                                struct drm_mode_fb_cmd2 *mode_cmd , struct gtt_range *gt ) 
{ 
  u32 bpp ;
  u32 depth ;
  int ret ;

  {
#line 470
  drm_fb_get_bpp_depth(mode_cmd->pixel_format, & depth, (int *)(& bpp));
#line 472
  if ((mode_cmd->pitches[0] & 63U) != 0U) {
#line 473
    return (-22);
  } else {

  }
#line 474
  switch (bpp) {
  case 8U: ;
  case 16U: ;
  case 24U: ;
  case 32U: ;
#line 479
  goto ldv_40994;
  default: ;
#line 481
  return (-22);
  }
  ldv_40994: 
#line 483
  drm_helper_mode_fill_fb_struct(& fb->base, mode_cmd);
#line 484
  fb->gtt = gt;
#line 485
  ret = drm_framebuffer_init(dev, & fb->base, & psb_fb_funcs);
#line 486
  if (ret != 0) {
#line 487
    dev_err((struct device  const  *)dev->dev, "framebuffer init failed: %d\n", ret);
#line 488
    return (ret);
  } else {

  }
#line 490
  return (0);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct drm_framebuffer *psb_framebuffer_create(struct drm_device *dev , struct drm_mode_fb_cmd2 *mode_cmd ,
                                                      struct gtt_range *gt ) 
{ 
  struct psb_framebuffer *fb ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 513
  tmp = kzalloc(160UL, 208U);
#line 513
  fb = (struct psb_framebuffer *)tmp;
#line 514
  if ((unsigned long )fb == (unsigned long )((struct psb_framebuffer *)0)) {
#line 515
    tmp___0 = ERR_PTR(-12L);
#line 515
    return ((struct drm_framebuffer *)tmp___0);
  } else {

  }
#line 517
  ret = psb_framebuffer_init(dev, fb, mode_cmd, gt);
#line 518
  if (ret != 0) {
#line 519
    kfree((void const   *)fb);
#line 520
    tmp___1 = ERR_PTR((long )ret);
#line 520
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
#line 522
  return (& fb->base);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct gtt_range *psbfb_alloc(struct drm_device *dev , int aligned_size ) 
{ 
  struct gtt_range *backing ;

  {
#line 542
  backing = psb_gtt_alloc_range(dev, aligned_size, "fb", 1, 4096U);
#line 543
  if ((unsigned long )backing != (unsigned long )((struct gtt_range *)0)) {
#line 544
    drm_gem_private_object_init(dev, & backing->gem, (size_t )aligned_size);
#line 545
    return (backing);
  } else {

  }
#line 547
  return ((struct gtt_range *)0);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_create(struct psb_fbdev *fbdev , struct drm_fb_helper_surface_size *sizes ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct fb_info *info ;
  struct drm_framebuffer *fb ;
  struct psb_framebuffer *psbfb ;
  struct drm_mode_fb_cmd2 mode_cmd ;
  struct device *device ;
  int size ;
  int ret ;
  struct gtt_range *backing ;
  u32 bpp ;
  u32 depth ;
  int gtt_roll ;
  int pitch_lines ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 560
  dev = fbdev->psb_fb_helper.dev;
#line 561
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 564
  psbfb = & fbdev->pfb;
#line 566
  device = & (dev->pdev)->dev;
#line 571
  gtt_roll = 0;
#line 572
  pitch_lines = 0;
#line 574
  mode_cmd.width = sizes->surface_width;
#line 575
  mode_cmd.height = sizes->surface_height;
#line 576
  bpp = sizes->surface_bpp;
#line 577
  depth = sizes->surface_depth;
#line 580
  if (bpp == 24U) {
#line 581
    bpp = 32U;
  } else {

  }
  ldv_41026: 
#line 589
  mode_cmd.pitches[0] = ((mode_cmd.width * ((bpp + 7U) / 8U) + (__u32 )(4096 >> pitch_lines)) - 1U) & - ((unsigned int )(4096 >> pitch_lines));
#line 591
  size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
#line 592
  size = (size + 4095) & -4096;
#line 595
  backing = psbfb_alloc(dev, size);
#line 597
  if (pitch_lines != 0) {
#line 598
    pitch_lines = pitch_lines * 2;
  } else {
#line 600
    pitch_lines = 1;
  }
#line 601
  gtt_roll = gtt_roll + 1;
#line 602
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0) && pitch_lines <= 16) {
#line 604
    goto ldv_41026;
  } else {

  }
#line 605
  pitch_lines = pitch_lines / 2;
#line 607
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
#line 614
    gtt_roll = 0;
#line 615
    pitch_lines = 64;
#line 617
    mode_cmd.pitches[0] = (mode_cmd.width * ((bpp + 7U) / 8U) + 63U) & 4294967232U;
#line 619
    size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
#line 620
    size = (size + 4095) & -4096;
#line 623
    backing = psbfb_alloc(dev, size);
#line 624
    if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
#line 625
      return (-12);
    } else {

    }
  } else {

  }
#line 628
  memset((void *)dev_priv->vram_addr + (unsigned long )backing->offset, 0, (size_t )size);
#line 630
  mutex_lock_nested(& dev->struct_mutex, 0U);
#line 632
  info = framebuffer_alloc(0UL, device);
#line 633
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
#line 634
    ret = -12;
#line 635
    goto out_err1;
  } else {

  }
#line 637
  info->par = (void *)fbdev;
#line 639
  mode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);
#line 641
  ret = psb_framebuffer_init(dev, psbfb, & mode_cmd, backing);
#line 642
  if (ret != 0) {
#line 643
    goto out_unref;
  } else {

  }
#line 645
  fb = & psbfb->base;
#line 646
  psbfb->fbdev = info;
#line 648
  fbdev->psb_fb_helper.fb = fb;
#line 649
  fbdev->psb_fb_helper.fbdev = info;
#line 651
  drm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);
#line 652
  strcpy((char *)(& info->fix.id), "psbdrmfb");
#line 654
  info->flags = 1;
#line 655
  if ((unsigned int )*((unsigned char *)dev_priv->ops + 8UL) != 0U && pitch_lines > 8) {
#line 656
    info->fbops = & psbfb_ops;
  } else
#line 657
  if (gtt_roll != 0) {
#line 658
    info->fbops = & psbfb_roll_ops;
#line 659
    info->flags = info->flags | 8192;
  } else {
#line 661
    info->fbops = & psbfb_unaccel_ops;
  }
#line 663
  ret = fb_alloc_cmap(& info->cmap, 256, 0);
#line 664
  if (ret != 0) {
#line 665
    ret = -12;
#line 666
    goto out_unref;
  } else {

  }
#line 669
  info->fix.smem_start = (unsigned long )dev->mode_config.fb_base;
#line 670
  info->fix.smem_len = (__u32 )size;
#line 671
  info->fix.ywrapstep = (__u16 )gtt_roll;
#line 672
  info->fix.ypanstep = 0U;
#line 675
  info->screen_base = (char *)dev_priv->vram_addr + (unsigned long )backing->offset;
#line 676
  info->screen_size = (unsigned long )size;
#line 678
  if (dev_priv->gtt.stolen_size != 0UL) {
#line 679
    info->apertures = alloc_apertures(1U);
#line 680
    if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
#line 681
      ret = -12;
#line 682
      goto out_unref;
    } else {

    }
#line 684
    (info->apertures)->ranges[0].base = dev->mode_config.fb_base;
#line 685
    (info->apertures)->ranges[0].size = (resource_size_t )dev_priv->gtt.stolen_size;
  } else {

  }
#line 688
  drm_fb_helper_fill_var(info, & fbdev->psb_fb_helper, sizes->fb_width, sizes->fb_height);
#line 691
  info->fix.mmio_start = (unsigned long )(dev->pdev)->resource[0].start;
#line 692
  info->fix.mmio_len = (dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start ? ((__u32 )(dev->pdev)->resource[0].end - (__u32 )(dev->pdev)->resource[0].start) + 1U : 0U;
#line 696
  descriptor.modname = "gma500_gfx";
#line 696
  descriptor.function = "psbfb_create";
#line 696
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared";
#line 696
  descriptor.format = "allocated %dx%d fb\n";
#line 696
  descriptor.lineno = 697U;
#line 696
  descriptor.flags = 0U;
#line 696
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 696
  if (tmp != 0L) {
#line 696
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "allocated %dx%d fb\n",
                      psbfb->base.width, psbfb->base.height);
  } else {

  }
#line 699
  mutex_unlock(& dev->struct_mutex);
#line 700
  return (0);
  out_unref: ;
#line 702
  if ((int )backing->stolen) {
#line 703
    psb_gtt_free_range(dev, backing);
  } else {
#line 705
    drm_gem_object_unreference(& backing->gem);
  }
  out_err1: 
#line 707
  mutex_unlock(& dev->struct_mutex);
#line 708
  psb_gtt_free_range(dev, backing);
#line 709
  return (ret);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct drm_framebuffer *psb_user_framebuffer_create(struct drm_device *dev ,
                                                           struct drm_file *filp ,
                                                           struct drm_mode_fb_cmd2 *cmd ) 
{ 
  struct gtt_range *r ;
  struct drm_gem_object *obj ;
  void *tmp ;
  struct drm_gem_object  const  *__mptr ;
  struct drm_framebuffer *tmp___0 ;

  {
#line 731
  obj = drm_gem_object_lookup(dev, filp, cmd->handles[0]);
#line 732
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 733
    tmp = ERR_PTR(-2L);
#line 733
    return ((struct drm_framebuffer *)tmp);
  } else {

  }
#line 736
  __mptr = (struct drm_gem_object  const  *)obj;
#line 736
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 737
  tmp___0 = psb_framebuffer_create(dev, cmd, r);
#line 737
  return (tmp___0);
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psbfb_gamma_set(struct drm_crtc *crtc , u16 red , u16 green , u16 blue ,
                            int regno ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 743
  __mptr = (struct drm_crtc  const  *)crtc;
#line 743
  gma_crtc = (struct gma_crtc *)__mptr;
#line 745
  gma_crtc->lut_r[regno] = (u8 )((int )red >> 8);
#line 746
  gma_crtc->lut_g[regno] = (u8 )((int )green >> 8);
#line 747
  gma_crtc->lut_b[regno] = (u8 )((int )blue >> 8);
#line 748
  return;
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psbfb_gamma_get(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                            int regno ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 753
  __mptr = (struct drm_crtc  const  *)crtc;
#line 753
  gma_crtc = (struct gma_crtc *)__mptr;
#line 755
  *red = (int )((u16 )gma_crtc->lut_r[regno]) << 8U;
#line 756
  *green = (int )((u16 )gma_crtc->lut_g[regno]) << 8U;
#line 757
  *blue = (int )((u16 )gma_crtc->lut_b[regno]) << 8U;
#line 758
  return;
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psbfb_probe(struct drm_fb_helper *helper , struct drm_fb_helper_surface_size *sizes ) 
{ 
  struct psb_fbdev *psb_fbdev ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int bytespp ;
  int tmp ;

  {
#line 763
  psb_fbdev = (struct psb_fbdev *)helper;
#line 764
  dev = psb_fbdev->psb_fb_helper.dev;
#line 765
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 768
  bytespp = (int )(sizes->surface_bpp / 8U);
#line 769
  if (bytespp == 3) {
#line 770
    bytespp = 4;
  } else {

  }
#line 775
  if ((unsigned long )(((sizes->fb_width * (u32 )bytespp + 63U) & 4294967232U) * sizes->fb_height) > dev_priv->vram_stolen_size) {
#line 777
    sizes->surface_bpp = 16U;
#line 778
    sizes->surface_depth = 16U;
  } else {

  }
#line 781
  tmp = psbfb_create(psb_fbdev, sizes);
#line 781
  return (tmp);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct drm_fb_helper_funcs psb_fb_helper_funcs  =    {& psbfb_gamma_set, & psbfb_gamma_get, & psbfb_probe, 0};
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psb_fbdev_destroy(struct drm_device *dev , struct psb_fbdev *fbdev ) 
{ 
  struct fb_info *info ;
  struct psb_framebuffer *psbfb ;

  {
#line 793
  psbfb = & fbdev->pfb;
#line 795
  if ((unsigned long )fbdev->psb_fb_helper.fbdev != (unsigned long )((struct fb_info *)0)) {
#line 796
    info = fbdev->psb_fb_helper.fbdev;
#line 797
    unregister_framebuffer(info);
#line 798
    if (info->cmap.len != 0U) {
#line 799
      fb_dealloc_cmap(& info->cmap);
    } else {

    }
#line 800
    framebuffer_release(info);
  } else {

  }
#line 802
  drm_fb_helper_fini(& fbdev->psb_fb_helper);
#line 803
  drm_framebuffer_unregister_private(& psbfb->base);
#line 804
  drm_framebuffer_cleanup(& psbfb->base);
#line 806
  if ((unsigned long )psbfb->gtt != (unsigned long )((struct gtt_range *)0)) {
#line 807
    drm_gem_object_unreference(& (psbfb->gtt)->gem);
  } else {

  }
#line 808
  return (0);
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
int psb_fbdev_init(struct drm_device *dev ) 
{ 
  struct psb_fbdev *fbdev ;
  struct drm_psb_private *dev_priv ;
  void *tmp ;

  {
#line 814
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 816
  tmp = kzalloc(320UL, 208U);
#line 816
  fbdev = (struct psb_fbdev *)tmp;
#line 817
  if ((unsigned long )fbdev == (unsigned long )((struct psb_fbdev *)0)) {
#line 818
    dev_err((struct device  const  *)dev->dev, "no memory\n");
#line 819
    return (-12);
  } else {

  }
#line 822
  dev_priv->fbdev = (void *)fbdev;
#line 823
  fbdev->psb_fb_helper.funcs = & psb_fb_helper_funcs;
#line 825
  drm_fb_helper_init(dev, & fbdev->psb_fb_helper, (dev_priv->ops)->crtcs, 4);
#line 828
  drm_fb_helper_single_add_all_connectors(& fbdev->psb_fb_helper);
#line 831
  drm_helper_disable_unused_functions(dev);
#line 833
  drm_fb_helper_initial_config(& fbdev->psb_fb_helper, 32);
#line 834
  return (0);
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psb_fbdev_fini(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 839
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 841
  if ((unsigned long )dev_priv->fbdev == (unsigned long )((void *)0)) {
#line 842
    return;
  } else {

  }
#line 844
  psb_fbdev_destroy(dev, (struct psb_fbdev *)dev_priv->fbdev);
#line 845
  kfree((void const   *)dev_priv->fbdev);
#line 846
  dev_priv->fbdev = (void *)0;
#line 847
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psbfb_output_poll_changed(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;

  {
#line 851
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 852
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
#line 853
  drm_fb_helper_hotplug_event(& fbdev->psb_fb_helper);
#line 854
  return;
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;
  int tmp ;

  {
#line 870
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 870
  psbfb = (struct psb_framebuffer *)__mptr;
#line 871
  r = psbfb->gtt;
#line 872
  tmp = drm_gem_handle_create(file_priv, & r->gem, handle);
#line 872
  return (tmp);
}
}
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) 
{ 
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;

  {
#line 884
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 884
  psbfb = (struct psb_framebuffer *)__mptr;
#line 885
  r = psbfb->gtt;
#line 888
  drm_framebuffer_cleanup(fb);
#line 890
  drm_gem_object_unreference_unlocked(& r->gem);
#line 891
  kfree((void const   *)fb);
#line 892
  return;
}
}
#line 894 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static struct drm_mode_config_funcs  const  psb_mode_funcs  =    {& psb_user_framebuffer_create, & psbfb_output_poll_changed};
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static int psb_create_backlight_property(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_property *backlight ;

  {
#line 901
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 904
  if ((unsigned long )dev_priv->backlight_property != (unsigned long )((struct drm_property *)0)) {
#line 905
    return (0);
  } else {

  }
#line 907
  backlight = drm_property_create_range(dev, 0, "backlight", 0ULL, 100ULL);
#line 909
  dev_priv->backlight_property = backlight;
#line 911
  return (0);
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
static void psb_setup_outputs(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_connector *connector ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct drm_encoder *encoder ;
  int crtc_mask ;
  int clone_mask ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 916
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 919
  drm_mode_create_scaling_mode_property(dev);
#line 920
  psb_create_backlight_property(dev);
#line 922
  (*((dev_priv->ops)->output_init))(dev);
#line 924
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 924
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 924
  goto ldv_41135;
  ldv_41134: 
#line 926
  tmp = gma_attached_encoder(connector);
#line 926
  gma_encoder = tmp;
#line 927
  encoder = & gma_encoder->base;
#line 928
  crtc_mask = 0;
#line 928
  clone_mask = 0;
#line 931
  switch (gma_encoder->type) {
  case 1: 
#line 933
  crtc_mask = 1;
#line 934
  clone_mask = 2;
#line 935
  goto ldv_41126;
  case 3: 
#line 937
  crtc_mask = (dev_priv->ops)->sdvo_mask;
#line 938
  clone_mask = 8;
#line 939
  goto ldv_41126;
  case 4: 
#line 941
  crtc_mask = (dev_priv->ops)->lvds_mask;
#line 942
  clone_mask = 16;
#line 943
  goto ldv_41126;
  case 7: 
#line 945
  crtc_mask = 1;
#line 946
  clone_mask = 128;
#line 947
  goto ldv_41126;
  case 8: 
#line 949
  crtc_mask = 4;
#line 950
  clone_mask = 256;
#line 951
  goto ldv_41126;
  case 6: 
#line 953
  crtc_mask = (dev_priv->ops)->hdmi_mask;
#line 954
  clone_mask = 64;
#line 955
  goto ldv_41126;
  case 9: 
#line 957
  crtc_mask = 3;
#line 958
  clone_mask = 512;
#line 959
  goto ldv_41126;
  case 10: 
#line 961
  crtc_mask = 2;
#line 962
  clone_mask = 1024;
  }
  ldv_41126: 
#line 964
  encoder->possible_crtcs = (uint32_t )crtc_mask;
#line 965
  tmp___0 = gma_connector_clones(dev, clone_mask);
#line 965
  encoder->possible_clones = (uint32_t )tmp___0;
#line 924
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 924
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_41135: ;
#line 924
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 926
    goto ldv_41134;
  } else {

  }

#line 931
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void psb_modeset_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  int i ;

  {
#line 972
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 973
  mode_dev = & dev_priv->mode_dev;
#line 976
  drm_mode_config_init(dev);
#line 978
  dev->mode_config.min_width = 0;
#line 979
  dev->mode_config.min_height = 0;
#line 981
  dev->mode_config.funcs = & psb_mode_funcs;
#line 985
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, (u32 *)(& dev->mode_config.fb_base));
#line 989
  i = 0;
#line 989
  goto ldv_41144;
  ldv_41143: 
#line 990
  psb_intel_crtc_init(dev, i, mode_dev);
#line 989
  i = i + 1;
  ldv_41144: ;
#line 989
  if ((uint32_t )i < dev_priv->num_pipe) {
#line 991
    goto ldv_41143;
  } else {

  }
#line 992
  dev->mode_config.max_width = 4096;
#line 993
  dev->mode_config.max_height = 4096;
#line 995
  psb_setup_outputs(dev);
#line 997
  if ((unsigned long )(dev_priv->ops)->errata != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 998
    (*((dev_priv->ops)->errata))(dev);
  } else {

  }
#line 1000
  dev_priv->modeset = 1;
#line 1001
  return;
}
}
#line 1003 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void psb_modeset_cleanup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 1005
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1006
  if ((int )dev_priv->modeset) {
#line 1007
    mutex_lock_nested(& dev->struct_mutex, 0U);
#line 1009
    drm_kms_helper_poll_fini(dev);
#line 1010
    psb_fbdev_fini(dev);
#line 1011
    drm_mode_config_cleanup(dev);
#line 1013
    mutex_unlock(& dev->struct_mutex);
  } else {

  }
#line 1015
  return;
}
}
#line 1017
extern int ldv_probe_57(void) ;
#line 1020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_55(void) 
{ 
  void *tmp ;

  {
#line 1021
  tmp = ldv_zalloc(1632UL);
#line 1021
  psbfb_ops_group0 = (struct fb_info *)tmp;
#line 1022
  return;
}
}
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_vm_operations_struct_56(void) 
{ 
  void *tmp ;

  {
#line 1025
  tmp = ldv_zalloc(184UL);
#line 1025
  psbfb_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 1026
  return;
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_54(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1029
  tmp = ldv_zalloc(160UL);
#line 1029
  psbfb_roll_ops_group0 = (struct fb_var_screeninfo *)tmp;
#line 1030
  tmp___0 = ldv_zalloc(1632UL);
#line 1030
  psbfb_roll_ops_group1 = (struct fb_info *)tmp___0;
#line 1031
  return;
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_mode_config_funcs_51(void) 
{ 
  void *tmp ;

  {
#line 1034
  tmp = ldv_zalloc(2992UL);
#line 1034
  psb_mode_funcs_group0 = (struct drm_device *)tmp;
#line 1035
  return;
}
}
#line 1037 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_fb_helper_funcs_52(void) 
{ 
  void *tmp ;

  {
#line 1038
  tmp = ldv_zalloc(1048UL);
#line 1038
  psb_fb_helper_funcs_group0 = (struct drm_crtc *)tmp;
#line 1039
  return;
}
}
#line 1041 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_drm_framebuffer_funcs_57(void) 
{ 
  void *tmp ;

  {
#line 1042
  tmp = ldv_zalloc(136UL);
#line 1042
  psb_fb_funcs_group0 = (struct drm_framebuffer *)tmp;
#line 1043
  return;
}
}
#line 1045 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_initialize_fb_ops_53(void) 
{ 
  void *tmp ;

  {
#line 1046
  tmp = ldv_zalloc(1632UL);
#line 1046
  psbfb_unaccel_ops_group0 = (struct fb_info *)tmp;
#line 1047
  return;
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_52(void) 
{ 
  u16 *ldvarg169 ;
  void *tmp ;
  u16 ldvarg166 ;
  u16 tmp___0 ;
  int ldvarg168 ;
  int tmp___1 ;
  u16 ldvarg165 ;
  u16 tmp___2 ;
  struct drm_fb_helper *ldvarg163 ;
  void *tmp___3 ;
  u16 *ldvarg171 ;
  void *tmp___4 ;
  u16 *ldvarg170 ;
  void *tmp___5 ;
  int ldvarg172 ;
  int tmp___6 ;
  struct drm_fb_helper_surface_size *ldvarg164 ;
  void *tmp___7 ;
  u16 ldvarg167 ;
  u16 tmp___8 ;
  int tmp___9 ;

  {
#line 1050
  tmp = ldv_zalloc(2UL);
#line 1050
  ldvarg169 = (u16 *)tmp;
#line 1051
  tmp___0 = __VERIFIER_nondet_u16();
#line 1051
  ldvarg166 = tmp___0;
#line 1052
  tmp___1 = __VERIFIER_nondet_int();
#line 1052
  ldvarg168 = tmp___1;
#line 1053
  tmp___2 = __VERIFIER_nondet_u16();
#line 1053
  ldvarg165 = tmp___2;
#line 1054
  tmp___3 = ldv_zalloc(160UL);
#line 1054
  ldvarg163 = (struct drm_fb_helper *)tmp___3;
#line 1055
  tmp___4 = ldv_zalloc(2UL);
#line 1055
  ldvarg171 = (u16 *)tmp___4;
#line 1056
  tmp___5 = ldv_zalloc(2UL);
#line 1056
  ldvarg170 = (u16 *)tmp___5;
#line 1057
  tmp___6 = __VERIFIER_nondet_int();
#line 1057
  ldvarg172 = tmp___6;
#line 1058
  tmp___7 = ldv_zalloc(24UL);
#line 1058
  ldvarg164 = (struct drm_fb_helper_surface_size *)tmp___7;
#line 1059
  tmp___8 = __VERIFIER_nondet_u16();
#line 1059
  ldvarg167 = tmp___8;
#line 1061
  tmp___9 = __VERIFIER_nondet_int();
#line 1061
  switch (tmp___9) {
  case 0: ;
#line 1064
  if (ldv_state_variable_52 == 1) {
#line 1066
    psbfb_gamma_get(psb_fb_helper_funcs_group0, ldvarg171, ldvarg170, ldvarg169, ldvarg172);
#line 1068
    ldv_state_variable_52 = 1;
  } else {

  }
#line 1071
  goto ldv_41187;
  case 1: ;
#line 1074
  if (ldv_state_variable_52 == 1) {
#line 1076
    psbfb_gamma_set(psb_fb_helper_funcs_group0, (int )ldvarg167, (int )ldvarg166,
                    (int )ldvarg165, ldvarg168);
#line 1078
    ldv_state_variable_52 = 1;
  } else {

  }
#line 1081
  goto ldv_41187;
  case 2: ;
#line 1084
  if (ldv_state_variable_52 == 1) {
#line 1086
    psbfb_probe(ldvarg163, ldvarg164);
#line 1088
    ldv_state_variable_52 = 1;
  } else {

  }
#line 1091
  goto ldv_41187;
  default: 
#line 1092
  ldv_stop();
  }
  ldv_41187: ;
#line 1096
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_53(void) 
{ 
  struct fb_image *ldvarg99 ;
  void *tmp ;
  unsigned int ldvarg96 ;
  unsigned int tmp___0 ;
  unsigned long ldvarg92 ;
  unsigned long tmp___1 ;
  struct fb_fillrect *ldvarg89 ;
  void *tmp___2 ;
  unsigned int ldvarg97 ;
  unsigned int tmp___3 ;
  unsigned int ldvarg98 ;
  unsigned int tmp___4 ;
  unsigned int ldvarg93 ;
  unsigned int tmp___5 ;
  struct fb_copyarea *ldvarg100 ;
  void *tmp___6 ;
  struct fb_var_screeninfo *ldvarg90 ;
  void *tmp___7 ;
  int ldvarg91 ;
  int tmp___8 ;
  unsigned int ldvarg94 ;
  unsigned int tmp___9 ;
  struct vm_area_struct *ldvarg101 ;
  void *tmp___10 ;
  unsigned int ldvarg95 ;
  unsigned int tmp___11 ;
  int tmp___12 ;

  {
#line 1099
  tmp = ldv_zalloc(80UL);
#line 1099
  ldvarg99 = (struct fb_image *)tmp;
#line 1100
  tmp___0 = __VERIFIER_nondet_uint();
#line 1100
  ldvarg96 = tmp___0;
#line 1101
  tmp___1 = __VERIFIER_nondet_ulong();
#line 1101
  ldvarg92 = tmp___1;
#line 1102
  tmp___2 = ldv_zalloc(24UL);
#line 1102
  ldvarg89 = (struct fb_fillrect *)tmp___2;
#line 1103
  tmp___3 = __VERIFIER_nondet_uint();
#line 1103
  ldvarg97 = tmp___3;
#line 1104
  tmp___4 = __VERIFIER_nondet_uint();
#line 1104
  ldvarg98 = tmp___4;
#line 1105
  tmp___5 = __VERIFIER_nondet_uint();
#line 1105
  ldvarg93 = tmp___5;
#line 1106
  tmp___6 = ldv_zalloc(24UL);
#line 1106
  ldvarg100 = (struct fb_copyarea *)tmp___6;
#line 1107
  tmp___7 = ldv_zalloc(160UL);
#line 1107
  ldvarg90 = (struct fb_var_screeninfo *)tmp___7;
#line 1108
  tmp___8 = __VERIFIER_nondet_int();
#line 1108
  ldvarg91 = tmp___8;
#line 1109
  tmp___9 = __VERIFIER_nondet_uint();
#line 1109
  ldvarg94 = tmp___9;
#line 1110
  tmp___10 = ldv_zalloc(184UL);
#line 1110
  ldvarg101 = (struct vm_area_struct *)tmp___10;
#line 1111
  tmp___11 = __VERIFIER_nondet_uint();
#line 1111
  ldvarg95 = tmp___11;
#line 1113
  tmp___12 = __VERIFIER_nondet_int();
#line 1113
  switch (tmp___12) {
  case 0: ;
#line 1116
  if (ldv_state_variable_53 == 1) {
#line 1118
    psbfb_mmap(psbfb_unaccel_ops_group0, ldvarg101);
#line 1120
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1123
  goto ldv_41208;
  case 1: ;
#line 1126
  if (ldv_state_variable_53 == 1) {
#line 1128
    cfb_copyarea(psbfb_unaccel_ops_group0, (struct fb_copyarea  const  *)ldvarg100);
#line 1130
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1133
  goto ldv_41208;
  case 2: ;
#line 1136
  if (ldv_state_variable_53 == 1) {
#line 1138
    cfb_imageblit(psbfb_unaccel_ops_group0, (struct fb_image  const  *)ldvarg99);
#line 1140
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1143
  goto ldv_41208;
  case 3: ;
#line 1146
  if (ldv_state_variable_53 == 1) {
#line 1148
    drm_fb_helper_set_par(psbfb_unaccel_ops_group0);
#line 1150
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1153
  goto ldv_41208;
  case 4: ;
#line 1156
  if (ldv_state_variable_53 == 1) {
#line 1158
    psbfb_setcolreg(ldvarg95, ldvarg97, ldvarg96, ldvarg94, ldvarg98, psbfb_unaccel_ops_group0);
#line 1160
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1163
  goto ldv_41208;
  case 5: ;
#line 1166
  if (ldv_state_variable_53 == 1) {
#line 1168
    psbfb_ioctl(psbfb_unaccel_ops_group0, ldvarg93, ldvarg92);
#line 1170
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1173
  goto ldv_41208;
  case 6: ;
#line 1176
  if (ldv_state_variable_53 == 1) {
#line 1178
    drm_fb_helper_blank(ldvarg91, psbfb_unaccel_ops_group0);
#line 1180
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1183
  goto ldv_41208;
  case 7: ;
#line 1186
  if (ldv_state_variable_53 == 1) {
#line 1188
    drm_fb_helper_check_var(ldvarg90, psbfb_unaccel_ops_group0);
#line 1190
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1193
  goto ldv_41208;
  case 8: ;
#line 1196
  if (ldv_state_variable_53 == 1) {
#line 1198
    cfb_fillrect(psbfb_unaccel_ops_group0, (struct fb_fillrect  const  *)ldvarg89);
#line 1200
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1203
  goto ldv_41208;
  default: 
#line 1204
  ldv_stop();
  }
  ldv_41208: ;
#line 1208
  return;
}
}
#line 1210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_57(void) 
{ 
  struct drm_file *ldvarg52 ;
  void *tmp ;
  unsigned int *ldvarg51 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1211
  tmp = ldv_zalloc(744UL);
#line 1211
  ldvarg52 = (struct drm_file *)tmp;
#line 1212
  tmp___0 = ldv_zalloc(4UL);
#line 1212
  ldvarg51 = (unsigned int *)tmp___0;
#line 1214
  tmp___1 = __VERIFIER_nondet_int();
#line 1214
  switch (tmp___1) {
  case 0: ;
#line 1217
  if (ldv_state_variable_57 == 2) {
#line 1219
    psb_user_framebuffer_destroy(psb_fb_funcs_group0);
#line 1221
    ldv_state_variable_57 = 1;
#line 1222
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1225
  goto ldv_41224;
  case 1: ;
#line 1228
  if (ldv_state_variable_57 == 1) {
#line 1230
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg52, ldvarg51);
#line 1232
    ldv_state_variable_57 = 1;
  } else {

  }
#line 1235
  if (ldv_state_variable_57 == 2) {
#line 1237
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg52, ldvarg51);
#line 1239
    ldv_state_variable_57 = 2;
  } else {

  }
#line 1242
  goto ldv_41224;
  case 2: ;
#line 1245
  if (ldv_state_variable_57 == 1) {
#line 1247
    ldv_probe_57();
#line 1249
    ldv_state_variable_57 = 2;
#line 1250
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1253
  goto ldv_41224;
  default: 
#line 1254
  ldv_stop();
  }
  ldv_41224: ;
#line 1258
  return;
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_56(void) 
{ 
  struct vm_fault *ldvarg179 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1261
  tmp = ldv_zalloc(48UL);
#line 1261
  ldvarg179 = (struct vm_fault *)tmp;
#line 1263
  tmp___0 = __VERIFIER_nondet_int();
#line 1263
  switch (tmp___0) {
  case 0: ;
#line 1266
  if (ldv_state_variable_56 == 2) {
#line 1268
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg179);
#line 1270
    ldv_state_variable_56 = 2;
  } else {

  }
#line 1273
  if (ldv_state_variable_56 == 1) {
#line 1275
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg179);
#line 1277
    ldv_state_variable_56 = 1;
  } else {

  }
#line 1280
  goto ldv_41233;
  case 1: ;
#line 1283
  if (ldv_state_variable_56 == 2) {
#line 1285
    psbfb_vm_close(psbfb_vm_ops_group0);
#line 1286
    ldv_state_variable_56 = 1;
  } else {

  }
#line 1289
  goto ldv_41233;
  case 2: ;
#line 1292
  if (ldv_state_variable_56 == 1) {
#line 1294
    psbfb_vm_open(psbfb_vm_ops_group0);
#line 1295
    ldv_state_variable_56 = 2;
#line 1296
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1299
  goto ldv_41233;
  default: 
#line 1300
  ldv_stop();
  }
  ldv_41233: ;
#line 1304
  return;
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_51(void) 
{ 
  struct drm_mode_fb_cmd2 *ldvarg144 ;
  void *tmp ;
  struct drm_file *ldvarg145 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1307
  tmp = ldv_zalloc(68UL);
#line 1307
  ldvarg144 = (struct drm_mode_fb_cmd2 *)tmp;
#line 1308
  tmp___0 = ldv_zalloc(744UL);
#line 1308
  ldvarg145 = (struct drm_file *)tmp___0;
#line 1310
  tmp___1 = __VERIFIER_nondet_int();
#line 1310
  switch (tmp___1) {
  case 0: ;
#line 1313
  if (ldv_state_variable_51 == 1) {
#line 1315
    psb_user_framebuffer_create(psb_mode_funcs_group0, ldvarg145, ldvarg144);
#line 1317
    ldv_state_variable_51 = 1;
  } else {

  }
#line 1320
  goto ldv_41243;
  case 1: ;
#line 1323
  if (ldv_state_variable_51 == 1) {
#line 1325
    psbfb_output_poll_changed(psb_mode_funcs_group0);
#line 1327
    ldv_state_variable_51 = 1;
  } else {

  }
#line 1330
  goto ldv_41243;
  default: 
#line 1331
  ldv_stop();
  }
  ldv_41243: ;
#line 1335
  return;
}
}
#line 1337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_55(void) 
{ 
  unsigned int ldvarg28 ;
  unsigned int tmp ;
  struct fb_image *ldvarg34 ;
  void *tmp___0 ;
  unsigned int ldvarg29 ;
  unsigned int tmp___1 ;
  struct vm_area_struct *ldvarg36 ;
  void *tmp___2 ;
  struct fb_var_screeninfo *ldvarg25 ;
  void *tmp___3 ;
  unsigned int ldvarg30 ;
  unsigned int tmp___4 ;
  unsigned int ldvarg33 ;
  unsigned int tmp___5 ;
  unsigned int ldvarg31 ;
  unsigned int tmp___6 ;
  unsigned int ldvarg32 ;
  unsigned int tmp___7 ;
  struct fb_copyarea *ldvarg35 ;
  void *tmp___8 ;
  int ldvarg26 ;
  int tmp___9 ;
  unsigned long ldvarg27 ;
  unsigned long tmp___10 ;
  struct fb_fillrect *ldvarg24 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
#line 1338
  tmp = __VERIFIER_nondet_uint();
#line 1338
  ldvarg28 = tmp;
#line 1339
  tmp___0 = ldv_zalloc(80UL);
#line 1339
  ldvarg34 = (struct fb_image *)tmp___0;
#line 1340
  tmp___1 = __VERIFIER_nondet_uint();
#line 1340
  ldvarg29 = tmp___1;
#line 1341
  tmp___2 = ldv_zalloc(184UL);
#line 1341
  ldvarg36 = (struct vm_area_struct *)tmp___2;
#line 1342
  tmp___3 = ldv_zalloc(160UL);
#line 1342
  ldvarg25 = (struct fb_var_screeninfo *)tmp___3;
#line 1343
  tmp___4 = __VERIFIER_nondet_uint();
#line 1343
  ldvarg30 = tmp___4;
#line 1344
  tmp___5 = __VERIFIER_nondet_uint();
#line 1344
  ldvarg33 = tmp___5;
#line 1345
  tmp___6 = __VERIFIER_nondet_uint();
#line 1345
  ldvarg31 = tmp___6;
#line 1346
  tmp___7 = __VERIFIER_nondet_uint();
#line 1346
  ldvarg32 = tmp___7;
#line 1347
  tmp___8 = ldv_zalloc(24UL);
#line 1347
  ldvarg35 = (struct fb_copyarea *)tmp___8;
#line 1348
  tmp___9 = __VERIFIER_nondet_int();
#line 1348
  ldvarg26 = tmp___9;
#line 1349
  tmp___10 = __VERIFIER_nondet_ulong();
#line 1349
  ldvarg27 = tmp___10;
#line 1350
  tmp___11 = ldv_zalloc(24UL);
#line 1350
  ldvarg24 = (struct fb_fillrect *)tmp___11;
#line 1352
  tmp___12 = __VERIFIER_nondet_int();
#line 1352
  switch (tmp___12) {
  case 0: ;
#line 1355
  if (ldv_state_variable_55 == 1) {
#line 1357
    psbfb_mmap(psbfb_ops_group0, ldvarg36);
#line 1359
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1362
  goto ldv_41263;
  case 1: ;
#line 1365
  if (ldv_state_variable_55 == 1) {
#line 1367
    psbfb_copyarea(psbfb_ops_group0, (struct fb_copyarea  const  *)ldvarg35);
#line 1369
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1372
  goto ldv_41263;
  case 2: ;
#line 1375
  if (ldv_state_variable_55 == 1) {
#line 1377
    psbfb_sync(psbfb_ops_group0);
#line 1379
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1382
  goto ldv_41263;
  case 3: ;
#line 1385
  if (ldv_state_variable_55 == 1) {
#line 1387
    cfb_imageblit(psbfb_ops_group0, (struct fb_image  const  *)ldvarg34);
#line 1389
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1392
  goto ldv_41263;
  case 4: ;
#line 1395
  if (ldv_state_variable_55 == 1) {
#line 1397
    drm_fb_helper_set_par(psbfb_ops_group0);
#line 1399
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1402
  goto ldv_41263;
  case 5: ;
#line 1405
  if (ldv_state_variable_55 == 1) {
#line 1407
    psbfb_setcolreg(ldvarg30, ldvarg32, ldvarg31, ldvarg29, ldvarg33, psbfb_ops_group0);
#line 1409
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1412
  goto ldv_41263;
  case 6: ;
#line 1415
  if (ldv_state_variable_55 == 1) {
#line 1417
    psbfb_ioctl(psbfb_ops_group0, ldvarg28, ldvarg27);
#line 1419
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1422
  goto ldv_41263;
  case 7: ;
#line 1425
  if (ldv_state_variable_55 == 1) {
#line 1427
    drm_fb_helper_blank(ldvarg26, psbfb_ops_group0);
#line 1429
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1432
  goto ldv_41263;
  case 8: ;
#line 1435
  if (ldv_state_variable_55 == 1) {
#line 1437
    drm_fb_helper_check_var(ldvarg25, psbfb_ops_group0);
#line 1439
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1442
  goto ldv_41263;
  case 9: ;
#line 1445
  if (ldv_state_variable_55 == 1) {
#line 1447
    cfb_fillrect(psbfb_ops_group0, (struct fb_fillrect  const  *)ldvarg24);
#line 1449
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1452
  goto ldv_41263;
  default: 
#line 1453
  ldv_stop();
  }
  ldv_41263: ;
#line 1457
  return;
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void ldv_main_exported_54(void) 
{ 
  struct vm_area_struct *ldvarg210 ;
  void *tmp ;
  unsigned int ldvarg206 ;
  unsigned int tmp___0 ;
  unsigned long ldvarg201 ;
  unsigned long tmp___1 ;
  struct fb_fillrect *ldvarg199 ;
  void *tmp___2 ;
  unsigned int ldvarg205 ;
  unsigned int tmp___3 ;
  struct fb_copyarea *ldvarg209 ;
  void *tmp___4 ;
  unsigned int ldvarg202 ;
  unsigned int tmp___5 ;
  unsigned int ldvarg207 ;
  unsigned int tmp___6 ;
  struct fb_image *ldvarg208 ;
  void *tmp___7 ;
  int ldvarg200 ;
  int tmp___8 ;
  unsigned int ldvarg203 ;
  unsigned int tmp___9 ;
  unsigned int ldvarg204 ;
  unsigned int tmp___10 ;
  int tmp___11 ;

  {
#line 1460
  tmp = ldv_zalloc(184UL);
#line 1460
  ldvarg210 = (struct vm_area_struct *)tmp;
#line 1461
  tmp___0 = __VERIFIER_nondet_uint();
#line 1461
  ldvarg206 = tmp___0;
#line 1462
  tmp___1 = __VERIFIER_nondet_ulong();
#line 1462
  ldvarg201 = tmp___1;
#line 1463
  tmp___2 = ldv_zalloc(24UL);
#line 1463
  ldvarg199 = (struct fb_fillrect *)tmp___2;
#line 1464
  tmp___3 = __VERIFIER_nondet_uint();
#line 1464
  ldvarg205 = tmp___3;
#line 1465
  tmp___4 = ldv_zalloc(24UL);
#line 1465
  ldvarg209 = (struct fb_copyarea *)tmp___4;
#line 1466
  tmp___5 = __VERIFIER_nondet_uint();
#line 1466
  ldvarg202 = tmp___5;
#line 1467
  tmp___6 = __VERIFIER_nondet_uint();
#line 1467
  ldvarg207 = tmp___6;
#line 1468
  tmp___7 = ldv_zalloc(80UL);
#line 1468
  ldvarg208 = (struct fb_image *)tmp___7;
#line 1469
  tmp___8 = __VERIFIER_nondet_int();
#line 1469
  ldvarg200 = tmp___8;
#line 1470
  tmp___9 = __VERIFIER_nondet_uint();
#line 1470
  ldvarg203 = tmp___9;
#line 1471
  tmp___10 = __VERIFIER_nondet_uint();
#line 1471
  ldvarg204 = tmp___10;
#line 1473
  tmp___11 = __VERIFIER_nondet_int();
#line 1473
  switch (tmp___11) {
  case 0: ;
#line 1476
  if (ldv_state_variable_54 == 1) {
#line 1478
    psbfb_mmap(psbfb_roll_ops_group1, ldvarg210);
#line 1480
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1483
  goto ldv_41290;
  case 1: ;
#line 1486
  if (ldv_state_variable_54 == 1) {
#line 1488
    psbfb_pan(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
#line 1490
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1493
  goto ldv_41290;
  case 2: ;
#line 1496
  if (ldv_state_variable_54 == 1) {
#line 1498
    cfb_copyarea(psbfb_roll_ops_group1, (struct fb_copyarea  const  *)ldvarg209);
#line 1500
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1503
  goto ldv_41290;
  case 3: ;
#line 1506
  if (ldv_state_variable_54 == 1) {
#line 1508
    cfb_imageblit(psbfb_roll_ops_group1, (struct fb_image  const  *)ldvarg208);
#line 1510
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1513
  goto ldv_41290;
  case 4: ;
#line 1516
  if (ldv_state_variable_54 == 1) {
#line 1518
    drm_fb_helper_set_par(psbfb_roll_ops_group1);
#line 1520
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1523
  goto ldv_41290;
  case 5: ;
#line 1526
  if (ldv_state_variable_54 == 1) {
#line 1528
    psbfb_setcolreg(ldvarg204, ldvarg206, ldvarg205, ldvarg203, ldvarg207, psbfb_roll_ops_group1);
#line 1530
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1533
  goto ldv_41290;
  case 6: ;
#line 1536
  if (ldv_state_variable_54 == 1) {
#line 1538
    psbfb_ioctl(psbfb_roll_ops_group1, ldvarg202, ldvarg201);
#line 1540
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1543
  goto ldv_41290;
  case 7: ;
#line 1546
  if (ldv_state_variable_54 == 1) {
#line 1548
    drm_fb_helper_blank(ldvarg200, psbfb_roll_ops_group1);
#line 1550
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1553
  goto ldv_41290;
  case 8: ;
#line 1556
  if (ldv_state_variable_54 == 1) {
#line 1558
    drm_fb_helper_check_var(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
#line 1560
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1563
  goto ldv_41290;
  case 9: ;
#line 1566
  if (ldv_state_variable_54 == 1) {
#line 1568
    cfb_fillrect(psbfb_roll_ops_group1, (struct fb_fillrect  const  *)ldvarg199);
#line 1570
    ldv_state_variable_54 = 1;
  } else {

  }
#line 1573
  goto ldv_41290;
  default: 
#line 1574
  ldv_stop();
  }
  ldv_41290: ;
#line 1578
  return;
}
}
#line 1706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
void *ldv_kmem_cache_alloc_56(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1709
  ldv_check_alloc_flags(flags);
#line 1711
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1712
  return ((void *)0);
}
}
#line 1714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/framebuffer.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 1717
  ldv_check_alloc_flags(flags);
#line 1718
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_76(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 1958 "include/linux/mm.h"
extern int vm_insert_pfn(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 92 "include/linux/pagemap.h"
__inline static void mapping_set_gfp_mask(struct address_space *m , gfp_t mask ) 
{ 


  {
#line 94
  m->flags = (m->flags & 0xfffffffffe000000UL) | (unsigned long )mask;
#line 96
  return;
}
}
#line 213 "include/drm/drm_vma_manager.h"
__inline static __u64 drm_vma_node_offset_addr(struct drm_vma_offset_node *node ) 
{ 


  {
#line 215
  return ((unsigned long long )node->vm_node.start << 12);
}
}
#line 1524 "include/drm/drmP.h"
extern void drm_gem_object_release(struct drm_gem_object * ) ;
#line 1526
extern int drm_gem_object_init(struct drm_device * , struct drm_gem_object * , size_t  ) ;
#line 1573
extern void drm_gem_free_mmap_offset(struct drm_gem_object * ) ;
#line 1574
extern int drm_gem_create_mmap_offset(struct drm_gem_object * ) ;
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gtt.h"
int psb_gtt_pin(struct gtt_range *gt ) ;
#line 741 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_gem_free_object(struct drm_gem_object *obj ) ;
#line 742
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) ;
#line 744
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
#line 746
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) ;
#line 748
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void psb_gem_free_object(struct drm_gem_object *obj ) 
{ 
  struct gtt_range *gtt ;
  struct drm_gem_object  const  *__mptr ;

  {
#line 254
  __mptr = (struct drm_gem_object  const  *)obj;
#line 254
  gtt = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 257
  drm_gem_free_mmap_offset(obj);
#line 258
  drm_gem_object_release(obj);
#line 261
  psb_gtt_free_range(obj->dev, gtt);
#line 262
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) 
{ 


  {
#line 267
  return (-22);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) 
{ 
  int ret ;
  struct drm_gem_object *obj ;

  {
#line 282
  ret = 0;
#line 285
  mutex_lock_nested(& dev->struct_mutex, 0U);
#line 288
  obj = drm_gem_object_lookup(dev, file, handle);
#line 289
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 290
    ret = -2;
#line 291
    goto unlock;
  } else {

  }
#line 296
  ret = drm_gem_create_mmap_offset(obj);
#line 297
  if (ret != 0) {
#line 298
    goto out;
  } else {

  }
#line 299
  *offset = drm_vma_node_offset_addr(& obj->vma_node);
  out: 
#line 301
  drm_gem_object_unreference(obj);
  unlock: 
#line 303
  mutex_unlock(& dev->struct_mutex);
#line 304
  return (ret);
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int psb_gem_create(struct drm_file *file , struct drm_device *dev , u64 size , u32 *handlep ,
                   int stolen , u32 align ) 
{ 
  struct gtt_range *r ;
  int ret ;
  u32 handle ;
  unsigned long __y ;
  int tmp ;

  {
#line 325
  __y = 4096UL;
#line 325
  size = ((((unsigned long long )__y + size) - 1ULL) / (unsigned long long )__y) * (unsigned long long )__y;
#line 329
  r = psb_gtt_alloc_range(dev, (int )size, "gem", 0, 4096U);
#line 330
  if ((unsigned long )r == (unsigned long )((struct gtt_range *)0)) {
#line 331
    dev_err((struct device  const  *)dev->dev, "no memory for %lld byte GEM object\n",
            size);
#line 332
    return (-28);
  } else {

  }
#line 335
  tmp = drm_gem_object_init(dev, & r->gem, (size_t )size);
#line 335
  if (tmp != 0) {
#line 336
    psb_gtt_free_range(dev, r);
#line 338
    dev_err((struct device  const  *)dev->dev, "GEM init failed for %lld\n", size);
#line 339
    return (-12);
  } else {

  }
#line 342
  mapping_set_gfp_mask((r->gem.filp)->f_mapping, 212U);
#line 344
  ret = drm_gem_handle_create(file, & r->gem, & handle);
#line 345
  if (ret != 0) {
#line 346
    dev_err((struct device  const  *)dev->dev, "GEM handle failed for %p, %lld\n",
            & r->gem, size);
#line 348
    drm_gem_object_release(& r->gem);
#line 349
    psb_gtt_free_range(dev, r);
#line 350
    return (ret);
  } else {

  }
#line 353
  drm_gem_object_unreference(& r->gem);
#line 354
  *handlep = handle;
#line 355
  return (0);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) 
{ 
  int tmp ;

  {
#line 371
  args->pitch = (args->width * ((args->bpp + 7U) / 8U) + 63U) & 4294967232U;
#line 372
  args->size = (uint64_t )(args->pitch * args->height);
#line 373
  tmp = psb_gem_create(file, dev, args->size, & args->handle, 0, 4096U);
#line 373
  return (tmp);
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct drm_gem_object *obj ;
  struct gtt_range *r ;
  int ret ;
  unsigned long pfn ;
  unsigned long page_offset___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_gem_object  const  *__mptr ;

  {
#line 404
  obj = (struct drm_gem_object *)vma->vm_private_data;
#line 405
  dev = obj->dev;
#line 406
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 408
  __mptr = (struct drm_gem_object  const  *)obj;
#line 408
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
#line 412
  mutex_lock_nested(& dev->struct_mutex, 0U);
#line 416
  if (! r->mmapping) {
#line 417
    ret = psb_gtt_pin(r);
#line 418
    if (ret < 0) {
#line 419
      dev_err((struct device  const  *)dev->dev, "gma500: pin failed: %d\n", ret);
#line 420
      goto fail;
    } else {

    }
#line 422
    r->mmapping = 1;
  } else {

  }
#line 427
  page_offset___0 = ((unsigned long )vmf->virtual_address - vma->vm_start) >> 12;
#line 431
  if ((int )r->stolen) {
#line 432
    pfn = (unsigned long )((dev_priv->stolen_base + r->offset) >> 12);
  } else {
#line 434
    pfn = (unsigned long )(((long )*(r->pages + page_offset___0) + 24189255811072L) / 64L);
  }
#line 435
  ret = vm_insert_pfn(vma, (unsigned long )vmf->virtual_address, pfn);
  fail: 
#line 438
  mutex_unlock(& dev->struct_mutex);
#line 439
  switch (ret) {
  case 0: ;
  case -512: ;
  case -4: ;
#line 443
  return (256);
  case -12: ;
#line 445
  return (1);
  default: ;
#line 447
  return (2);
  }
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gem.o.c.prepared"
void *ldv_kmem_cache_alloc_76(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 581
  ldv_check_alloc_flags(flags);
#line 583
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 584
  return ((void *)0);
}
}
#line 28 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 30
  return ((long )ptr);
}
}
#line 33 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 35
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 35
  return (tmp != 0L);
}
}
#line 120 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 86 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 143 "include/linux/ioport.h"
extern int release_resource(struct resource * ) ;
#line 152
extern int allocate_resource(struct resource * , struct resource * , resource_size_t  ,
                             resource_size_t  , resource_size_t  , resource_size_t  ,
                             resource_size_t (*)(void * , struct resource  const  * ,
                                                 resource_size_t  , resource_size_t  ) ,
                             void * ) ;
#line 175 "./arch/x86/include/asm/io.h"
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 188
extern void iounmap(void volatile   * ) ;
#line 318
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_96(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 844 "include/linux/pci.h"
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 850
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 860 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 862
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 862
  return (tmp);
}
}
#line 873 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 875
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 875
  return (tmp);
}
}
#line 113 "./arch/x86/include/asm/cacheflush.h"
extern int set_pages_array_wc(struct page ** , int  ) ;
#line 114
extern int set_pages_array_wb(struct page ** , int  ) ;
#line 125 "include/drm/drmP.h"
extern void drm_ut_debug_printk(char const   * , char const   *  , ...) ;
#line 128
extern int drm_err(char const   * , char const   *  , ...) ;
#line 1397
extern unsigned int drm_debug ;
#line 1577
extern struct page **drm_gem_get_pages(struct drm_gem_object * , gfp_t  ) ;
#line 1578
extern void drm_gem_put_pages(struct drm_gem_object * , struct page ** , bool  , bool  ) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gtt.h"
int psb_gtt_init(struct drm_device *dev , int resume ) ;
#line 40
void psb_gtt_takedown(struct drm_device *dev ) ;
#line 61
void psb_gtt_unpin(struct gtt_range *gt ) ;
#line 64
int psb_gtt_restore(struct drm_device *dev ) ;
#line 67 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) ;
#line 84
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) ;
#line 88
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) ;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/blitter.h"
int gma_blt_wait_idle(struct drm_psb_private *dev_priv ) ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
__inline static uint32_t psb_gtt_mask_pte(uint32_t pfn , int type ) 
{ 
  uint32_t mask ;
  long tmp ;

  {
#line 261
  mask = 1U;
#line 265
  tmp = ldv__builtin_expect((pfn & 4293918720U) != 0U, 0L);
#line 265
  if (tmp != 0L) {
#line 265
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"),
                         "i" (265), "i" (12UL));
    ldv_41227: ;
#line 265
    goto ldv_41227;
  } else {

  }
#line 267
  if (type & 1) {
#line 268
    mask = mask | 8U;
  } else {

  }
#line 269
  if ((type & 2) != 0) {
#line 270
    mask = mask | 4U;
  } else {

  }
#line 271
  if ((type & 4) != 0) {
#line 272
    mask = mask | 2U;
  } else {

  }
#line 274
  return ((pfn << 12) | mask);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
static u32 *psb_gtt_entry(struct drm_device *dev , struct gtt_range *r ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long offset ;

  {
#line 287
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 290
  offset = (unsigned long )(r->resource.start - (dev_priv->gtt_mem)->start);
#line 292
  return (dev_priv->gtt_map + (offset >> 12));
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
static int psb_gtt_insert(struct drm_device *dev , struct gtt_range *r , int resume ) 
{ 
  u32 *gtt_slot ;
  u32 pte ;
  struct page **pages ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;

  {
#line 312
  if ((unsigned long )r->pages == (unsigned long )((struct page **)0)) {
#line 313
    __ret_warn_on = 1;
#line 313
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 313
    if (tmp != 0L) {
#line 313
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                         313);
    } else {

    }
#line 313
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 314
    return (-22);
  } else {

  }
#line 317
  __ret_warn_on___0 = (int )r->stolen;
#line 317
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 317
  if (tmp___0 != 0L) {
#line 317
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                       317);
  } else {

  }
#line 317
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 319
  gtt_slot = psb_gtt_entry(dev, r);
#line 320
  pages = r->pages;
#line 322
  if (resume == 0) {
#line 324
    set_pages_array_wc(pages, r->npage);
  } else {

  }
#line 328
  i = r->roll;
#line 328
  goto ldv_41248;
  ldv_41247: 
#line 329
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 331
  tmp___1 = gtt_slot;
#line 331
  gtt_slot = gtt_slot + 1;
#line 331
  iowrite32(pte, (void *)tmp___1);
#line 328
  i = i + 1;
  ldv_41248: ;
#line 328
  if (r->npage > i) {
#line 330
    goto ldv_41247;
  } else {

  }
#line 333
  i = 0;
#line 333
  goto ldv_41251;
  ldv_41250: 
#line 334
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 336
  tmp___2 = gtt_slot;
#line 336
  gtt_slot = gtt_slot + 1;
#line 336
  iowrite32(pte, (void *)tmp___2);
#line 333
  i = i + 1;
  ldv_41251: ;
#line 333
  if (r->roll > i) {
#line 335
    goto ldv_41250;
  } else {

  }
#line 339
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 341
  return (0);
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void psb_gtt_remove(struct drm_device *dev , struct gtt_range *r ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;

  {
#line 355
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 360
  __ret_warn_on = (int )r->stolen;
#line 360
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 360
  if (tmp != 0L) {
#line 360
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                       360);
  } else {

  }
#line 360
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 362
  gtt_slot = psb_gtt_entry(dev, r);
#line 363
  pte = psb_gtt_mask_pte((uint32_t )(((long )dev_priv->scratch_page + 24189255811072L) / 64L),
                         1);
#line 366
  i = 0;
#line 366
  goto ldv_41264;
  ldv_41263: 
#line 367
  tmp___0 = gtt_slot;
#line 367
  gtt_slot = gtt_slot + 1;
#line 367
  iowrite32(pte, (void *)tmp___0);
#line 366
  i = i + 1;
  ldv_41264: ;
#line 366
  if (r->npage > i) {
#line 368
    goto ldv_41263;
  } else {

  }
#line 368
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 369
  set_pages_array_wb(r->pages, r->npage);
#line 370
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) 
{ 
  u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;

  {
#line 388
  if (r->npage <= roll) {
#line 389
    __ret_warn_on = 1;
#line 389
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 389
    if (tmp != 0L) {
#line 389
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                         389);
    } else {

    }
#line 389
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 390
    return;
  } else {

  }
#line 393
  r->roll = roll;
#line 397
  if (! r->stolen && r->in_gart == 0) {
#line 398
    return;
  } else {

  }
#line 400
  gtt_slot = psb_gtt_entry(dev, r);
#line 402
  i = r->roll;
#line 402
  goto ldv_41277;
  ldv_41276: 
#line 403
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 405
  tmp___0 = gtt_slot;
#line 405
  gtt_slot = gtt_slot + 1;
#line 405
  iowrite32(pte, (void *)tmp___0);
#line 402
  i = i + 1;
  ldv_41277: ;
#line 402
  if (r->npage > i) {
#line 404
    goto ldv_41276;
  } else {

  }
#line 407
  i = 0;
#line 407
  goto ldv_41280;
  ldv_41279: 
#line 408
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 64L),
                         1);
#line 410
  tmp___1 = gtt_slot;
#line 410
  gtt_slot = gtt_slot + 1;
#line 410
  iowrite32(pte, (void *)tmp___1);
#line 407
  i = i + 1;
  ldv_41280: ;
#line 407
  if (r->roll > i) {
#line 409
    goto ldv_41279;
  } else {

  }
#line 412
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
#line 413
  return;
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
static int psb_gtt_attach_pages(struct gtt_range *gt ) 
{ 
  struct page **pages ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 427
  __ret_warn_on = (unsigned long )gt->pages != (unsigned long )((struct page **)0);
#line 427
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 427
  if (tmp != 0L) {
#line 427
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                       427);
  } else {

  }
#line 427
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 429
  pages = drm_gem_get_pages(& gt->gem, 0U);
#line 430
  tmp___1 = IS_ERR((void const   *)pages);
#line 430
  if ((int )tmp___1) {
#line 431
    tmp___0 = PTR_ERR((void const   *)pages);
#line 431
    return ((int )tmp___0);
  } else {

  }
#line 433
  gt->npage = (int )(gt->gem.size / 4096UL);
#line 434
  gt->pages = pages;
#line 436
  return (0);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
static void psb_gtt_detach_pages(struct gtt_range *gt ) 
{ 


  {
#line 450
  drm_gem_put_pages(& gt->gem, gt->pages, 1, 0);
#line 451
  gt->pages = (struct page **)0;
#line 452
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int psb_gtt_pin(struct gtt_range *gt ) 
{ 
  int ret ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 gpu_base ;
  struct psb_mmu_pd *tmp ;

  {
#line 466
  ret = 0;
#line 467
  dev = gt->gem.dev;
#line 468
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 469
  gpu_base = dev_priv->gtt.gatt_start;
#line 471
  mutex_lock_nested(& dev_priv->gtt_mutex, 0U);
#line 473
  if (gt->in_gart == 0 && ! gt->stolen) {
#line 474
    ret = psb_gtt_attach_pages(gt);
#line 475
    if (ret < 0) {
#line 476
      goto out;
    } else {

    }
#line 477
    ret = psb_gtt_insert(dev, gt, 0);
#line 478
    if (ret < 0) {
#line 479
      psb_gtt_detach_pages(gt);
#line 480
      goto out;
    } else {

    }
#line 482
    tmp = psb_mmu_get_default_pd(dev_priv->mmu);
#line 482
    psb_mmu_insert_pages(tmp, gt->pages, (unsigned long )(gt->offset + gpu_base),
                         (uint32_t )gt->npage, 0U, 0U, 1);
  } else {

  }
#line 486
  gt->in_gart = gt->in_gart + 1;
  out: 
#line 488
  mutex_unlock(& dev_priv->gtt_mutex);
#line 489
  return (ret);
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void psb_gtt_unpin(struct gtt_range *gt ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 gpu_base ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;
  struct psb_mmu_pd *tmp___0 ;

  {
#line 505
  dev = gt->gem.dev;
#line 506
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 507
  gpu_base = dev_priv->gtt.gatt_start;
#line 511
  mutex_lock_nested(& dev_priv->gtt_mutex, 0U);
#line 514
  ret = gma_blt_wait_idle(dev_priv);
#line 515
  if (ret != 0) {
#line 516
    drm_err("psb_gtt_unpin", "Failed to idle the blitter, unpin failed!");
#line 517
    goto out;
  } else {

  }
#line 520
  __ret_warn_on = gt->in_gart == 0;
#line 520
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 520
  if (tmp != 0L) {
#line 520
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                       520);
  } else {

  }
#line 520
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 522
  gt->in_gart = gt->in_gart - 1;
#line 523
  if (gt->in_gart == 0 && ! gt->stolen) {
#line 524
    tmp___0 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 524
    psb_mmu_remove_pages(tmp___0, (unsigned long )(gt->offset + gpu_base), (uint32_t )gt->npage,
                         0U, 0U);
#line 526
    psb_gtt_remove(dev, gt);
#line 527
    psb_gtt_detach_pages(gt);
  } else {

  }
  out: 
#line 531
  mutex_unlock(& dev_priv->gtt_mutex);
#line 532
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed , u32 align ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gtt_range *gt ;
  struct resource *r ;
  int ret ;
  unsigned long start ;
  unsigned long end ;
  void *tmp ;

  {
#line 555
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 557
  r = dev_priv->gtt_mem;
#line 561
  if (backed != 0) {
#line 563
    start = (unsigned long )r->start;
#line 564
    end = (unsigned long )((r->start + (unsigned long long )dev_priv->gtt.stolen_size) - 1ULL);
  } else {
#line 567
    start = (unsigned long )(r->start + (unsigned long long )dev_priv->gtt.stolen_size);
#line 568
    end = (unsigned long )r->end;
  }
#line 571
  tmp = kzalloc(336UL, 208U);
#line 571
  gt = (struct gtt_range *)tmp;
#line 572
  if ((unsigned long )gt == (unsigned long )((struct gtt_range *)0)) {
#line 573
    return ((struct gtt_range *)0);
  } else {

  }
#line 574
  gt->resource.name = name;
#line 575
  gt->stolen = backed != 0;
#line 576
  gt->in_gart = backed;
#line 577
  gt->roll = 0;
#line 579
  gt->gem.dev = dev;
#line 580
  ret = allocate_resource(dev_priv->gtt_mem, & gt->resource, (resource_size_t )len,
                          (resource_size_t )start, (resource_size_t )end, (resource_size_t )align,
                          (resource_size_t (*)(void * , struct resource  const  * ,
                                               resource_size_t  , resource_size_t  ))0,
                          (void *)0);
#line 582
  if (ret == 0) {
#line 583
    gt->offset = (u32 )gt->resource.start - (u32 )r->start;
#line 584
    return (gt);
  } else {

  }
#line 586
  kfree((void const   *)gt);
#line 587
  return ((struct gtt_range *)0);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 601
  if ((int )gt->mmapping) {
#line 602
    psb_gtt_unpin(gt);
#line 603
    gt->mmapping = 0;
  } else {

  }
#line 605
  __ret_warn_on = gt->in_gart != 0 && ! gt->stolen;
#line 605
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 605
  if (tmp != 0L) {
#line 605
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared",
                       605);
  } else {

  }
#line 605
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 606
  release_resource(& gt->resource);
#line 607
  kfree((void const   *)gt);
#line 608
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
static void psb_gtt_alloc(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;

  {
#line 612
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 613
  __init_rwsem(& dev_priv->gtt.sem, "&dev_priv->gtt.sem", & __key);
#line 615
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void psb_gtt_takedown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 618
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 620
  if ((unsigned long )dev_priv->gtt_map != (unsigned long )((u32 *)0U)) {
#line 621
    iounmap((void volatile   *)dev_priv->gtt_map);
#line 622
    dev_priv->gtt_map = (u32 *)0U;
  } else {

  }
#line 624
  if (dev_priv->gtt_initialized != 0) {
#line 625
    pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )dev_priv->gmch_ctrl);
#line 627
    iowrite32(dev_priv->pge_ctl, (void *)dev_priv->vdc_reg + 8224U);
#line 628
    ioread32((void *)dev_priv->vdc_reg + 8224U);
  } else {

  }
#line 630
  if ((unsigned long )dev_priv->vram_addr != (unsigned long )((u8 *)0U)) {
#line 631
    iounmap((void volatile   *)dev_priv->gtt_map);
  } else {

  }
#line 632
  return;
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int psb_gtt_init(struct drm_device *dev , int resume ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int gtt_pages ;
  unsigned long stolen_size ;
  unsigned long vram_stolen_size ;
  unsigned int i ;
  unsigned int num_pages ;
  unsigned int pfn_base ;
  struct psb_gtt *pg ;
  int ret ;
  uint32_t pte ;
  struct lock_class_key __key ;
  struct _ddebug descriptor ;
  long tmp ;
  struct resource fudge ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;

  {
#line 636
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 643
  ret = 0;
#line 646
  if (resume == 0) {
#line 647
    __mutex_init(& dev_priv->gtt_mutex, "&dev_priv->gtt_mutex", & __key);
#line 648
    psb_gtt_alloc(dev);
  } else {

  }
#line 651
  pg = & dev_priv->gtt;
#line 654
  pci_read_config_word((struct pci_dev  const  *)dev->pdev, 82, & dev_priv->gmch_ctrl);
#line 655
  pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
#line 658
  dev_priv->pge_ctl = ioread32((void *)dev_priv->vdc_reg + 8224U);
#line 659
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
#line 660
  ioread32((void *)dev_priv->vdc_reg + 8224U);
#line 663
  dev_priv->gtt_initialized = 1;
#line 665
  pg->gtt_phys_start = dev_priv->pge_ctl & 4294963200U;
#line 673
  pg->mmu_gatt_start = 3758096384U;
#line 675
  pg->gtt_start = (uint32_t )(dev->pdev)->resource[3].start;
#line 676
  gtt_pages = (dev->pdev)->resource[3].start != 0ULL || (dev->pdev)->resource[3].end != (dev->pdev)->resource[3].start ? (unsigned int )((((dev->pdev)->resource[3].end - (dev->pdev)->resource[3].start) + 1ULL) >> 12) : 0U;
#line 679
  if (pg->gtt_start == 0U || gtt_pages == 0U) {
#line 680
    descriptor.modname = "gma500_gfx";
#line 680
    descriptor.function = "psb_gtt_init";
#line 680
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared";
#line 680
    descriptor.format = "GTT PCI BAR not initialized.\n";
#line 680
    descriptor.lineno = 680U;
#line 680
    descriptor.flags = 0U;
#line 680
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 680
    if (tmp != 0L) {
#line 680
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "GTT PCI BAR not initialized.\n");
    } else {

    }
#line 681
    gtt_pages = 64U;
#line 682
    pg->gtt_start = dev_priv->pge_ctl;
  } else {

  }
#line 685
  pg->gatt_start = (uint32_t )(dev->pdev)->resource[2].start;
#line 686
  pg->gatt_pages = (dev->pdev)->resource[2].start != 0ULL || (dev->pdev)->resource[2].end != (dev->pdev)->resource[2].start ? (unsigned int )((((dev->pdev)->resource[2].end - (dev->pdev)->resource[2].start) + 1ULL) >> 12) : 0U;
#line 688
  dev_priv->gtt_mem = (struct resource *)(& (dev->pdev)->resource) + 2UL;
#line 690
  if (pg->gatt_pages == 0U || pg->gatt_start == 0U) {
#line 695
    descriptor___0.modname = "gma500_gfx";
#line 695
    descriptor___0.function = "psb_gtt_init";
#line 695
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared";
#line 695
    descriptor___0.format = "GATT PCI BAR not initialized.\n";
#line 695
    descriptor___0.lineno = 695U;
#line 695
    descriptor___0.flags = 0U;
#line 695
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 695
    if (tmp___0 != 0L) {
#line 695
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GATT PCI BAR not initialized.\n");
    } else {

    }
#line 696
    pg->gatt_start = 1073741824U;
#line 697
    pg->gatt_pages = 32768U;
#line 702
    fudge.start = 1073741824ULL;
#line 703
    fudge.end = 1207959551ULL;
#line 704
    fudge.name = "fudge";
#line 705
    fudge.flags = 512UL;
#line 706
    dev_priv->gtt_mem = & fudge;
  } else {

  }
#line 709
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, & dev_priv->stolen_base);
#line 710
  vram_stolen_size = (unsigned long )(pg->gtt_phys_start - dev_priv->stolen_base) - 4096UL;
#line 713
  stolen_size = vram_stolen_size;
#line 715
  descriptor___1.modname = "gma500_gfx";
#line 715
  descriptor___1.function = "psb_gtt_init";
#line 715
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared";
#line 715
  descriptor___1.format = "Stolen memory base 0x%x, size %luK\n";
#line 715
  descriptor___1.lineno = 716U;
#line 715
  descriptor___1.flags = 0U;
#line 715
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 715
  if (tmp___1 != 0L) {
#line 715
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)dev->dev, "Stolen memory base 0x%x, size %luK\n",
                      dev_priv->stolen_base, vram_stolen_size / 1024UL);
  } else {

  }
#line 718
  if ((resume != 0 && pg->gtt_pages != gtt_pages) && pg->stolen_size != stolen_size) {
#line 720
    dev_err((struct device  const  *)dev->dev, "GTT resume error.\n");
#line 721
    ret = -22;
#line 722
    goto out_err;
  } else {

  }
#line 725
  pg->gtt_pages = gtt_pages;
#line 726
  pg->stolen_size = stolen_size;
#line 727
  dev_priv->vram_stolen_size = vram_stolen_size;
#line 732
  if (resume == 0) {
#line 733
    tmp___2 = ioremap_nocache((resource_size_t )pg->gtt_phys_start, (unsigned long )(gtt_pages << 12));
#line 733
    dev_priv->gtt_map = (u32 *)tmp___2;
  } else {

  }
#line 735
  if ((unsigned long )dev_priv->gtt_map == (unsigned long )((u32 *)0U)) {
#line 736
    dev_err((struct device  const  *)dev->dev, "Failure to map gtt.\n");
#line 737
    ret = -12;
#line 738
    goto out_err;
  } else {

  }
#line 741
  if (resume == 0) {
#line 742
    tmp___3 = ioremap_wc((resource_size_t )dev_priv->stolen_base, stolen_size);
#line 742
    dev_priv->vram_addr = (u8 *)tmp___3;
  } else {

  }
#line 745
  if ((unsigned long )dev_priv->vram_addr == (unsigned long )((u8 *)0U)) {
#line 746
    dev_err((struct device  const  *)dev->dev, "Failure to map stolen base.\n");
#line 747
    ret = -12;
#line 748
    goto out_err;
  } else {

  }
#line 755
  pfn_base = dev_priv->stolen_base >> 12;
#line 756
  num_pages = (unsigned int )(vram_stolen_size >> 12);
#line 757
  descriptor___2.modname = "gma500_gfx";
#line 757
  descriptor___2.function = "psb_gtt_init";
#line 757
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared";
#line 757
  descriptor___2.format = "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n";
#line 757
  descriptor___2.lineno = 758U;
#line 757
  descriptor___2.flags = 0U;
#line 757
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 757
  if (tmp___4 != 0L) {
#line 757
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)dev->dev, "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n",
                      num_pages, pfn_base << 12, 0);
  } else {

  }
#line 759
  i = 0U;
#line 759
  goto ldv_41361;
  ldv_41360: 
#line 760
  pte = psb_gtt_mask_pte(pfn_base + i, 1);
#line 761
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
#line 759
  i = i + 1U;
  ldv_41361: ;
#line 759
  if (i < num_pages) {
#line 761
    goto ldv_41360;
  } else {

  }
#line 768
  pfn_base = (unsigned int )(((long )dev_priv->scratch_page + 24189255811072L) / 64L);
#line 769
  pte = psb_gtt_mask_pte(pfn_base, 1);
#line 770
  goto ldv_41364;
  ldv_41363: 
#line 771
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
#line 770
  i = i + 1U;
  ldv_41364: ;
#line 770
  if (i < gtt_pages) {
#line 772
    goto ldv_41363;
  } else {

  }
#line 773
  ioread32((void *)(dev_priv->gtt_map + ((unsigned long )i + 0xffffffffffffffffUL)));
#line 774
  return (0);
  out_err: 
#line 777
  psb_gtt_takedown(dev);
#line 778
  return (ret);
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
int psb_gtt_restore(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct resource *r ;
  struct gtt_range *range ;
  unsigned int restored ;
  unsigned int total ;
  unsigned int size ;
  struct resource  const  *__mptr ;
  long tmp ;

  {
#line 783
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 784
  r = (dev_priv->gtt_mem)->child;
#line 786
  restored = 0U;
#line 786
  total = 0U;
#line 786
  size = 0U;
#line 789
  mutex_lock_nested(& dev_priv->gtt_mutex, 0U);
#line 790
  psb_gtt_init(dev, 1);
#line 792
  goto ldv_41378;
  ldv_41377: 
#line 793
  __mptr = (struct resource  const  *)r;
#line 793
  range = (struct gtt_range *)__mptr;
#line 794
  if ((unsigned long )range->pages != (unsigned long )((struct page **)0)) {
#line 795
    psb_gtt_insert(dev, range, 1);
#line 796
    size = ((unsigned int )range->resource.end - (unsigned int )range->resource.start) + size;
#line 797
    restored = restored + 1U;
  } else {

  }
#line 799
  r = r->sibling;
#line 800
  total = total + 1U;
  ldv_41378: ;
#line 792
  if ((unsigned long )r != (unsigned long )((struct resource *)0)) {
#line 794
    goto ldv_41377;
  } else {

  }
#line 802
  mutex_unlock(& dev_priv->gtt_mutex);
#line 803
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 803
  if (tmp != 0L) {
#line 803
    drm_ut_debug_printk("psb_gtt_restore", "Restored %u of %u gtt ranges (%u KB)",
                        restored, total, size / 1024U);
  } else {

  }
#line 806
  return (0);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gtt.o.c.prepared"
void *ldv_kmem_cache_alloc_96(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 939
  ldv_check_alloc_flags(flags);
#line 941
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 942
  return ((void *)0);
}
}
#line 1 "<compiler builtins>"
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 120 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 315 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_116(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 563 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 565
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 566
    return ((void *)0);
  } else {

  }
#line 567
  tmp = __kmalloc(n * size, flags);
#line 567
  return (tmp);
}
}
#line 576 "include/linux/slab.h"
__inline static void *ldv_kcalloc_114(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 578
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 578
  return (tmp);
}
}
#line 576
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 991 "include/linux/pci.h"
extern void *pci_map_rom(struct pci_dev * , size_t * ) ;
#line 992
extern void pci_unmap_rom(struct pci_dev * , void * ) ;
#line 183 "include/drm/drm_modes.h"
extern void drm_mode_debug_printmodeline(struct drm_display_mode  const  * ) ;
#line 204
extern void drm_mode_set_name(struct drm_display_mode * ) ;
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/intel_bios.h"
int psb_intel_init_bios(struct drm_device *dev ) ;
#line 481
void psb_intel_destroy_bios(struct drm_device *dev ) ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void *find_section(struct bdb_header *bdb , int section_id ) 
{ 
  u8 *base ;
  int index ;
  u16 total ;
  u16 current_size ;
  u8 current_id ;

  {
#line 254
  base = (u8 *)bdb;
#line 255
  index = 0;
#line 260
  index = (int )bdb->header_size + index;
#line 261
  total = bdb->bdb_size;
#line 264
  goto ldv_39739;
  ldv_39738: 
#line 265
  current_id = *(base + (unsigned long )index);
#line 266
  index = index + 1;
#line 267
  current_size = *((u16 *)base + (unsigned long )index);
#line 268
  index = index + 2;
#line 269
  if ((int )current_id == section_id) {
#line 270
    return ((void *)base + (unsigned long )index);
  } else {

  }
#line 271
  index = (int )current_size + index;
  ldv_39739: ;
#line 264
  if ((int )total > index) {
#line 266
    goto ldv_39738;
  } else {

  }

#line 274
  return ((void *)0);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_edp(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_edp *edp ;
  struct edp_power_seq *edp_pps ;
  struct edp_link_params *edp_link_params ;
  uint8_t panel_type ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 285
  tmp = find_section(bdb, 27);
#line 285
  edp = (struct bdb_edp *)tmp;
#line 287
  dev_priv->edp.bpp = 18;
#line 288
  if ((unsigned long )edp == (unsigned long )((struct bdb_edp *)0)) {
#line 289
    if ((int )dev_priv->edp.support) {
#line 290
      tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 290
      if (tmp___0 != 0L) {
#line 290
        drm_ut_debug_printk("parse_edp", "No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\n",
                            dev_priv->edp.bpp);
      } else {

      }
    } else {

    }
#line 293
    return;
  } else {

  }
#line 296
  panel_type = dev_priv->panel_type;
#line 297
  switch ((edp->color_depth >> (int )panel_type * 2) & 3U) {
  case 0U: 
#line 299
  dev_priv->edp.bpp = 18;
#line 300
  goto ldv_39751;
  case 1U: 
#line 302
  dev_priv->edp.bpp = 24;
#line 303
  goto ldv_39751;
  case 2U: 
#line 305
  dev_priv->edp.bpp = 30;
#line 306
  goto ldv_39751;
  }
  ldv_39751: 
#line 310
  edp_pps = (struct edp_power_seq *)(& edp->power_seqs) + (unsigned long )panel_type;
#line 311
  edp_link_params = (struct edp_link_params *)(& edp->link_params) + (unsigned long )panel_type;
#line 313
  dev_priv->edp.pps = *edp_pps;
#line 315
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 315
  if (tmp___1 != 0L) {
#line 315
    drm_ut_debug_printk("parse_edp", "EDP timing in vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                        (int )dev_priv->edp.pps.t1_t3, (int )dev_priv->edp.pps.t8,
                        (int )dev_priv->edp.pps.t9, (int )dev_priv->edp.pps.t10, (int )dev_priv->edp.pps.t11_t12);
  } else {

  }
#line 320
  dev_priv->edp.rate = (unsigned int )*((unsigned char *)edp_link_params + 0UL) != 0U ? 10 : 6;
#line 322
  switch ((int )edp_link_params->lanes) {
  case 0: 
#line 324
  dev_priv->edp.lanes = 1;
#line 325
  goto ldv_39755;
  case 1: 
#line 327
  dev_priv->edp.lanes = 2;
#line 328
  goto ldv_39755;
  case 3: ;
  default: 
#line 331
  dev_priv->edp.lanes = 4;
#line 332
  goto ldv_39755;
  }
  ldv_39755: 
#line 334
  tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 334
  if (tmp___2 != 0L) {
#line 334
    drm_ut_debug_printk("parse_edp", "VBT reports EDP: Lane_count %d, Lane_rate %d, Bpp %d\n",
                        dev_priv->edp.lanes, dev_priv->edp.rate, dev_priv->edp.bpp);
  } else {

  }
#line 337
  switch ((int )edp_link_params->preemphasis) {
  case 0: 
#line 339
  dev_priv->edp.preemphasis = 0;
#line 340
  goto ldv_39760;
  case 1: 
#line 342
  dev_priv->edp.preemphasis = 8;
#line 343
  goto ldv_39760;
  case 2: 
#line 345
  dev_priv->edp.preemphasis = 16;
#line 346
  goto ldv_39760;
  case 3: 
#line 348
  dev_priv->edp.preemphasis = 24;
#line 349
  goto ldv_39760;
  }
  ldv_39760: ;
#line 351
  switch ((int )edp_link_params->vswing) {
  case 0: 
#line 353
  dev_priv->edp.vswing = 0;
#line 354
  goto ldv_39765;
  case 1: 
#line 356
  dev_priv->edp.vswing = 1;
#line 357
  goto ldv_39765;
  case 2: 
#line 359
  dev_priv->edp.vswing = 2;
#line 360
  goto ldv_39765;
  case 3: 
#line 362
  dev_priv->edp.vswing = 3;
#line 363
  goto ldv_39765;
  }
  ldv_39765: 
#line 365
  tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 365
  if (tmp___3 != 0L) {
#line 365
    drm_ut_debug_printk("parse_edp", "VBT reports EDP: VSwing  %d, Preemph %d\n",
                        dev_priv->edp.vswing, dev_priv->edp.preemphasis);
  } else {

  }
#line 366
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static u16 get_blocksize(void *p ) 
{ 
  u16 *block_ptr ;
  u16 block_size ;

  {
#line 374
  block_ptr = (u16 *)p + 0xfffffffffffffffeUL;
#line 375
  block_size = *block_ptr;
#line 376
  return (block_size);
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode , struct lvds_dvo_timing *dvo_timing ) 
{ 


  {
#line 382
  panel_fixed_mode->hdisplay = ((int )dvo_timing->hactive_hi << 8) | (int )dvo_timing->hactive_lo;
#line 384
  panel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay + (((int )dvo_timing->hsync_off_hi << 8) | (int )dvo_timing->hsync_off_lo);
#line 386
  panel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start + (int )dvo_timing->hsync_pulse_width;
#line 388
  panel_fixed_mode->htotal = panel_fixed_mode->hdisplay + (((int )dvo_timing->hblank_hi << 8) | (int )dvo_timing->hblank_lo);
#line 391
  panel_fixed_mode->vdisplay = ((int )dvo_timing->vactive_hi << 8) | (int )dvo_timing->vactive_lo;
#line 393
  panel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay + (int )dvo_timing->vsync_off;
#line 395
  panel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start + (int )dvo_timing->vsync_pulse_width;
#line 397
  panel_fixed_mode->vtotal = panel_fixed_mode->vdisplay + (((int )dvo_timing->vblank_hi << 8) | (int )dvo_timing->vblank_lo);
#line 399
  panel_fixed_mode->clock = (int )dvo_timing->clock * 10;
#line 400
  panel_fixed_mode->type = 8U;
#line 402
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
#line 403
    panel_fixed_mode->flags = panel_fixed_mode->flags | 1U;
  } else {
#line 405
    panel_fixed_mode->flags = panel_fixed_mode->flags | 2U;
  }
#line 407
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
#line 408
    panel_fixed_mode->flags = panel_fixed_mode->flags | 4U;
  } else {
#line 410
    panel_fixed_mode->flags = panel_fixed_mode->flags | 8U;
  }
#line 413
  if (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal) {
#line 414
    panel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;
  } else {

  }
#line 415
  if (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal) {
#line 416
    panel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;
  } else {

  }
#line 418
  drm_mode_set_name(panel_fixed_mode);
#line 419
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_backlight_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_lvds_backlight *vbt_lvds_bl ;
  struct bdb_lvds_backlight *lvds_bl ;
  u8 p_type ;
  void *bl_start ;
  struct bdb_lvds_options *lvds_opts ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 424
  vbt_lvds_bl = (struct bdb_lvds_backlight *)0;
#line 426
  p_type = 0U;
#line 427
  bl_start = (void *)0;
#line 428
  tmp = find_section(bdb, 40);
#line 428
  lvds_opts = (struct bdb_lvds_options *)tmp;
#line 431
  dev_priv->lvds_bl = (struct bdb_lvds_backlight *)0;
#line 433
  if ((unsigned long )lvds_opts != (unsigned long )((struct bdb_lvds_options *)0)) {
#line 434
    p_type = lvds_opts->panel_type;
  } else {
#line 436
    return;
  }
#line 438
  bl_start = find_section(bdb, 43);
#line 439
  vbt_lvds_bl = (struct bdb_lvds_backlight *)bl_start + ((unsigned long )p_type + 1UL);
#line 441
  tmp___0 = kmemdup((void const   *)vbt_lvds_bl, 6UL, 208U);
#line 441
  lvds_bl = (struct bdb_lvds_backlight *)tmp___0;
#line 442
  if ((unsigned long )lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
#line 443
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for backlight data\n");
#line 444
    return;
  } else {

  }
#line 446
  dev_priv->lvds_bl = lvds_bl;
#line 447
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_lfp_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_lvds_options *lvds_options ;
  struct bdb_lvds_lfp_data *lvds_lfp_data ;
  struct bdb_lvds_lfp_data_entry *entry ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
#line 460
  dev_priv->lvds_dither = 0U;
#line 461
  dev_priv->lvds_vbt = 0U;
#line 463
  tmp = find_section(bdb, 40);
#line 463
  lvds_options = (struct bdb_lvds_options *)tmp;
#line 464
  if ((unsigned long )lvds_options == (unsigned long )((struct bdb_lvds_options *)0)) {
#line 465
    return;
  } else {

  }
#line 467
  dev_priv->lvds_dither = lvds_options->pixel_dither;
#line 468
  dev_priv->panel_type = lvds_options->panel_type;
#line 470
  if ((unsigned int )lvds_options->panel_type == 255U) {
#line 471
    return;
  } else {

  }
#line 473
  tmp___0 = find_section(bdb, 42);
#line 473
  lvds_lfp_data = (struct bdb_lvds_lfp_data *)tmp___0;
#line 474
  if ((unsigned long )lvds_lfp_data == (unsigned long )((struct bdb_lvds_lfp_data *)0)) {
#line 475
    return;
  } else {

  }
#line 478
  entry = (struct bdb_lvds_lfp_data_entry *)(& lvds_lfp_data->data) + (unsigned long )lvds_options->panel_type;
#line 479
  dvo_timing = & entry->dvo_timing;
#line 481
  tmp___1 = kzalloc(208UL, 208U);
#line 481
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
#line 483
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 484
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for fixed panel mode\n");
#line 485
    return;
  } else {

  }
#line 488
  dev_priv->lvds_vbt = 1U;
#line 489
  fill_detail_timing_data(panel_fixed_mode, dvo_timing);
#line 491
  if (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {
#line 492
    dev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;
#line 493
    drm_mode_debug_printmodeline((struct drm_display_mode  const  *)panel_fixed_mode);
  } else {
#line 495
    descriptor.modname = "gma500_gfx";
#line 495
    descriptor.function = "parse_lfp_panel_data";
#line 495
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared";
#line 495
    descriptor.format = "ignoring invalid LVDS VBT\n";
#line 495
    descriptor.lineno = 495U;
#line 495
    descriptor.flags = 0U;
#line 495
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 495
    if (tmp___2 != 0L) {
#line 495
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                        "ignoring invalid LVDS VBT\n");
    } else {

    }
#line 496
    dev_priv->lvds_vbt = 0U;
#line 497
    kfree((void const   *)panel_fixed_mode);
  }
#line 499
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_sdvo_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_sdvo_lvds_options *sdvo_lvds_options ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 510
  dev_priv->sdvo_lvds_vbt_mode = (struct drm_display_mode *)0;
#line 512
  tmp = find_section(bdb, 22);
#line 512
  sdvo_lvds_options = (struct bdb_sdvo_lvds_options *)tmp;
#line 513
  if ((unsigned long )sdvo_lvds_options == (unsigned long )((struct bdb_sdvo_lvds_options *)0)) {
#line 514
    return;
  } else {

  }
#line 516
  tmp___0 = find_section(bdb, 23);
#line 516
  dvo_timing = (struct lvds_dvo_timing *)tmp___0;
#line 517
  if ((unsigned long )dvo_timing == (unsigned long )((struct lvds_dvo_timing *)0)) {
#line 518
    return;
  } else {

  }
#line 520
  tmp___1 = kzalloc(208UL, 208U);
#line 520
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
#line 522
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 523
    return;
  } else {

  }
#line 525
  fill_detail_timing_data(panel_fixed_mode, dvo_timing + (unsigned long )sdvo_lvds_options->panel_type);
#line 528
  dev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;
#line 530
  return;
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_general_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_general_features *general ;
  void *tmp ;

  {
#line 539
  dev_priv->int_tv_support = 1U;
#line 540
  dev_priv->int_crt_support = 1U;
#line 542
  tmp = find_section(bdb, 1);
#line 542
  general = (struct bdb_general_features *)tmp;
#line 543
  if ((unsigned long )general != (unsigned long )((struct bdb_general_features *)0)) {
#line 544
    dev_priv->int_tv_support = general->int_tv_support;
#line 545
    dev_priv->int_crt_support = general->int_crt_support;
#line 546
    dev_priv->lvds_use_ssc = general->enable_ssc;
#line 548
    if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 549
      dev_priv->lvds_ssc_freq = (unsigned int )*((unsigned char *)general + 1UL) != 0U ? 100 : 96;
    } else {

    }
  } else {

  }
#line 552
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_sdvo_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct sdvo_device_mapping *p_mapping ;
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 565
  tmp = find_section(bdb, 2);
#line 565
  p_defs = (struct bdb_general_definitions *)tmp;
#line 566
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
#line 567
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 567
    if (tmp___0 != 0L) {
#line 567
      drm_ut_debug_printk("parse_sdvo_device_mapping", "No general definition block is found, unable to construct sdvo mapping.\n");
    } else {

    }
#line 568
    return;
  } else {

  }
#line 575
  if ((unsigned int )p_defs->child_dev_size != 33U) {
#line 577
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 577
    if (tmp___1 != 0L) {
#line 577
      drm_ut_debug_printk("parse_sdvo_device_mapping", "different child size is found. Invalid.\n");
    } else {

    }
#line 578
    return;
  } else {

  }
#line 581
  block_size = get_blocksize((void *)p_defs);
#line 583
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
#line 585
  count = 0;
#line 586
  i = 0;
#line 586
  goto ldv_39824;
  ldv_39823: 
#line 587
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 588
  if ((unsigned int )p_child->device_type == 0U) {
#line 590
    goto ldv_39822;
  } else {

  }
#line 592
  if ((unsigned int )p_child->slave_addr != 112U && (unsigned int )p_child->slave_addr != 114U) {
#line 598
    goto ldv_39822;
  } else {

  }
#line 600
  if ((unsigned int )p_child->dvo_port != 1U && (unsigned int )p_child->dvo_port != 2U) {
#line 603
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 603
    if (tmp___2 != 0L) {
#line 603
      drm_ut_debug_printk("parse_sdvo_device_mapping", "Incorrect SDVO port. Skip it\n");
    } else {

    }
#line 604
    goto ldv_39822;
  } else {

  }
#line 606
  tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 606
  if (tmp___3 != 0L) {
#line 606
    drm_ut_debug_printk("parse_sdvo_device_mapping", "the SDVO device with slave addr %2x is found on %s port\n",
                        (int )p_child->slave_addr, (unsigned int )p_child->dvo_port == 1U ? (char *)"SDVOB" : (char *)"SDVOC");
  } else {

  }
#line 611
  p_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + ((unsigned long )p_child->dvo_port + 0xffffffffffffffffUL);
#line 612
  if ((unsigned int )p_mapping->initialized == 0U) {
#line 613
    p_mapping->dvo_port = p_child->dvo_port;
#line 614
    p_mapping->slave_addr = p_child->slave_addr;
#line 615
    p_mapping->dvo_wiring = p_child->dvo_wiring;
#line 616
    p_mapping->ddc_pin = p_child->ddc_pin;
#line 617
    p_mapping->i2c_pin = p_child->i2c_pin;
#line 618
    p_mapping->initialized = 1U;
#line 619
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 619
    if (tmp___4 != 0L) {
#line 619
      drm_ut_debug_printk("parse_sdvo_device_mapping", "SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",
                          (int )p_mapping->dvo_port, (int )p_mapping->slave_addr,
                          (int )p_mapping->dvo_wiring, (int )p_mapping->ddc_pin, (int )p_mapping->i2c_pin);
    } else {

    }
  } else {
#line 626
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 626
    if (tmp___5 != 0L) {
#line 626
      drm_ut_debug_printk("parse_sdvo_device_mapping", "Maybe one SDVO port is shared by two SDVO device.\n");
    } else {

    }
  }
#line 629
  if ((unsigned int )p_child->slave2_addr != 0U) {
#line 632
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 632
    if (tmp___6 != 0L) {
#line 632
      drm_ut_debug_printk("parse_sdvo_device_mapping", "there exists the slave2_addr. Maybe this is a SDVO device with multiple inputs.\n");
    } else {

    }
  } else {

  }
#line 635
  count = count + 1;
  ldv_39822: 
#line 586
  i = i + 1;
  ldv_39824: ;
#line 586
  if (i < child_device_num) {
#line 588
    goto ldv_39823;
  } else {

  }

#line 638
  if (count == 0) {
#line 640
    tmp___7 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 640
    if (tmp___7 != 0L) {
#line 640
      drm_ut_debug_printk("parse_sdvo_device_mapping", "No SDVO device info is found in VBT\n");
    } else {

    }
  } else {

  }
#line 642
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_driver_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_driver_features *driver___0 ;
  void *tmp ;

  {
#line 652
  tmp = find_section(bdb, 12);
#line 652
  driver___0 = (struct bdb_driver_features *)tmp;
#line 653
  if ((unsigned long )driver___0 == (unsigned long )((struct bdb_driver_features *)0)) {
#line 654
    return;
  } else {

  }
#line 656
  if ((unsigned int )*((unsigned char *)driver___0 + 8UL) == 24U) {
#line 657
    dev_priv->edp.support = 1;
  } else {

  }
#line 660
  if ((unsigned int )*((unsigned char *)driver___0 + 0UL) != 0U) {
#line 661
    dev_priv->dplla_96mhz = 1;
  } else {
#line 663
    dev_priv->dplla_96mhz = 0;
  }
#line 664
  return;
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
static void parse_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ 
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  struct child_device_config *child_dev_ptr ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 675
  tmp = find_section(bdb, 2);
#line 675
  p_defs = (struct bdb_general_definitions *)tmp;
#line 676
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
#line 677
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 677
    if (tmp___0 != 0L) {
#line 677
      drm_ut_debug_printk("parse_device_mapping", "No general definition block is found, no devices defined.\n");
    } else {

    }
#line 678
    return;
  } else {

  }
#line 685
  if ((unsigned int )p_defs->child_dev_size != 33U) {
#line 687
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 687
    if (tmp___1 != 0L) {
#line 687
      drm_ut_debug_printk("parse_device_mapping", "different child size is found. Invalid.\n");
    } else {

    }
#line 688
    return;
  } else {

  }
#line 691
  block_size = get_blocksize((void *)p_defs);
#line 693
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
#line 695
  count = 0;
#line 697
  i = 0;
#line 697
  goto ldv_39845;
  ldv_39844: 
#line 698
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 699
  if ((unsigned int )p_child->device_type == 0U) {
#line 701
    goto ldv_39843;
  } else {

  }
#line 703
  count = count + 1;
  ldv_39843: 
#line 697
  i = i + 1;
  ldv_39845: ;
#line 697
  if (i < child_device_num) {
#line 699
    goto ldv_39844;
  } else {

  }

#line 705
  if (count == 0) {
#line 706
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 706
    if (tmp___2 != 0L) {
#line 706
      drm_ut_debug_printk("parse_device_mapping", "no child dev is parsed from VBT\n");
    } else {

    }
#line 707
    return;
  } else {

  }
#line 709
  tmp___3 = kcalloc((size_t )count, 33UL, 208U);
#line 709
  dev_priv->child_dev = (struct child_device_config *)tmp___3;
#line 710
  if ((unsigned long )dev_priv->child_dev == (unsigned long )((struct child_device_config *)0)) {
#line 711
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 711
    if (tmp___4 != 0L) {
#line 711
      drm_ut_debug_printk("parse_device_mapping", "No memory space for child devices\n");
    } else {

    }
#line 712
    return;
  } else {

  }
#line 715
  dev_priv->child_dev_num = count;
#line 716
  count = 0;
#line 717
  i = 0;
#line 717
  goto ldv_39852;
  ldv_39851: 
#line 718
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
#line 719
  if ((unsigned int )p_child->device_type == 0U) {
#line 721
    goto ldv_39847;
  } else {

  }
#line 723
  child_dev_ptr = dev_priv->child_dev + (unsigned long )count;
#line 724
  count = count + 1;
#line 725
  __len = 33UL;
#line 725
  if (__len > 63UL) {
#line 725
    __ret = __memcpy((void *)child_dev_ptr, (void const   *)p_child, __len);
  } else {
#line 725
    __ret = __builtin_memcpy((void *)child_dev_ptr, (void const   *)p_child, __len);
  }
  ldv_39847: 
#line 717
  i = i + 1;
  ldv_39852: ;
#line 717
  if (i < child_device_num) {
#line 719
    goto ldv_39851;
  } else {

  }

#line 728
  return;
}
}
#line 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
int psb_intel_init_bios(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct vbt_header *vbt ;
  struct bdb_header *bdb ;
  u8 *bios ;
  size_t size ;
  int i ;
  struct vbt_header *vbt___0 ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 748
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 749
  pdev = dev->pdev;
#line 750
  vbt = (struct vbt_header *)0;
#line 751
  bdb = (struct bdb_header *)0;
#line 752
  bios = (u8 *)0U;
#line 757
  dev_priv->panel_type = 255U;
#line 760
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
#line 761
    vbt___0 = (struct vbt_header *)dev_priv->opregion.vbt;
#line 762
    tmp___0 = memcmp((void const   *)(& vbt___0->signature), (void const   *)"$VBT",
                     4UL);
#line 762
    if (tmp___0 == 0) {
#line 763
      tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 763
      if (tmp != 0L) {
#line 763
        drm_ut_debug_printk("psb_intel_init_bios", "Using VBT from OpRegion: %20s\n",
                            (u8 *)(& vbt___0->signature));
      } else {

      }
#line 765
      bdb = (struct bdb_header *)vbt___0 + (unsigned long )vbt___0->bdb_offset;
    } else {
#line 767
      dev_priv->opregion.vbt = (void *)0;
    }
  } else {

  }
#line 770
  if ((unsigned long )bdb == (unsigned long )((struct bdb_header *)0)) {
#line 771
    tmp___1 = pci_map_rom(pdev, & size);
#line 771
    bios = (u8 *)tmp___1;
#line 772
    if ((unsigned long )bios == (unsigned long )((u8 *)0U)) {
#line 773
      return (-1);
    } else {

    }
#line 776
    i = 0;
#line 776
    goto ldv_39868;
    ldv_39867: 
#line 777
    tmp___2 = memcmp((void const   *)bios + (unsigned long )i, (void const   *)"$VBT",
                     4UL);
#line 777
    if (tmp___2 == 0) {
#line 778
      vbt = (struct vbt_header *)bios + (unsigned long )i;
#line 779
      goto ldv_39866;
    } else {

    }
#line 776
    i = i + 1;
    ldv_39868: ;
#line 776
    if ((size_t )(i + 4) < size) {
#line 778
      goto ldv_39867;
    } else {

    }
    ldv_39866: ;
#line 783
    if ((unsigned long )vbt == (unsigned long )((struct vbt_header *)0)) {
#line 784
      dev_err((struct device  const  *)dev->dev, "VBT signature missing\n");
#line 785
      pci_unmap_rom(pdev, (void *)bios);
#line 786
      return (-1);
    } else {

    }
#line 788
    bdb = (struct bdb_header *)(bios + ((unsigned long )i + (unsigned long )vbt->bdb_offset));
  } else {

  }
#line 792
  parse_general_features(dev_priv, bdb);
#line 793
  parse_driver_features(dev_priv, bdb);
#line 794
  parse_lfp_panel_data(dev_priv, bdb);
#line 795
  parse_sdvo_panel_data(dev_priv, bdb);
#line 796
  parse_sdvo_device_mapping(dev_priv, bdb);
#line 797
  parse_device_mapping(dev_priv, bdb);
#line 798
  parse_backlight_data(dev_priv, bdb);
#line 799
  parse_edp(dev_priv, bdb);
#line 801
  if ((unsigned long )bios != (unsigned long )((u8 *)0U)) {
#line 802
    pci_unmap_rom(pdev, (void *)bios);
  } else {

  }
#line 804
  return (0);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void psb_intel_destroy_bios(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 812
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 814
  kfree((void const   *)dev_priv->sdvo_lvds_vbt_mode);
#line 815
  kfree((void const   *)dev_priv->lfp_lvds_vbt_mode);
#line 816
  kfree((void const   *)dev_priv->lvds_bl);
#line 817
  return;
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 


  {
#line 935
  ldv_check_alloc_flags(flags);
#line 937
  ldv_kcalloc_114(n, size, flags);
#line 938
  return ((void *)0);
}
}
#line 946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_bios.o.c.prepared"
void *ldv_kmem_cache_alloc_116(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 949
  ldv_check_alloc_flags(flags);
#line 951
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 952
  return ((void *)0);
}
}
#line 391 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 304 "include/linux/jiffies.h"
extern unsigned long usecs_to_jiffies(unsigned int const    ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_136(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 454 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 456
  dev_set_drvdata(& dev->dev, data);
#line 457
  return;
}
}
#line 506
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 51 "include/linux/i2c-algo-bit.h"
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) ;
#line 207
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) ;
#line 820 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ(struct drm_device *dev , uint32_t reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int tmp ;

  {
#line 822
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 823
  tmp = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 823
  return (tmp);
}
}
#line 851 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE(struct drm_device *dev , uint32_t reg , uint32_t val ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 854
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 855
  iowrite32(val, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 856
  return;
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
static int get_clock(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
#line 255
  chan = (struct psb_intel_i2c_chan *)data;
#line 256
  dev = chan->drm_dev;
#line 259
  val = REGISTER_READ(dev, chan->reg);
#line 260
  return ((val & 16U) != 0U);
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
static int get_data(void *data ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
#line 265
  chan = (struct psb_intel_i2c_chan *)data;
#line 266
  dev = chan->drm_dev;
#line 269
  val = REGISTER_READ(dev, chan->reg);
#line 270
  return ((val & 4096U) != 0U);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
static void set_clock(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 clock_bits ;
  uint32_t tmp ;

  {
#line 275
  chan = (struct psb_intel_i2c_chan *)data;
#line 276
  dev = chan->drm_dev;
#line 277
  reserved = 0U;
#line 280
  tmp = REGISTER_READ(dev, chan->reg);
#line 280
  reserved = tmp & 8224U;
#line 284
  if (state_high != 0) {
#line 285
    clock_bits = 1U;
  } else {
#line 287
    clock_bits = 7U;
  }
#line 289
  REGISTER_WRITE(dev, chan->reg, reserved | clock_bits);
#line 290
  __const_udelay(85900UL);
#line 292
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
static void set_data(void *data , int state_high ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 data_bits ;
  uint32_t tmp ;

  {
#line 295
  chan = (struct psb_intel_i2c_chan *)data;
#line 296
  dev = chan->drm_dev;
#line 297
  reserved = 0U;
#line 300
  tmp = REGISTER_READ(dev, chan->reg);
#line 300
  reserved = tmp & 8224U;
#line 304
  if (state_high != 0) {
#line 305
    data_bits = 256U;
  } else {
#line 307
    data_bits = 1792U;
  }
#line 311
  REGISTER_WRITE(dev, chan->reg, reserved | data_bits);
#line 312
  __const_udelay(85900UL);
#line 314
  return;
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) 
{ 
  struct psb_intel_i2c_chan *chan ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 341
  tmp = kzalloc(2024UL, 208U);
#line 341
  chan = (struct psb_intel_i2c_chan *)tmp;
#line 342
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 343
    goto out_free;
  } else {

  }
#line 345
  chan->drm_dev = dev;
#line 346
  chan->reg = reg;
#line 347
  snprintf((char *)(& chan->adapter.name), 20UL, "intel drm %s", name);
#line 348
  chan->adapter.owner = & __this_module;
#line 349
  chan->adapter.algo_data = (void *)(& chan->algo);
#line 350
  chan->adapter.dev.parent = & (dev->pdev)->dev;
#line 351
  chan->algo.setsda = & set_data;
#line 352
  chan->algo.setscl = & set_clock;
#line 353
  chan->algo.getsda = & get_data;
#line 354
  chan->algo.getscl = & get_clock;
#line 355
  chan->algo.udelay = 20;
#line 356
  tmp___0 = usecs_to_jiffies(2200U);
#line 356
  chan->algo.timeout = (int )tmp___0;
#line 357
  chan->algo.data = (void *)chan;
#line 359
  i2c_set_adapdata(& chan->adapter, (void *)chan);
#line 361
  tmp___1 = i2c_bit_add_bus(& chan->adapter);
#line 361
  if (tmp___1 != 0) {
#line 362
    goto out_free;
  } else {

  }
#line 365
  set_data((void *)chan, 1);
#line 366
  set_clock((void *)chan, 1);
#line 367
  __const_udelay(85900UL);
#line 369
  return (chan);
  out_free: 
#line 372
  kfree((void const   *)chan);
#line 373
  return ((struct psb_intel_i2c_chan *)0);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) 
{ 


  {
#line 384
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 385
    return;
  } else {

  }
#line 387
  i2c_del_adapter(& chan->adapter);
#line 388
  kfree((void const   *)chan);
#line 389
  return;
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_i2c.o.c.prepared"
void *ldv_kmem_cache_alloc_136(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 521
  ldv_check_alloc_flags(flags);
#line 523
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 524
  return ((void *)0);
}
}
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6004;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6004;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6004;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6004;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6004: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 303 "include/linux/jiffies.h"
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 174 "include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_156(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 576
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int ldv_state_variable_50 ;
#line 145
struct i2c_adapter *gmbus_algorithm_group0 ;
#line 176
void ldv_initialize_i2c_algorithm_50(void) ;
#line 505 "include/linux/i2c.h"
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 318 "include/linux/kgdb.h"
extern atomic_t kgdb_active ;
#line 263 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void gma_intel_i2c_reset(struct drm_device *dev ) ;
#line 264
int gma_intel_setup_gmbus(struct drm_device *dev ) ;
#line 265
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) ;
#line 266
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) ;
#line 267
void gma_intel_teardown_gmbus(struct drm_device *dev ) ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
__inline static struct intel_gmbus *to_intel_gmbus(struct i2c_adapter *i2c ) 
{ 
  struct i2c_adapter  const  *__mptr ;

  {
#line 284
  __mptr = (struct i2c_adapter  const  *)i2c;
#line 284
  return ((struct intel_gmbus *)__mptr);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void gma_intel_i2c_reset(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 297
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 298
  iowrite32(0U, (void *)dev_priv->gmbus_reg + 20736U);
#line 299
  return;
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static void intel_i2c_quirk_set(struct drm_psb_private *dev_priv , bool enable ) 
{ 


  {
#line 303
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static u32 get_reserved(struct intel_gpio *gpio ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  unsigned int tmp ;

  {
#line 324
  dev_priv = gpio->dev_priv;
#line 325
  reserved = 0U;
#line 328
  tmp = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 328
  reserved = tmp & 8224U;
#line 332
  return (reserved);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static int get_clock___0(void *data ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 337
  gpio = (struct intel_gpio *)data;
#line 338
  dev_priv = gpio->dev_priv;
#line 339
  tmp = get_reserved(gpio);
#line 339
  reserved = tmp;
#line 340
  iowrite32(reserved | 1U, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 341
  iowrite32(reserved, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 342
  tmp___0 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 342
  return ((tmp___0 & 16U) != 0U);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static int get_data___0(void *data ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 347
  gpio = (struct intel_gpio *)data;
#line 348
  dev_priv = gpio->dev_priv;
#line 349
  tmp = get_reserved(gpio);
#line 349
  reserved = tmp;
#line 350
  iowrite32(reserved | 256U, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 351
  iowrite32(reserved, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 352
  tmp___0 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 352
  return ((tmp___0 & 4096U) != 0U);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static void set_clock___0(void *data , int state_high ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 clock_bits ;

  {
#line 357
  gpio = (struct intel_gpio *)data;
#line 358
  dev_priv = gpio->dev_priv;
#line 359
  tmp = get_reserved(gpio);
#line 359
  reserved = tmp;
#line 362
  if (state_high != 0) {
#line 363
    clock_bits = 1U;
  } else {
#line 365
    clock_bits = 7U;
  }
#line 368
  iowrite32(reserved | clock_bits, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 369
  ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 370
  return;
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static void set_data___0(void *data , int state_high ) 
{ 
  struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  u32 reserved ;
  u32 tmp ;
  u32 data_bits ;

  {
#line 374
  gpio = (struct intel_gpio *)data;
#line 375
  dev_priv = gpio->dev_priv;
#line 376
  tmp = get_reserved(gpio);
#line 376
  reserved = tmp;
#line 379
  if (state_high != 0) {
#line 380
    data_bits = 256U;
  } else {
#line 382
    data_bits = 1792U;
  }
#line 385
  iowrite32(reserved | data_bits, (void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 386
  ioread32((void *)dev_priv->gmbus_reg + (unsigned long )gpio->reg);
#line 387
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static struct i2c_adapter *intel_gpio_create(struct drm_psb_private *dev_priv , u32 pin ) 
{ 
  int map_pin_to_reg[8U] ;
  struct intel_gpio *gpio ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 392
  map_pin_to_reg[0] = 0;
#line 392
  map_pin_to_reg[1] = 20500;
#line 392
  map_pin_to_reg[2] = 20496;
#line 392
  map_pin_to_reg[3] = 20504;
#line 392
  map_pin_to_reg[4] = 20508;
#line 392
  map_pin_to_reg[5] = 20512;
#line 392
  map_pin_to_reg[6] = 0;
#line 392
  map_pin_to_reg[7] = 20516;
#line 404
  if (pin > 7U || map_pin_to_reg[pin] == 0) {
#line 405
    return ((struct i2c_adapter *)0);
  } else {

  }
#line 407
  tmp = kzalloc(2016UL, 208U);
#line 407
  gpio = (struct intel_gpio *)tmp;
#line 408
  if ((unsigned long )gpio == (unsigned long )((struct intel_gpio *)0)) {
#line 409
    return ((struct i2c_adapter *)0);
  } else {

  }
#line 411
  gpio->reg = (u32 )map_pin_to_reg[pin];
#line 412
  gpio->dev_priv = dev_priv;
#line 414
  snprintf((char *)(& gpio->adapter.name), 48UL, "gma500 GPIO%c", (int )*("?BACDE?F" + pin));
#line 416
  gpio->adapter.owner = & __this_module;
#line 417
  gpio->adapter.algo_data = (void *)(& gpio->algo);
#line 418
  gpio->adapter.dev.parent = & ((dev_priv->dev)->pdev)->dev;
#line 419
  gpio->algo.setsda = & set_data___0;
#line 420
  gpio->algo.setscl = & set_clock___0;
#line 421
  gpio->algo.getsda = & get_data___0;
#line 422
  gpio->algo.getscl = & get_clock___0;
#line 423
  gpio->algo.udelay = 20;
#line 424
  tmp___0 = usecs_to_jiffies(2200U);
#line 424
  gpio->algo.timeout = (int )tmp___0;
#line 425
  gpio->algo.data = (void *)gpio;
#line 427
  tmp___1 = i2c_bit_add_bus(& gpio->adapter);
#line 427
  if (tmp___1 != 0) {
#line 428
    goto out_free;
  } else {

  }
#line 430
  return (& gpio->adapter);
  out_free: 
#line 433
  kfree((void const   *)gpio);
#line 434
  return ((struct i2c_adapter *)0);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static int intel_i2c_quirk_xfer(struct drm_psb_private *dev_priv , struct i2c_adapter *adapter ,
                                struct i2c_msg *msgs , int num ) 
{ 
  struct intel_gpio *gpio ;
  struct i2c_adapter  const  *__mptr ;
  int ret ;

  {
#line 443
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 443
  gpio = (struct intel_gpio *)__mptr;
#line 448
  gma_intel_i2c_reset(dev_priv->dev);
#line 450
  intel_i2c_quirk_set(dev_priv, 1);
#line 451
  set_data___0((void *)gpio, 1);
#line 452
  set_clock___0((void *)gpio, 1);
#line 453
  __const_udelay(85900UL);
#line 455
  ret = (*((adapter->algo)->master_xfer))(adapter, msgs, num);
#line 457
  set_data___0((void *)gpio, 1);
#line 458
  set_clock___0((void *)gpio, 1);
#line 459
  intel_i2c_quirk_set(dev_priv, 0);
#line 461
  return (ret);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static int gmbus_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs , int num ) 
{ 
  struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int i ;
  int reg_offset ;
  int tmp ;
  u16 len ;
  u8 *buf ;
  u32 val ;
  u32 loop ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  int tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  u8 *tmp___5 ;
  u32 val___0 ;
  u32 loop___0 ;
  u8 *tmp___6 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___7 ;
  int ret_____0 ;
  int tmp___8 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  u8 *tmp___12 ;
  unsigned long timeout_____1 ;
  unsigned long tmp___13 ;
  int ret_____1 ;
  int tmp___14 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;

  {
#line 469
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 469
  bus = (struct intel_gmbus *)__mptr;
#line 472
  dev_priv = (struct drm_psb_private *)adapter->algo_data;
#line 475
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 476
    tmp = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
#line 476
    return (tmp);
  } else {

  }
#line 479
  reg_offset = 0;
#line 481
  iowrite32(bus->reg0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 483
  i = 0;
#line 483
  goto ldv_39989;
  ldv_39988: 
#line 484
  len = (msgs + (unsigned long )i)->len;
#line 485
  buf = (msgs + (unsigned long )i)->buf;
#line 487
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
#line 488
    iowrite32((u32 )((((i + 1 == num ? 167772160 : 33554432) | ((int )len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741825),
              (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 494
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
    ldv_39871: 
#line 496
    loop = 0U;
#line 498
    tmp___0 = msecs_to_jiffies(50U);
#line 498
    timeout__ = tmp___0 + (unsigned long )jiffies;
#line 498
    ret__ = 0;
#line 498
    goto ldv_39865;
    ldv_39864: ;
#line 498
    if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 498
      ret__ = -110;
#line 498
      goto ldv_39822;
    } else {

    }
#line 498
    tmp___1 = preempt_count();
#line 499
    if (((unsigned long )tmp___1 & 0xffffffffffdfffffUL) == 0UL) {
#line 498
      __vpp_verify = (void const   *)0;
#line 498
      switch (4UL) {
      case 1UL: ;
#line 499
      switch (4UL) {
      case 1UL: 
#line 499
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 499
      goto ldv_39828;
      case 2UL: 
#line 499
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 499
      goto ldv_39828;
      case 4UL: 
#line 499
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 499
      goto ldv_39828;
      case 8UL: 
#line 499
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 499
      goto ldv_39828;
      default: 
#line 499
      __bad_percpu_size();
      }
      ldv_39828: 
#line 499
      pscr_ret__ = pfo_ret__;
#line 499
      goto ldv_39834;
      case 2UL: ;
#line 499
      switch (4UL) {
      case 1UL: 
#line 499
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 499
      goto ldv_39838;
      case 2UL: 
#line 499
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 499
      goto ldv_39838;
      case 4UL: 
#line 499
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 499
      goto ldv_39838;
      case 8UL: 
#line 499
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 499
      goto ldv_39838;
      default: 
#line 499
      __bad_percpu_size();
      }
      ldv_39838: 
#line 499
      pscr_ret__ = pfo_ret_____0;
#line 499
      goto ldv_39834;
      case 4UL: ;
#line 499
      switch (4UL) {
      case 1UL: 
#line 499
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 499
      goto ldv_39847;
      case 2UL: 
#line 499
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 499
      goto ldv_39847;
      case 4UL: 
#line 499
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 499
      goto ldv_39847;
      case 8UL: 
#line 499
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 499
      goto ldv_39847;
      default: 
#line 499
      __bad_percpu_size();
      }
      ldv_39847: 
#line 499
      pscr_ret__ = pfo_ret_____1;
#line 499
      goto ldv_39834;
      case 8UL: ;
#line 499
      switch (4UL) {
      case 1UL: 
#line 499
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 499
      goto ldv_39856;
      case 2UL: 
#line 499
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 499
      goto ldv_39856;
      case 4UL: 
#line 499
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 499
      goto ldv_39856;
      case 8UL: 
#line 499
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 499
      goto ldv_39856;
      default: 
#line 499
      __bad_percpu_size();
      }
      ldv_39856: 
#line 499
      pscr_ret__ = pfo_ret_____2;
#line 499
      goto ldv_39834;
      default: 
#line 499
      __bad_size_call_parameter();
#line 499
      goto ldv_39834;
      }
      ldv_39834: 
#line 499
      tmp___2 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 499
      if (pscr_ret__ != tmp___2) {
#line 499
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_39865: 
#line 498
    tmp___3 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 498
    if ((tmp___3 & 3072U) == 0U) {
#line 500
      goto ldv_39864;
    } else {

    }
    ldv_39822: ;
#line 499
    if (ret__ != 0) {
#line 500
      goto timeout;
    } else {

    }
#line 501
    tmp___4 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 501
    if ((tmp___4 & 1024U) != 0U) {
#line 502
      goto clear_err;
    } else {

    }
#line 504
    val = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
    ldv_39869: 
#line 506
    tmp___5 = buf;
#line 506
    buf = buf + 1;
#line 506
    *tmp___5 = (u8 )val;
#line 507
    val = val >> 8;
#line 508
    len = (u16 )((int )len - 1);
#line 508
    if ((unsigned int )len != 0U) {
#line 508
      loop = loop + 1U;
#line 508
      if (loop <= 3U) {
#line 510
        goto ldv_39869;
      } else {
#line 513
        goto ldv_39870;
      }
    } else {

    }
    ldv_39870: ;
#line 509
    if ((unsigned int )len != 0U) {
#line 511
      goto ldv_39871;
    } else {

    }

  } else {
#line 513
    loop___0 = 0U;
#line 513
    val___0 = loop___0;
    ldv_39875: 
#line 515
    tmp___6 = buf;
#line 515
    buf = buf + 1;
#line 515
    val___0 = (u32 )((int )*tmp___6 << (int )(loop___0 * 8U)) | val___0;
#line 516
    len = (u16 )((int )len - 1);
#line 516
    if ((unsigned int )len != 0U) {
#line 516
      loop___0 = loop___0 + 1U;
#line 516
      if (loop___0 <= 3U) {
#line 518
        goto ldv_39875;
      } else {
#line 521
        goto ldv_39876;
      }
    } else {

    }
    ldv_39876: 
#line 518
    iowrite32(val___0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
#line 519
    iowrite32((u32 )((((i + 1 == num ? 134217728 : 33554432) | ((int )(msgs + (unsigned long )i)->len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741824),
              (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 524
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 526
    goto ldv_39933;
    ldv_39932: 
#line 527
    tmp___7 = msecs_to_jiffies(50U);
#line 527
    timeout_____0 = tmp___7 + (unsigned long )jiffies;
#line 527
    ret_____0 = 0;
#line 527
    goto ldv_39928;
    ldv_39927: ;
#line 527
    if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 527
      ret_____0 = -110;
#line 527
      goto ldv_39885;
    } else {

    }
#line 527
    tmp___8 = preempt_count();
#line 528
    if (((unsigned long )tmp___8 & 0xffffffffffdfffffUL) == 0UL) {
#line 527
      __vpp_verify___0 = (void const   *)0;
#line 527
      switch (4UL) {
      case 1UL: ;
#line 528
      switch (4UL) {
      case 1UL: 
#line 528
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 528
      goto ldv_39891;
      case 2UL: 
#line 528
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 528
      goto ldv_39891;
      case 4UL: 
#line 528
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 528
      goto ldv_39891;
      case 8UL: 
#line 528
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 528
      goto ldv_39891;
      default: 
#line 528
      __bad_percpu_size();
      }
      ldv_39891: 
#line 528
      pscr_ret_____0 = pfo_ret_____3;
#line 528
      goto ldv_39897;
      case 2UL: ;
#line 528
      switch (4UL) {
      case 1UL: 
#line 528
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 528
      goto ldv_39901;
      case 2UL: 
#line 528
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 528
      goto ldv_39901;
      case 4UL: 
#line 528
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 528
      goto ldv_39901;
      case 8UL: 
#line 528
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 528
      goto ldv_39901;
      default: 
#line 528
      __bad_percpu_size();
      }
      ldv_39901: 
#line 528
      pscr_ret_____0 = pfo_ret_____4;
#line 528
      goto ldv_39897;
      case 4UL: ;
#line 528
      switch (4UL) {
      case 1UL: 
#line 528
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 528
      goto ldv_39910;
      case 2UL: 
#line 528
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 528
      goto ldv_39910;
      case 4UL: 
#line 528
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 528
      goto ldv_39910;
      case 8UL: 
#line 528
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 528
      goto ldv_39910;
      default: 
#line 528
      __bad_percpu_size();
      }
      ldv_39910: 
#line 528
      pscr_ret_____0 = pfo_ret_____5;
#line 528
      goto ldv_39897;
      case 8UL: ;
#line 528
      switch (4UL) {
      case 1UL: 
#line 528
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 528
      goto ldv_39919;
      case 2UL: 
#line 528
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 528
      goto ldv_39919;
      case 4UL: 
#line 528
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 528
      goto ldv_39919;
      case 8UL: 
#line 528
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 528
      goto ldv_39919;
      default: 
#line 528
      __bad_percpu_size();
      }
      ldv_39919: 
#line 528
      pscr_ret_____0 = pfo_ret_____6;
#line 528
      goto ldv_39897;
      default: 
#line 528
      __bad_size_call_parameter();
#line 528
      goto ldv_39897;
      }
      ldv_39897: 
#line 528
      tmp___9 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 528
      if (pscr_ret_____0 != tmp___9) {
#line 528
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_39928: 
#line 527
    tmp___10 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 527
    if ((tmp___10 & 3072U) == 0U) {
#line 529
      goto ldv_39927;
    } else {

    }
    ldv_39885: ;
#line 528
    if (ret_____0 != 0) {
#line 529
      goto timeout;
    } else {

    }
#line 530
    tmp___11 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 530
    if ((tmp___11 & 1024U) != 0U) {
#line 532
      goto clear_err;
    } else {

    }
#line 534
    loop___0 = 0U;
#line 534
    val___0 = loop___0;
    ldv_39930: 
#line 536
    tmp___12 = buf;
#line 536
    buf = buf + 1;
#line 536
    val___0 = (u32 )((int )*tmp___12 << (int )(loop___0 * 8U)) | val___0;
#line 537
    len = (u16 )((int )len - 1);
#line 537
    if ((unsigned int )len != 0U) {
#line 537
      loop___0 = loop___0 + 1U;
#line 537
      if (loop___0 <= 3U) {
#line 539
        goto ldv_39930;
      } else {
#line 542
        goto ldv_39931;
      }
    } else {

    }
    ldv_39931: 
#line 539
    iowrite32(val___0, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20748));
#line 540
    ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
    ldv_39933: ;
#line 526
    if ((unsigned int )len != 0U) {
#line 528
      goto ldv_39932;
    } else {

    }

  }
#line 544
  if (i + 1 < num) {
#line 544
    tmp___13 = msecs_to_jiffies(50U);
#line 544
    timeout_____1 = tmp___13 + (unsigned long )jiffies;
#line 544
    ret_____1 = 0;
#line 544
    goto ldv_39986;
    ldv_39985: ;
#line 544
    if ((long )(timeout_____1 - (unsigned long )jiffies) < 0L) {
#line 544
      ret_____1 = -110;
#line 544
      goto ldv_39943;
    } else {

    }
#line 544
    tmp___14 = preempt_count();
#line 544
    if (((unsigned long )tmp___14 & 0xffffffffffdfffffUL) == 0UL) {
#line 544
      __vpp_verify___1 = (void const   *)0;
#line 544
      switch (4UL) {
      case 1UL: ;
#line 544
      switch (4UL) {
      case 1UL: 
#line 544
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 544
      goto ldv_39949;
      case 2UL: 
#line 544
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 544
      goto ldv_39949;
      case 4UL: 
#line 544
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 544
      goto ldv_39949;
      case 8UL: 
#line 544
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 544
      goto ldv_39949;
      default: 
#line 544
      __bad_percpu_size();
      }
      ldv_39949: 
#line 544
      pscr_ret_____1 = pfo_ret_____7;
#line 544
      goto ldv_39955;
      case 2UL: ;
#line 544
      switch (4UL) {
      case 1UL: 
#line 544
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 544
      goto ldv_39959;
      case 2UL: 
#line 544
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 544
      goto ldv_39959;
      case 4UL: 
#line 544
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 544
      goto ldv_39959;
      case 8UL: 
#line 544
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 544
      goto ldv_39959;
      default: 
#line 544
      __bad_percpu_size();
      }
      ldv_39959: 
#line 544
      pscr_ret_____1 = pfo_ret_____8;
#line 544
      goto ldv_39955;
      case 4UL: ;
#line 544
      switch (4UL) {
      case 1UL: 
#line 544
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 544
      goto ldv_39968;
      case 2UL: 
#line 544
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 544
      goto ldv_39968;
      case 4UL: 
#line 544
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 544
      goto ldv_39968;
      case 8UL: 
#line 544
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 544
      goto ldv_39968;
      default: 
#line 544
      __bad_percpu_size();
      }
      ldv_39968: 
#line 544
      pscr_ret_____1 = pfo_ret_____9;
#line 544
      goto ldv_39955;
      case 8UL: ;
#line 544
      switch (4UL) {
      case 1UL: 
#line 544
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 544
      goto ldv_39977;
      case 2UL: 
#line 544
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 544
      goto ldv_39977;
      case 4UL: 
#line 544
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 544
      goto ldv_39977;
      case 8UL: 
#line 544
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 544
      goto ldv_39977;
      default: 
#line 544
      __bad_percpu_size();
      }
      ldv_39977: 
#line 544
      pscr_ret_____1 = pfo_ret_____10;
#line 544
      goto ldv_39955;
      default: 
#line 544
      __bad_size_call_parameter();
#line 544
      goto ldv_39955;
      }
      ldv_39955: 
#line 544
      tmp___15 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 544
      if (pscr_ret_____1 != tmp___15) {
#line 544
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_39986: 
#line 544
    tmp___16 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 544
    if ((tmp___16 & 17408U) == 0U) {
#line 546
      goto ldv_39985;
    } else {

    }
    ldv_39943: ;
#line 544
    if (ret_____1 != 0) {
#line 545
      goto timeout;
    } else {

    }
  } else {

  }
#line 546
  tmp___17 = ioread32((void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20744));
#line 546
  if ((tmp___17 & 1024U) != 0U) {
#line 547
    goto clear_err;
  } else {

  }
#line 483
  i = i + 1;
  ldv_39989: ;
#line 483
  if (i < num) {
#line 485
    goto ldv_39988;
  } else {

  }

#line 550
  goto done;
  clear_err: 
#line 557
  iowrite32(2147483648U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
#line 558
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20740));
  done: 
#line 564
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 565
  return (i);
  timeout: 
#line 568
  printk("\016[drm] GMBUS timed out, falling back to bit banging on pin %d [%s]\n",
         bus->reg0 & 255U, (char *)(& bus->adapter.name));
#line 570
  iowrite32(0U, (void *)dev_priv->gmbus_reg + (unsigned long )(reg_offset + 20736));
#line 573
  bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
#line 574
  if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
#line 575
    return (-12);
  } else {

  }
#line 577
  tmp___18 = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
#line 577
  return (tmp___18);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static u32 gmbus_func(struct i2c_adapter *adapter ) 
{ 
  struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;

  {
#line 582
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 582
  bus = (struct intel_gmbus *)__mptr;
#line 586
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 587
    (*(((bus->force_bit)->algo)->functionality))(bus->force_bit);
  } else {

  }
#line 589
  return (268402697U);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
static struct i2c_algorithm  const  gmbus_algorithm  =    {& gmbus_xfer, 0, & gmbus_func};
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
int gma_intel_setup_gmbus(struct drm_device *dev ) 
{ 
  char const   *names[8U] ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  int i ;
  void *tmp ;
  struct intel_gmbus *bus ;
  struct intel_gmbus *bus___0 ;

  {
#line 606
  names[0] = "disabled";
#line 606
  names[1] = "ssc";
#line 606
  names[2] = "vga";
#line 606
  names[3] = "panel";
#line 606
  names[4] = "dpc";
#line 606
  names[5] = "dpb";
#line 606
  names[6] = "reserved";
#line 606
  names[7] = "dpd";
#line 616
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 619
  tmp = kcalloc(8UL, 1952UL, 208U);
#line 619
  dev_priv->gmbus = (struct intel_gmbus *)tmp;
#line 621
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
#line 622
    return (-12);
  } else {

  }
#line 624
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 625
    dev_priv->gmbus_reg = dev_priv->aux_reg;
  } else {
#line 627
    dev_priv->gmbus_reg = dev_priv->vdc_reg;
  }
#line 629
  i = 0;
#line 629
  goto ldv_40009;
  ldv_40008: 
#line 630
  bus = dev_priv->gmbus + (unsigned long )i;
#line 632
  bus->adapter.owner = & __this_module;
#line 633
  bus->adapter.class = 8U;
#line 634
  snprintf((char *)(& bus->adapter.name), 48UL, "gma500 gmbus %s", names[i]);
#line 639
  bus->adapter.dev.parent = & (dev->pdev)->dev;
#line 640
  bus->adapter.algo_data = (void *)dev_priv;
#line 642
  bus->adapter.algo = & gmbus_algorithm;
#line 643
  ret = i2c_add_adapter(& bus->adapter);
#line 644
  if (ret != 0) {
#line 645
    goto err;
  } else {

  }
#line 648
  bus->reg0 = (u32 )i;
#line 651
  bus->force_bit = intel_gpio_create(dev_priv, (u32 )i);
#line 629
  i = i + 1;
  ldv_40009: ;
#line 629
  if (i <= 7) {
#line 631
    goto ldv_40008;
  } else {

  }
#line 654
  gma_intel_i2c_reset(dev_priv->dev);
#line 656
  return (0);
  err: ;
#line 659
  goto ldv_40013;
  ldv_40012: 
#line 660
  bus___0 = dev_priv->gmbus + (unsigned long )i;
#line 661
  i2c_del_adapter(& bus___0->adapter);
  ldv_40013: 
#line 659
  i = i - 1;
#line 659
  if (i != 0) {
#line 661
    goto ldv_40012;
  } else {

  }
#line 663
  kfree((void const   *)dev_priv->gmbus);
#line 664
  dev_priv->gmbus = (struct intel_gmbus *)0;
#line 665
  return (ret);
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) 
{ 
  struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;

  {
#line 670
  tmp = to_intel_gmbus(adapter);
#line 670
  bus = tmp;
#line 678
  bus->reg0 = (bus->reg0 & 4294966527U) | (u32 )(speed << 8);
#line 679
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) 
{ 
  struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 683
  tmp = to_intel_gmbus(adapter);
#line 683
  bus = tmp;
#line 685
  if ((int )force_bit) {
#line 686
    if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
#line 687
      dev_priv = (struct drm_psb_private *)adapter->algo_data;
#line 688
      bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
    } else {

    }
  } else
#line 692
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 693
    i2c_del_adapter(bus->force_bit);
#line 694
    kfree((void const   *)bus->force_bit);
#line 695
    bus->force_bit = (struct i2c_adapter *)0;
  } else {

  }
#line 697
  return;
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void gma_intel_teardown_gmbus(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  int i ;
  struct intel_gmbus *bus ;

  {
#line 702
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 705
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
#line 706
    return;
  } else {

  }
#line 708
  i = 0;
#line 708
  goto ldv_40033;
  ldv_40032: 
#line 709
  bus = dev_priv->gmbus + (unsigned long )i;
#line 710
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
#line 711
    i2c_del_adapter(bus->force_bit);
#line 712
    kfree((void const   *)bus->force_bit);
  } else {

  }
#line 714
  i2c_del_adapter(& bus->adapter);
#line 708
  i = i + 1;
  ldv_40033: ;
#line 708
  if (i <= 7) {
#line 710
    goto ldv_40032;
  } else {

  }
#line 717
  dev_priv->gmbus_reg = (uint8_t *)0U;
#line 718
  kfree((void const   *)dev_priv->gmbus);
#line 719
  dev_priv->gmbus = (struct intel_gmbus *)0;
#line 720
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_initialize_i2c_algorithm_50(void) 
{ 
  void *tmp ;

  {
#line 724
  tmp = ldv_zalloc(1936UL);
#line 724
  gmbus_algorithm_group0 = (struct i2c_adapter *)tmp;
#line 725
  return;
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void ldv_main_exported_50(void) 
{ 
  int ldvarg128 ;
  int tmp ;
  struct i2c_msg *ldvarg129 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 728
  tmp = __VERIFIER_nondet_int();
#line 728
  ldvarg128 = tmp;
#line 729
  tmp___0 = ldv_zalloc(16UL);
#line 729
  ldvarg129 = (struct i2c_msg *)tmp___0;
#line 731
  tmp___1 = __VERIFIER_nondet_int();
#line 731
  switch (tmp___1) {
  case 0: ;
#line 734
  if (ldv_state_variable_50 == 1) {
#line 736
    gmbus_xfer(gmbus_algorithm_group0, ldvarg129, ldvarg128);
#line 738
    ldv_state_variable_50 = 1;
  } else {

  }
#line 741
  goto ldv_40044;
  case 1: ;
#line 744
  if (ldv_state_variable_50 == 1) {
#line 746
    gmbus_func(gmbus_algorithm_group0);
#line 748
    ldv_state_variable_50 = 1;
  } else {

  }
#line 751
  goto ldv_40044;
  default: 
#line 752
  ldv_stop();
  }
  ldv_40044: ;
#line 756
  return;
}
}
#line 884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/intel_gmbus.o.c.prepared"
void *ldv_kmem_cache_alloc_156(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 887
  ldv_check_alloc_flags(flags);
#line 889
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 890
  return ((void *)0);
}
}
#line 357 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_cpu_ops pv_cpu_ops ;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 165 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 37 "./arch/x86/include/asm/page_64.h"
extern void clear_page(void * ) ;
#line 29 "./arch/x86/include/asm/paravirt.h"
__inline static void __cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                             unsigned int *edx ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 32
  __edi = __edi;
#line 32
  __esi = __esi;
#line 32
  __edx = __edx;
#line 32
  __ecx = __ecx;
#line 32
  __eax = __eax;
#line 32
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.cpuid == (unsigned long )((void (*)(unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ))0),
                         0L);
#line 32
  if (tmp != 0L) {
#line 32
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (32), "i" (12UL));
    ldv_3872: ;
#line 32
    goto ldv_3872;
  } else {

  }
#line 32
  __asm__  volatile   ("771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx): [paravirt_typenum] "i" (31UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.cpuid), [paravirt_clobber] "i" (511),
                       "D" ((unsigned long )eax), "S" ((unsigned long )ebx), "d" ((unsigned long )ecx),
                       "c" ((unsigned long )edx): "memory", "cc", "rax", "r8", "r9",
                       "r10", "r11");
#line 34
  return;
}
}
#line 630 "./arch/x86/include/asm/processor.h"
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 


  {
#line 634
  *eax = op;
#line 635
  *ecx = 0U;
#line 636
  __cpuid(eax, ebx, ecx, edx);
#line 637
  return;
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 73 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 75
  pao_ID__ = 0;
#line 75
  switch (4UL) {
  case 1UL: ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (val));
  }
#line 75
  goto ldv_6061;
  case 2UL: ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
#line 75
  goto ldv_6061;
  case 4UL: ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
#line 75
  goto ldv_6061;
  case 8UL: ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (val));
  }
#line 75
  goto ldv_6061;
  default: 
#line 75
  __bad_percpu_size();
  }
  ldv_6061: ;
#line 77
  return;
}
}
#line 78 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 80
  pao_ID__ = 0;
#line 80
  switch (4UL) {
  case 1UL: ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (- val));
  }
#line 80
  goto ldv_6073;
  case 2UL: ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
#line 80
  goto ldv_6073;
  case 4UL: ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
#line 80
  goto ldv_6073;
  case 8UL: ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (- val));
  }
#line 80
  goto ldv_6073;
  default: 
#line 80
  __bad_percpu_size();
  }
  ldv_6073: ;
#line 82
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6347.rlock);
}
}
#line 301 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_161(spinlock_t *lock ) 
{ 


  {
#line 303
  _raw_spin_lock(& lock->ldv_6347.rlock);
#line 304
  return;
}
}
#line 301
__inline static void spin_lock(spinlock_t *lock ) ;
#line 345 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_165(spinlock_t *lock ) 
{ 


  {
#line 347
  _raw_spin_unlock(& lock->ldv_6347.rlock);
#line 348
  return;
}
}
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 110 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 120
extern void down_write(struct rw_semaphore * ) ;
#line 130
extern void up_read(struct rw_semaphore * ) ;
#line 135
extern void up_write(struct rw_semaphore * ) ;
#line 69 "include/linux/vmalloc.h"
extern void *vmalloc_user(unsigned long  ) ;
#line 72
void *ldv_vmalloc_user_180(unsigned long ldv_func_arg1 ) ;
#line 83
extern void vfree(void const   * ) ;
#line 331 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 334 "include/linux/gfp.h"
__inline static struct page *ldv_alloc_pages_171(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 336
  tmp = alloc_pages_current(gfp_mask, order);
#line 336
  return (tmp);
}
}
#line 334
__inline static struct page *alloc_pages(gfp_t flags , unsigned int order ) ;
#line 371
extern void __free_pages(struct page * , unsigned int  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_176(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445 "include/linux/slab.h"
__inline static void *ldv_kmalloc_172(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 462
  tmp___2 = __kmalloc(size, flags);
#line 462
  return (tmp___2);
}
}
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 12 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void ldv_check_alloc_nonatomic(void) ;
#line 912 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 914
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 18
  __preempt_count_add(1);
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 33
  __asm__  volatile   ("": : : "memory");
#line 34
  __preempt_count_sub(1);
#line 35
  return;
}
}
#line 56 "include/linux/highmem.h"
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
#line 58
  __might_sleep("include/linux/highmem.h", 58, 0);
#line 59
  tmp = lowmem_page_address((struct page  const  *)page);
#line 59
  return (tmp);
}
}
#line 62 "include/linux/highmem.h"
__inline static void kunmap(struct page *page ) 
{ 


  {
#line 64
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  pagefault_disable();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
#line 69
  return (tmp);
}
}
#line 73 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 75
  pagefault_enable();
#line 76
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mmu.h"
struct psb_mmu_driver *psb_mmu_driver_init(struct drm_device *dev , int trap_pagefaults ,
                                           int invalid_type , atomic_t *msvdx_mmu_invaldc ) ;
#line 66
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) ;
#line 69
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) ;
#line 72
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) ;
#line 73
void psb_mmu_flush(struct psb_mmu_driver *driver___0 ) ;
#line 74
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) ;
#line 77
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) ;
#line 81
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) ;
#line 83
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static uint32_t psb_mmu_pt_index(uint32_t offset ) 
{ 


  {
#line 273
  return ((offset >> 12) & 1023U);
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static uint32_t psb_mmu_pd_index(uint32_t offset ) 
{ 


  {
#line 278
  return (offset >> 22);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void psb_clflush(void *addr ) 
{ 


  {
#line 284
  __asm__  volatile   ("clflush (%0)\n": : "r" (addr): "memory");
#line 285
  return;
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void psb_mmu_clflush(struct psb_mmu_driver *driver___0 , void *addr ) 
{ 


  {
#line 289
  if (driver___0->has_clflush == 0) {
#line 290
    return;
  } else {

  }
#line 292
  __asm__  volatile   ("mfence": : : "memory");
#line 293
  psb_clflush(addr);
#line 294
  __asm__  volatile   ("mfence": : : "memory");
#line 295
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static void psb_mmu_flush_pd_locked(struct psb_mmu_driver *driver___0 , int force ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t val ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 306
  dev = driver___0->dev;
#line 307
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 309
  tmp___0 = atomic_read((atomic_t const   *)(& driver___0->needs_tlbflush));
#line 309
  if (tmp___0 != 0 || force != 0) {
#line 310
    tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 310
    val = tmp;
#line 311
    iowrite32(val | 8U, (void *)dev_priv->sgx_reg + 3072U);
#line 314
    __asm__  volatile   ("sfence": : : "memory");
#line 315
    iowrite32(val & 4294967287U, (void *)dev_priv->sgx_reg + 3072U);
#line 316
    ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 317
    if ((unsigned long )driver___0->msvdx_mmu_invaldc != (unsigned long )((atomic_t *)0)) {
#line 318
      atomic_set(driver___0->msvdx_mmu_invaldc, 1);
    } else {

    }
  } else {

  }
#line 320
  atomic_set(& driver___0->needs_tlbflush, 0);
#line 321
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_flush(struct psb_mmu_driver *driver___0 ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t val ;
  int tmp ;

  {
#line 334
  dev = driver___0->dev;
#line 335
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 338
  down_write(& driver___0->sem);
#line 339
  val = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 340
  tmp = atomic_read((atomic_t const   *)(& driver___0->needs_tlbflush));
#line 340
  if (tmp != 0) {
#line 341
    iowrite32(val | 8U, (void *)dev_priv->sgx_reg + 3072U);
  } else {
#line 343
    iowrite32(val | 4U, (void *)dev_priv->sgx_reg + 3072U);
  }
#line 347
  __asm__  volatile   ("sfence": : : "memory");
#line 348
  iowrite32(val & 4294967283U, (void *)dev_priv->sgx_reg + 3072U);
#line 350
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 352
  atomic_set(& driver___0->needs_tlbflush, 0);
#line 353
  if ((unsigned long )driver___0->msvdx_mmu_invaldc != (unsigned long )((atomic_t *)0)) {
#line 354
    atomic_set(driver___0->msvdx_mmu_invaldc, 1);
  } else {

  }
#line 355
  up_write(& driver___0->sem);
#line 356
  return;
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t offset ;

  {
#line 360
  dev = (pd->driver)->dev;
#line 361
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 362
  offset = hw_context != 0 ? (uint32_t )((hw_context + 782) * 4) : 3204U;
#line 365
  down_write(& (pd->driver)->sem);
#line 366
  iowrite32((u32 )(((long )pd->p + 24189255811072L) / 64L) << 12U, (void *)dev_priv->sgx_reg + (unsigned long )offset);
#line 367
  __asm__  volatile   ("sfence": : : "memory");
#line 368
  psb_mmu_flush_pd_locked(pd->driver, 1);
#line 369
  pd->hw_context = hw_context;
#line 370
  up_write(& (pd->driver)->sem);
#line 371
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static unsigned long psb_pd_addr_end(unsigned long addr , unsigned long end ) 
{ 


  {
#line 377
  addr = (addr + 4194304UL) & 0xffffffffffc00000UL;
#line 378
  return (addr < end ? addr : end);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static uint32_t psb_mmu_mask_pte(uint32_t pfn , int type ) 
{ 
  uint32_t mask ;

  {
#line 383
  mask = 1U;
#line 385
  if (type & 1) {
#line 386
    mask = mask | 8U;
  } else {

  }
#line 387
  if ((type & 2) != 0) {
#line 388
    mask = mask | 4U;
  } else {

  }
#line 389
  if ((type & 4) != 0) {
#line 390
    mask = mask | 2U;
  } else {

  }
#line 392
  return ((pfn << 12) | mask);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) 
{ 
  struct psb_mmu_pd *pd ;
  void *tmp ;
  uint32_t *v ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 398
  tmp = kmalloc(64UL, 208U);
#line 398
  pd = (struct psb_mmu_pd *)tmp;
#line 402
  if ((unsigned long )pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 403
    return ((struct psb_mmu_pd *)0);
  } else {

  }
#line 405
  pd->p = alloc_pages(4U, 0U);
#line 406
  if ((unsigned long )pd->p == (unsigned long )((struct page *)0)) {
#line 407
    goto out_err1;
  } else {

  }
#line 408
  pd->dummy_pt = alloc_pages(4U, 0U);
#line 409
  if ((unsigned long )pd->dummy_pt == (unsigned long )((struct page *)0)) {
#line 410
    goto out_err2;
  } else {

  }
#line 411
  pd->dummy_page = alloc_pages(4U, 0U);
#line 412
  if ((unsigned long )pd->dummy_page == (unsigned long )((struct page *)0)) {
#line 413
    goto out_err3;
  } else {

  }
#line 415
  if (trap_pagefaults == 0) {
#line 416
    pd->invalid_pde = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_pt + 24189255811072L) / 64L),
                                       invalid_type);
#line 418
    pd->invalid_pte = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_page + 24189255811072L) / 64L),
                                       invalid_type);
  } else {
#line 421
    pd->invalid_pde = 0U;
#line 422
    pd->invalid_pte = 0U;
  }
#line 425
  tmp___0 = kmap(pd->dummy_pt);
#line 425
  v = (uint32_t *)tmp___0;
#line 426
  i = 0;
#line 426
  goto ldv_39759;
  ldv_39758: 
#line 427
  *(v + (unsigned long )i) = pd->invalid_pte;
#line 426
  i = i + 1;
  ldv_39759: ;
#line 426
  if ((unsigned int )i <= 1023U) {
#line 428
    goto ldv_39758;
  } else {

  }
#line 429
  kunmap(pd->dummy_pt);
#line 431
  tmp___1 = kmap(pd->p);
#line 431
  v = (uint32_t *)tmp___1;
#line 432
  i = 0;
#line 432
  goto ldv_39762;
  ldv_39761: 
#line 433
  *(v + (unsigned long )i) = pd->invalid_pde;
#line 432
  i = i + 1;
  ldv_39762: ;
#line 432
  if ((unsigned int )i <= 1023U) {
#line 434
    goto ldv_39761;
  } else {

  }
#line 435
  kunmap(pd->p);
#line 437
  tmp___2 = kmap(pd->dummy_page);
#line 437
  clear_page(tmp___2);
#line 438
  kunmap(pd->dummy_page);
#line 440
  tmp___3 = ldv_vmalloc_user_180(8192UL);
#line 440
  pd->tables = (struct psb_mmu_pt **)tmp___3;
#line 441
  if ((unsigned long )pd->tables == (unsigned long )((struct psb_mmu_pt **)0)) {
#line 442
    goto out_err4;
  } else {

  }
#line 444
  pd->hw_context = -1;
#line 445
  pd->pd_mask = 1U;
#line 446
  pd->driver = driver___0;
#line 448
  return (pd);
  out_err4: 
#line 451
  __free_pages(pd->dummy_page, 0U);
  out_err3: 
#line 453
  __free_pages(pd->dummy_pt, 0U);
  out_err2: 
#line 455
  __free_pages(pd->p, 0U);
  out_err1: 
#line 457
  kfree((void const   *)pd);
#line 458
  return ((struct psb_mmu_pd *)0);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static void psb_mmu_free_pt(struct psb_mmu_pt *pt ) 
{ 


  {
#line 463
  __free_pages(pt->p, 0U);
#line 464
  kfree((void const   *)pt);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) 
{ 
  struct psb_mmu_driver *driver___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_mmu_pt *pt ;
  int i ;

  {
#line 469
  driver___0 = pd->driver;
#line 470
  dev = driver___0->dev;
#line 471
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 475
  down_write(& driver___0->sem);
#line 476
  if (pd->hw_context != -1) {
#line 477
    iowrite32(0U, (void *)dev_priv->sgx_reg + (unsigned long )((pd->hw_context + 801) * 4));
#line 478
    psb_mmu_flush_pd_locked(driver___0, 1);
  } else {

  }
#line 484
  i = 0;
#line 484
  goto ldv_39777;
  ldv_39776: 
#line 485
  pt = *(pd->tables + (unsigned long )i);
#line 486
  if ((unsigned long )pt != (unsigned long )((struct psb_mmu_pt *)0)) {
#line 487
    psb_mmu_free_pt(pt);
  } else {

  }
#line 484
  i = i + 1;
  ldv_39777: ;
#line 484
  if (i <= 1023) {
#line 486
    goto ldv_39776;
  } else {

  }
#line 490
  vfree((void const   *)pd->tables);
#line 491
  __free_pages(pd->dummy_page, 0U);
#line 492
  __free_pages(pd->dummy_pt, 0U);
#line 493
  __free_pages(pd->p, 0U);
#line 494
  kfree((void const   *)pd);
#line 495
  up_write(& driver___0->sem);
#line 496
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static struct psb_mmu_pt *psb_mmu_alloc_pt(struct psb_mmu_pd *pd ) 
{ 
  struct psb_mmu_pt *pt ;
  void *tmp ;
  void *v ;
  uint32_t clflush_add ;
  uint32_t clflush_count ;
  spinlock_t *lock ;
  uint8_t *clf ;
  uint32_t *ptes ;
  int i ;
  uint32_t *tmp___0 ;

  {
#line 500
  tmp = kmalloc(32UL, 208U);
#line 500
  pt = (struct psb_mmu_pt *)tmp;
#line 502
  clflush_add = (uint32_t )((pd->driver)->clflush_add >> 12);
#line 503
  clflush_count = 4096U / clflush_add;
#line 504
  lock = & (pd->driver)->lock;
#line 509
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 510
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 512
  pt->p = alloc_pages(4U, 0U);
#line 513
  if ((unsigned long )pt->p == (unsigned long )((struct page *)0)) {
#line 514
    kfree((void const   *)pt);
#line 515
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 518
  spin_lock(lock);
#line 520
  v = kmap_atomic(pt->p);
#line 521
  clf = (uint8_t *)v;
#line 522
  ptes = (uint32_t *)v;
#line 523
  i = 0;
#line 523
  goto ldv_39791;
  ldv_39790: 
#line 524
  tmp___0 = ptes;
#line 524
  ptes = ptes + 1;
#line 524
  *tmp___0 = pd->invalid_pte;
#line 523
  i = i + 1;
  ldv_39791: ;
#line 523
  if ((unsigned int )i <= 1023U) {
#line 525
    goto ldv_39790;
  } else {

  }

#line 527
  if ((pd->driver)->has_clflush != 0 && pd->hw_context != -1) {
#line 528
    __asm__  volatile   ("mfence": : : "memory");
#line 529
    i = 0;
#line 529
    goto ldv_39794;
    ldv_39793: 
#line 530
    psb_clflush((void *)clf);
#line 531
    clf = clf + (unsigned long )clflush_add;
#line 529
    i = i + 1;
    ldv_39794: ;
#line 529
    if ((uint32_t )i < clflush_count) {
#line 531
      goto ldv_39793;
    } else {

    }
#line 533
    __asm__  volatile   ("mfence": : : "memory");
  } else {

  }
#line 536
  __kunmap_atomic(v);
#line 537
  spin_unlock(lock);
#line 539
  pt->count = 0U;
#line 540
  pt->pd = pd;
#line 541
  pt->index = 0U;
#line 543
  return (pt);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
struct psb_mmu_pt *psb_mmu_pt_alloc_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ 
  uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  uint32_t *v ;
  spinlock_t *lock ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 549
  tmp = psb_mmu_pd_index((uint32_t )addr);
#line 549
  index = tmp;
#line 552
  lock = & (pd->driver)->lock;
#line 554
  spin_lock(lock);
#line 555
  pt = *(pd->tables + (unsigned long )index);
#line 556
  goto ldv_39804;
  ldv_39805: 
#line 557
  spin_unlock(lock);
#line 558
  pt = psb_mmu_alloc_pt(pd);
#line 559
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 560
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 561
  spin_lock(lock);
#line 563
  if ((unsigned long )*(pd->tables + (unsigned long )index) != (unsigned long )((struct psb_mmu_pt *)0)) {
#line 564
    spin_unlock(lock);
#line 565
    psb_mmu_free_pt(pt);
#line 566
    spin_lock(lock);
#line 567
    pt = *(pd->tables + (unsigned long )index);
#line 568
    goto ldv_39804;
  } else {

  }
#line 571
  tmp___0 = kmap_atomic(pd->p);
#line 571
  v = (uint32_t *)tmp___0;
#line 572
  *(pd->tables + (unsigned long )index) = pt;
#line 573
  *(v + (unsigned long )index) = ((uint32_t )(((long )pt->p + 24189255811072L) / 64L) << 12U) | pd->pd_mask;
#line 574
  pt->index = index;
#line 575
  __kunmap_atomic((void *)v);
#line 577
  if (pd->hw_context != -1) {
#line 578
    psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )index);
#line 579
    atomic_set(& (pd->driver)->needs_tlbflush, 1);
  } else {

  }
  ldv_39804: ;
#line 556
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 558
    goto ldv_39805;
  } else {

  }
#line 582
  tmp___1 = kmap_atomic(pt->p);
#line 582
  pt->v = (uint32_t *)tmp___1;
#line 583
  return (pt);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static struct psb_mmu_pt *psb_mmu_pt_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ 
  uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  spinlock_t *lock ;
  void *tmp___0 ;

  {
#line 589
  tmp = psb_mmu_pd_index((uint32_t )addr);
#line 589
  index = tmp;
#line 591
  lock = & (pd->driver)->lock;
#line 593
  spin_lock(lock);
#line 594
  pt = *(pd->tables + (unsigned long )index);
#line 595
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 596
    spin_unlock(lock);
#line 597
    return ((struct psb_mmu_pt *)0);
  } else {

  }
#line 599
  tmp___0 = kmap_atomic(pt->p);
#line 599
  pt->v = (uint32_t *)tmp___0;
#line 600
  return (pt);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static void psb_mmu_pt_unmap_unlock(struct psb_mmu_pt *pt ) 
{ 
  struct psb_mmu_pd *pd ;
  uint32_t *v ;
  void *tmp ;

  {
#line 605
  pd = pt->pd;
#line 608
  __kunmap_atomic((void *)pt->v);
#line 609
  if (pt->count == 0U) {
#line 610
    tmp = kmap_atomic(pd->p);
#line 610
    v = (uint32_t *)tmp;
#line 611
    *(v + (unsigned long )pt->index) = pd->invalid_pde;
#line 612
    *(pd->tables + (unsigned long )pt->index) = (struct psb_mmu_pt *)0;
#line 614
    if (pd->hw_context != -1) {
#line 615
      psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )pt->index);
#line 616
      atomic_set(& (pd->driver)->needs_tlbflush, 1);
    } else {

    }
#line 618
    __kunmap_atomic((void *)pt->v);
#line 619
    spin_unlock(& (pd->driver)->lock);
#line 620
    psb_mmu_free_pt(pt);
#line 621
    return;
  } else {

  }
#line 623
  spin_unlock(& (pd->driver)->lock);
#line 624
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void psb_mmu_set_pte(struct psb_mmu_pt *pt , unsigned long addr ,
                                     uint32_t pte ) 
{ 
  uint32_t tmp ;

  {
#line 629
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 629
  *(pt->v + (unsigned long )tmp) = pte;
#line 630
  return;
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void psb_mmu_invalidate_pte(struct psb_mmu_pt *pt , unsigned long addr ) 
{ 
  uint32_t tmp ;

  {
#line 635
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 635
  *(pt->v + (unsigned long )tmp) = (pt->pd)->invalid_pte;
#line 636
  return;
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) 
{ 
  struct psb_mmu_pd *pd ;

  {
#line 642
  down_read(& driver___0->sem);
#line 643
  pd = driver___0->default_pd;
#line 644
  up_read(& driver___0->sem);
#line 646
  return (pd);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
uint32_t psb_get_default_pd_addr(struct psb_mmu_driver *driver___0 ) 
{ 
  struct psb_mmu_pd *pd ;

  {
#line 654
  pd = psb_mmu_get_default_pd(driver___0);
#line 655
  return ((uint32_t )(((long )pd->p + 24189255811072L) / 64L) << 12U);
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;

  {
#line 660
  dev = driver___0->dev;
#line 661
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 663
  iowrite32(driver___0->bif_ctrl, (void *)dev_priv->sgx_reg + 3072U);
#line 664
  psb_mmu_free_pagedir(driver___0->default_pd);
#line 665
  kfree((void const   *)driver___0);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
struct psb_mmu_driver *psb_mmu_driver_init(struct drm_device *dev , int trap_pagefaults ,
                                           int invalid_type , atomic_t *msvdx_mmu_invaldc ) 
{ 
  struct psb_mmu_driver *driver___0 ;
  struct drm_psb_private *dev_priv ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tfms ;
  uint32_t misc ;
  uint32_t cap0 ;
  uint32_t cap4 ;
  uint32_t clflush_size ;
  int tmp___0 ;

  {
#line 674
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 676
  tmp = kmalloc(288UL, 208U);
#line 676
  driver___0 = (struct psb_mmu_driver *)tmp;
#line 678
  if ((unsigned long )driver___0 == (unsigned long )((struct psb_mmu_driver *)0)) {
#line 679
    return ((struct psb_mmu_driver *)0);
  } else {

  }
#line 681
  driver___0->dev = dev;
#line 682
  driver___0->default_pd = psb_mmu_alloc_pd(driver___0, trap_pagefaults, invalid_type);
#line 684
  if ((unsigned long )driver___0->default_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 685
    goto out_err1;
  } else {

  }
#line 687
  spinlock_check(& driver___0->lock);
#line 687
  __raw_spin_lock_init(& driver___0->lock.ldv_6347.rlock, "&(&driver->lock)->rlock",
                       & __key);
#line 688
  __init_rwsem(& driver___0->sem, "&driver->sem", & __key___0);
#line 689
  down_write(& driver___0->sem);
#line 690
  atomic_set(& driver___0->needs_tlbflush, 1);
#line 691
  driver___0->msvdx_mmu_invaldc = msvdx_mmu_invaldc;
#line 693
  driver___0->bif_ctrl = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 694
  iowrite32(driver___0->bif_ctrl | 16U, (void *)dev_priv->sgx_reg + 3072U);
#line 696
  iowrite32(driver___0->bif_ctrl & 4294967279U, (void *)dev_priv->sgx_reg + 3072U);
#line 699
  driver___0->has_clflush = 0;
#line 702
  tmp___0 = constant_test_bit(19L, (unsigned long const volatile   *)(& boot_cpu_data.x86_capability));
#line 702
  if (tmp___0 != 0) {
#line 710
    cpuid(1U, & tfms, & misc, & cap0, & cap4);
#line 711
    clflush_size = ((misc >> 8) & 255U) * 8U;
#line 712
    driver___0->has_clflush = 1;
#line 713
    driver___0->clflush_add = (int )(((unsigned long )clflush_size * 4096UL) / 4UL);
#line 715
    driver___0->clflush_mask = (unsigned long )(driver___0->clflush_add + -1);
#line 716
    driver___0->clflush_mask = ~ driver___0->clflush_mask;
  } else {

  }
#line 720
  up_write(& driver___0->sem);
#line 721
  return (driver___0);
  out_err1: 
#line 724
  kfree((void const   *)driver___0);
#line 725
  return ((struct psb_mmu_driver *)0);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
static void psb_mmu_flush_ptes(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                               uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long clflush_add ;
  unsigned long clflush_mask ;
  uint32_t tmp ;

  {
#line 734
  rows = 1U;
#line 741
  clflush_add = (unsigned long )(pd->driver)->clflush_add;
#line 742
  clflush_mask = (pd->driver)->clflush_mask;
#line 744
  if ((pd->driver)->has_clflush == 0) {
#line 745
    return;
  } else {

  }
#line 747
  if (hw_tile_stride != 0U) {
#line 748
    rows = num_pages / desired_tile_stride;
  } else {
#line 750
    desired_tile_stride = num_pages;
  }
#line 752
  add = (unsigned long )(desired_tile_stride << 12);
#line 753
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 754
  __asm__  volatile   ("mfence": : : "memory");
#line 755
  i = 0U;
#line 755
  goto ldv_39880;
  ldv_39879: 
#line 757
  addr = address;
#line 758
  end = addr + add;
  ldv_39877: 
#line 761
  next = psb_pd_addr_end(addr, end);
#line 762
  pt = psb_mmu_pt_map_lock(pd, addr);
#line 763
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 764
    goto ldv_39874;
  } else {

  }
  ldv_39875: 
#line 766
  tmp = psb_mmu_pt_index((uint32_t )addr);
#line 766
  psb_clflush((void *)pt->v + (unsigned long )tmp);
#line 768
  addr = addr + clflush_add;
#line 768
  if ((addr & clflush_mask) < next) {
#line 770
    goto ldv_39875;
  } else {

  }
#line 770
  psb_mmu_pt_unmap_unlock(pt);
  ldv_39874: 
#line 771
  addr = next;
#line 771
  if (next != end) {
#line 773
    goto ldv_39877;
  } else {

  }
#line 772
  address = address + row_add;
#line 755
  i = i + 1U;
  ldv_39880: ;
#line 755
  if (i < rows) {
#line 757
    goto ldv_39879;
  } else {

  }
#line 774
  __asm__  volatile   ("mfence": : : "memory");
#line 775
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) 
{ 
  struct psb_mmu_pt *pt ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;

  {
#line 792
  f_address = address;
#line 794
  down_read(& (pd->driver)->sem);
#line 796
  addr = address;
#line 797
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_39895: 
#line 800
  next = psb_pd_addr_end(addr, end);
#line 801
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 802
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 803
    goto out;
  } else {

  }
  ldv_39893: 
#line 805
  psb_mmu_invalidate_pte(pt, addr);
#line 806
  pt->count = pt->count - 1U;
#line 807
  addr = addr + 4096UL;
#line 807
  if (addr < next) {
#line 809
    goto ldv_39893;
  } else {

  }
#line 808
  psb_mmu_pt_unmap_unlock(pt);
#line 810
  addr = next;
#line 810
  if (next != end) {
#line 812
    goto ldv_39895;
  } else {

  }

  out: ;
#line 813
  if (pd->hw_context != -1) {
#line 814
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
#line 816
  up_read(& (pd->driver)->sem);
#line 818
  if (pd->hw_context != -1) {
#line 819
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 821
  return;
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;

  {
#line 829
  rows = 1U;
#line 836
  f_address = address;
#line 838
  if (hw_tile_stride != 0U) {
#line 839
    rows = num_pages / desired_tile_stride;
  } else {
#line 841
    desired_tile_stride = num_pages;
  }
#line 843
  add = (unsigned long )(desired_tile_stride << 12);
#line 844
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 846
  down_read(& (pd->driver)->sem);
#line 850
  i = 0U;
#line 850
  goto ldv_39919;
  ldv_39918: 
#line 852
  addr = address;
#line 853
  end = addr + add;
  ldv_39916: 
#line 856
  next = psb_pd_addr_end(addr, end);
#line 857
  pt = psb_mmu_pt_map_lock(pd, addr);
#line 858
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 859
    goto ldv_39913;
  } else {

  }
  ldv_39914: 
#line 861
  psb_mmu_invalidate_pte(pt, addr);
#line 862
  pt->count = pt->count - 1U;
#line 864
  addr = addr + 4096UL;
#line 864
  if (addr < next) {
#line 866
    goto ldv_39914;
  } else {

  }
#line 865
  psb_mmu_pt_unmap_unlock(pt);
  ldv_39913: 
#line 867
  addr = next;
#line 867
  if (next != end) {
#line 869
    goto ldv_39916;
  } else {

  }
#line 868
  address = address + row_add;
#line 850
  i = i + 1U;
  ldv_39919: ;
#line 850
  if (i < rows) {
#line 852
    goto ldv_39918;
  } else {

  }

#line 870
  if (pd->hw_context != -1) {
#line 871
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
#line 874
  up_read(& (pd->driver)->sem);
#line 876
  if (pd->hw_context != -1) {
#line 877
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 878
  return;
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;
  int ret ;
  uint32_t tmp ;

  {
#line 889
  f_address = address;
#line 890
  ret = -12;
#line 892
  down_read(& (pd->driver)->sem);
#line 894
  addr = address;
#line 895
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_39938: 
#line 898
  next = psb_pd_addr_end(addr, end);
#line 899
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 900
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 901
    ret = -12;
#line 902
    goto out;
  } else {

  }
  ldv_39936: 
#line 905
  tmp = start_pfn;
#line 905
  start_pfn = start_pfn + 1U;
#line 905
  pte = psb_mmu_mask_pte(tmp, type);
#line 906
  psb_mmu_set_pte(pt, addr, pte);
#line 907
  pt->count = pt->count + 1U;
#line 908
  addr = addr + 4096UL;
#line 908
  if (addr < next) {
#line 910
    goto ldv_39936;
  } else {

  }
#line 909
  psb_mmu_pt_unmap_unlock(pt);
#line 911
  addr = next;
#line 911
  if (next != end) {
#line 913
    goto ldv_39938;
  } else {

  }
#line 912
  ret = 0;
  out: ;
#line 915
  if (pd->hw_context != -1) {
#line 916
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
#line 918
  up_read(& (pd->driver)->sem);
#line 920
  if (pd->hw_context != -1) {
#line 921
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 923
  return (0);
}
}
#line 926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) 
{ 
  struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;
  int ret ;
  struct page **tmp ;

  {
#line 932
  rows = 1U;
#line 940
  f_address = address;
#line 941
  ret = -12;
#line 943
  if (hw_tile_stride != 0U) {
#line 944
    if (num_pages % desired_tile_stride != 0U) {
#line 945
      return (-22);
    } else {

    }
#line 946
    rows = num_pages / desired_tile_stride;
  } else {
#line 948
    desired_tile_stride = num_pages;
  }
#line 951
  add = (unsigned long )(desired_tile_stride << 12);
#line 952
  row_add = (unsigned long )(hw_tile_stride << 12);
#line 954
  down_read(& (pd->driver)->sem);
#line 956
  i = 0U;
#line 956
  goto ldv_39966;
  ldv_39965: 
#line 958
  addr = address;
#line 959
  end = addr + add;
  ldv_39963: 
#line 962
  next = psb_pd_addr_end(addr, end);
#line 963
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
#line 964
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 965
    goto out;
  } else {

  }
  ldv_39961: 
#line 967
  tmp = pages;
#line 967
  pages = pages + 1;
#line 967
  pte = psb_mmu_mask_pte((uint32_t )(((long )*tmp + 24189255811072L) / 64L), type);
#line 969
  psb_mmu_set_pte(pt, addr, pte);
#line 970
  pt->count = pt->count + 1U;
#line 971
  addr = addr + 4096UL;
#line 971
  if (addr < next) {
#line 973
    goto ldv_39961;
  } else {

  }
#line 972
  psb_mmu_pt_unmap_unlock(pt);
#line 974
  addr = next;
#line 974
  if (next != end) {
#line 976
    goto ldv_39963;
  } else {

  }
#line 976
  address = address + row_add;
#line 956
  i = i + 1U;
  ldv_39966: ;
#line 956
  if (i < rows) {
#line 958
    goto ldv_39965;
  } else {

  }
#line 979
  ret = 0;
  out: ;
#line 981
  if (pd->hw_context != -1) {
#line 982
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
#line 985
  up_read(& (pd->driver)->sem);
#line 987
  if (pd->hw_context != -1) {
#line 988
    psb_mmu_flush(pd->driver);
  } else {

  }
#line 990
  return (ret);
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) 
{ 
  int ret ;
  struct psb_mmu_pt *pt ;
  uint32_t tmp ;
  spinlock_t *lock ;
  uint32_t *v ;
  void *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 999
  lock = & (pd->driver)->lock;
#line 1001
  down_read(& (pd->driver)->sem);
#line 1002
  pt = psb_mmu_pt_map_lock(pd, (unsigned long )virtual);
#line 1003
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
#line 1006
    spin_lock(lock);
#line 1007
    tmp___0 = kmap_atomic(pd->p);
#line 1007
    v = (uint32_t *)tmp___0;
#line 1008
    tmp___1 = psb_mmu_pd_index(virtual);
#line 1008
    tmp = *(v + (unsigned long )tmp___1);
#line 1009
    __kunmap_atomic((void *)v);
#line 1010
    spin_unlock(lock);
#line 1012
    if ((pd->invalid_pde != tmp || (tmp & 1U) == 0U) || (pd->invalid_pte & 1U) == 0U) {
#line 1014
      ret = -22;
#line 1015
      goto out;
    } else {

    }
#line 1017
    ret = 0;
#line 1018
    *pfn = (unsigned long )(pd->invalid_pte >> 12);
#line 1019
    goto out;
  } else {

  }
#line 1021
  tmp___2 = psb_mmu_pt_index(virtual);
#line 1021
  tmp = *(pt->v + (unsigned long )tmp___2);
#line 1022
  if ((tmp & 1U) == 0U) {
#line 1023
    ret = -22;
  } else {
#line 1025
    ret = 0;
#line 1026
    *pfn = (unsigned long )(tmp >> 12);
  }
#line 1028
  psb_mmu_pt_unmap_unlock(pt);
  out: 
#line 1030
  up_read(& (pd->driver)->sem);
#line 1031
  return (ret);
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 1037
  ldv_spin_lock();
#line 1039
  ldv_spin_lock_161(lock);
#line 1040
  return;
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 1072
  ldv_spin_unlock();
#line 1074
  ldv_spin_unlock_165(lock);
#line 1075
  return;
}
}
#line 1123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static struct page *alloc_pages(gfp_t flags , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 1126
  ldv_check_alloc_flags(flags);
#line 1128
  tmp = ldv_alloc_pages_171(flags, order);
#line 1128
  return (tmp);
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 1134
  ldv_check_alloc_flags(flags);
#line 1136
  ldv_kmalloc_172(size, flags);
#line 1137
  return ((void *)0);
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void *ldv_kmem_cache_alloc_176(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1164
  ldv_check_alloc_flags(flags);
#line 1166
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1167
  return ((void *)0);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mmu.o.c.prepared"
void *ldv_vmalloc_user_180(unsigned long ldv_func_arg1 ) 
{ 


  {
#line 1192
  ldv_check_alloc_nonatomic();
#line 1194
  vmalloc_user(ldv_func_arg1);
#line 1195
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_198(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
int gma_blt_wait_idle(struct drm_psb_private *dev_priv ) 
{ 
  unsigned long stop ;
  int busy ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 245
  stop = (unsigned long )jiffies + 250UL;
#line 246
  busy = 1;
#line 249
  if (((int )((dev_priv->dev)->pdev)->device & 65520) == 3040) {
#line 250
    return (0);
  } else {

  }
#line 253
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 253
  if (tmp == 128U) {
#line 253
    tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 253
    if ((tmp___0 & 16777216U) == 0U) {
#line 255
      return (0);
    } else {

    }
  } else {

  }
  ldv_39714: 
#line 258
  tmp___1 = ioread32((void *)dev_priv->sgx_reg + 3608U);
#line 258
  busy = tmp___1 != 128U;
#line 259
  if (busy != 0 && (long )((unsigned long )jiffies - stop) < 0L) {
#line 261
    goto ldv_39714;
  } else {

  }

#line 261
  if (busy != 0) {
#line 262
    return (-16);
  } else {

  }
  ldv_39722: 
#line 265
  tmp___2 = ioread32((void *)dev_priv->sgx_reg + 3588U);
#line 265
  busy = (tmp___2 & 16777216U) != 0U;
#line 267
  if (busy != 0 && (long )((unsigned long )jiffies - stop) < 0L) {
#line 269
    goto ldv_39722;
  } else {

  }

#line 270
  return (busy != 0 ? -16 : 0);
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/blitter.o.c.prepared"
void *ldv_kmem_cache_alloc_198(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 403
  ldv_check_alloc_flags(flags);
#line 405
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 406
  return ((void *)0);
}
}
#line 372 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_218(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 852 "include/linux/pci.h"
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 877 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 880
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 880
  return (tmp);
}
}
#line 924
extern int pci_enable_device(struct pci_dev * ) ;
#line 941
extern void pci_disable_device(struct pci_dev * ) ;
#line 997
extern int pci_save_state(struct pci_dev * ) ;
#line 998
extern void pci_restore_state(struct pci_dev * ) ;
#line 1009
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1426 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1428
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1428
  return (tmp);
}
}
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/power.h"
void gma_power_init(struct drm_device *dev ) ;
#line 37
void gma_power_uninit(struct drm_device *dev ) ;
#line 42
int gma_power_suspend(struct device *_dev ) ;
#line 43
int gma_power_resume(struct device *_dev ) ;
#line 44
int gma_power_thaw(struct device *_dev ) ;
#line 45
int gma_power_freeze(struct device *_dev ) ;
#line 46
int gma_power_restore(struct device *_dev ) ;
#line 61
bool gma_power_is_on(struct drm_device *dev ) ;
#line 66
int psb_runtime_suspend(struct device *dev ) ;
#line 67
int psb_runtime_resume(struct device *dev ) ;
#line 68
int psb_runtime_idle(struct device *dev ) ;
#line 42 "include/linux/pm_runtime.h"
extern int __pm_runtime_idle(struct device * , int  ) ;
#line 44
extern int __pm_runtime_resume(struct device * , int  ) ;
#line 46
extern int __pm_runtime_set_status(struct device * , unsigned int  ) ;
#line 49
extern void __pm_runtime_disable(struct device * , bool  ) ;
#line 212 "include/linux/pm_runtime.h"
__inline static int pm_runtime_get(struct device *dev ) 
{ 
  int tmp ;

  {
#line 214
  tmp = __pm_runtime_resume(dev, 5);
#line 214
  return (tmp);
}
}
#line 222 "include/linux/pm_runtime.h"
__inline static int pm_runtime_put(struct device *dev ) 
{ 
  int tmp ;

  {
#line 224
  tmp = __pm_runtime_idle(dev, 5);
#line 224
  return (tmp);
}
}
#line 253 "include/linux/pm_runtime.h"
__inline static void pm_runtime_set_suspended(struct device *dev ) 
{ 


  {
#line 255
  __pm_runtime_set_status(dev, 2U);
#line 256
  return;
}
}
#line 258 "include/linux/pm_runtime.h"
__inline static void pm_runtime_disable(struct device *dev ) 
{ 


  {
#line 260
  __pm_runtime_disable(dev, 1);
#line 261
  return;
}
}
#line 678 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_irq_preinstall(struct drm_device *dev ) ;
#line 679
int psb_irq_postinstall(struct drm_device *dev ) ;
#line 680
void psb_irq_uninstall(struct drm_device *dev ) ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static struct mutex power_mutex  ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static spinlock_t power_ctrl_lock  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
void gma_power_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 269
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 272
  dev_priv->apm_base = (uint16_t )dev_priv->apm_reg;
#line 273
  dev_priv->ospm_base = dev_priv->ospm_base & 65535U;
#line 275
  dev_priv->display_power = 1;
#line 276
  dev_priv->display_count = 0;
#line 277
  dev_priv->suspended = 0;
#line 278
  spinlock_check(& power_ctrl_lock);
#line 278
  __raw_spin_lock_init(& power_ctrl_lock.ldv_6347.rlock, "&(&power_ctrl_lock)->rlock",
                       & __key);
#line 279
  __mutex_init(& power_mutex, "&power_mutex", & __key___0);
#line 281
  if ((unsigned long )(dev_priv->ops)->init_pm != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 282
    (*((dev_priv->ops)->init_pm))(dev);
  } else {

  }
#line 283
  return;
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
void gma_power_uninit(struct drm_device *dev ) 
{ 


  {
#line 293
  pm_runtime_disable(& (dev->pdev)->dev);
#line 294
  pm_runtime_set_suspended(& (dev->pdev)->dev);
#line 295
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static void gma_suspend_display(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 305
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 307
  if ((int )dev_priv->suspended) {
#line 308
    return;
  } else {

  }
#line 309
  (*((dev_priv->ops)->save_regs))(dev);
#line 310
  (*((dev_priv->ops)->power_down))(dev);
#line 311
  dev_priv->display_power = 0;
#line 312
  return;
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static void gma_resume_display(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 322
  tmp = pci_get_drvdata(pdev);
#line 322
  dev = (struct drm_device *)tmp;
#line 323
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 326
  (*((dev_priv->ops)->power_up))(dev);
#line 327
  dev_priv->suspended = 0;
#line 328
  dev_priv->display_power = 1;
#line 330
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
#line 331
  pci_write_config_word((struct pci_dev  const  *)pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
#line 334
  psb_gtt_restore(dev);
#line 335
  (*((dev_priv->ops)->restore_regs))(dev);
#line 336
  return;
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static void gma_suspend_pci(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int bsm ;
  int vbt ;

  {
#line 346
  tmp = pci_get_drvdata(pdev);
#line 346
  dev = (struct drm_device *)tmp;
#line 347
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 350
  if ((int )dev_priv->suspended) {
#line 351
    return;
  } else {

  }
#line 353
  pci_save_state(pdev);
#line 354
  pci_read_config_dword((struct pci_dev  const  *)pdev, 92, (u32 *)(& bsm));
#line 355
  dev_priv->regs.saveBSM = (uint32_t )bsm;
#line 356
  pci_read_config_dword((struct pci_dev  const  *)pdev, 252, (u32 *)(& vbt));
#line 357
  dev_priv->regs.saveVBT = (uint32_t )vbt;
#line 358
  pci_read_config_dword((struct pci_dev  const  *)pdev, 148, & dev_priv->msi_addr);
#line 359
  pci_read_config_dword((struct pci_dev  const  *)pdev, 152, & dev_priv->msi_data);
#line 361
  pci_disable_device(pdev);
#line 362
  pci_set_power_state(pdev, 3);
#line 364
  dev_priv->suspended = 1;
#line 365
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
static bool gma_resume_pci(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int ret ;

  {
#line 376
  tmp = pci_get_drvdata(pdev);
#line 376
  dev = (struct drm_device *)tmp;
#line 377
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 380
  if (! dev_priv->suspended) {
#line 381
    return (1);
  } else {

  }
#line 383
  pci_set_power_state(pdev, 0);
#line 384
  pci_restore_state(pdev);
#line 385
  pci_write_config_dword((struct pci_dev  const  *)pdev, 92, dev_priv->regs.saveBSM);
#line 386
  pci_write_config_dword((struct pci_dev  const  *)pdev, 252, dev_priv->regs.saveVBT);
#line 388
  pci_write_config_dword((struct pci_dev  const  *)pdev, 148, dev_priv->msi_addr);
#line 389
  pci_write_config_dword((struct pci_dev  const  *)pdev, 152, dev_priv->msi_data);
#line 390
  ret = pci_enable_device(pdev);
#line 392
  if (ret != 0) {
#line 393
    dev_err((struct device  const  *)(& pdev->dev), "pci_enable failed: %d\n", ret);
  } else {
#line 395
    dev_priv->suspended = 0;
  }
#line 396
  return ((bool )(! ((int )dev_priv->suspended != 0)));
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int gma_power_suspend(struct device *_dev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 410
  __mptr = (struct device  const  *)_dev;
#line 410
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 411
  tmp = pci_get_drvdata(pdev);
#line 411
  dev = (struct drm_device *)tmp;
#line 412
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 414
  mutex_lock_nested(& power_mutex, 0U);
#line 415
  if (! dev_priv->suspended) {
#line 416
    if (dev_priv->display_count != 0) {
#line 417
      mutex_unlock(& power_mutex);
#line 418
      dev_err((struct device  const  *)dev->dev, "GPU hardware busy, cannot suspend\n");
#line 419
      return (-16);
    } else {

    }
#line 421
    psb_irq_uninstall(dev);
#line 422
    gma_suspend_display(dev);
#line 423
    gma_suspend_pci(pdev);
  } else {

  }
#line 425
  mutex_unlock(& power_mutex);
#line 426
  return (0);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int gma_power_resume(struct device *_dev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;

  {
#line 437
  __mptr = (struct device  const  *)_dev;
#line 437
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 438
  tmp = pci_get_drvdata(pdev);
#line 438
  dev = (struct drm_device *)tmp;
#line 440
  mutex_lock_nested(& power_mutex, 0U);
#line 441
  gma_resume_pci(pdev);
#line 442
  gma_resume_display(pdev);
#line 443
  psb_irq_preinstall(dev);
#line 444
  psb_irq_postinstall(dev);
#line 445
  mutex_unlock(& power_mutex);
#line 446
  return (0);
}
}
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool gma_power_is_on(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 457
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 458
  return (dev_priv->display_power);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
bool gma_power_begin(struct drm_device *dev , bool force_on ) 
{ 
  struct drm_psb_private *dev_priv ;
  int ret ;
  unsigned long flags ;
  bool tmp ;

  {
#line 471
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 475
  ldv_spin_lock();
#line 477
  if ((int )dev_priv->display_power) {
#line 478
    dev_priv->display_count = dev_priv->display_count + 1;
#line 479
    pm_runtime_get(& (dev->pdev)->dev);
#line 480
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 481
    return (1);
  } else {

  }
#line 483
  if (! force_on) {
#line 484
    goto out_false;
  } else {

  }
#line 487
  tmp = gma_resume_pci(dev->pdev);
#line 487
  ret = (int )tmp;
#line 488
  if (ret == 0) {
#line 489
    psb_irq_preinstall(dev);
#line 490
    psb_irq_postinstall(dev);
#line 491
    pm_runtime_get(& (dev->pdev)->dev);
#line 492
    dev_priv->display_count = dev_priv->display_count + 1;
#line 493
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 494
    return (1);
  } else {

  }
  out_false: 
#line 497
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 498
  return (0);
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
void gma_power_end(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 510
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 512
  ldv_spin_lock();
#line 513
  dev_priv->display_count = dev_priv->display_count - 1;
#line 514
  __ret_warn_on = dev_priv->display_count < 0;
#line 514
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 514
  if (tmp != 0L) {
#line 514
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared",
                       514);
  } else {

  }
#line 514
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 515
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
#line 516
  pm_runtime_put(& (dev->pdev)->dev);
#line 517
  return;
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int psb_runtime_suspend(struct device *dev ) 
{ 
  int tmp ;

  {
#line 521
  tmp = gma_power_suspend(dev);
#line 521
  return (tmp);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int psb_runtime_resume(struct device *dev ) 
{ 
  int tmp ;

  {
#line 526
  tmp = gma_power_resume(dev);
#line 526
  return (tmp);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int psb_runtime_idle(struct device *dev ) 
{ 
  struct drm_device *drmdev ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 531
  __mptr = (struct device  const  *)dev;
#line 531
  tmp = pci_get_drvdata((struct pci_dev *)__mptr + 0xffffffffffffff68UL);
#line 531
  drmdev = (struct drm_device *)tmp;
#line 532
  dev_priv = (struct drm_psb_private *)drmdev->dev_private;
#line 533
  if (dev_priv->display_count != 0) {
#line 534
    return (0);
  } else {
#line 536
    return (1);
  }
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int gma_power_thaw(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 541
  tmp = gma_power_resume(_dev);
#line 541
  return (tmp);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int gma_power_freeze(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 546
  tmp = gma_power_suspend(_dev);
#line 546
  return (tmp);
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
int gma_power_restore(struct device *_dev ) 
{ 
  int tmp ;

  {
#line 551
  tmp = gma_power_resume(_dev);
#line 551
  return (tmp);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/power.o.c.prepared"
void *ldv_kmem_cache_alloc_218(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 684
  ldv_check_alloc_flags(flags);
#line 686
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 687
  return ((void *)0);
}
}
#line 372 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 183 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 185
  tmp = ioremap_nocache(offset, size);
#line 185
  return (tmp);
}
}
#line 334 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t flags , unsigned int order ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_238(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 19 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern size_t __VERIFIER_nondet_size_t(void) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_47  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_var_screeninfo *psbfb_roll_ops_group0  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_20  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_hdmi_connector_funcs_group0  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_ops_group0  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_hdmi_helper_funcs_group0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *mrst_clock_funcs_group1  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *cdv_chip_ops_group0  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_30  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_0  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_45  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_12  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *oaktrail_hdmi_connector_funcs_group0  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_22  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_54  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_14  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_fb_helper_funcs_group0  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_file *driver_group0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_37  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_29  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_17  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_51  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_intel_helper_funcs_group1  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *psb_mode_funcs_group0  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_19  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_lvds_helper_funcs_group0  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_27  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_9  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_dp_connector_funcs_group0  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_hdmi_connector_helper_funcs_group0  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ref_cnt  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_42  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *psb_intel_lvds_helper_funcs_group0  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_dp_connector_helper_funcs_group0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_7  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *psb_intel_sdvo_helper_funcs_group0  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_crt_helper_funcs_group0  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_crt_connector_helper_funcs_group0  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_23  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *psb_intel_helper_funcs_group0  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_55  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct file *psb_gem_fops_group2  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_lvds_connector_funcs_group0  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_6  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_dp_helper_funcs_group1  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_50  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *mrst_clock_funcs_group0  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_26  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_28  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_lvds_helper_funcs_group1  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct device *psb_pm_ops_group1  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_44  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_38  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct inode *psb_gem_fops_group1  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_39  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct pci_dev *psb_pci_driver_group0  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_56  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_3  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_clock_funcs_group0  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_31  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_52  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_lvds_connector_helper_funcs_group0  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *cdv_intel_crtc_funcs_group0  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_4  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *psb_fb_funcs_group0  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_hdmi_helper_funcs_group1  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_36  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_8  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_46  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_sdvo_helper_funcs_group1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_15  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_roll_ops_group1  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_48  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct vm_area_struct *psbfb_vm_ops_group0  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *psb_intel_sdvo_ddc_proxy_group0  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_5  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_21  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_33  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_13  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_lvds_helper_funcs_group1  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *cdv_intel_dp_helper_funcs_group0  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_49  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *psb_clock_funcs_group1  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_24  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_lvds_connector_helper_funcs_group0  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *driver_group1  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_crt_helper_funcs_group1  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_hdmi_helper_funcs_group1  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_1  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_41  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_40  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *psb_intel_helper_funcs_group2  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_intel_helper_funcs_group1  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *oaktrail_hdmi_connector_helper_funcs_group0  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *oaktrail_helper_funcs_group2  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_10  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *oaktrail_hdmi_helper_funcs_group0  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct fb_info *psbfb_unaccel_ops_group0  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct vm_area_struct *psb_gem_vm_ops_group0  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_encoder *oaktrail_lvds_helper_funcs_group0  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_lvds_connector_funcs_group0  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_clock_funcs_group0  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_16  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *oaktrail_hdmi_i2c_algorithm_group0  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct gma_clock_t *cdv_clock_funcs_group1  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_2  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_43  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *oaktrail_helper_funcs_group0  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_25  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *oaktrail_chip_ops_group0  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *oaktrail_helper_funcs_group1  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_57  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct i2c_adapter *gmbus_algorithm_group0  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_crtc *psb_intel_crtc_funcs_group0  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_11  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_framebuffer *cdv_intel_helper_funcs_group0  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_53  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_sdvo_connector_funcs_group0  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_18  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_lvds_helper_funcs_group1  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_32  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_34  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_display_mode *cdv_intel_helper_funcs_group2  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_device *psb_chip_ops_group0  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *cdv_intel_crt_connector_funcs_group0  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_state_variable_35  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct drm_connector *psb_intel_sdvo_connector_helper_funcs_group0  ;
#line 164
void ldv_initialize_vm_operations_struct_48(void) ;
#line 165
void ldv_initialize_drm_connector_helper_funcs_35(void) ;
#line 166
void ldv_initialize_drm_connector_funcs_28(void) ;
#line 169
void ldv_initialize_drm_connector_funcs_17(void) ;
#line 170
void ldv_initialize_drm_crtc_helper_funcs_10(void) ;
#line 172
void ldv_initialize_drm_connector_funcs_36(void) ;
#line 173
void ldv_initialize_drm_encoder_helper_funcs_19(void) ;
#line 174
void ldv_initialize_drm_encoder_helper_funcs_41(void) ;
#line 175
void ldv_initialize_gma_clock_funcs_9(void) ;
#line 176
void ldv_initialize_drm_connector_helper_funcs_18(void) ;
#line 178
void ldv_initialize_drm_connector_funcs_14(void) ;
#line 179
void ldv_initialize_i2c_algorithm_33(void) ;
#line 180
void ldv_initialize_drm_encoder_helper_funcs_22(void) ;
#line 185
void ldv_initialize_drm_connector_helper_funcs_6(void) ;
#line 186
void ldv_initialize_drm_connector_helper_funcs_27(void) ;
#line 187
void ldv_initialize_drm_encoder_helper_funcs_15(void) ;
#line 189
void ldv_initialize_drm_connector_funcs_5(void) ;
#line 192
void ldv_initialize_drm_encoder_helper_funcs_29(void) ;
#line 194
void ldv_initialize_drm_connector_helper_funcs_13(void) ;
#line 195
void ldv_initialize_drm_connector_funcs_39(void) ;
#line 196
void ldv_initialize_psb_ops_11(void) ;
#line 197
void ldv_initialize_drm_driver_46(void) ;
#line 200
void ldv_initialize_drm_crtc_funcs_24(void) ;
#line 201
void ldv_initialize_drm_crtc_helper_funcs_25(void) ;
#line 202
void ldv_initialize_pci_driver_45(void) ;
#line 203
void ldv_initialize_drm_encoder_helper_funcs_7(void) ;
#line 204
void ldv_initialize_psb_ops_30(void) ;
#line 205
void ldv_initialize_gma_clock_funcs_42(void) ;
#line 207
void ldv_initialize_drm_encoder_helper_funcs_8(void) ;
#line 208
void ldv_initialize_i2c_algorithm_3(void) ;
#line 209
void ldv_initialize_drm_crtc_funcs_43(void) ;
#line 212
void ldv_initialize_drm_connector_funcs_20(void) ;
#line 213
void ldv_initialize_drm_connector_helper_funcs_21(void) ;
#line 214
void ldv_initialize_drm_connector_helper_funcs_40(void) ;
#line 216
void ldv_initialize_drm_crtc_helper_funcs_44(void) ;
#line 217
void ldv_initialize_psb_ops_32(void) ;
#line 218
void ldv_file_operations_47(void) ;
#line 219
void ldv_dev_pm_ops_49(void) ;
#line 220
void ldv_initialize_gma_clock_funcs_23(void) ;
#line 221
void ldv_initialize_drm_encoder_helper_funcs_37(void) ;
#line 797 "include/linux/pci.h"
extern void pci_dev_put(struct pci_dev * ) ;
#line 832
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
#line 834 "include/linux/pci.h"
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) 
{ 
  struct pci_dev *tmp ;

  {
#line 837
  tmp = pci_get_domain_bus_and_slot(0, bus, devfn);
#line 837
  return (tmp);
}
}
#line 944
extern void pci_set_master(struct pci_dev * ) ;
#line 136 "./arch/x86/include/asm/cacheflush.h"
extern int set_pages_uc(struct page * , int  ) ;
#line 137
extern int set_pages_wb(struct page * , int  ) ;
#line 1208 "include/drm/drmP.h"
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1217
extern int drm_open(struct inode * , struct file * ) ;
#line 1219
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1221
extern int drm_release(struct inode * , struct file * ) ;
#line 1228
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
#line 1342
extern int drm_irq_install(struct drm_device * , int  ) ;
#line 1345
extern int drm_vblank_init(struct drm_device * , int  ) ;
#line 1395
extern void drm_put_dev(struct drm_device * ) ;
#line 1478
extern int drm_gem_dumb_destroy(struct drm_file * , struct drm_device * , uint32_t  ) ;
#line 1530
extern void drm_gem_vm_open(struct vm_area_struct * ) ;
#line 1531
extern void drm_gem_vm_close(struct vm_area_struct * ) ;
#line 1534
extern int drm_gem_mmap(struct file * , struct vm_area_struct * ) ;
#line 1641
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
#line 1642
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
#line 1643
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
#line 172 "include/drm/drm_crtc_helper.h"
extern void drm_kms_helper_poll_init(struct drm_device * ) ;
#line 50 "include/linux/pm_runtime.h"
extern void pm_runtime_allow(struct device * ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_fini(struct drm_device *dev ) ;
#line 29
int psb_intel_opregion_setup(struct drm_device *dev ) ;
#line 30
void psb_intel_opregion_enable_asle(struct drm_device *dev ) ;
#line 675 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
irqreturn_t psb_irq_handler(int irq , void *arg ) ;
#line 687
int psb_enable_vblank(struct drm_device *dev , int pipe ) ;
#line 688
void psb_disable_vblank(struct drm_device *dev , int pipe ) ;
#line 695
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) ;
#line 755
struct psb_ops  const  psb_chip_ops ;
#line 758
struct psb_ops  const  oaktrail_chip_ops ;
#line 764
struct psb_ops  const  cdv_chip_ops ;
#line 111 "include/drm/drm_fb_helper.h"
extern bool drm_fb_helper_restore_fbdev_mode_unlocked(struct drm_fb_helper * ) ;
#line 20 "include/acpi/video.h"
extern int acpi_video_register(void) ;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct drm_driver driver ;
#line 261
static int psb_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct pci_device_id  const  pciidlist[28U]  = 
#line 278
  {      {32902U, 33032U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      33033U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      16640U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16641U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16642U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16643U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16644U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16645U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16646U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16647U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16648U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      3040U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3041U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3042U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3043U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3044U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3045U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3046U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3047U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3048U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3049U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3050U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3051U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3052U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3053U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3054U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3055U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {0U,
      0U, 0U, 0U, 0U, 0U, 0UL}};
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
struct pci_device_id  const  __mod_pci__pciidlist_device_table  ;
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct drm_ioctl_desc  const  psb_ioctls[0U]  = { };
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static void psb_driver_lastclose(struct drm_device *dev ) 
{ 
  int ret ;
  struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;
  bool tmp ;
  long tmp___0 ;

  {
#line 333
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 334
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
#line 336
  tmp = drm_fb_helper_restore_fbdev_mode_unlocked(& fbdev->psb_fb_helper);
#line 336
  ret = (int )tmp;
#line 337
  if (ret != 0) {
#line 338
    tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 338
    if (tmp___0 != 0L) {
#line 338
      drm_ut_debug_printk("psb_driver_lastclose", "failed to restore crtc mode\n");
    } else {

    }
  } else {

  }
#line 340
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_do_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  uint32_t stolen_gtt ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  unsigned int tmp ;

  {
#line 345
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 346
  pg = & dev_priv->gtt;
#line 350
  if ((pg->mmu_gatt_start & 268435455U) != 0U) {
#line 351
    dev_err((struct device  const  *)dev->dev, "Gatt must be 256M aligned. This is a bug.\n");
#line 352
    return (-22);
  } else {

  }
#line 355
  stolen_gtt = (uint32_t )(pg->stolen_size >> 12) * 4U;
#line 356
  stolen_gtt = (uint32_t )(((unsigned long )stolen_gtt + 4095UL) >> 12);
#line 357
  stolen_gtt = stolen_gtt < pg->gtt_pages ? stolen_gtt : pg->gtt_pages;
#line 359
  dev_priv->gatt_free_offset = pg->mmu_gatt_start + stolen_gtt * 4194304U;
#line 362
  spinlock_check(& dev_priv->irqmask_lock);
#line 362
  __raw_spin_lock_init(& dev_priv->irqmask_lock.ldv_6347.rlock, "&(&dev_priv->irqmask_lock)->rlock",
                       & __key);
#line 363
  spinlock_check(& dev_priv->lock_2d);
#line 363
  __raw_spin_lock_init(& dev_priv->lock_2d.ldv_6347.rlock, "&(&dev_priv->lock_2d)->rlock",
                       & __key___0);
#line 365
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3192U);
#line 366
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3196U);
#line 367
  ioread32((void *)dev_priv->sgx_reg + 3196U);
#line 370
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 370
  iowrite32(tmp & 4294836479U, (void *)dev_priv->sgx_reg + 3072U);
#line 372
  ioread32((void *)dev_priv->sgx_reg + 3072U);
#line 374
  psb_spank(dev_priv);
#line 377
  iowrite32(pg->gatt_start, (void *)dev_priv->sgx_reg + 3208U);
#line 378
  ioread32((void *)dev_priv->sgx_reg + 3208U);
#line 380
  return (0);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_driver_unload(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  struct psb_mmu_pd *tmp ;

  {
#line 385
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 389
  if ((unsigned long )dev_priv != (unsigned long )((struct drm_psb_private *)0)) {
#line 390
    if ((unsigned long )dev_priv->backlight_device != (unsigned long )((struct backlight_device *)0)) {
#line 391
      gma_backlight_exit(dev);
    } else {

    }
#line 392
    psb_modeset_cleanup(dev);
#line 394
    if ((unsigned long )(dev_priv->ops)->chip_teardown != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
#line 395
      (*((dev_priv->ops)->chip_teardown))(dev);
    } else {

    }
#line 397
    psb_intel_opregion_fini(dev);
#line 399
    if ((unsigned long )dev_priv->pf_pd != (unsigned long )((struct psb_mmu_pd *)0)) {
#line 400
      psb_mmu_free_pagedir(dev_priv->pf_pd);
#line 401
      dev_priv->pf_pd = (struct psb_mmu_pd *)0;
    } else {

    }
#line 403
    if ((unsigned long )dev_priv->mmu != (unsigned long )((struct psb_mmu_driver *)0)) {
#line 404
      pg = & dev_priv->gtt;
#line 406
      down_read(& pg->sem);
#line 407
      tmp = psb_mmu_get_default_pd(dev_priv->mmu);
#line 407
      psb_mmu_remove_pfn_sequence(tmp, (unsigned long )pg->mmu_gatt_start, (uint32_t )(dev_priv->vram_stolen_size >> 12));
#line 412
      up_read(& pg->sem);
#line 413
      psb_mmu_driver_takedown(dev_priv->mmu);
#line 414
      dev_priv->mmu = (struct psb_mmu_driver *)0;
    } else {

    }
#line 416
    psb_gtt_takedown(dev);
#line 417
    if ((unsigned long )dev_priv->scratch_page != (unsigned long )((struct page *)0)) {
#line 418
      set_pages_wb(dev_priv->scratch_page, 1);
#line 419
      __free_pages(dev_priv->scratch_page, 0U);
#line 420
      dev_priv->scratch_page = (struct page *)0;
    } else {

    }
#line 422
    if ((unsigned long )dev_priv->vdc_reg != (unsigned long )((uint8_t *)0U)) {
#line 423
      iounmap((void volatile   *)dev_priv->vdc_reg);
#line 424
      dev_priv->vdc_reg = (uint8_t *)0U;
    } else {

    }
#line 426
    if ((unsigned long )dev_priv->sgx_reg != (unsigned long )((uint8_t *)0U)) {
#line 427
      iounmap((void volatile   *)dev_priv->sgx_reg);
#line 428
      dev_priv->sgx_reg = (uint8_t *)0U;
    } else {

    }
#line 430
    if ((unsigned long )dev_priv->aux_reg != (unsigned long )((uint8_t *)0U)) {
#line 431
      iounmap((void volatile   *)dev_priv->aux_reg);
#line 432
      dev_priv->aux_reg = (uint8_t *)0U;
    } else {

    }
#line 434
    if ((unsigned long )dev_priv->aux_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 435
      pci_dev_put(dev_priv->aux_pdev);
    } else {

    }
#line 438
    psb_intel_destroy_bios(dev);
#line 440
    kfree((void const   *)dev_priv);
#line 441
    dev->dev_private = (void *)0;
  } else {

  }
#line 443
  gma_power_uninit(dev);
#line 444
  return (0);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_driver_load(struct drm_device *dev , unsigned long flags ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long resource_start ;
  unsigned long resource_len ;
  unsigned long irqflags ;
  int ret ;
  struct drm_connector *connector ;
  struct gma_encoder *gma_encoder ;
  struct psb_gtt *pg ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  struct psb_mmu_pd *tmp___5 ;
  struct psb_mmu_pd *tmp___6 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 452
  ret = -12;
#line 458
  tmp = kzalloc(5176UL, 208U);
#line 458
  dev_priv = (struct drm_psb_private *)tmp;
#line 459
  if ((unsigned long )dev_priv == (unsigned long )((struct drm_psb_private *)0)) {
#line 460
    return (-12);
  } else {

  }
#line 462
  dev_priv->ops = (struct psb_ops  const  *)flags;
#line 463
  dev_priv->dev = dev;
#line 464
  dev->dev_private = (void *)dev_priv;
#line 466
  pg = & dev_priv->gtt;
#line 468
  pci_set_master(dev->pdev);
#line 470
  dev_priv->num_pipe = (uint32_t )(dev_priv->ops)->pipes;
#line 472
  resource_start = (unsigned long )(dev->pdev)->resource[0].start;
#line 474
  tmp___0 = ioremap((resource_size_t )resource_start, 524288UL);
#line 474
  dev_priv->vdc_reg = (uint8_t *)tmp___0;
#line 476
  if ((unsigned long )dev_priv->vdc_reg == (unsigned long )((uint8_t *)0U)) {
#line 477
    goto out_err;
  } else {

  }
#line 479
  tmp___1 = ioremap((resource_size_t )((unsigned long )(dev_priv->ops)->sgx_offset + resource_start),
                    32768UL);
#line 479
  dev_priv->sgx_reg = (uint8_t *)tmp___1;
#line 481
  if ((unsigned long )dev_priv->sgx_reg == (unsigned long )((uint8_t *)0U)) {
#line 482
    goto out_err;
  } else {

  }
#line 484
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 485
    dev_priv->aux_pdev = pci_get_bus_and_slot(0U, 24U);
#line 487
    if ((unsigned long )dev_priv->aux_pdev != (unsigned long )((struct pci_dev *)0)) {
#line 488
      resource_start = (unsigned long )(dev_priv->aux_pdev)->resource[0].start;
#line 490
      resource_len = (dev_priv->aux_pdev)->resource[0].start != 0ULL || (dev_priv->aux_pdev)->resource[0].end != (dev_priv->aux_pdev)->resource[0].start ? (unsigned long )(((dev_priv->aux_pdev)->resource[0].end - (dev_priv->aux_pdev)->resource[0].start) + 1ULL) : 0UL;
#line 492
      tmp___2 = ioremap_nocache((resource_size_t )resource_start, resource_len);
#line 492
      dev_priv->aux_reg = (uint8_t *)tmp___2;
#line 494
      if ((unsigned long )dev_priv->aux_reg == (unsigned long )((uint8_t *)0U)) {
#line 495
        goto out_err;
      } else {

      }
#line 497
      tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 497
      if (tmp___3 != 0L) {
#line 497
        drm_ut_debug_printk("psb_driver_load", "Found aux vdc");
      } else {

      }
    } else {
#line 500
      dev_priv->aux_reg = dev_priv->vdc_reg;
#line 501
      tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 501
      if (tmp___4 != 0L) {
#line 501
        drm_ut_debug_printk("psb_driver_load", "Couldn\'t find aux pci device");
      } else {

      }
    }
#line 503
    dev_priv->gmbus_reg = dev_priv->aux_reg;
  } else {
#line 505
    dev_priv->gmbus_reg = dev_priv->vdc_reg;
  }
#line 508
  psb_intel_opregion_setup(dev);
#line 510
  ret = (*((dev_priv->ops)->chip_setup))(dev);
#line 511
  if (ret != 0) {
#line 512
    goto out_err;
  } else {

  }
#line 515
  gma_power_init(dev);
#line 517
  ret = -12;
#line 519
  dev_priv->scratch_page = alloc_pages(32772U, 0U);
#line 520
  if ((unsigned long )dev_priv->scratch_page == (unsigned long )((struct page *)0)) {
#line 521
    goto out_err;
  } else {

  }
#line 523
  set_pages_uc(dev_priv->scratch_page, 1);
#line 525
  ret = psb_gtt_init(dev, 0);
#line 526
  if (ret != 0) {
#line 527
    goto out_err;
  } else {

  }
#line 529
  dev_priv->mmu = psb_mmu_driver_init(dev, 1, 0, (atomic_t *)0);
#line 530
  if ((unsigned long )dev_priv->mmu == (unsigned long )((struct psb_mmu_driver *)0)) {
#line 531
    goto out_err;
  } else {

  }
#line 533
  dev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);
#line 534
  if ((unsigned long )dev_priv->pf_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
#line 535
    goto out_err;
  } else {

  }
#line 537
  ret = psb_do_init(dev);
#line 538
  if (ret != 0) {
#line 539
    return (ret);
  } else {

  }
#line 542
  down_read(& pg->sem);
#line 543
  tmp___5 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 543
  ret = psb_mmu_insert_pfn_sequence(tmp___5, dev_priv->stolen_base >> 12, (unsigned long )pg->gatt_start,
                                    (uint32_t )(pg->stolen_size >> 12), 0);
#line 547
  up_read(& pg->sem);
#line 549
  tmp___6 = psb_mmu_get_default_pd(dev_priv->mmu);
#line 549
  psb_mmu_set_pd_context(tmp___6, 0);
#line 550
  psb_mmu_set_pd_context(dev_priv->pf_pd, 1);
#line 552
  iowrite32(536870912U, (void *)dev_priv->sgx_reg + 2744U);
#line 553
  iowrite32(805306368U, (void *)dev_priv->sgx_reg + 3244U);
#line 555
  acpi_video_register();
#line 558
  ret = drm_vblank_init(dev, (int )dev_priv->num_pipe);
#line 559
  if (ret != 0) {
#line 560
    goto out_err;
  } else {

  }
#line 566
  dev_priv->vdc_irq_mask = 0U;
#line 567
  dev_priv->pipestat[0] = 0U;
#line 568
  dev_priv->pipestat[1] = 0U;
#line 569
  dev_priv->pipestat[2] = 0U;
#line 570
  ldv_spin_lock();
#line 571
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 572
  iowrite32(0U, (void *)dev_priv->vdc_reg + 8352U);
#line 573
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8360U);
#line 574
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 576
  drm_irq_install(dev, (int )(dev->pdev)->irq);
#line 578
  dev->vblank_disable_allowed = 1;
#line 579
  dev->max_vblank_count = 16777215U;
#line 580
  (dev->driver)->get_vblank_counter = & psb_get_vblank_counter;
#line 582
  psb_modeset_init(dev);
#line 583
  psb_fbdev_init(dev);
#line 584
  drm_kms_helper_poll_init(dev);
#line 587
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 587
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 587
  goto ldv_40027;
  ldv_40026: 
#line 589
  gma_encoder = gma_attached_encoder(connector);
#line 591
  switch (gma_encoder->type) {
  case 4: ;
  case 7: 
#line 594
  ret = gma_backlight_init(dev);
#line 595
  goto ldv_40025;
  }
  ldv_40025: 
#line 587
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 587
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_40027: ;
#line 587
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 589
    goto ldv_40026;
  } else {

  }

#line 599
  if (ret != 0) {
#line 600
    return (ret);
  } else {

  }
#line 601
  psb_intel_opregion_enable_asle(dev);
#line 608
  return (0);
  out_err: 
#line 610
  psb_driver_unload(dev);
#line 611
  return (ret);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_driver_device_is_agp(struct drm_device *dev ) 
{ 


  {
#line 616
  return (0);
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static long psb_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ 
  struct drm_file *file_priv ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned int runtime_allowed ;
  long tmp ;

  {
#line 632
  file_priv = (struct drm_file *)filp->private_data;
#line 633
  dev = (file_priv->minor)->dev;
#line 634
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 637
  if (runtime_allowed == 1U && (int )dev_priv->is_lvds_on) {
#line 638
    runtime_allowed = runtime_allowed + 1U;
#line 639
    pm_runtime_allow(& (dev->pdev)->dev);
#line 640
    dev_priv->rpm_enabled = 1;
  } else {

  }
#line 642
  tmp = drm_ioctl(filp, cmd, arg);
#line 642
  return (tmp);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static void psb_driver_preclose(struct drm_device *dev , struct drm_file *priv ) 
{ 


  {
#line 652
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  int tmp ;

  {
#line 656
  tmp = drm_get_pci_dev(pdev, ent, & driver);
#line 656
  return (tmp);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static void psb_pci_remove(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;

  {
#line 662
  tmp = pci_get_drvdata(pdev);
#line 662
  dev = (struct drm_device *)tmp;
#line 663
  drm_put_dev(dev);
#line 664
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct dev_pm_ops  const  psb_pm_ops  = 
#line 666
     {0, 0, & gma_power_suspend, & gma_power_resume, & gma_power_freeze, & gma_power_thaw,
    0, & gma_power_restore, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & psb_runtime_suspend,
    & psb_runtime_resume, & psb_runtime_idle};
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct vm_operations_struct  const  psb_gem_vm_ops  = 
#line 677
     {& drm_gem_vm_open, & drm_gem_vm_close, & psb_gem_fault, 0, 0, 0, 0, 0, 0, 0, 0};
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct file_operations  const  psb_gem_fops  = 
#line 683
     {& __this_module, 0, & drm_read, 0, 0, 0, 0, 0, 0, & drm_poll, & psb_unlocked_ioctl,
    0, & drm_gem_mmap, & drm_open, 0, & drm_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0};
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct drm_driver driver  = 
#line 693
     {& psb_driver_load, 0, 0, & psb_driver_preclose, 0, & psb_driver_lastclose, & psb_driver_unload,
    0, 0, 0, 0, 0, & psb_get_vblank_counter, & psb_enable_vblank, & psb_disable_vblank,
    & psb_driver_device_is_agp, 0, 0, & psb_irq_handler, & psb_irq_preinstall, & psb_irq_postinstall,
    & psb_irq_uninstall, 0, 0, 0, 0, 0, 0, & psb_gem_free_object, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, & psb_gem_dumb_create, & psb_gem_dumb_map_gtt, & drm_gem_dumb_destroy,
    & psb_gem_vm_ops, 1, 0, 0, (char *)"gma500", (char *)"DRM driver for the Intel GMA500, GMA600, GMA3600, GMA3650",
    (char *)"20140314", 12480U, 0, (struct drm_ioctl_desc  const  *)(& psb_ioctls),
    0, & psb_gem_fops, 0, {0, 0}};
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static struct pci_driver psb_pci_driver  = 
#line 727
     {{0, 0}, "gma500", (struct pci_device_id  const  *)(& pciidlist), & psb_pci_probe,
    & psb_pci_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0,
                                            0, 0, & psb_pm_ops, 0}, {{{{{{0U}}, 0U,
                                                                        0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                     {0, 0}}};
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static int psb_init(void) 
{ 
  int tmp ;

  {
#line 737
  tmp = drm_pci_init(& driver, & psb_pci_driver);
#line 737
  return (tmp);
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
static void psb_exit(void) 
{ 


  {
#line 742
  drm_pci_exit(& driver, & psb_pci_driver);
#line 743
  return;
}
}
#line 752
extern int ldv_complete_49(void) ;
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_20  ;
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_18  ;
#line 755
extern int ldv_suspend_late_49(void) ;
#line 756 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_2  ;
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_5  ;
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_0  ;
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_23  ;
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_11  ;
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_1  ;
#line 762
extern int ldv_poweroff_noirq_49(void) ;
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_22  ;
#line 764
extern int ldv_freeze_late_49(void) ;
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_15  ;
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_16  ;
#line 767
extern int ldv_poweroff_late_49(void) ;
#line 768
extern int ldv_thaw_noirq_49(void) ;
#line 769
extern int ldv_prepare_49(void) ;
#line 770
extern void ldv_check_final_state(void) ;
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_8  ;
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_7  ;
#line 773
extern int ldv_restore_noirq_49(void) ;
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_19  ;
#line 775
extern int ldv_resume_early_49(void) ;
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_14  ;
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_17  ;
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_12  ;
#line 779
extern void ldv_initialize(void) ;
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_6  ;
#line 781
extern int ldv_freeze_noirq_49(void) ;
#line 782
extern int ldv_thaw_early_49(void) ;
#line 783
extern int ldv_suspend_noirq_49(void) ;
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_21  ;
#line 785
extern int ldv_restore_early_49(void) ;
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_13  ;
#line 787
extern int ldv_resume_noirq_49(void) ;
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_9  ;
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_10  ;
#line 790
extern int ldv_poweroff_49(void) ;
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_4  ;
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int ldv_retval_3  ;
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_initialize_vm_operations_struct_48(void) 
{ 
  void *tmp ;

  {
#line 796
  tmp = ldv_zalloc(184UL);
#line 796
  psb_gem_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 797
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_initialize_drm_driver_46(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 800
  tmp = ldv_zalloc(744UL);
#line 800
  driver_group0 = (struct drm_file *)tmp;
#line 801
  tmp___0 = ldv_zalloc(2992UL);
#line 801
  driver_group1 = (struct drm_device *)tmp___0;
#line 802
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_initialize_pci_driver_45(void) 
{ 
  void *tmp ;

  {
#line 805
  tmp = ldv_zalloc(2976UL);
#line 805
  psb_pci_driver_group0 = (struct pci_dev *)tmp;
#line 806
  return;
}
}
#line 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_file_operations_47(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 810
  tmp = ldv_zalloc(1032UL);
#line 810
  psb_gem_fops_group1 = (struct inode *)tmp;
#line 811
  tmp___0 = ldv_zalloc(512UL);
#line 811
  psb_gem_fops_group2 = (struct file *)tmp___0;
#line 812
  return;
}
}
#line 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void ldv_dev_pm_ops_49(void) 
{ 
  void *tmp ;

  {
#line 816
  tmp = ldv_zalloc(1416UL);
#line 816
  psb_pm_ops_group1 = (struct device *)tmp;
#line 817
  return;
}
}
#line 821
void ldv_main_exported_31(void) ;
#line 822
void ldv_main_exported_22(void) ;
#line 823
void ldv_main_exported_21(void) ;
#line 824
void ldv_main_exported_20(void) ;
#line 825
void ldv_main_exported_10(void) ;
#line 826
void ldv_main_exported_9(void) ;
#line 827
void ldv_main_exported_35(void) ;
#line 828
void ldv_main_exported_33(void) ;
#line 829
void ldv_main_exported_34(void) ;
#line 830
void ldv_main_exported_36(void) ;
#line 831
void ldv_main_exported_37(void) ;
#line 832
void ldv_main_exported_42(void) ;
#line 833
void ldv_main_exported_43(void) ;
#line 834
void ldv_main_exported_44(void) ;
#line 835
void ldv_main_exported_32(void) ;
#line 836
void ldv_main_exported_6(void) ;
#line 837
void ldv_main_exported_4(void) ;
#line 838
void ldv_main_exported_7(void) ;
#line 839
void ldv_main_exported_5(void) ;
#line 840
void ldv_main_exported_13(void) ;
#line 841
void ldv_main_exported_12(void) ;
#line 842
void ldv_main_exported_15(void) ;
#line 843
void ldv_main_exported_14(void) ;
#line 845
void ldv_main_exported_18(void) ;
#line 846
void ldv_main_exported_19(void) ;
#line 847
void ldv_main_exported_16(void) ;
#line 848
void ldv_main_exported_17(void) ;
#line 856
void ldv_main_exported_8(void) ;
#line 857
void ldv_main_exported_3(void) ;
#line 858
void ldv_main_exported_25(void) ;
#line 859
void ldv_main_exported_24(void) ;
#line 860
void ldv_main_exported_23(void) ;
#line 861
void ldv_main_exported_38(void) ;
#line 862
void ldv_main_exported_39(void) ;
#line 863
void ldv_main_exported_40(void) ;
#line 864
void ldv_main_exported_41(void) ;
#line 865
void ldv_main_exported_30(void) ;
#line 866
void ldv_main_exported_11(void) ;
#line 867
void ldv_main_exported_27(void) ;
#line 868
void ldv_main_exported_28(void) ;
#line 869
void ldv_main_exported_26(void) ;
#line 870
void ldv_main_exported_29(void) ;
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
int main(void) 
{ 
  struct vm_fault *ldvarg102 ;
  void *tmp ;
  struct drm_gem_object *ldvarg116 ;
  void *tmp___0 ;
  uint32_t ldvarg118 ;
  unsigned long ldvarg115 ;
  unsigned long tmp___1 ;
  int ldvarg109 ;
  int tmp___2 ;
  int ldvarg111 ;
  int tmp___3 ;
  int ldvarg110 ;
  int tmp___4 ;
  void *ldvarg112 ;
  void *tmp___5 ;
  struct drm_mode_create_dumb *ldvarg113 ;
  void *tmp___6 ;
  int ldvarg119 ;
  int tmp___7 ;
  uint64_t *ldvarg117 ;
  void *tmp___8 ;
  uint32_t ldvarg114 ;
  unsigned int ldvarg154 ;
  unsigned int tmp___9 ;
  unsigned long ldvarg153 ;
  unsigned long tmp___10 ;
  struct poll_table_struct *ldvarg156 ;
  void *tmp___11 ;
  char *ldvarg159 ;
  void *tmp___12 ;
  loff_t *ldvarg157 ;
  void *tmp___13 ;
  struct vm_area_struct *ldvarg155 ;
  void *tmp___14 ;
  size_t ldvarg158 ;
  size_t tmp___15 ;
  struct pci_device_id *ldvarg180 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 883
  tmp = ldv_zalloc(48UL);
#line 883
  ldvarg102 = (struct vm_fault *)tmp;
#line 884
  tmp___0 = ldv_zalloc(248UL);
#line 884
  ldvarg116 = (struct drm_gem_object *)tmp___0;
#line 886
  tmp___1 = __VERIFIER_nondet_ulong();
#line 886
  ldvarg115 = tmp___1;
#line 887
  tmp___2 = __VERIFIER_nondet_int();
#line 887
  ldvarg109 = tmp___2;
#line 888
  tmp___3 = __VERIFIER_nondet_int();
#line 888
  ldvarg111 = tmp___3;
#line 889
  tmp___4 = __VERIFIER_nondet_int();
#line 889
  ldvarg110 = tmp___4;
#line 890
  tmp___5 = ldv_zalloc(1UL);
#line 890
  ldvarg112 = tmp___5;
#line 891
  tmp___6 = ldv_zalloc(32UL);
#line 891
  ldvarg113 = (struct drm_mode_create_dumb *)tmp___6;
#line 892
  tmp___7 = __VERIFIER_nondet_int();
#line 892
  ldvarg119 = tmp___7;
#line 893
  tmp___8 = ldv_zalloc(8UL);
#line 893
  ldvarg117 = (uint64_t *)tmp___8;
#line 895
  tmp___9 = __VERIFIER_nondet_uint();
#line 895
  ldvarg154 = tmp___9;
#line 896
  tmp___10 = __VERIFIER_nondet_ulong();
#line 896
  ldvarg153 = tmp___10;
#line 897
  tmp___11 = ldv_zalloc(16UL);
#line 897
  ldvarg156 = (struct poll_table_struct *)tmp___11;
#line 898
  tmp___12 = ldv_zalloc(1UL);
#line 898
  ldvarg159 = (char *)tmp___12;
#line 899
  tmp___13 = ldv_zalloc(8UL);
#line 899
  ldvarg157 = (loff_t *)tmp___13;
#line 900
  tmp___14 = ldv_zalloc(184UL);
#line 900
  ldvarg155 = (struct vm_area_struct *)tmp___14;
#line 901
  tmp___15 = __VERIFIER_nondet_size_t();
#line 901
  ldvarg158 = tmp___15;
#line 902
  tmp___16 = ldv_zalloc(32UL);
#line 902
  ldvarg180 = (struct pci_device_id *)tmp___16;
#line 881
  ldv_initialize();
#line 885
  memset((void *)(& ldvarg118), 0, 4UL);
#line 894
  memset((void *)(& ldvarg114), 0, 4UL);
#line 904
  ldv_state_variable_33 = 0;
#line 905
  ldv_state_variable_32 = 0;
#line 906
  ldv_state_variable_21 = 0;
#line 907
  ldv_state_variable_7 = 0;
#line 908
  ldv_state_variable_26 = 0;
#line 909
  ldv_state_variable_17 = 0;
#line 911
  ldv_state_variable_2 = 1;
#line 913
  ldv_state_variable_1 = 1;
#line 914
  ldv_state_variable_18 = 0;
#line 915
  ldv_state_variable_30 = 0;
#line 916
  ldv_state_variable_16 = 0;
#line 917
  ldv_state_variable_44 = 0;
#line 918
  ldv_state_variable_55 = 0;
#line 919
  ldv_state_variable_27 = 0;
#line 920
  ldv_state_variable_25 = 0;
#line 921
  ldv_state_variable_28 = 0;
#line 922
  ldv_state_variable_57 = 0;
#line 923
  ldv_state_variable_40 = 0;
#line 924
  ldv_state_variable_20 = 0;
#line 925
  ldv_state_variable_14 = 0;
#line 926
  ldv_state_variable_49 = 0;
#line 927
  ldv_state_variable_24 = 0;
#line 928
  ldv_state_variable_10 = 0;
#line 929
  ldv_state_variable_31 = 0;
#line 930
  ldv_state_variable_35 = 0;
#line 931
  ldv_state_variable_11 = 0;
#line 932
  ldv_state_variable_53 = 0;
#line 933
  ldv_state_variable_48 = 0;
#line 934
  ldv_state_variable_42 = 0;
#line 935
  ldv_state_variable_22 = 0;
#line 936
  ref_cnt = 0;
#line 937
  ldv_state_variable_0 = 1;
#line 938
  ldv_state_variable_46 = 0;
#line 939
  ldv_state_variable_13 = 0;
#line 940
  ldv_state_variable_23 = 0;
#line 941
  ldv_state_variable_29 = 0;
#line 942
  ldv_state_variable_6 = 0;
#line 943
  ldv_state_variable_50 = 0;
#line 944
  ldv_state_variable_39 = 0;
#line 945
  ldv_state_variable_36 = 0;
#line 946
  ldv_state_variable_3 = 0;
#line 947
  ldv_state_variable_51 = 0;
#line 948
  ldv_state_variable_9 = 0;
#line 949
  ldv_state_variable_41 = 0;
#line 950
  ldv_state_variable_12 = 0;
#line 951
  ldv_state_variable_47 = 0;
#line 952
  ldv_state_variable_15 = 0;
#line 953
  ldv_state_variable_52 = 0;
#line 954
  ldv_state_variable_38 = 0;
#line 955
  ldv_state_variable_8 = 0;
#line 956
  ldv_state_variable_4 = 0;
#line 957
  ldv_state_variable_34 = 0;
#line 958
  ldv_state_variable_56 = 0;
#line 959
  ldv_state_variable_45 = 0;
#line 960
  ldv_state_variable_37 = 0;
#line 961
  ldv_state_variable_43 = 0;
#line 962
  ldv_state_variable_19 = 0;
#line 963
  ldv_state_variable_54 = 0;
#line 964
  ldv_state_variable_5 = 0;
  ldv_40417: 
#line 966
  tmp___17 = __VERIFIER_nondet_int();
#line 966
  switch (tmp___17) {
  case 0: ;
#line 970
  if (ldv_state_variable_33 != 0) {
#line 971
    ldv_main_exported_33();
  } else {

  }
#line 974
  goto ldv_40293;
  case 1: ;
#line 978
  if (ldv_state_variable_32 != 0) {
#line 979
    ldv_main_exported_32();
  } else {

  }
#line 982
  goto ldv_40293;
  case 2: ;
#line 986
  if (ldv_state_variable_21 != 0) {
#line 987
    ldv_main_exported_21();
  } else {

  }
#line 990
  goto ldv_40293;
  case 3: ;
#line 994
  if (ldv_state_variable_7 != 0) {
#line 995
    ldv_main_exported_7();
  } else {

  }
#line 998
  goto ldv_40293;
  case 4: ;
#line 1002
  if (ldv_state_variable_26 != 0) {
#line 1003
    ldv_main_exported_26();
  } else {

  }
#line 1006
  goto ldv_40293;
  case 5: ;
#line 1010
  if (ldv_state_variable_17 != 0) {
#line 1011
    ldv_main_exported_17();
  } else {

  }
#line 1014
  goto ldv_40293;
  case 6: ;
#line 1021
  goto ldv_40293;
  case 7: ;
#line 1028
  goto ldv_40293;
  case 8: ;
#line 1032
  if (ldv_state_variable_18 != 0) {
#line 1033
    ldv_main_exported_18();
  } else {

  }
#line 1036
  goto ldv_40293;
  case 9: ;
#line 1040
  if (ldv_state_variable_30 != 0) {
#line 1041
    ldv_main_exported_30();
  } else {

  }
#line 1044
  goto ldv_40293;
  case 10: ;
#line 1048
  if (ldv_state_variable_16 != 0) {
#line 1049
    ldv_main_exported_16();
  } else {

  }
#line 1052
  goto ldv_40293;
  case 11: ;
#line 1056
  if (ldv_state_variable_44 != 0) {
#line 1057
    ldv_main_exported_44();
  } else {

  }
#line 1060
  goto ldv_40293;
  case 12: ;
#line 1064
  if (ldv_state_variable_55 != 0) {
#line 1065
    ldv_main_exported_55();
  } else {

  }
#line 1068
  goto ldv_40293;
  case 13: ;
#line 1072
  if (ldv_state_variable_27 != 0) {
#line 1073
    ldv_main_exported_27();
  } else {

  }
#line 1076
  goto ldv_40293;
  case 14: ;
#line 1080
  if (ldv_state_variable_25 != 0) {
#line 1081
    ldv_main_exported_25();
  } else {

  }
#line 1084
  goto ldv_40293;
  case 15: ;
#line 1088
  if (ldv_state_variable_28 != 0) {
#line 1089
    ldv_main_exported_28();
  } else {

  }
#line 1092
  goto ldv_40293;
  case 16: ;
#line 1096
  if (ldv_state_variable_57 != 0) {
#line 1097
    ldv_main_exported_57();
  } else {

  }
#line 1100
  goto ldv_40293;
  case 17: ;
#line 1104
  if (ldv_state_variable_40 != 0) {
#line 1105
    ldv_main_exported_40();
  } else {

  }
#line 1108
  goto ldv_40293;
  case 18: ;
#line 1112
  if (ldv_state_variable_20 != 0) {
#line 1113
    ldv_main_exported_20();
  } else {

  }
#line 1116
  goto ldv_40293;
  case 19: ;
#line 1120
  if (ldv_state_variable_14 != 0) {
#line 1121
    ldv_main_exported_14();
  } else {

  }
#line 1124
  goto ldv_40293;
  case 20: ;
#line 1128
  if (ldv_state_variable_49 != 0) {
#line 1129
    tmp___18 = __VERIFIER_nondet_int();
#line 1129
    switch (tmp___18) {
    case 0: ;
#line 1132
    if (ldv_state_variable_49 == 14) {
#line 1134
      ldv_retval_20 = gma_power_thaw(psb_pm_ops_group1);
#line 1135
      if (ldv_retval_20 == 0) {
#line 1136
        ldv_state_variable_49 = 16;
      } else {

      }
    } else {

    }
#line 1140
    goto ldv_40315;
    case 1: ;
#line 1143
    if (ldv_state_variable_49 == 2) {
#line 1145
      ldv_retval_19 = psb_runtime_resume(psb_pm_ops_group1);
#line 1146
      if (ldv_retval_19 == 0) {
#line 1147
        ldv_state_variable_49 = 1;
#line 1148
        ref_cnt = ref_cnt - 1;
      } else {

      }
    } else {

    }
#line 1152
    goto ldv_40315;
    case 2: ;
#line 1155
    if (ldv_state_variable_49 == 2) {
#line 1157
      psb_runtime_idle(psb_pm_ops_group1);
#line 1159
      ldv_state_variable_49 = 2;
    } else {

    }
#line 1162
    if (ldv_state_variable_49 == 1) {
#line 1164
      psb_runtime_idle(psb_pm_ops_group1);
#line 1166
      ldv_state_variable_49 = 1;
    } else {

    }
#line 1169
    goto ldv_40315;
    case 3: ;
#line 1172
    if (ldv_state_variable_49 == 3) {
#line 1174
      ldv_retval_18 = gma_power_suspend(psb_pm_ops_group1);
#line 1175
      if (ldv_retval_18 == 0) {
#line 1176
        ldv_state_variable_49 = 4;
      } else {

      }
    } else {

    }
#line 1180
    goto ldv_40315;
    case 4: ;
#line 1183
    if (ldv_state_variable_49 == 15) {
#line 1185
      ldv_retval_17 = gma_power_restore(psb_pm_ops_group1);
#line 1186
      if (ldv_retval_17 == 0) {
#line 1187
        ldv_state_variable_49 = 16;
      } else {

      }
    } else {

    }
#line 1191
    goto ldv_40315;
    case 5: ;
#line 1194
    if (ldv_state_variable_49 == 1) {
#line 1196
      ldv_retval_16 = psb_runtime_suspend(psb_pm_ops_group1);
#line 1197
      if (ldv_retval_16 == 0) {
#line 1198
        ldv_state_variable_49 = 2;
#line 1199
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1203
    goto ldv_40315;
    case 6: ;
#line 1206
    if (ldv_state_variable_49 == 3) {
#line 1208
      ldv_retval_15 = gma_power_freeze(psb_pm_ops_group1);
#line 1209
      if (ldv_retval_15 == 0) {
#line 1210
        ldv_state_variable_49 = 5;
      } else {

      }
    } else {

    }
#line 1214
    goto ldv_40315;
    case 7: ;
#line 1217
    if (ldv_state_variable_49 == 13) {
#line 1219
      ldv_retval_14 = gma_power_resume(psb_pm_ops_group1);
#line 1220
      if (ldv_retval_14 == 0) {
#line 1221
        ldv_state_variable_49 = 16;
      } else {

      }
    } else {

    }
#line 1225
    goto ldv_40315;
    case 8: ;
#line 1228
    if (ldv_state_variable_49 == 4) {
#line 1230
      ldv_retval_13 = ldv_suspend_late_49();
#line 1231
      if (ldv_retval_13 == 0) {
#line 1232
        ldv_state_variable_49 = 7;
      } else {

      }
    } else {

    }
#line 1236
    goto ldv_40315;
    case 9: ;
#line 1239
    if (ldv_state_variable_49 == 12) {
#line 1241
      ldv_retval_12 = ldv_restore_early_49();
#line 1242
      if (ldv_retval_12 == 0) {
#line 1243
        ldv_state_variable_49 = 15;
      } else {

      }
    } else {

    }
#line 1247
    goto ldv_40315;
    case 10: ;
#line 1250
    if (ldv_state_variable_49 == 7) {
#line 1252
      ldv_retval_11 = ldv_resume_early_49();
#line 1253
      if (ldv_retval_11 == 0) {
#line 1254
        ldv_state_variable_49 = 13;
      } else {

      }
    } else {

    }
#line 1258
    goto ldv_40315;
    case 11: ;
#line 1261
    if (ldv_state_variable_49 == 10) {
#line 1263
      ldv_retval_10 = ldv_thaw_early_49();
#line 1264
      if (ldv_retval_10 == 0) {
#line 1265
        ldv_state_variable_49 = 14;
      } else {

      }
    } else {

    }
#line 1269
    goto ldv_40315;
    case 12: ;
#line 1272
    if (ldv_state_variable_49 == 8) {
#line 1274
      ldv_retval_9 = ldv_resume_noirq_49();
#line 1275
      if (ldv_retval_9 == 0) {
#line 1276
        ldv_state_variable_49 = 13;
      } else {

      }
    } else {

    }
#line 1280
    goto ldv_40315;
    case 13: ;
#line 1283
    if (ldv_state_variable_49 == 5) {
#line 1285
      ldv_retval_8 = ldv_freeze_noirq_49();
#line 1286
      if (ldv_retval_8 == 0) {
#line 1287
        ldv_state_variable_49 = 9;
      } else {

      }
    } else {

    }
#line 1291
    goto ldv_40315;
    case 14: ;
#line 1294
    if (ldv_state_variable_49 == 1) {
#line 1296
      ldv_retval_7 = ldv_prepare_49();
#line 1297
      if (ldv_retval_7 == 0) {
#line 1298
        ldv_state_variable_49 = 3;
#line 1299
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1303
    goto ldv_40315;
    case 15: ;
#line 1306
    if (ldv_state_variable_49 == 5) {
#line 1308
      ldv_retval_6 = ldv_freeze_late_49();
#line 1309
      if (ldv_retval_6 == 0) {
#line 1310
        ldv_state_variable_49 = 10;
      } else {

      }
    } else {

    }
#line 1314
    goto ldv_40315;
    case 16: ;
#line 1317
    if (ldv_state_variable_49 == 9) {
#line 1319
      ldv_retval_5 = ldv_thaw_noirq_49();
#line 1320
      if (ldv_retval_5 == 0) {
#line 1321
        ldv_state_variable_49 = 14;
      } else {

      }
    } else {

    }
#line 1325
    goto ldv_40315;
    case 17: ;
#line 1328
    if (ldv_state_variable_49 == 3) {
#line 1330
      ldv_retval_4 = ldv_poweroff_49();
#line 1331
      if (ldv_retval_4 == 0) {
#line 1332
        ldv_state_variable_49 = 6;
      } else {

      }
    } else {

    }
#line 1336
    goto ldv_40315;
    case 18: ;
#line 1339
    if (ldv_state_variable_49 == 6) {
#line 1341
      ldv_retval_3 = ldv_poweroff_noirq_49();
#line 1342
      if (ldv_retval_3 == 0) {
#line 1343
        ldv_state_variable_49 = 11;
      } else {

      }
    } else {

    }
#line 1347
    goto ldv_40315;
    case 19: ;
#line 1350
    if (ldv_state_variable_49 == 6) {
#line 1352
      ldv_retval_2 = ldv_poweroff_late_49();
#line 1353
      if (ldv_retval_2 == 0) {
#line 1354
        ldv_state_variable_49 = 12;
      } else {

      }
    } else {

    }
#line 1358
    goto ldv_40315;
    case 20: ;
#line 1361
    if (ldv_state_variable_49 == 11) {
#line 1363
      ldv_retval_1 = ldv_restore_noirq_49();
#line 1364
      if (ldv_retval_1 == 0) {
#line 1365
        ldv_state_variable_49 = 15;
      } else {

      }
    } else {

    }
#line 1369
    goto ldv_40315;
    case 21: ;
#line 1372
    if (ldv_state_variable_49 == 4) {
#line 1374
      ldv_retval_0 = ldv_suspend_noirq_49();
#line 1375
      if (ldv_retval_0 == 0) {
#line 1376
        ldv_state_variable_49 = 8;
      } else {

      }
    } else {

    }
#line 1380
    goto ldv_40315;
    case 22: ;
#line 1383
    if (ldv_state_variable_49 == 16) {
#line 1385
      ldv_complete_49();
#line 1386
      ldv_state_variable_49 = 1;
#line 1387
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1390
    goto ldv_40315;
    default: 
#line 1391
    ldv_stop();
    }
    ldv_40315: ;
  } else {

  }
#line 1395
  goto ldv_40293;
  case 21: ;
#line 1399
  if (ldv_state_variable_24 != 0) {
#line 1400
    ldv_main_exported_24();
  } else {

  }
#line 1403
  goto ldv_40293;
  case 22: ;
#line 1407
  if (ldv_state_variable_10 != 0) {
#line 1408
    ldv_main_exported_10();
  } else {

  }
#line 1411
  goto ldv_40293;
  case 23: ;
#line 1415
  if (ldv_state_variable_31 != 0) {
#line 1416
    ldv_main_exported_31();
  } else {

  }
#line 1419
  goto ldv_40293;
  case 24: ;
#line 1423
  if (ldv_state_variable_35 != 0) {
#line 1424
    ldv_main_exported_35();
  } else {

  }
#line 1427
  goto ldv_40293;
  case 25: ;
#line 1431
  if (ldv_state_variable_11 != 0) {
#line 1432
    ldv_main_exported_11();
  } else {

  }
#line 1435
  goto ldv_40293;
  case 26: ;
#line 1439
  if (ldv_state_variable_53 != 0) {
#line 1440
    ldv_main_exported_53();
  } else {

  }
#line 1443
  goto ldv_40293;
  case 27: ;
#line 1447
  if (ldv_state_variable_48 != 0) {
#line 1448
    tmp___19 = __VERIFIER_nondet_int();
#line 1448
    switch (tmp___19) {
    case 0: ;
#line 1451
    if (ldv_state_variable_48 == 2) {
#line 1453
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg102);
#line 1455
      ldv_state_variable_48 = 2;
    } else {

    }
#line 1458
    if (ldv_state_variable_48 == 1) {
#line 1460
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg102);
#line 1462
      ldv_state_variable_48 = 1;
    } else {

    }
#line 1465
    goto ldv_40347;
    case 1: ;
#line 1468
    if (ldv_state_variable_48 == 2) {
#line 1470
      drm_gem_vm_close(psb_gem_vm_ops_group0);
#line 1471
      ldv_state_variable_48 = 1;
    } else {

    }
#line 1474
    goto ldv_40347;
    case 2: ;
#line 1477
    if (ldv_state_variable_48 == 1) {
#line 1479
      drm_gem_vm_open(psb_gem_vm_ops_group0);
#line 1480
      ldv_state_variable_48 = 2;
#line 1481
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1484
    goto ldv_40347;
    default: 
#line 1485
    ldv_stop();
    }
    ldv_40347: ;
  } else {

  }
#line 1489
  goto ldv_40293;
  case 28: ;
#line 1493
  if (ldv_state_variable_42 != 0) {
#line 1494
    ldv_main_exported_42();
  } else {

  }
#line 1497
  goto ldv_40293;
  case 29: ;
#line 1501
  if (ldv_state_variable_22 != 0) {
#line 1502
    ldv_main_exported_22();
  } else {

  }
#line 1505
  goto ldv_40293;
  case 30: ;
#line 1509
  if (ldv_state_variable_0 != 0) {
#line 1510
    tmp___20 = __VERIFIER_nondet_int();
#line 1510
    switch (tmp___20) {
    case 0: ;
#line 1513
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1515
      psb_exit();
#line 1516
      ldv_state_variable_0 = 2;
#line 1517
      goto ldv_final;
    } else {

    }
#line 1520
    goto ldv_40356;
    case 1: ;
#line 1523
    if (ldv_state_variable_0 == 1) {
#line 1525
      ldv_retval_21 = psb_init();
#line 1527
      if (ldv_retval_21 == 0) {
#line 1528
        ldv_state_variable_0 = 3;
#line 1529
        ldv_state_variable_5 = 1;
#line 1530
        ldv_initialize_drm_connector_funcs_5();
#line 1531
        ldv_state_variable_54 = 1;
#line 1532
        ldv_initialize_fb_ops_54();
#line 1533
        ldv_state_variable_19 = 1;
#line 1534
        ldv_initialize_drm_encoder_helper_funcs_19();
#line 1535
        ldv_state_variable_43 = 1;
#line 1536
        ldv_initialize_drm_crtc_funcs_43();
#line 1537
        ldv_state_variable_37 = 1;
#line 1538
        ldv_initialize_drm_encoder_helper_funcs_37();
#line 1539
        ldv_state_variable_45 = 1;
#line 1540
        ldv_initialize_pci_driver_45();
#line 1541
        ldv_state_variable_56 = 1;
#line 1542
        ldv_initialize_vm_operations_struct_56();
#line 1543
        ldv_state_variable_34 = 1;
#line 1544
        ldv_state_variable_4 = 1;
#line 1545
        ldv_state_variable_8 = 1;
#line 1546
        ldv_initialize_drm_encoder_helper_funcs_8();
#line 1547
        ldv_state_variable_38 = 1;
#line 1548
        ldv_state_variable_52 = 1;
#line 1549
        ldv_initialize_drm_fb_helper_funcs_52();
#line 1550
        ldv_state_variable_15 = 1;
#line 1551
        ldv_initialize_drm_encoder_helper_funcs_15();
#line 1552
        ldv_state_variable_47 = 1;
#line 1553
        ldv_file_operations_47();
#line 1554
        ldv_state_variable_12 = 1;
#line 1555
        ldv_state_variable_41 = 1;
#line 1556
        ldv_initialize_drm_encoder_helper_funcs_41();
#line 1557
        ldv_state_variable_9 = 1;
#line 1558
        ldv_initialize_gma_clock_funcs_9();
#line 1559
        ldv_state_variable_51 = 1;
#line 1560
        ldv_initialize_drm_mode_config_funcs_51();
#line 1561
        ldv_state_variable_36 = 1;
#line 1562
        ldv_initialize_drm_connector_funcs_36();
#line 1563
        ldv_state_variable_3 = 1;
#line 1564
        ldv_initialize_i2c_algorithm_3();
#line 1565
        ldv_state_variable_39 = 1;
#line 1566
        ldv_initialize_drm_connector_funcs_39();
#line 1567
        ldv_state_variable_50 = 1;
#line 1568
        ldv_initialize_i2c_algorithm_50();
#line 1569
        ldv_state_variable_6 = 1;
#line 1570
        ldv_initialize_drm_connector_helper_funcs_6();
#line 1571
        ldv_state_variable_29 = 1;
#line 1572
        ldv_initialize_drm_encoder_helper_funcs_29();
#line 1573
        ldv_state_variable_23 = 1;
#line 1574
        ldv_initialize_gma_clock_funcs_23();
#line 1575
        ldv_state_variable_13 = 1;
#line 1576
        ldv_initialize_drm_connector_helper_funcs_13();
#line 1577
        ldv_state_variable_46 = 1;
#line 1578
        ldv_initialize_drm_driver_46();
#line 1579
        ldv_state_variable_22 = 1;
#line 1580
        ldv_initialize_drm_encoder_helper_funcs_22();
#line 1581
        ldv_state_variable_42 = 1;
#line 1582
        ldv_initialize_gma_clock_funcs_42();
#line 1583
        ldv_state_variable_48 = 1;
#line 1584
        ldv_initialize_vm_operations_struct_48();
#line 1585
        ldv_state_variable_53 = 1;
#line 1586
        ldv_initialize_fb_ops_53();
#line 1587
        ldv_state_variable_11 = 1;
#line 1588
        ldv_initialize_psb_ops_11();
#line 1589
        ldv_state_variable_35 = 1;
#line 1590
        ldv_initialize_drm_connector_helper_funcs_35();
#line 1591
        ldv_state_variable_31 = 1;
#line 1592
        ldv_state_variable_10 = 1;
#line 1593
        ldv_initialize_drm_crtc_helper_funcs_10();
#line 1594
        ldv_state_variable_24 = 1;
#line 1595
        ldv_initialize_drm_crtc_funcs_24();
#line 1596
        ldv_state_variable_49 = 1;
#line 1597
        ldv_dev_pm_ops_49();
#line 1598
        ldv_state_variable_14 = 1;
#line 1599
        ldv_initialize_drm_connector_funcs_14();
#line 1600
        ldv_state_variable_20 = 1;
#line 1601
        ldv_initialize_drm_connector_funcs_20();
#line 1602
        ldv_state_variable_40 = 1;
#line 1603
        ldv_initialize_drm_connector_helper_funcs_40();
#line 1604
        ldv_state_variable_57 = 1;
#line 1605
        ldv_initialize_drm_framebuffer_funcs_57();
#line 1606
        ldv_state_variable_28 = 1;
#line 1607
        ldv_initialize_drm_connector_funcs_28();
#line 1608
        ldv_state_variable_25 = 1;
#line 1609
        ldv_initialize_drm_crtc_helper_funcs_25();
#line 1610
        ldv_state_variable_27 = 1;
#line 1611
        ldv_initialize_drm_connector_helper_funcs_27();
#line 1612
        ldv_state_variable_55 = 1;
#line 1613
        ldv_initialize_fb_ops_55();
#line 1614
        ldv_state_variable_44 = 1;
#line 1615
        ldv_initialize_drm_crtc_helper_funcs_44();
#line 1616
        ldv_state_variable_16 = 1;
#line 1617
        ldv_state_variable_30 = 1;
#line 1618
        ldv_initialize_psb_ops_30();
#line 1619
        ldv_state_variable_18 = 1;
#line 1620
        ldv_initialize_drm_connector_helper_funcs_18();
#line 1621
        ldv_state_variable_17 = 1;
#line 1622
        ldv_initialize_drm_connector_funcs_17();
#line 1623
        ldv_state_variable_26 = 1;
#line 1624
        ldv_state_variable_7 = 1;
#line 1625
        ldv_initialize_drm_encoder_helper_funcs_7();
#line 1626
        ldv_state_variable_21 = 1;
#line 1627
        ldv_initialize_drm_connector_helper_funcs_21();
#line 1628
        ldv_state_variable_32 = 1;
#line 1629
        ldv_initialize_psb_ops_32();
#line 1630
        ldv_state_variable_33 = 1;
#line 1631
        ldv_initialize_i2c_algorithm_33();
      } else {

      }
#line 1633
      if (ldv_retval_21 != 0) {
#line 1634
        ldv_state_variable_0 = 2;
#line 1635
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1639
    goto ldv_40356;
    default: 
#line 1640
    ldv_stop();
    }
    ldv_40356: ;
  } else {

  }
#line 1644
  goto ldv_40293;
  case 31: ;
#line 1648
  if (ldv_state_variable_46 != 0) {
#line 1649
    tmp___21 = __VERIFIER_nondet_int();
#line 1649
    switch (tmp___21) {
    case 0: ;
#line 1652
    if (ldv_state_variable_46 == 1) {
#line 1654
      psb_driver_lastclose(driver_group1);
#line 1656
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1659
    goto ldv_40361;
    case 1: ;
#line 1662
    if (ldv_state_variable_46 == 1) {
#line 1664
      psb_get_vblank_counter(driver_group1, ldvarg119);
#line 1666
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1669
    goto ldv_40361;
    case 2: ;
#line 1672
    if (ldv_state_variable_46 == 1) {
#line 1674
      psb_gem_dumb_map_gtt(driver_group0, driver_group1, ldvarg118, ldvarg117);
#line 1676
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1679
    goto ldv_40361;
    case 3: ;
#line 1682
    if (ldv_state_variable_46 == 1) {
#line 1684
      psb_gem_free_object(ldvarg116);
#line 1686
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1689
    goto ldv_40361;
    case 4: ;
#line 1692
    if (ldv_state_variable_46 == 1) {
#line 1694
      psb_driver_unload(driver_group1);
#line 1696
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1699
    goto ldv_40361;
    case 5: ;
#line 1702
    if (ldv_state_variable_46 == 1) {
#line 1704
      psb_irq_preinstall(driver_group1);
#line 1706
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1709
    goto ldv_40361;
    case 6: ;
#line 1712
    if (ldv_state_variable_46 == 1) {
#line 1714
      psb_driver_load(driver_group1, ldvarg115);
#line 1716
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1719
    goto ldv_40361;
    case 7: ;
#line 1722
    if (ldv_state_variable_46 == 1) {
#line 1724
      psb_irq_uninstall(driver_group1);
#line 1726
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1729
    goto ldv_40361;
    case 8: ;
#line 1732
    if (ldv_state_variable_46 == 1) {
#line 1734
      drm_gem_dumb_destroy(driver_group0, driver_group1, ldvarg114);
#line 1736
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1739
    goto ldv_40361;
    case 9: ;
#line 1742
    if (ldv_state_variable_46 == 1) {
#line 1744
      psb_irq_postinstall(driver_group1);
#line 1746
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1749
    goto ldv_40361;
    case 10: ;
#line 1752
    if (ldv_state_variable_46 == 1) {
#line 1754
      psb_gem_dumb_create(driver_group0, driver_group1, ldvarg113);
#line 1756
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1759
    goto ldv_40361;
    case 11: ;
#line 1762
    if (ldv_state_variable_46 == 1) {
#line 1764
      psb_irq_handler(ldvarg111, ldvarg112);
#line 1766
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1769
    goto ldv_40361;
    case 12: ;
#line 1772
    if (ldv_state_variable_46 == 1) {
#line 1774
      psb_enable_vblank(driver_group1, ldvarg110);
#line 1776
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1779
    goto ldv_40361;
    case 13: ;
#line 1782
    if (ldv_state_variable_46 == 1) {
#line 1784
      psb_driver_preclose(driver_group1, driver_group0);
#line 1786
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1789
    goto ldv_40361;
    case 14: ;
#line 1792
    if (ldv_state_variable_46 == 1) {
#line 1794
      psb_driver_device_is_agp(driver_group1);
#line 1796
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1799
    goto ldv_40361;
    case 15: ;
#line 1802
    if (ldv_state_variable_46 == 1) {
#line 1804
      psb_disable_vblank(driver_group1, ldvarg109);
#line 1806
      ldv_state_variable_46 = 1;
    } else {

    }
#line 1809
    goto ldv_40361;
    default: 
#line 1810
    ldv_stop();
    }
    ldv_40361: ;
  } else {

  }
#line 1814
  goto ldv_40293;
  case 32: ;
#line 1818
  if (ldv_state_variable_13 != 0) {
#line 1819
    ldv_main_exported_13();
  } else {

  }
#line 1822
  goto ldv_40293;
  case 33: ;
#line 1826
  if (ldv_state_variable_23 != 0) {
#line 1827
    ldv_main_exported_23();
  } else {

  }
#line 1830
  goto ldv_40293;
  case 34: ;
#line 1834
  if (ldv_state_variable_29 != 0) {
#line 1835
    ldv_main_exported_29();
  } else {

  }
#line 1838
  goto ldv_40293;
  case 35: ;
#line 1842
  if (ldv_state_variable_6 != 0) {
#line 1843
    ldv_main_exported_6();
  } else {

  }
#line 1846
  goto ldv_40293;
  case 36: ;
#line 1850
  if (ldv_state_variable_50 != 0) {
#line 1851
    ldv_main_exported_50();
  } else {

  }
#line 1854
  goto ldv_40293;
  case 37: ;
#line 1858
  if (ldv_state_variable_39 != 0) {
#line 1859
    ldv_main_exported_39();
  } else {

  }
#line 1862
  goto ldv_40293;
  case 38: ;
#line 1866
  if (ldv_state_variable_36 != 0) {
#line 1867
    ldv_main_exported_36();
  } else {

  }
#line 1870
  goto ldv_40293;
  case 39: ;
#line 1874
  if (ldv_state_variable_3 != 0) {
#line 1875
    ldv_main_exported_3();
  } else {

  }
#line 1878
  goto ldv_40293;
  case 40: ;
#line 1882
  if (ldv_state_variable_51 != 0) {
#line 1883
    ldv_main_exported_51();
  } else {

  }
#line 1886
  goto ldv_40293;
  case 41: ;
#line 1890
  if (ldv_state_variable_9 != 0) {
#line 1891
    ldv_main_exported_9();
  } else {

  }
#line 1894
  goto ldv_40293;
  case 42: ;
#line 1898
  if (ldv_state_variable_41 != 0) {
#line 1899
    ldv_main_exported_41();
  } else {

  }
#line 1902
  goto ldv_40293;
  case 43: ;
#line 1906
  if (ldv_state_variable_12 != 0) {
#line 1907
    ldv_main_exported_12();
  } else {

  }
#line 1910
  goto ldv_40293;
  case 44: ;
#line 1914
  if (ldv_state_variable_47 != 0) {
#line 1915
    tmp___22 = __VERIFIER_nondet_int();
#line 1915
    switch (tmp___22) {
    case 0: ;
#line 1918
    if (ldv_state_variable_47 == 2) {
#line 1920
      drm_read(psb_gem_fops_group2, ldvarg159, ldvarg158, ldvarg157);
#line 1922
      ldv_state_variable_47 = 2;
    } else {

    }
#line 1925
    goto ldv_40392;
    case 1: ;
#line 1928
    if (ldv_state_variable_47 == 2) {
#line 1930
      drm_poll(psb_gem_fops_group2, ldvarg156);
#line 1932
      ldv_state_variable_47 = 2;
    } else {

    }
#line 1935
    if (ldv_state_variable_47 == 1) {
#line 1937
      drm_poll(psb_gem_fops_group2, ldvarg156);
#line 1939
      ldv_state_variable_47 = 1;
    } else {

    }
#line 1942
    goto ldv_40392;
    case 2: ;
#line 1945
    if (ldv_state_variable_47 == 1) {
#line 1947
      ldv_retval_22 = drm_open(psb_gem_fops_group1, psb_gem_fops_group2);
#line 1948
      if (ldv_retval_22 == 0) {
#line 1949
        ldv_state_variable_47 = 2;
#line 1950
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1954
    goto ldv_40392;
    case 3: ;
#line 1957
    if (ldv_state_variable_47 == 2) {
#line 1959
      drm_gem_mmap(psb_gem_fops_group2, ldvarg155);
#line 1961
      ldv_state_variable_47 = 2;
    } else {

    }
#line 1964
    if (ldv_state_variable_47 == 1) {
#line 1966
      drm_gem_mmap(psb_gem_fops_group2, ldvarg155);
#line 1968
      ldv_state_variable_47 = 1;
    } else {

    }
#line 1971
    goto ldv_40392;
    case 4: ;
#line 1974
    if (ldv_state_variable_47 == 2) {
#line 1976
      drm_release(psb_gem_fops_group1, psb_gem_fops_group2);
#line 1977
      ldv_state_variable_47 = 1;
#line 1978
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1981
    goto ldv_40392;
    case 5: ;
#line 1984
    if (ldv_state_variable_47 == 2) {
#line 1986
      psb_unlocked_ioctl(psb_gem_fops_group2, ldvarg154, ldvarg153);
#line 1988
      ldv_state_variable_47 = 2;
    } else {

    }
#line 1991
    goto ldv_40392;
    default: 
#line 1992
    ldv_stop();
    }
    ldv_40392: ;
  } else {

  }
#line 1996
  goto ldv_40293;
  case 45: ;
#line 2000
  if (ldv_state_variable_15 != 0) {
#line 2001
    ldv_main_exported_15();
  } else {

  }
#line 2004
  goto ldv_40293;
  case 46: ;
#line 2008
  if (ldv_state_variable_52 != 0) {
#line 2009
    ldv_main_exported_52();
  } else {

  }
#line 2012
  goto ldv_40293;
  case 47: ;
#line 2016
  if (ldv_state_variable_38 != 0) {
#line 2017
    ldv_main_exported_38();
  } else {

  }
#line 2020
  goto ldv_40293;
  case 48: ;
#line 2024
  if (ldv_state_variable_8 != 0) {
#line 2025
    ldv_main_exported_8();
  } else {

  }
#line 2028
  goto ldv_40293;
  case 49: ;
#line 2032
  if (ldv_state_variable_4 != 0) {
#line 2033
    ldv_main_exported_4();
  } else {

  }
#line 2036
  goto ldv_40293;
  case 50: ;
#line 2040
  if (ldv_state_variable_34 != 0) {
#line 2041
    ldv_main_exported_34();
  } else {

  }
#line 2044
  goto ldv_40293;
  case 51: ;
#line 2048
  if (ldv_state_variable_56 != 0) {
#line 2049
    ldv_main_exported_56();
  } else {

  }
#line 2052
  goto ldv_40293;
  case 52: ;
#line 2056
  if (ldv_state_variable_45 != 0) {
#line 2057
    tmp___23 = __VERIFIER_nondet_int();
#line 2057
    switch (tmp___23) {
    case 0: ;
#line 2060
    if (ldv_state_variable_45 == 1) {
#line 2062
      ldv_retval_23 = psb_pci_probe(psb_pci_driver_group0, (struct pci_device_id  const  *)ldvarg180);
#line 2064
      if (ldv_retval_23 == 0) {
#line 2065
        ldv_state_variable_45 = 2;
#line 2066
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 2070
    goto ldv_40408;
    case 1: ;
#line 2073
    if (ldv_state_variable_45 == 2) {
#line 2075
      psb_pci_remove(psb_pci_driver_group0);
#line 2077
      ldv_state_variable_45 = 1;
#line 2078
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2081
    goto ldv_40408;
    default: 
#line 2082
    ldv_stop();
    }
    ldv_40408: ;
  } else {

  }
#line 2086
  goto ldv_40293;
  case 53: ;
#line 2090
  if (ldv_state_variable_37 != 0) {
#line 2091
    ldv_main_exported_37();
  } else {

  }
#line 2094
  goto ldv_40293;
  case 54: ;
#line 2098
  if (ldv_state_variable_43 != 0) {
#line 2099
    ldv_main_exported_43();
  } else {

  }
#line 2102
  goto ldv_40293;
  case 55: ;
#line 2106
  if (ldv_state_variable_19 != 0) {
#line 2107
    ldv_main_exported_19();
  } else {

  }
#line 2110
  goto ldv_40293;
  case 56: ;
#line 2114
  if (ldv_state_variable_54 != 0) {
#line 2115
    ldv_main_exported_54();
  } else {

  }
#line 2118
  goto ldv_40293;
  case 57: ;
#line 2122
  if (ldv_state_variable_5 != 0) {
#line 2123
    ldv_main_exported_5();
  } else {

  }
#line 2126
  goto ldv_40293;
  default: 
#line 2127
  ldv_stop();
  }
  ldv_40293: ;
#line 2129
  goto ldv_40417;
  ldv_final: 
#line 2131
  ldv_check_final_state();
#line 2132
  return 0;
}
}
#line 2262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_drv.o.c.prepared"
void *ldv_kmem_cache_alloc_238(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2265
  ldv_check_alloc_flags(flags);
#line 2267
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2268
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_258(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 860 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
#line 928
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
#line 1015
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
#line 1358 "include/drm/drmP.h"
extern void drm_vblank_off(struct drm_device * , int  ) ;
#line 51 "include/linux/pm_runtime.h"
extern void pm_runtime_forbid(struct device * ) ;
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/gma_display.h"
bool gma_pipe_has_type(struct drm_crtc *crtc , int type ) ;
#line 66
void gma_wait_for_vblank(struct drm_device *dev ) ;
#line 67
int gma_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) ;
#line 69
int gma_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                        uint32_t width , uint32_t height ) ;
#line 73
int gma_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 74
void gma_crtc_load_lut(struct drm_crtc *crtc ) ;
#line 75
void gma_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                        u32 start , u32 size ) ;
#line 77
void gma_crtc_dpms(struct drm_crtc *crtc , int mode ) ;
#line 78
bool gma_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                         struct drm_display_mode *adjusted_mode ) ;
#line 81
void gma_crtc_prepare(struct drm_crtc *crtc ) ;
#line 82
void gma_crtc_commit(struct drm_crtc *crtc ) ;
#line 83
void gma_crtc_disable(struct drm_crtc *crtc ) ;
#line 84
void gma_crtc_destroy(struct drm_crtc *crtc ) ;
#line 85
int gma_crtc_set_config(struct drm_mode_set *set ) ;
#line 87
void gma_crtc_save(struct drm_crtc *crtc ) ;
#line 88
void gma_crtc_restore(struct drm_crtc *crtc ) ;
#line 90
void gma_encoder_prepare(struct drm_encoder *encoder ) ;
#line 91
void gma_encoder_commit(struct drm_encoder *encoder ) ;
#line 92
void gma_encoder_destroy(struct drm_encoder *encoder ) ;
#line 93
bool gma_encoder_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                            struct drm_display_mode *adjusted_mode ) ;
#line 100
bool gma_pll_is_valid(struct drm_crtc *crtc , struct gma_limit_t  const  *limit ,
                      struct gma_clock_t *clock ) ;
#line 103
bool gma_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                       int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 129 "include/drm/drm_crtc_helper.h"
extern int drm_crtc_helper_set_config(struct drm_mode_set * ) ;
#line 229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct drm_encoder *gma_best_encoder(struct drm_connector *connector ) ;
#line 230
void gma_connector_attach_encoder(struct gma_connector *connector , struct gma_encoder *encoder ) ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool gma_pipe_has_type(struct drm_crtc *crtc , int type ) 
{ 
  struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *l_entry ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 254
  dev = crtc->dev;
#line 255
  mode_config = & dev->mode_config;
#line 258
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
#line 258
  l_entry = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 258
  goto ldv_39852;
  ldv_39851: ;
#line 259
  if ((unsigned long )l_entry->encoder != (unsigned long )((struct drm_encoder *)0) && (unsigned long )(l_entry->encoder)->crtc == (unsigned long )crtc) {
#line 260
    tmp = gma_attached_encoder(l_entry);
#line 260
    gma_encoder = tmp;
#line 262
    if (gma_encoder->type == type) {
#line 263
      return (1);
    } else {

    }
  } else {

  }
#line 258
  __mptr___0 = (struct list_head  const  *)l_entry->head.next;
#line 258
  l_entry = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_39852: ;
#line 258
  if ((unsigned long )(& l_entry->head) != (unsigned long )(& mode_config->connector_list)) {
#line 260
    goto ldv_39851;
  } else {

  }

#line 267
  return (0);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_wait_for_vblank(struct drm_device *dev ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 273
  __ms = 20UL;
#line 273
  goto ldv_39859;
  ldv_39858: 
#line 273
  __const_udelay(4295000UL);
  ldv_39859: 
#line 273
  tmp = __ms;
#line 273
  __ms = __ms - 1UL;
#line 273
  if (tmp != 0UL) {
#line 275
    goto ldv_39858;
  } else {

  }

#line 282
  return;
}
}
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int gma_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct drm_framebuffer  const  *__mptr___1 ;

  {
#line 279
  dev = crtc->dev;
#line 280
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 281
  __mptr = (struct drm_crtc  const  *)crtc;
#line 281
  gma_crtc = (struct gma_crtc *)__mptr;
#line 282
  __mptr___0 = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 282
  psbfb = (struct psb_framebuffer *)__mptr___0;
#line 283
  pipe = gma_crtc->pipe;
#line 284
  map = dev_priv->regmap + (unsigned long )pipe;
#line 287
  ret = 0;
#line 289
  tmp = gma_power_begin(dev, 1);
#line 289
  if (tmp) {
#line 289
    tmp___0 = 0;
  } else {
#line 289
    tmp___0 = 1;
  }
#line 289
  if (tmp___0) {
#line 290
    return (0);
  } else {

  }
#line 293
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 294
    dev_err((struct device  const  *)dev->dev, "No FB bound\n");
#line 295
    goto gma_pipe_cleaner;
  } else {

  }
#line 300
  ret = psb_gtt_pin(psbfb->gtt);
#line 301
  if (ret < 0) {
#line 302
    goto gma_pipe_set_base_exit;
  } else {

  }
#line 303
  start = (unsigned long )(psbfb->gtt)->offset;
#line 304
  offset = (unsigned long )(((crtc->primary)->fb)->pitches[0] * (unsigned int )y + (unsigned int )((((crtc->primary)->fb)->bits_per_pixel / 8) * x));
#line 306
  REGISTER_WRITE(dev, map->stride, ((crtc->primary)->fb)->pitches[0]);
#line 308
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 309
  dspcntr = dspcntr & 3288334335U;
#line 311
  switch (((crtc->primary)->fb)->bits_per_pixel) {
  case 8: 
#line 313
  dspcntr = dspcntr | 134217728U;
#line 314
  goto ldv_39884;
  case 16: ;
#line 316
  if (((crtc->primary)->fb)->depth == 15U) {
#line 317
    dspcntr = dspcntr | 268435456U;
  } else {
#line 319
    dspcntr = dspcntr | 335544320U;
  }
#line 320
  goto ldv_39884;
  case 24: ;
  case 32: 
#line 323
  dspcntr = dspcntr | 402653184U;
#line 324
  goto ldv_39884;
  default: 
#line 326
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
#line 327
  ret = -22;
#line 328
  goto gma_pipe_set_base_exit;
  }
  ldv_39884: 
#line 330
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 332
  descriptor.modname = "gma500_gfx";
#line 332
  descriptor.function = "gma_pipe_set_base";
#line 332
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared";
#line 332
  descriptor.format = "Writing base %08lX %08lX %d %d\n";
#line 332
  descriptor.lineno = 333U;
#line 332
  descriptor.flags = 0U;
#line 332
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 332
  if (tmp___1 != 0L) {
#line 332
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Writing base %08lX %08lX %d %d\n",
                      start, offset, x, y);
  } else {

  }
#line 338
  if (((int )(dev->pdev)->device & 65534) == 33032) {
#line 339
    REGISTER_WRITE(dev, map->base, (uint32_t )offset + (uint32_t )start);
#line 340
    REGISTER_READ(dev, map->base);
  } else {
#line 342
    REGISTER_WRITE(dev, map->base, (uint32_t )offset);
#line 343
    REGISTER_READ(dev, map->base);
#line 344
    REGISTER_WRITE(dev, map->surf, (uint32_t )start);
#line 345
    REGISTER_READ(dev, map->surf);
  }
  gma_pipe_cleaner: ;
#line 350
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 351
    __mptr___1 = (struct drm_framebuffer  const  *)old_fb;
#line 351
    psb_gtt_unpin(((struct psb_framebuffer *)__mptr___1)->gtt);
  } else {

  }
  gma_pipe_set_base_exit: 
#line 354
  gma_power_end(dev);
#line 355
  return (ret);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_load_lut(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_offset  const  *map ;
  int palreg ;
  int i ;
  bool tmp ;

  {
#line 361
  dev = crtc->dev;
#line 362
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 363
  __mptr = (struct drm_crtc  const  *)crtc;
#line 363
  gma_crtc = (struct gma_crtc *)__mptr;
#line 364
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 365
  palreg = (int )map->palette;
#line 369
  if (! crtc->enabled) {
#line 370
    return;
  } else {

  }
#line 372
  tmp = gma_power_begin(dev, 0);
#line 372
  if ((int )tmp) {
#line 373
    i = 0;
#line 373
    goto ldv_39905;
    ldv_39904: 
#line 374
    REGISTER_WRITE(dev, (uint32_t )(i * 4 + palreg), (uint32_t )(((((int )gma_crtc->lut_r[i] + (int )gma_crtc->lut_adj[i]) << 16) | (((int )gma_crtc->lut_g[i] + (int )gma_crtc->lut_adj[i]) << 8)) | ((int )gma_crtc->lut_b[i] + (int )gma_crtc->lut_adj[i])));
#line 373
    i = i + 1;
    ldv_39905: ;
#line 373
    if (i <= 255) {
#line 375
      goto ldv_39904;
    } else {

    }
#line 382
    gma_power_end(dev);
  } else {
#line 384
    i = 0;
#line 384
    goto ldv_39908;
    ldv_39907: 
#line 386
    dev_priv->regs.pipe[0].palette[i] = (u32 )(((((int )gma_crtc->lut_r[i] + (int )gma_crtc->lut_adj[i]) << 16) | (((int )gma_crtc->lut_g[i] + (int )gma_crtc->lut_adj[i]) << 8)) | ((int )gma_crtc->lut_b[i] + (int )gma_crtc->lut_adj[i]));
#line 384
    i = i + 1;
    ldv_39908: ;
#line 384
    if (i <= 255) {
#line 386
      goto ldv_39907;
    } else {

    }

  }
#line 392
  return;
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                        u32 start , u32 size ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int i ;
  int end ;

  {
#line 401
  __mptr = (struct drm_crtc  const  *)crtc;
#line 401
  gma_crtc = (struct gma_crtc *)__mptr;
#line 403
  end = (int )(256U < start + size ? 256U : start + size);
#line 405
  i = (int )start;
#line 405
  goto ldv_39924;
  ldv_39923: 
#line 406
  gma_crtc->lut_r[i] = (u8 )((int )*(red + (unsigned long )i) >> 8);
#line 407
  gma_crtc->lut_g[i] = (u8 )((int )*(green + (unsigned long )i) >> 8);
#line 408
  gma_crtc->lut_b[i] = (u8 )((int )*(blue + (unsigned long )i) >> 8);
#line 405
  i = i + 1;
  ldv_39924: ;
#line 405
  if (i < end) {
#line 407
    goto ldv_39923;
  } else {

  }
#line 411
  gma_crtc_load_lut(crtc);
#line 412
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 422
  dev = crtc->dev;
#line 423
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 424
  __mptr = (struct drm_crtc  const  *)crtc;
#line 424
  gma_crtc = (struct gma_crtc *)__mptr;
#line 425
  pipe = gma_crtc->pipe;
#line 426
  map = dev_priv->regmap + (unsigned long )pipe;
#line 433
  if (((int )(dev->pdev)->device & 65520) == 3040) {
#line 434
    (*((dev_priv->ops)->disable_sr))(dev);
  } else {

  }
#line 436
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: ;
#line 440
  if ((int )gma_crtc->active) {
#line 441
    goto ldv_39941;
  } else {

  }
#line 443
  gma_crtc->active = 1;
#line 446
  temp = REGISTER_READ(dev, map->dpll);
#line 447
  if ((int )temp >= 0) {
#line 448
    REGISTER_WRITE(dev, map->dpll, temp);
#line 449
    REGISTER_READ(dev, map->dpll);
#line 451
    __const_udelay(644250UL);
#line 452
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
#line 453
    REGISTER_READ(dev, map->dpll);
#line 455
    __const_udelay(644250UL);
#line 456
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
#line 457
    REGISTER_READ(dev, map->dpll);
#line 459
    __const_udelay(644250UL);
  } else {

  }
#line 463
  temp = REGISTER_READ(dev, map->cntr);
#line 464
  if ((int )temp >= 0) {
#line 465
    REGISTER_WRITE(dev, map->cntr, temp | 2147483648U);
#line 468
    tmp = REGISTER_READ(dev, map->base);
#line 468
    REGISTER_WRITE(dev, map->base, tmp);
  } else {

  }
#line 471
  __const_udelay(644250UL);
#line 474
  temp = REGISTER_READ(dev, map->conf);
#line 475
  if ((int )temp >= 0) {
#line 476
    REGISTER_WRITE(dev, map->conf, temp | 2147483648U);
  } else {

  }
#line 478
  temp = REGISTER_READ(dev, map->status);
#line 479
  temp = temp & 4294901760U;
#line 480
  temp = temp | 2147483648U;
#line 481
  REGISTER_WRITE(dev, map->status, temp);
#line 482
  REGISTER_READ(dev, map->status);
#line 484
  gma_crtc_load_lut(crtc);
#line 489
  goto ldv_39941;
  case 3: ;
#line 491
  if (! gma_crtc->active) {
#line 492
    goto ldv_39941;
  } else {

  }
#line 494
  gma_crtc->active = 0;
#line 501
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 504
  drm_vblank_off(dev, pipe);
#line 507
  gma_wait_for_vblank(dev);
#line 510
  temp = REGISTER_READ(dev, map->cntr);
#line 511
  if ((int )temp < 0) {
#line 512
    REGISTER_WRITE(dev, map->cntr, temp & 2147483647U);
#line 515
    tmp___0 = REGISTER_READ(dev, map->base);
#line 515
    REGISTER_WRITE(dev, map->base, tmp___0);
#line 516
    REGISTER_READ(dev, map->base);
  } else {

  }
#line 520
  temp = REGISTER_READ(dev, map->conf);
#line 521
  if ((int )temp < 0) {
#line 522
    REGISTER_WRITE(dev, map->conf, temp & 2147483647U);
#line 523
    REGISTER_READ(dev, map->conf);
  } else {

  }
#line 527
  gma_wait_for_vblank(dev);
#line 529
  __const_udelay(644250UL);
#line 532
  temp = REGISTER_READ(dev, map->dpll);
#line 533
  if ((int )temp < 0) {
#line 534
    REGISTER_WRITE(dev, map->dpll, temp & 2147483647U);
#line 535
    REGISTER_READ(dev, map->dpll);
  } else {

  }
#line 539
  __const_udelay(644250UL);
#line 540
  goto ldv_39941;
  }
  ldv_39941: ;
#line 543
  if (((int )(dev->pdev)->device & 65520) == 3040) {
#line 544
    (*((dev_priv->ops)->update_wm))(dev, crtc);
  } else {

  }
#line 547
  REGISTER_WRITE(dev, 458800U, 16190U);
#line 548
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int gma_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                        uint32_t width , uint32_t height ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t control ;
  uint32_t base ;
  uint32_t temp ;
  size_t addr ;
  struct gtt_range *gt ;
  struct gtt_range *cursor_gt ;
  struct drm_gem_object *obj ;
  void *tmp_dst ;
  void *tmp_src ;
  int ret ;
  int i ;
  int cursor_pages ;
  bool tmp ;
  struct drm_gem_object  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct drm_gem_object  const  *__mptr___1 ;
  size_t __len ;
  void *__ret ;
  bool tmp___2 ;
  struct drm_gem_object  const  *__mptr___2 ;

  {
#line 555
  dev = crtc->dev;
#line 556
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 557
  __mptr = (struct drm_crtc  const  *)crtc;
#line 557
  gma_crtc = (struct gma_crtc *)__mptr;
#line 558
  pipe = gma_crtc->pipe;
#line 559
  control = pipe == 0 ? 458880U : 458944U;
#line 560
  base = pipe == 0 ? 458884U : 458948U;
#line 562
  addr = 0UL;
#line 564
  cursor_gt = gma_crtc->cursor_gt;
#line 567
  ret = 0;
#line 570
  if (handle == 0U) {
#line 571
    temp = 0U;
#line 572
    mutex_lock_nested(& dev->struct_mutex, 0U);
#line 574
    tmp = gma_power_begin(dev, 0);
#line 574
    if ((int )tmp) {
#line 575
      REGISTER_WRITE(dev, control, temp);
#line 576
      REGISTER_WRITE(dev, base, 0U);
#line 577
      gma_power_end(dev);
    } else {

    }
#line 581
    if ((unsigned long )gma_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 582
      __mptr___0 = (struct drm_gem_object  const  *)gma_crtc->cursor_obj;
#line 582
      gt = (struct gtt_range *)__mptr___0 + 0xffffffffffffffc0UL;
#line 584
      psb_gtt_unpin(gt);
#line 585
      drm_gem_object_unreference(gma_crtc->cursor_obj);
#line 586
      gma_crtc->cursor_obj = (struct drm_gem_object *)0;
    } else {

    }
#line 589
    mutex_unlock(& dev->struct_mutex);
#line 590
    return (0);
  } else {

  }
#line 594
  if (width != 64U || height != 64U) {
#line 595
    descriptor.modname = "gma500_gfx";
#line 595
    descriptor.function = "gma_crtc_cursor_set";
#line 595
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared";
#line 595
    descriptor.format = "We currently only support 64x64 cursors\n";
#line 595
    descriptor.lineno = 595U;
#line 595
    descriptor.flags = 0U;
#line 595
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 595
    if (tmp___0 != 0L) {
#line 595
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "We currently only support 64x64 cursors\n");
    } else {

    }
#line 596
    return (-22);
  } else {

  }
#line 599
  mutex_lock_nested(& dev->struct_mutex, 0U);
#line 600
  obj = drm_gem_object_lookup(dev, file_priv, handle);
#line 601
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
#line 602
    ret = -2;
#line 603
    goto unlock;
  } else {

  }
#line 606
  if (obj->size < (size_t )((width * height) * 4U)) {
#line 607
    descriptor___0.modname = "gma500_gfx";
#line 607
    descriptor___0.function = "gma_crtc_cursor_set";
#line 607
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared";
#line 607
    descriptor___0.format = "Buffer is too small\n";
#line 607
    descriptor___0.lineno = 607U;
#line 607
    descriptor___0.flags = 0U;
#line 607
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 607
    if (tmp___1 != 0L) {
#line 607
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "Buffer is too small\n");
    } else {

    }
#line 608
    ret = -12;
#line 609
    goto unref_cursor;
  } else {

  }
#line 612
  __mptr___1 = (struct drm_gem_object  const  *)obj;
#line 612
  gt = (struct gtt_range *)__mptr___1 + 0xffffffffffffffc0UL;
#line 615
  ret = psb_gtt_pin(gt);
#line 616
  if (ret != 0) {
#line 617
    dev_err((struct device  const  *)dev->dev, "Can not pin down handle 0x%x\n", handle);
#line 618
    goto unref_cursor;
  } else {

  }
#line 621
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
#line 622
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
#line 623
      dev_err((struct device  const  *)dev->dev, "No hardware cursor mem available");
#line 624
      ret = -12;
#line 625
      goto unref_cursor;
    } else {

    }
#line 629
    if (gt->npage > 4) {
#line 630
      cursor_pages = 4;
    } else {
#line 632
      cursor_pages = gt->npage;
    }
#line 635
    tmp_dst = (void *)dev_priv->vram_addr + (unsigned long )cursor_gt->offset;
#line 636
    i = 0;
#line 636
    goto ldv_39981;
    ldv_39980: 
#line 637
    tmp_src = kmap(*(gt->pages + (unsigned long )i));
#line 638
    __len = 4096UL;
#line 638
    if (__len > 63UL) {
#line 638
      __ret = __memcpy(tmp_dst, (void const   *)tmp_src, __len);
    } else {
#line 638
      __ret = __builtin_memcpy(tmp_dst, (void const   *)tmp_src, __len);
    }
#line 639
    kunmap(*(gt->pages + (unsigned long )i));
#line 640
    tmp_dst = tmp_dst + 4096UL;
#line 636
    i = i + 1;
    ldv_39981: ;
#line 636
    if (i < cursor_pages) {
#line 638
      goto ldv_39980;
    } else {

    }
#line 643
    addr = (size_t )gma_crtc->cursor_addr;
  } else {
#line 645
    addr = (size_t )gt->offset;
#line 646
    gma_crtc->cursor_addr = (uint32_t )addr;
  }
#line 649
  temp = 0U;
#line 651
  temp = (uint32_t )(pipe << 28) | temp;
#line 652
  temp = temp | 67108903U;
#line 654
  tmp___2 = gma_power_begin(dev, 0);
#line 654
  if ((int )tmp___2) {
#line 655
    REGISTER_WRITE(dev, control, temp);
#line 656
    REGISTER_WRITE(dev, base, (uint32_t )addr);
#line 657
    gma_power_end(dev);
  } else {

  }
#line 661
  if ((unsigned long )gma_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
#line 662
    __mptr___2 = (struct drm_gem_object  const  *)gma_crtc->cursor_obj;
#line 662
    gt = (struct gtt_range *)__mptr___2 + 0xffffffffffffffc0UL;
#line 663
    psb_gtt_unpin(gt);
#line 664
    drm_gem_object_unreference(gma_crtc->cursor_obj);
  } else {

  }
#line 667
  gma_crtc->cursor_obj = obj;
  unlock: 
#line 669
  mutex_unlock(& dev->struct_mutex);
#line 670
  return (ret);
  unref_cursor: 
#line 673
  drm_gem_object_unreference(obj);
#line 674
  mutex_unlock(& dev->struct_mutex);
#line 675
  return (ret);
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int gma_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ 
  struct drm_device *dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t temp ;
  uint32_t addr ;
  bool tmp ;

  {
#line 680
  dev = crtc->dev;
#line 681
  __mptr = (struct drm_crtc  const  *)crtc;
#line 681
  gma_crtc = (struct gma_crtc *)__mptr;
#line 682
  pipe = gma_crtc->pipe;
#line 683
  temp = 0U;
#line 686
  if (x < 0) {
#line 687
    temp = temp | 32768U;
#line 688
    x = - x;
  } else {

  }
#line 690
  if (y < 0) {
#line 691
    temp = temp | 2147483648U;
#line 692
    y = - y;
  } else {

  }
#line 695
  temp = ((uint32_t )x & 2047U) | temp;
#line 696
  temp = (uint32_t )((y & 2047) << 16) | temp;
#line 698
  addr = gma_crtc->cursor_addr;
#line 700
  tmp = gma_power_begin(dev, 0);
#line 700
  if ((int )tmp) {
#line 701
    REGISTER_WRITE(dev, pipe == 0 ? 458888U : 458952U, temp);
#line 702
    REGISTER_WRITE(dev, pipe == 0 ? 458884U : 458948U, addr);
#line 703
    gma_power_end(dev);
  } else {

  }
#line 705
  return (0);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool gma_encoder_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                            struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 712
  return (1);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool gma_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                         struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 719
  return (1);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_prepare(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
#line 724
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 725
  (*(crtc_funcs->dpms))(crtc, 3);
#line 726
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_commit(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
#line 730
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 731
  (*(crtc_funcs->dpms))(crtc, 0);
#line 732
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_disable(struct drm_crtc *crtc ) 
{ 
  struct gtt_range *gt ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  struct drm_framebuffer  const  *__mptr ;

  {
#line 737
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 739
  (*(crtc_funcs->dpms))(crtc, 3);
#line 741
  if ((unsigned long )(crtc->primary)->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 742
    __mptr = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 742
    gt = ((struct psb_framebuffer *)__mptr)->gtt;
#line 743
    psb_gtt_unpin(gt);
  } else {

  }
#line 745
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 749
  __mptr = (struct drm_crtc  const  *)crtc;
#line 749
  gma_crtc = (struct gma_crtc *)__mptr;
#line 751
  kfree((void const   *)gma_crtc->crtc_state);
#line 752
  drm_crtc_cleanup(crtc);
#line 753
  kfree((void const   *)gma_crtc);
#line 754
  return;
}
}
#line 756 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
int gma_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  int tmp ;

  {
#line 758
  dev = (set->crtc)->dev;
#line 759
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 762
  if (dev_priv->rpm_enabled == 0) {
#line 763
    tmp = drm_crtc_helper_set_config(set);
#line 763
    return (tmp);
  } else {

  }
#line 765
  pm_runtime_forbid(& (dev->pdev)->dev);
#line 766
  ret = drm_crtc_helper_set_config(set);
#line 767
  pm_runtime_allow(& (dev->pdev)->dev);
#line 769
  return (ret);
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_save(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t palette_reg ;
  int i ;

  {
#line 777
  dev = crtc->dev;
#line 778
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 779
  __mptr = (struct drm_crtc  const  *)crtc;
#line 779
  gma_crtc = (struct gma_crtc *)__mptr;
#line 780
  crtc_state = gma_crtc->crtc_state;
#line 781
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 785
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 786
    dev_err((struct device  const  *)dev->dev, "No CRTC state found\n");
#line 787
    return;
  } else {

  }
#line 790
  crtc_state->saveDSPCNTR = REGISTER_READ(dev, map->cntr);
#line 791
  crtc_state->savePIPECONF = REGISTER_READ(dev, map->conf);
#line 792
  crtc_state->savePIPESRC = REGISTER_READ(dev, map->src);
#line 793
  crtc_state->saveFP0 = REGISTER_READ(dev, map->fp0);
#line 794
  crtc_state->saveFP1 = REGISTER_READ(dev, map->fp1);
#line 795
  crtc_state->saveDPLL = REGISTER_READ(dev, map->dpll);
#line 796
  crtc_state->saveHTOTAL = REGISTER_READ(dev, map->htotal);
#line 797
  crtc_state->saveHBLANK = REGISTER_READ(dev, map->hblank);
#line 798
  crtc_state->saveHSYNC = REGISTER_READ(dev, map->hsync);
#line 799
  crtc_state->saveVTOTAL = REGISTER_READ(dev, map->vtotal);
#line 800
  crtc_state->saveVBLANK = REGISTER_READ(dev, map->vblank);
#line 801
  crtc_state->saveVSYNC = REGISTER_READ(dev, map->vsync);
#line 802
  crtc_state->saveDSPSTRIDE = REGISTER_READ(dev, map->stride);
#line 805
  crtc_state->saveDSPSIZE = REGISTER_READ(dev, map->size);
#line 806
  crtc_state->saveDSPPOS = REGISTER_READ(dev, map->pos);
#line 808
  crtc_state->saveDSPBASE = REGISTER_READ(dev, map->base);
#line 810
  palette_reg = map->palette;
#line 811
  i = 0;
#line 811
  goto ldv_40047;
  ldv_40046: 
#line 812
  crtc_state->savePalette[i] = REGISTER_READ(dev, (uint32_t )(i << 2) + palette_reg);
#line 811
  i = i + 1;
  ldv_40047: ;
#line 811
  if (i <= 255) {
#line 813
    goto ldv_40046;
  } else {

  }

#line 818
  return;
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_crtc_restore(struct drm_crtc *crtc ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t palette_reg ;
  int i ;

  {
#line 820
  dev = crtc->dev;
#line 821
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 822
  __mptr = (struct drm_crtc  const  *)crtc;
#line 822
  gma_crtc = (struct gma_crtc *)__mptr;
#line 823
  crtc_state = gma_crtc->crtc_state;
#line 824
  map = dev_priv->regmap + (unsigned long )gma_crtc->pipe;
#line 828
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 829
    dev_err((struct device  const  *)dev->dev, "No crtc state\n");
#line 830
    return;
  } else {

  }
#line 833
  if ((int )crtc_state->saveDPLL < 0) {
#line 834
    REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL & 2147483647U);
#line 836
    REGISTER_READ(dev, map->dpll);
#line 837
    __const_udelay(644250UL);
  } else {

  }
#line 840
  REGISTER_WRITE(dev, map->fp0, crtc_state->saveFP0);
#line 841
  REGISTER_READ(dev, map->fp0);
#line 843
  REGISTER_WRITE(dev, map->fp1, crtc_state->saveFP1);
#line 844
  REGISTER_READ(dev, map->fp1);
#line 846
  REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL);
#line 847
  REGISTER_READ(dev, map->dpll);
#line 848
  __const_udelay(644250UL);
#line 850
  REGISTER_WRITE(dev, map->htotal, crtc_state->saveHTOTAL);
#line 851
  REGISTER_WRITE(dev, map->hblank, crtc_state->saveHBLANK);
#line 852
  REGISTER_WRITE(dev, map->hsync, crtc_state->saveHSYNC);
#line 853
  REGISTER_WRITE(dev, map->vtotal, crtc_state->saveVTOTAL);
#line 854
  REGISTER_WRITE(dev, map->vblank, crtc_state->saveVBLANK);
#line 855
  REGISTER_WRITE(dev, map->vsync, crtc_state->saveVSYNC);
#line 856
  REGISTER_WRITE(dev, map->stride, crtc_state->saveDSPSTRIDE);
#line 858
  REGISTER_WRITE(dev, map->size, crtc_state->saveDSPSIZE);
#line 859
  REGISTER_WRITE(dev, map->pos, crtc_state->saveDSPPOS);
#line 861
  REGISTER_WRITE(dev, map->src, crtc_state->savePIPESRC);
#line 862
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
#line 863
  REGISTER_WRITE(dev, map->conf, crtc_state->savePIPECONF);
#line 865
  gma_wait_for_vblank(dev);
#line 867
  REGISTER_WRITE(dev, map->cntr, crtc_state->saveDSPCNTR);
#line 868
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
#line 870
  gma_wait_for_vblank(dev);
#line 872
  palette_reg = map->palette;
#line 873
  i = 0;
#line 873
  goto ldv_40062;
  ldv_40061: 
#line 874
  REGISTER_WRITE(dev, (uint32_t )(i << 2) + palette_reg, crtc_state->savePalette[i]);
#line 873
  i = i + 1;
  ldv_40062: ;
#line 873
  if (i <= 255) {
#line 875
    goto ldv_40061;
  } else {

  }

#line 880
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_encoder_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder_helper_funcs *encoder_funcs ;

  {
#line 879
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
#line 882
  (*(encoder_funcs->dpms))(encoder, 3);
#line 883
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_encoder_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder_helper_funcs *encoder_funcs ;

  {
#line 887
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
#line 890
  (*(encoder_funcs->dpms))(encoder, 0);
#line 891
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
#line 895
  __mptr = (struct drm_encoder  const  *)encoder;
#line 895
  intel_encoder = (struct gma_encoder *)__mptr;
#line 897
  drm_encoder_cleanup(encoder);
#line 898
  kfree((void const   *)intel_encoder);
#line 899
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
struct drm_encoder *gma_best_encoder(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 904
  tmp = gma_attached_encoder(connector);
#line 904
  gma_encoder = tmp;
#line 906
  return (& gma_encoder->base);
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void gma_connector_attach_encoder(struct gma_connector *connector , struct gma_encoder *encoder ) 
{ 


  {
#line 912
  connector->encoder = encoder;
#line 913
  drm_mode_connector_attach_encoder(& connector->base, & encoder->base);
#line 915
  return;
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool gma_pll_is_valid(struct drm_crtc *crtc , struct gma_limit_t  const  *limit ,
                      struct gma_clock_t *clock ) 
{ 


  {
#line 923
  if (clock->p1 < (int )limit->p1.min || (int )limit->p1.max < clock->p1) {
#line 924
    return (0);
  } else {

  }
#line 925
  if (clock->p < (int )limit->p.min || (int )limit->p.max < clock->p) {
#line 926
    return (0);
  } else {

  }
#line 927
  if (clock->m2 < (int )limit->m2.min || (int )limit->m2.max < clock->m2) {
#line 928
    return (0);
  } else {

  }
#line 929
  if (clock->m1 < (int )limit->m1.min || (int )limit->m1.max < clock->m1) {
#line 930
    return (0);
  } else {

  }
#line 932
  if (clock->m1 <= clock->m2 && clock->m1 != 0) {
#line 933
    return (0);
  } else {

  }
#line 934
  if (clock->m < (int )limit->m.min || (int )limit->m.max < clock->m) {
#line 935
    return (0);
  } else {

  }
#line 936
  if (clock->n < (int )limit->n.min || (int )limit->n.max < clock->n) {
#line 937
    return (0);
  } else {

  }
#line 938
  if (clock->vco < (int )limit->vco.min || (int )limit->vco.max < clock->vco) {
#line 939
    return (0);
  } else {

  }
#line 944
  if (clock->dot < (int )limit->dot.min || (int )limit->dot.max < clock->dot) {
#line 945
    return (0);
  } else {

  }
#line 947
  return (1);
}
}
#line 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
bool gma_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                       int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct drm_device *dev ;
  struct gma_clock_funcs  const  *clock_funcs ;
  struct drm_crtc  const  *__mptr ;
  struct gma_clock_t clock ;
  int err ;
  uint32_t tmp ;
  bool tmp___0 ;
  uint32_t tmp___1 ;
  int this_err ;
  bool tmp___2 ;
  int tmp___3 ;
  long ret ;
  int __x___0 ;

  {
#line 954
  dev = crtc->dev;
#line 956
  __mptr = (struct drm_crtc  const  *)crtc;
#line 956
  clock_funcs = ((struct gma_crtc *)__mptr)->clock_funcs;
#line 958
  err = target;
#line 960
  tmp___0 = gma_pipe_has_type(crtc, 4);
#line 960
  if ((int )tmp___0) {
#line 960
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 960
    if ((int )tmp___1 < 0) {
#line 968
      tmp = REGISTER_READ(dev, 397696U);
#line 968
      if ((tmp & 48U) == 48U) {
#line 970
        clock.p2 = limit->p2.p2_fast;
      } else {
#line 972
        clock.p2 = limit->p2.p2_slow;
      }
    } else {
#line 960
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 974
  if ((int )limit->p2.dot_limit > target) {
#line 975
    clock.p2 = limit->p2.p2_slow;
  } else {
#line 977
    clock.p2 = limit->p2.p2_fast;
  }
#line 980
  memset((void *)best_clock, 0, 36UL);
#line 983
  clock.m1 = limit->m1.min;
#line 983
  goto ldv_40120;
  ldv_40119: 
#line 984
  clock.m2 = limit->m2.min;
#line 984
  goto ldv_40117;
  ldv_40116: 
#line 987
  clock.n = limit->n.min;
#line 987
  goto ldv_40114;
  ldv_40113: 
#line 989
  clock.p1 = limit->p1.min;
#line 989
  goto ldv_40111;
  ldv_40110: 
#line 994
  (*(clock_funcs->clock))(refclk, & clock);
#line 996
  tmp___2 = (*(clock_funcs->pll_is_valid))(crtc, limit, & clock);
#line 996
  if (tmp___2) {
#line 996
    tmp___3 = 0;
  } else {
#line 996
    tmp___3 = 1;
  }
#line 996
  if (tmp___3) {
#line 998
    goto ldv_40105;
  } else {

  }
#line 1000
  __x___0 = clock.dot - target;
#line 1000
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 1000
  this_err = (int )ret;
#line 1001
  if (this_err < err) {
#line 1002
    *best_clock = clock;
#line 1003
    err = this_err;
  } else {

  }
  ldv_40105: 
#line 991
  clock.p1 = clock.p1 + 1;
  ldv_40111: ;
#line 989
  if (clock.p1 <= (int )limit->p1.max) {
#line 992
    goto ldv_40110;
  } else {

  }
#line 988
  clock.n = clock.n + 1;
  ldv_40114: ;
#line 987
  if (clock.n <= (int )limit->n.max) {
#line 990
    goto ldv_40113;
  } else {

  }
#line 986
  clock.m2 = clock.m2 + 1;
  ldv_40117: ;
#line 984
  if ((clock.m2 < clock.m1 || clock.m1 == 0) && clock.m2 <= (int )limit->m2.max) {
#line 988
    goto ldv_40116;
  } else {

  }
#line 983
  clock.m1 = clock.m1 + 1;
  ldv_40120: ;
#line 983
  if (clock.m1 <= (int )limit->m1.max) {
#line 985
    goto ldv_40119;
  } else {

  }

#line 1010
  return (err != target);
}
}
#line 1140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_display.o.c.prepared"
void *ldv_kmem_cache_alloc_258(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1143
  ldv_check_alloc_flags(flags);
#line 1145
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1146
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_278(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void gma_get_core_freq(struct drm_device *dev ) 
{ 
  uint32_t clock ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  struct drm_psb_private *dev_priv ;

  {
#line 242
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 242
  pci_root = tmp;
#line 243
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 248
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3489989376U);
#line 249
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & clock);
#line 250
  pci_dev_put(pci_root);
#line 252
  switch (clock & 7U) {
  case 0U: 
#line 254
  dev_priv->core_freq = 100U;
#line 255
  goto ldv_39708;
  case 1U: 
#line 257
  dev_priv->core_freq = 133U;
#line 258
  goto ldv_39708;
  case 2U: 
#line 260
  dev_priv->core_freq = 150U;
#line 261
  goto ldv_39708;
  case 3U: 
#line 263
  dev_priv->core_freq = 178U;
#line 264
  goto ldv_39708;
  case 4U: 
#line 266
  dev_priv->core_freq = 200U;
#line 267
  goto ldv_39708;
  case 5U: ;
  case 6U: ;
  case 7U: 
#line 271
  dev_priv->core_freq = 266U;
#line 272
  goto ldv_39708;
  default: 
#line 274
  dev_priv->core_freq = 0U;
  }
  ldv_39708: ;
#line 277
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/gma_device.o.c.prepared"
void *ldv_kmem_cache_alloc_278(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 408
  ldv_check_alloc_flags(flags);
#line 410
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 411
  return ((void *)0);
}
}
#line 396 "./arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
#line 410
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 423
  return (r + 1);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_298(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 208 "include/drm/drm_modes.h"
extern void drm_mode_set_crtcinfo(struct drm_display_mode * , int  ) ;
#line 857 "include/drm/drm_crtc.h"
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
#line 1017
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
#line 144 "include/drm/drm_crtc_helper.h"
__inline static void drm_crtc_helper_add(struct drm_crtc *crtc , struct drm_crtc_helper_funcs  const  *funcs ) 
{ 


  {
#line 147
  crtc->helper_private = (void *)funcs;
#line 148
  return;
}
}
#line 239 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 241
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) ;
#line 732 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs ;
#line 733
struct drm_crtc_funcs  const  psb_intel_crtc_funcs ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static struct gma_limit_t  const  psb_intel_limits[2U]  = {      {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {8, 18}, {3, 7}, {5,
                                                                                80},
      {1, 8}, {200000, 10, 5}, & gma_find_best_pll}, 
        {{20000, 400000}, {1400000, 2800000}, {1, 6}, {70, 120}, {8, 18}, {3, 7}, {7,
                                                                                98},
      {1, 8}, {112000, 14, 7}, & gma_find_best_pll}};
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static struct gma_limit_t  const  *psb_intel_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  bool tmp ;

  {
#line 289
  tmp = gma_pipe_has_type(crtc, 4);
#line 289
  if ((int )tmp) {
#line 290
    limit = (struct gma_limit_t  const  *)(& psb_intel_limits) + 1UL;
  } else {
#line 292
    limit = (struct gma_limit_t  const  *)(& psb_intel_limits);
  }
#line 293
  return (limit);
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static void psb_intel_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 298
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
#line 299
  clock->p = clock->p1 * clock->p2;
#line 300
  clock->vco = (clock->m * refclk) / (clock->n + 2);
#line 301
  clock->dot = clock->vco / clock->p;
#line 302
  return;
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static int psb_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 312
  pfit_control = REGISTER_READ(dev, 397872U);
#line 315
  if ((int )pfit_control >= 0) {
#line 316
    return (-1);
  } else {

  }
#line 318
  return (1);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static int psb_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_tv ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct gma_limit_t  const  *limit ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  int sdvo_pixel_multiply ;
  int tmp___0 ;
  u32 lvds ;
  uint32_t tmp___1 ;

  {
#line 327
  dev = crtc->dev;
#line 328
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 329
  __mptr = (struct drm_crtc  const  *)crtc;
#line 329
  gma_crtc = (struct gma_crtc *)__mptr;
#line 330
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 331
  pipe = gma_crtc->pipe;
#line 332
  map = dev_priv->regmap + (unsigned long )pipe;
#line 335
  dpll = 0U;
#line 335
  fp = 0U;
#line 336
  is_sdvo = 0;
#line 337
  is_lvds = 0;
#line 337
  is_tv = 0;
#line 338
  mode_config = & dev->mode_config;
#line 343
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 344
    (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 345
    return (0);
  } else {

  }
#line 348
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 348
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 348
  goto ldv_39893;
  ldv_39892: 
#line 349
  tmp = gma_attached_encoder(connector);
#line 349
  gma_encoder = tmp;
#line 351
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 353
    goto ldv_39887;
  } else {

  }
#line 355
  switch (gma_encoder->type) {
  case 4: 
#line 357
  is_lvds = 1;
#line 358
  goto ldv_39889;
  case 3: 
#line 360
  is_sdvo = 1;
#line 361
  goto ldv_39889;
  case 5: 
#line 363
  is_tv = 1;
#line 364
  goto ldv_39889;
  }
  ldv_39889: ;
  ldv_39887: 
#line 348
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 348
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_39893: ;
#line 348
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 350
    goto ldv_39892;
  } else {

  }
#line 368
  refclk = 96000;
#line 370
  limit = (*((gma_crtc->clock_funcs)->limit))(crtc, refclk);
#line 372
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 374
  if (! ok) {
#line 375
    drm_err("psb_intel_crtc_mode_set", "Couldn\'t find PLL settings for mode! target: %d, actual: %d",
            adjusted_mode->clock, clock.dot);
#line 377
    return (0);
  } else {

  }
#line 380
  fp = (u32 )(((clock.n << 16) | (clock.m1 << 8)) | clock.m2);
#line 382
  dpll = 268435456U;
#line 383
  if ((int )is_lvds) {
#line 384
    dpll = dpll | 134217728U;
#line 385
    dpll = dpll | 1073741824U;
  } else {
#line 387
    dpll = dpll | 67108864U;
  }
#line 388
  if ((int )is_sdvo) {
#line 389
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 391
    dpll = dpll | 1073741824U;
#line 392
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
#line 397
  dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
#line 398
  switch (clock.p2) {
  case 5: 
#line 400
  dpll = dpll | 16777216U;
#line 401
  goto ldv_39898;
  case 7: 
#line 403
  dpll = dpll | 16777216U;
#line 404
  goto ldv_39898;
  case 10: 
#line 406
  dpll = dpll;
#line 407
  goto ldv_39898;
  case 14: 
#line 409
  dpll = dpll;
#line 410
  goto ldv_39898;
  }
  ldv_39898: ;
#line 413
  if ((int )is_tv) {
#line 416
    dpll = dpll | 3U;
  } else {

  }
#line 418
  dpll = dpll;
#line 421
  pipeconf = REGISTER_READ(dev, map->conf);
#line 424
  dspcntr = 1073741824U;
#line 426
  if (pipe == 0) {
#line 427
    dspcntr = dspcntr;
  } else {
#line 429
    dspcntr = dspcntr | 16777216U;
  }
#line 431
  dspcntr = dspcntr | 2147483648U;
#line 432
  pipeconf = pipeconf | 2147483648U;
#line 433
  dpll = dpll | 2147483648U;
#line 437
  tmp___0 = psb_intel_panel_fitter_pipe(dev);
#line 437
  if (tmp___0 == pipe) {
#line 438
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 440
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
#line 442
  if ((int )dpll < 0) {
#line 443
    REGISTER_WRITE(dev, map->fp0, fp);
#line 444
    REGISTER_WRITE(dev, map->dpll, dpll & 2147483647U);
#line 445
    REGISTER_READ(dev, map->dpll);
#line 446
    __const_udelay(644250UL);
  } else {

  }
#line 453
  if ((int )is_lvds) {
#line 454
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 454
    lvds = tmp___1;
#line 456
    lvds = lvds & 3221225471U;
#line 457
    if (pipe == 1) {
#line 458
      lvds = lvds | 1073741824U;
    } else {

    }
#line 460
    lvds = lvds | 2147484416U;
#line 465
    lvds = lvds & 4294967235U;
#line 466
    if (clock.p2 == 7) {
#line 467
      lvds = lvds | 60U;
    } else {

    }
#line 474
    REGISTER_WRITE(dev, 397696U, lvds);
#line 475
    REGISTER_READ(dev, 397696U);
  } else {

  }
#line 478
  REGISTER_WRITE(dev, map->fp0, fp);
#line 479
  REGISTER_WRITE(dev, map->dpll, dpll);
#line 480
  REGISTER_READ(dev, map->dpll);
#line 482
  __const_udelay(644250UL);
#line 485
  REGISTER_WRITE(dev, map->dpll, dpll);
#line 487
  REGISTER_READ(dev, map->dpll);
#line 489
  __const_udelay(644250UL);
#line 491
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 493
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 495
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 497
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 499
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 501
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 506
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 508
  REGISTER_WRITE(dev, map->pos, 0U);
#line 509
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
#line 511
  REGISTER_WRITE(dev, map->conf, pipeconf);
#line 512
  REGISTER_READ(dev, map->conf);
#line 514
  gma_wait_for_vblank(dev);
#line 516
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 519
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 521
  gma_wait_for_vblank(dev);
#line 523
  return (0);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static int psb_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct gma_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 530
  __mptr = (struct drm_crtc  const  *)crtc;
#line 530
  gma_crtc = (struct gma_crtc *)__mptr;
#line 531
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 532
  pipe = gma_crtc->pipe;
#line 533
  map = dev_priv->regmap + (unsigned long )pipe;
#line 538
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 540
  tmp___1 = gma_power_begin(dev, 0);
#line 540
  if ((int )tmp___1) {
#line 541
    dpll = REGISTER_READ(dev, map->dpll);
#line 542
    if ((dpll & 256U) == 0U) {
#line 543
      fp = REGISTER_READ(dev, map->fp0);
    } else {
#line 545
      fp = REGISTER_READ(dev, map->fp1);
    }
#line 546
    if (pipe == 1) {
#line 546
      tmp = REGISTER_READ(dev, 397696U);
#line 546
      if ((int )tmp < 0) {
#line 546
        tmp___0 = 1;
      } else {
#line 546
        tmp___0 = 0;
      }
    } else {
#line 546
      tmp___0 = 0;
    }
#line 546
    is_lvds = (bool )tmp___0;
#line 547
    gma_power_end(dev);
  } else {
#line 549
    dpll = p->dpll;
#line 551
    if ((dpll & 256U) == 0U) {
#line 552
      fp = p->fp0;
    } else {
#line 554
      fp = p->fp1;
    }
#line 556
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.ldv_40416.psb.saveLVDS < 0);
  }
#line 560
  clock.m1 = (int )((fp & 16128U) >> 8);
#line 561
  clock.m2 = (int )fp & 63;
#line 562
  clock.n = (int )((fp & 4128768U) >> 16);
#line 564
  if ((int )is_lvds) {
#line 565
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
#line 569
    clock.p2 = 14;
#line 571
    if ((dpll & 24576U) == 24576U) {
#line 574
      psb_intel_clock(66000, & clock);
    } else {
#line 576
      psb_intel_clock(48000, & clock);
    }
  } else {
#line 578
    if ((dpll & 2097152U) != 0U) {
#line 579
      clock.p1 = 2;
    } else {
#line 581
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
#line 586
    if ((dpll & 8388608U) != 0U) {
#line 587
      clock.p2 = 4;
    } else {
#line 589
      clock.p2 = 2;
    }
#line 591
    psb_intel_clock(48000, & clock);
  }
#line 599
  return (clock.dot);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
#line 606
  __mptr = (struct drm_crtc  const  *)crtc;
#line 606
  gma_crtc = (struct gma_crtc *)__mptr;
#line 607
  pipe = gma_crtc->pipe;
#line 613
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 614
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 615
  map = dev_priv->regmap + (unsigned long )pipe;
#line 617
  tmp___3 = gma_power_begin(dev, 0);
#line 617
  if ((int )tmp___3) {
#line 618
    tmp = REGISTER_READ(dev, map->htotal);
#line 618
    htot = (int )tmp;
#line 619
    tmp___0 = REGISTER_READ(dev, map->hsync);
#line 619
    hsync = (int )tmp___0;
#line 620
    tmp___1 = REGISTER_READ(dev, map->vtotal);
#line 620
    vtot = (int )tmp___1;
#line 621
    tmp___2 = REGISTER_READ(dev, map->vsync);
#line 621
    vsync = (int )tmp___2;
#line 622
    gma_power_end(dev);
  } else {
#line 624
    htot = (int )p->htotal;
#line 625
    hsync = (int )p->hsync;
#line 626
    vtot = (int )p->vtotal;
#line 627
    vsync = (int )p->vsync;
  }
#line 630
  tmp___4 = kzalloc(208UL, 208U);
#line 630
  mode = (struct drm_display_mode *)tmp___4;
#line 631
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 632
    return ((struct drm_display_mode *)0);
  } else {

  }
#line 634
  mode->clock = psb_intel_crtc_clock_get(dev, crtc);
#line 635
  mode->hdisplay = (htot & 65535) + 1;
#line 636
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
#line 637
  mode->hsync_start = (hsync & 65535) + 1;
#line 638
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
#line 639
  mode->vdisplay = (vtot & 65535) + 1;
#line 640
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
#line 641
  mode->vsync_start = (vsync & 65535) + 1;
#line 642
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
#line 644
  drm_mode_set_name(mode);
#line 645
  drm_mode_set_crtcinfo(mode, 0);
#line 647
  return (mode);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs  = 
#line 650
     {& gma_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & psb_intel_crtc_mode_set, & gma_pipe_set_base, 0, 0, & gma_crtc_disable};
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
struct drm_crtc_funcs  const  psb_intel_crtc_funcs  = 
#line 660
     {& gma_crtc_save, & gma_crtc_restore, 0, & gma_crtc_cursor_set, 0, & gma_crtc_cursor_move,
    & gma_crtc_gamma_set, & gma_crtc_destroy, & gma_crtc_set_config, 0, 0};
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
struct gma_clock_funcs  const  psb_clock_funcs  =    {& psb_intel_clock, & psb_intel_limit, & gma_pll_is_valid};
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
static void psb_intel_cursor_init(struct drm_device *dev , struct gma_crtc *gma_crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 control[3U] ;
  u32 base[3U] ;
  struct gtt_range *cursor_gt ;

  {
#line 683
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 684
  control[0] = 458880U;
#line 684
  control[1] = 458944U;
#line 684
  control[2] = 458976U;
#line 685
  base[0] = 458884U;
#line 685
  base[1] = 458948U;
#line 685
  base[2] = 458980U;
#line 688
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
#line 692
    cursor_gt = psb_gtt_alloc_range(dev, 16384, "cursor", 1, 4096U);
#line 694
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
#line 695
      gma_crtc->cursor_gt = (struct gtt_range *)0;
#line 696
      goto out;
    } else {

    }
#line 698
    gma_crtc->cursor_gt = cursor_gt;
#line 699
    gma_crtc->cursor_addr = dev_priv->stolen_base + cursor_gt->offset;
  } else {
#line 702
    gma_crtc->cursor_gt = (struct gtt_range *)0;
  }
  out: 
#line 706
  REGISTER_WRITE(dev, control[gma_crtc->pipe], 0U);
#line 707
  REGISTER_WRITE(dev, base[gma_crtc->pipe], 0U);
#line 708
  return;
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  int i ;
  uint16_t *r_base ;
  uint16_t *g_base ;
  uint16_t *b_base ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 713
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 720
  tmp = kzalloc(2640UL, 208U);
#line 720
  gma_crtc = (struct gma_crtc *)tmp;
#line 723
  if ((unsigned long )gma_crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 724
    return;
  } else {

  }
#line 726
  tmp___0 = kzalloc(1088UL, 208U);
#line 726
  gma_crtc->crtc_state = (struct psb_intel_crtc_state *)tmp___0;
#line 728
  if ((unsigned long )gma_crtc->crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
#line 729
    dev_err((struct device  const  *)dev->dev, "Crtc state error: No memory\n");
#line 730
    kfree((void const   *)gma_crtc);
#line 731
    return;
  } else {

  }
#line 735
  drm_crtc_init(dev, & gma_crtc->base, (dev_priv->ops)->crtc_funcs);
#line 738
  gma_crtc->clock_funcs = (dev_priv->ops)->clock_funcs;
#line 740
  drm_mode_crtc_set_gamma_size(& gma_crtc->base, 256);
#line 741
  gma_crtc->pipe = pipe;
#line 742
  gma_crtc->plane = pipe;
#line 744
  r_base = gma_crtc->base.gamma_store;
#line 745
  g_base = r_base + 256UL;
#line 746
  b_base = g_base + 256UL;
#line 747
  i = 0;
#line 747
  goto ldv_39958;
  ldv_39957: 
#line 748
  gma_crtc->lut_r[i] = (u8 )i;
#line 749
  gma_crtc->lut_g[i] = (u8 )i;
#line 750
  gma_crtc->lut_b[i] = (u8 )i;
#line 751
  *(r_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 752
  *(g_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 753
  *(b_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
#line 755
  gma_crtc->lut_adj[i] = 0U;
#line 747
  i = i + 1;
  ldv_39958: ;
#line 747
  if (i <= 255) {
#line 749
    goto ldv_39957;
  } else {

  }
#line 758
  gma_crtc->mode_dev = mode_dev;
#line 759
  gma_crtc->cursor_addr = 0U;
#line 761
  drm_crtc_helper_add(& gma_crtc->base, (dev_priv->ops)->crtc_helper);
#line 765
  gma_crtc->mode_set.crtc = & gma_crtc->base;
#line 766
  tmp___1 = ldv__builtin_expect((unsigned int )pipe > 2U, 0L);
#line 766
  if (tmp___1 != 0L) {
#line 766
    goto _L;
  } else {
#line 766
    tmp___2 = ldv__builtin_expect((unsigned long )dev_priv->plane_to_crtc_mapping[gma_crtc->plane] != (unsigned long )((struct drm_crtc *)0),
                               0L);
#line 766
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 766
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"),
                           "i" (767), "i" (12UL));
      ldv_39962: ;
#line 766
      goto ldv_39962;
    } else {

    }
  }
#line 768
  dev_priv->plane_to_crtc_mapping[gma_crtc->plane] = & gma_crtc->base;
#line 769
  dev_priv->pipe_to_crtc_mapping[gma_crtc->pipe] = & gma_crtc->base;
#line 770
  gma_crtc->mode_set.connectors = (struct drm_connector **)gma_crtc + 1U;
#line 771
  gma_crtc->mode_set.num_connectors = 0UL;
#line 772
  psb_intel_cursor_init(dev, gma_crtc);
#line 775
  gma_crtc->active = 1;
#line 776
  return;
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) 
{ 
  struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 780
  crtc = (struct drm_crtc *)0;
#line 782
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 782
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 782
  goto ldv_39977;
  ldv_39976: 
#line 783
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 783
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 784
  if (gma_crtc->pipe == pipe) {
#line 785
    goto ldv_39975;
  } else {

  }
#line 782
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 782
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39977: ;
#line 782
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 784
    goto ldv_39976;
  } else {

  }
  ldv_39975: ;
#line 787
  return (crtc);
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
int gma_connector_clones(struct drm_device *dev , int type_mask ) 
{ 
  int index_mask ;
  struct drm_connector *connector ;
  int entry ;
  struct list_head  const  *__mptr ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 792
  index_mask = 0;
#line 794
  entry = 0;
#line 796
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 796
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 796
  goto ldv_39991;
  ldv_39990: 
#line 798
  tmp = gma_attached_encoder(connector);
#line 798
  gma_encoder = tmp;
#line 799
  if ((type_mask >> gma_encoder->type) & 1) {
#line 800
    index_mask = (1 << entry) | index_mask;
  } else {

  }
#line 801
  entry = entry + 1;
#line 796
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 796
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_39991: ;
#line 796
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 798
    goto ldv_39990;
  } else {

  }

#line 803
  return (index_mask);
}
}
#line 806
extern int ldv_release_44(void) ;
#line 807
extern int ldv_bind_44(void) ;
#line 808
extern int ldv_connect_44(void) ;
#line 809
extern int ldv_probe_43(void) ;
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_gma_clock_funcs_42(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 813
  tmp = ldv_zalloc(1048UL);
#line 813
  psb_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 814
  tmp___0 = ldv_zalloc(36UL);
#line 814
  psb_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 815
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_funcs_43(void) 
{ 
  void *tmp ;

  {
#line 818
  tmp = ldv_zalloc(1048UL);
#line 818
  psb_intel_crtc_funcs_group0 = (struct drm_crtc *)tmp;
#line 819
  return;
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_44(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 822
  tmp = ldv_zalloc(136UL);
#line 822
  psb_intel_helper_funcs_group0 = (struct drm_framebuffer *)tmp;
#line 823
  tmp___0 = ldv_zalloc(1048UL);
#line 823
  psb_intel_helper_funcs_group1 = (struct drm_crtc *)tmp___0;
#line 824
  tmp___1 = ldv_zalloc(208UL);
#line 824
  psb_intel_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 825
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_42(void) 
{ 
  int ldvarg103 ;
  int tmp ;
  struct gma_limit_t *ldvarg105 ;
  void *tmp___0 ;
  int ldvarg104 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 828
  tmp = __VERIFIER_nondet_int();
#line 828
  ldvarg103 = tmp;
#line 829
  tmp___0 = ldv_zalloc(88UL);
#line 829
  ldvarg105 = (struct gma_limit_t *)tmp___0;
#line 830
  tmp___1 = __VERIFIER_nondet_int();
#line 830
  ldvarg104 = tmp___1;
#line 832
  tmp___2 = __VERIFIER_nondet_int();
#line 832
  switch (tmp___2) {
  case 0: ;
#line 835
  if (ldv_state_variable_42 == 1) {
#line 837
    gma_pll_is_valid(psb_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg105,
                     psb_clock_funcs_group1);
#line 839
    ldv_state_variable_42 = 1;
  } else {

  }
#line 842
  goto ldv_40017;
  case 1: ;
#line 845
  if (ldv_state_variable_42 == 1) {
#line 847
    psb_intel_clock(ldvarg104, psb_clock_funcs_group1);
#line 849
    ldv_state_variable_42 = 1;
  } else {

  }
#line 852
  goto ldv_40017;
  case 2: ;
#line 855
  if (ldv_state_variable_42 == 1) {
#line 857
    psb_intel_limit(psb_clock_funcs_group0, ldvarg103);
#line 859
    ldv_state_variable_42 = 1;
  } else {

  }
#line 862
  goto ldv_40017;
  default: 
#line 863
  ldv_stop();
  }
  ldv_40017: ;
#line 867
  return;
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_43(void) 
{ 
  struct drm_file *ldvarg192 ;
  void *tmp ;
  u16 *ldvarg188 ;
  void *tmp___0 ;
  uint32_t ldvarg185 ;
  uint32_t ldvarg193 ;
  uint32_t ldvarg189 ;
  uint32_t ldvarg190 ;
  struct drm_mode_set *ldvarg184 ;
  void *tmp___1 ;
  u16 *ldvarg186 ;
  void *tmp___2 ;
  int ldvarg194 ;
  int tmp___3 ;
  u16 *ldvarg187 ;
  void *tmp___4 ;
  int ldvarg195 ;
  int tmp___5 ;
  uint32_t ldvarg191 ;
  int tmp___6 ;

  {
#line 870
  tmp = ldv_zalloc(744UL);
#line 870
  ldvarg192 = (struct drm_file *)tmp;
#line 871
  tmp___0 = ldv_zalloc(2UL);
#line 871
  ldvarg188 = (u16 *)tmp___0;
#line 876
  tmp___1 = ldv_zalloc(48UL);
#line 876
  ldvarg184 = (struct drm_mode_set *)tmp___1;
#line 877
  tmp___2 = ldv_zalloc(2UL);
#line 877
  ldvarg186 = (u16 *)tmp___2;
#line 878
  tmp___3 = __VERIFIER_nondet_int();
#line 878
  ldvarg194 = tmp___3;
#line 879
  tmp___4 = ldv_zalloc(2UL);
#line 879
  ldvarg187 = (u16 *)tmp___4;
#line 880
  tmp___5 = __VERIFIER_nondet_int();
#line 880
  ldvarg195 = tmp___5;
#line 872
  memset((void *)(& ldvarg185), 0, 4UL);
#line 873
  memset((void *)(& ldvarg193), 0, 4UL);
#line 874
  memset((void *)(& ldvarg189), 0, 4UL);
#line 875
  memset((void *)(& ldvarg190), 0, 4UL);
#line 881
  memset((void *)(& ldvarg191), 0, 4UL);
#line 883
  tmp___6 = __VERIFIER_nondet_int();
#line 883
  switch (tmp___6) {
  case 0: ;
#line 886
  if (ldv_state_variable_43 == 2) {
#line 888
    gma_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg195, ldvarg194);
#line 890
    ldv_state_variable_43 = 2;
  } else {

  }
#line 893
  if (ldv_state_variable_43 == 1) {
#line 895
    gma_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg195, ldvarg194);
#line 897
    ldv_state_variable_43 = 1;
  } else {

  }
#line 900
  goto ldv_40037;
  case 1: ;
#line 903
  if (ldv_state_variable_43 == 2) {
#line 905
    gma_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg192, ldvarg191, ldvarg190,
                        ldvarg193);
#line 907
    ldv_state_variable_43 = 2;
  } else {

  }
#line 910
  if (ldv_state_variable_43 == 1) {
#line 912
    gma_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg192, ldvarg191, ldvarg190,
                        ldvarg193);
#line 914
    ldv_state_variable_43 = 1;
  } else {

  }
#line 917
  goto ldv_40037;
  case 2: ;
#line 920
  if (ldv_state_variable_43 == 2) {
#line 922
    gma_crtc_destroy(psb_intel_crtc_funcs_group0);
#line 924
    ldv_state_variable_43 = 1;
#line 925
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 928
  goto ldv_40037;
  case 3: ;
#line 931
  if (ldv_state_variable_43 == 2) {
#line 933
    gma_crtc_save(psb_intel_crtc_funcs_group0);
#line 935
    ldv_state_variable_43 = 2;
  } else {

  }
#line 938
  if (ldv_state_variable_43 == 1) {
#line 940
    gma_crtc_save(psb_intel_crtc_funcs_group0);
#line 942
    ldv_state_variable_43 = 1;
  } else {

  }
#line 945
  goto ldv_40037;
  case 4: ;
#line 948
  if (ldv_state_variable_43 == 2) {
#line 950
    gma_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg188, ldvarg187, ldvarg186,
                       ldvarg189, ldvarg185);
#line 952
    ldv_state_variable_43 = 2;
  } else {

  }
#line 955
  if (ldv_state_variable_43 == 1) {
#line 957
    gma_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg188, ldvarg187, ldvarg186,
                       ldvarg189, ldvarg185);
#line 959
    ldv_state_variable_43 = 1;
  } else {

  }
#line 962
  goto ldv_40037;
  case 5: ;
#line 965
  if (ldv_state_variable_43 == 2) {
#line 967
    gma_crtc_restore(psb_intel_crtc_funcs_group0);
#line 969
    ldv_state_variable_43 = 2;
  } else {

  }
#line 972
  if (ldv_state_variable_43 == 1) {
#line 974
    gma_crtc_restore(psb_intel_crtc_funcs_group0);
#line 976
    ldv_state_variable_43 = 1;
  } else {

  }
#line 979
  goto ldv_40037;
  case 6: ;
#line 982
  if (ldv_state_variable_43 == 2) {
#line 984
    gma_crtc_set_config(ldvarg184);
#line 986
    ldv_state_variable_43 = 2;
  } else {

  }
#line 989
  if (ldv_state_variable_43 == 1) {
#line 991
    gma_crtc_set_config(ldvarg184);
#line 993
    ldv_state_variable_43 = 1;
  } else {

  }
#line 996
  goto ldv_40037;
  case 7: ;
#line 999
  if (ldv_state_variable_43 == 1) {
#line 1001
    ldv_probe_43();
#line 1003
    ldv_state_variable_43 = 2;
#line 1004
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1007
  goto ldv_40037;
  default: 
#line 1008
  ldv_stop();
  }
  ldv_40037: ;
#line 1012
  return;
}
}
#line 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void ldv_main_exported_44(void) 
{ 
  int ldvarg19 ;
  int tmp ;
  int ldvarg22 ;
  int tmp___0 ;
  int ldvarg23 ;
  int tmp___1 ;
  int ldvarg17 ;
  int tmp___2 ;
  struct drm_display_mode *ldvarg20 ;
  void *tmp___3 ;
  struct drm_display_mode *ldvarg18 ;
  void *tmp___4 ;
  int ldvarg21 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1015
  tmp = __VERIFIER_nondet_int();
#line 1015
  ldvarg19 = tmp;
#line 1016
  tmp___0 = __VERIFIER_nondet_int();
#line 1016
  ldvarg22 = tmp___0;
#line 1017
  tmp___1 = __VERIFIER_nondet_int();
#line 1017
  ldvarg23 = tmp___1;
#line 1018
  tmp___2 = __VERIFIER_nondet_int();
#line 1018
  ldvarg17 = tmp___2;
#line 1019
  tmp___3 = ldv_zalloc(208UL);
#line 1019
  ldvarg20 = (struct drm_display_mode *)tmp___3;
#line 1020
  tmp___4 = ldv_zalloc(208UL);
#line 1020
  ldvarg18 = (struct drm_display_mode *)tmp___4;
#line 1021
  tmp___5 = __VERIFIER_nondet_int();
#line 1021
  ldvarg21 = tmp___5;
#line 1023
  tmp___6 = __VERIFIER_nondet_int();
#line 1023
  switch (tmp___6) {
  case 0: ;
#line 1026
  if (ldv_state_variable_44 == 1) {
#line 1028
    gma_pipe_set_base(psb_intel_helper_funcs_group1, ldvarg23, ldvarg22, psb_intel_helper_funcs_group0);
#line 1030
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1033
  if (ldv_state_variable_44 == 3) {
#line 1035
    gma_pipe_set_base(psb_intel_helper_funcs_group1, ldvarg23, ldvarg22, psb_intel_helper_funcs_group0);
#line 1037
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1040
  if (ldv_state_variable_44 == 2) {
#line 1042
    gma_pipe_set_base(psb_intel_helper_funcs_group1, ldvarg23, ldvarg22, psb_intel_helper_funcs_group0);
#line 1044
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1047
  goto ldv_40057;
  case 1: ;
#line 1050
  if (ldv_state_variable_44 == 1) {
#line 1052
    gma_crtc_dpms(psb_intel_helper_funcs_group1, ldvarg21);
#line 1054
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1057
  if (ldv_state_variable_44 == 3) {
#line 1059
    gma_crtc_dpms(psb_intel_helper_funcs_group1, ldvarg21);
#line 1061
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1064
  if (ldv_state_variable_44 == 2) {
#line 1066
    gma_crtc_dpms(psb_intel_helper_funcs_group1, ldvarg21);
#line 1068
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1071
  goto ldv_40057;
  case 2: ;
#line 1074
  if (ldv_state_variable_44 == 1) {
#line 1076
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg20,
                        psb_intel_helper_funcs_group2);
#line 1078
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1081
  if (ldv_state_variable_44 == 3) {
#line 1083
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg20,
                        psb_intel_helper_funcs_group2);
#line 1085
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1088
  if (ldv_state_variable_44 == 2) {
#line 1090
    gma_crtc_mode_fixup(psb_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg20,
                        psb_intel_helper_funcs_group2);
#line 1092
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1095
  goto ldv_40057;
  case 3: ;
#line 1098
  if (ldv_state_variable_44 == 1) {
#line 1100
    gma_crtc_commit(psb_intel_helper_funcs_group1);
#line 1102
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1105
  if (ldv_state_variable_44 == 3) {
#line 1107
    gma_crtc_commit(psb_intel_helper_funcs_group1);
#line 1109
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1112
  if (ldv_state_variable_44 == 2) {
#line 1114
    gma_crtc_commit(psb_intel_helper_funcs_group1);
#line 1116
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1119
  goto ldv_40057;
  case 4: ;
#line 1122
  if (ldv_state_variable_44 == 1) {
#line 1124
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group1, psb_intel_helper_funcs_group2,
                            ldvarg18, ldvarg17, ldvarg19, psb_intel_helper_funcs_group0);
#line 1126
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1129
  if (ldv_state_variable_44 == 3) {
#line 1131
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group1, psb_intel_helper_funcs_group2,
                            ldvarg18, ldvarg17, ldvarg19, psb_intel_helper_funcs_group0);
#line 1133
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1136
  if (ldv_state_variable_44 == 2) {
#line 1138
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group1, psb_intel_helper_funcs_group2,
                            ldvarg18, ldvarg17, ldvarg19, psb_intel_helper_funcs_group0);
#line 1140
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1143
  goto ldv_40057;
  case 5: ;
#line 1146
  if (ldv_state_variable_44 == 3) {
#line 1148
    gma_crtc_disable(psb_intel_helper_funcs_group1);
#line 1149
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1152
  goto ldv_40057;
  case 6: ;
#line 1155
  if (ldv_state_variable_44 == 1) {
#line 1157
    gma_crtc_prepare(psb_intel_helper_funcs_group1);
#line 1159
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1162
  if (ldv_state_variable_44 == 3) {
#line 1164
    gma_crtc_prepare(psb_intel_helper_funcs_group1);
#line 1166
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1169
  if (ldv_state_variable_44 == 2) {
#line 1171
    gma_crtc_prepare(psb_intel_helper_funcs_group1);
#line 1173
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1176
  goto ldv_40057;
  case 7: ;
#line 1179
  if (ldv_state_variable_44 == 2) {
#line 1181
    ldv_release_44();
#line 1182
    ldv_state_variable_44 = 1;
#line 1183
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1186
  goto ldv_40057;
  case 8: ;
#line 1189
  if (ldv_state_variable_44 == 1) {
#line 1191
    ldv_bind_44();
#line 1192
    ldv_state_variable_44 = 2;
#line 1193
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1196
  goto ldv_40057;
  case 9: ;
#line 1199
  if (ldv_state_variable_44 == 2) {
#line 1201
    ldv_connect_44();
#line 1202
    ldv_state_variable_44 = 3;
  } else {

  }
#line 1205
  goto ldv_40057;
  default: 
#line 1206
  ldv_stop();
  }
  ldv_40057: ;
#line 1210
  return;
}
}
#line 1338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_display.o.c.prepared"
void *ldv_kmem_cache_alloc_298(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1341
  ldv_check_alloc_flags(flags);
#line 1343
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1344
  return ((void *)0);
}
}
#line 64 "./arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_318(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 1033 "include/linux/device.h"
extern int dev_printk(char const   * , struct device  const  * , char const   *  , ...) ;
#line 1048
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 67 "include/linux/i2c.h"
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int  ) ;
#line 182 "include/drm/drm_modes.h"
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
#line 212
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
#line 877 "include/drm/drm_crtc.h"
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
#line 882
extern void drm_connector_cleanup(struct drm_connector * ) ;
#line 890
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
#line 968
extern int drm_object_property_set_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t  ) ;
#line 971
extern int drm_object_property_get_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t * ) ;
#line 985
extern void drm_object_attach_property(struct drm_mode_object * , struct drm_property * ,
                                       uint64_t  ) ;
#line 1518 "include/drm/drmP.h"
extern int drm_sysfs_connector_add(struct drm_connector * ) ;
#line 1519
extern void drm_sysfs_connector_remove(struct drm_connector * ) ;
#line 130 "include/drm/drm_crtc_helper.h"
extern bool drm_crtc_helper_set_mode(struct drm_crtc * , struct drm_display_mode * ,
                                     int  , int  , struct drm_framebuffer * ) ;
#line 137
extern void drm_helper_connector_dpms(struct drm_connector * , int  ) ;
#line 150 "include/drm/drm_crtc_helper.h"
__inline static void drm_encoder_helper_add(struct drm_encoder *encoder , struct drm_encoder_helper_funcs  const  *funcs ) 
{ 


  {
#line 153
  encoder->helper_private = (void *)funcs;
#line 154
  return;
}
}
#line 156 "include/drm/drm_crtc_helper.h"
__inline static void drm_connector_helper_add(struct drm_connector *connector , struct drm_connector_helper_funcs  const  *funcs ) 
{ 


  {
#line 159
  connector->helper_private = (void *)funcs;
#line 160
  return;
}
}
#line 165
extern int drm_helper_probe_single_connector_modes(struct drm_connector * , uint32_t  ,
                                                   uint32_t  ) ;
#line 208 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) ;
#line 218
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 220
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) ;
#line 251
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) ;
#line 254
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) ;
#line 256
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) ;
#line 259
void psb_intel_lvds_destroy(struct drm_connector *connector ) ;
#line 260
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs ;
#line 737 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs ;
#line 738
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs ;
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static u32 psb_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 ret ;
  bool tmp ;
  uint32_t tmp___0 ;

  {
#line 293
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 296
  tmp = gma_power_begin(dev, 0);
#line 296
  if ((int )tmp) {
#line 297
    ret = REGISTER_READ(dev, 397908U);
#line 298
    gma_power_end(dev);
  } else {
#line 300
    ret = dev_priv->regs.saveBLC_PWM_CTL;
  }
#line 303
  ret = ret >> 17;
#line 306
  ret = ret * 2U;
#line 307
  if (ret == 0U) {
#line 308
    tmp___0 = REGISTER_READ(dev, 397908U);
#line 308
    dev_err((struct device  const  *)dev->dev, "BL bug: Reg %08x save %08X\n", tmp___0,
            dev_priv->regs.saveBLC_PWM_CTL);
  } else {

  }
#line 310
  return (ret);
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static int psb_lvds_i2c_set_brightness(struct drm_device *dev , unsigned int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_i2c_chan *lvds_i2c_bus ;
  u8 out_buf[2U] ;
  unsigned int blc_i2c_brightness ;
  struct i2c_msg msgs[1U] ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
#line 322
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 325
  lvds_i2c_bus = dev_priv->lvds_i2c_bus;
#line 329
  msgs[0].addr = (unsigned short )lvds_i2c_bus->slave_addr;
#line 329
  msgs[0].flags = 0U;
#line 329
  msgs[0].len = 2U;
#line 329
  msgs[0].buf = (__u8 *)(& out_buf);
#line 338
  blc_i2c_brightness = (level * 255U) / 100U & 255U;
#line 342
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
#line 343
    blc_i2c_brightness = 255U - blc_i2c_brightness;
  } else {

  }
#line 345
  out_buf[0] = (dev_priv->lvds_bl)->brightnesscmd;
#line 346
  out_buf[1] = (unsigned char )blc_i2c_brightness;
#line 348
  tmp___0 = i2c_transfer(& lvds_i2c_bus->adapter, (struct i2c_msg *)(& msgs), 1);
#line 348
  if (tmp___0 == 1) {
#line 349
    descriptor.modname = "gma500_gfx";
#line 349
    descriptor.function = "psb_lvds_i2c_set_brightness";
#line 349
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared";
#line 349
    descriptor.format = "I2C set brightness.(command, value) (%d, %d)\n";
#line 349
    descriptor.lineno = 351U;
#line 349
    descriptor.flags = 0U;
#line 349
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 349
    if (tmp != 0L) {
#line 349
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "I2C set brightness.(command, value) (%d, %d)\n",
                        (int )(dev_priv->lvds_bl)->brightnesscmd, blc_i2c_brightness);
    } else {

    }
#line 352
    return (0);
  } else {

  }
#line 355
  dev_err((struct device  const  *)dev->dev, "I2C transfer error\n");
#line 356
  return (-1);
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static int psb_lvds_pwm_set_brightness(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 max_pwm_blc ;
  u32 blc_pwm_duty_cycle ;
  long tmp ;

  {
#line 362
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 368
  max_pwm_blc = psb_intel_lvds_get_max_backlight(dev);
#line 371
  tmp = ldv__builtin_expect(max_pwm_blc == 0U, 0L);
#line 371
  if (tmp != 0L) {
#line 371
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"),
                         "i" (371), "i" (12UL));
    ldv_39763: ;
#line 371
    goto ldv_39763;
  } else {

  }
#line 373
  blc_pwm_duty_cycle = ((u32 )level * max_pwm_blc) / 100U;
#line 375
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
#line 376
    blc_pwm_duty_cycle = max_pwm_blc - blc_pwm_duty_cycle;
  } else {

  }
#line 378
  blc_pwm_duty_cycle = blc_pwm_duty_cycle & 65534U;
#line 379
  REGISTER_WRITE(dev, 397908U, (max_pwm_blc << 16) | blc_pwm_duty_cycle);
#line 383
  _dev_info((struct device  const  *)dev->dev, "Backlight lvds set brightness %08x\n",
            (max_pwm_blc << 16) | blc_pwm_duty_cycle);
#line 387
  return (0);
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 395
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 397
  descriptor.modname = "gma500_gfx";
#line 397
  descriptor.function = "psb_intel_lvds_set_brightness";
#line 397
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared";
#line 397
  descriptor.format = "backlight level is %d\n";
#line 397
  descriptor.lineno = 397U;
#line 397
  descriptor.flags = 0U;
#line 397
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 397
  if (tmp != 0L) {
#line 397
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "backlight level is %d\n",
                      level);
  } else {

  }
#line 399
  if ((unsigned long )dev_priv->lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
#line 400
    dev_err((struct device  const  *)dev->dev, "NO LVDS backlight info\n");
#line 401
    return;
  } else {

  }
#line 404
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) == 1U) {
#line 405
    psb_lvds_i2c_set_brightness(dev, (unsigned int )level);
  } else {
#line 407
    psb_lvds_pwm_set_brightness(dev, level);
  }
#line 408
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  bool tmp ;

  {
#line 417
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 420
  tmp = gma_power_begin(dev, 0);
#line 420
  if ((int )tmp) {
#line 421
    blc_pwm_ctl = REGISTER_READ(dev, 397908U);
#line 422
    blc_pwm_ctl = blc_pwm_ctl & 4294901760U;
#line 423
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
#line 426
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
#line 428
    gma_power_end(dev);
  } else {
#line 430
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
#line 432
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
#line 434
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_set_power(struct drm_device *dev , bool on ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 442
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 443
  mode_dev = & dev_priv->mode_dev;
#line 446
  tmp = gma_power_begin(dev, 1);
#line 446
  if (tmp) {
#line 446
    tmp___0 = 0;
  } else {
#line 446
    tmp___0 = 1;
  }
#line 446
  if (tmp___0) {
#line 447
    dev_err((struct device  const  *)dev->dev, "set power, chip off!\n");
#line 448
    return;
  } else {

  }
#line 451
  if ((int )on) {
#line 452
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 452
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_39784: 
#line 455
    pp_status = REGISTER_READ(dev, 397824U);
#line 456
    if ((int )pp_status >= 0) {
#line 458
      goto ldv_39784;
    } else {

    }
#line 458
    psb_intel_lvds_set_backlight(dev, mode_dev->backlight_duty_cycle);
  } else {
#line 461
    psb_intel_lvds_set_backlight(dev, 0);
#line 463
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 463
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_39786: 
#line 466
    pp_status = REGISTER_READ(dev, 397824U);
#line 467
    if ((int )pp_status < 0) {
#line 469
      goto ldv_39786;
    } else {

    }

  }
#line 470
  gma_power_end(dev);
#line 471
  return;
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;

  {
#line 475
  dev = encoder->dev;
#line 477
  if (mode == 0) {
#line 478
    psb_intel_lvds_set_power(dev, 1);
  } else {
#line 480
    psb_intel_lvds_set_power(dev, 0);
  }
#line 481
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 487
  dev = connector->dev;
#line 488
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 490
  tmp = gma_attached_encoder(connector);
#line 490
  gma_encoder = tmp;
#line 491
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 494
  lvds_priv->savePP_ON = REGISTER_READ(dev, 397832U);
#line 495
  lvds_priv->savePP_OFF = REGISTER_READ(dev, 397836U);
#line 496
  lvds_priv->saveLVDS = REGISTER_READ(dev, 397696U);
#line 497
  lvds_priv->savePP_CONTROL = REGISTER_READ(dev, 397828U);
#line 498
  lvds_priv->savePP_CYCLE = REGISTER_READ(dev, 397840U);
#line 500
  lvds_priv->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 501
  lvds_priv->savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
#line 502
  lvds_priv->savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
#line 505
  dev_priv->backlight_duty_cycle = (int )dev_priv->regs.saveBLC_PWM_CTL & 65535;
#line 512
  if (dev_priv->backlight_duty_cycle == 0) {
#line 513
    tmp___0 = psb_intel_lvds_get_max_backlight(dev);
#line 513
    dev_priv->backlight_duty_cycle = (int )tmp___0;
  } else {

  }
#line 516
  descriptor.modname = "gma500_gfx";
#line 516
  descriptor.function = "psb_intel_lvds_save";
#line 516
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared";
#line 516
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
#line 516
  descriptor.lineno = 522U;
#line 516
  descriptor.flags = 0U;
#line 516
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 516
  if (tmp___1 != 0L) {
#line 516
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
#line 518
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  u32 pp_status ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 527
  dev = connector->dev;
#line 529
  tmp = gma_attached_encoder(connector);
#line 529
  gma_encoder = tmp;
#line 530
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 533
  descriptor.modname = "gma500_gfx";
#line 533
  descriptor.function = "psb_intel_lvds_restore";
#line 533
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared";
#line 533
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
#line 533
  descriptor.lineno = 539U;
#line 533
  descriptor.flags = 0U;
#line 533
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 533
  if (tmp___0 != 0L) {
#line 533
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
#line 541
  REGISTER_WRITE(dev, 397908U, lvds_priv->saveBLC_PWM_CTL);
#line 542
  REGISTER_WRITE(dev, 397872U, lvds_priv->savePFIT_CONTROL);
#line 543
  REGISTER_WRITE(dev, 397876U, lvds_priv->savePFIT_PGM_RATIOS);
#line 544
  REGISTER_WRITE(dev, 397832U, lvds_priv->savePP_ON);
#line 545
  REGISTER_WRITE(dev, 397836U, lvds_priv->savePP_OFF);
#line 547
  REGISTER_WRITE(dev, 397840U, lvds_priv->savePP_CYCLE);
#line 548
  REGISTER_WRITE(dev, 397828U, lvds_priv->savePP_CONTROL);
#line 549
  REGISTER_WRITE(dev, 397696U, lvds_priv->saveLVDS);
#line 551
  if ((int )lvds_priv->savePP_CONTROL & 1) {
#line 552
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 552
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_39811: 
#line 555
    pp_status = REGISTER_READ(dev, 397824U);
#line 556
    if ((int )pp_status >= 0) {
#line 558
      goto ldv_39811;
    } else {

    }

  } else {
#line 558
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 558
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_39813: 
#line 561
    pp_status = REGISTER_READ(dev, 397824U);
#line 562
    if ((int )pp_status < 0) {
#line 564
      goto ldv_39813;
    } else {

    }

  }
#line 570
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct drm_display_mode *fixed_mode ;

  {
#line 569
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 570
  tmp = gma_attached_encoder(connector);
#line 570
  gma_encoder = tmp;
#line 571
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
#line 574
  if (gma_encoder->type == 8) {
#line 575
    fixed_mode = dev_priv->mode_dev.panel_fixed_mode2;
  } else {

  }
#line 578
  if ((mode->flags & 32U) != 0U) {
#line 579
    return (8);
  } else {

  }
#line 582
  if ((mode->flags & 16U) != 0U) {
#line 583
    return (7);
  } else {

  }
#line 585
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 586
    if (mode->hdisplay > fixed_mode->hdisplay) {
#line 587
      return (29);
    } else {

    }
#line 588
    if (mode->vdisplay > fixed_mode->vdisplay) {
#line 589
      return (29);
    } else {

    }
  } else {

  }
#line 591
  return (0);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 598
  dev = encoder->dev;
#line 599
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 600
  mode_dev = & dev_priv->mode_dev;
#line 601
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 601
  gma_crtc = (struct gma_crtc *)__mptr;
#line 603
  panel_fixed_mode = mode_dev->panel_fixed_mode;
#line 604
  __mptr___0 = (struct drm_encoder  const  *)encoder;
#line 604
  gma_encoder = (struct gma_encoder *)__mptr___0;
#line 606
  if (gma_encoder->type == 8) {
#line 607
    panel_fixed_mode = mode_dev->panel_fixed_mode2;
  } else {

  }
#line 610
  if (((int )(dev->pdev)->device & 65520) != 16640 && gma_crtc->pipe == 0) {
#line 611
    printk("\vCan\'t support LVDS on pipe A\n");
#line 612
    return (0);
  } else {

  }
#line 614
  if (((int )(dev->pdev)->device & 65520) == 16640 && gma_crtc->pipe != 0) {
#line 615
    printk("\vMust use PIPE A\n");
#line 616
    return (0);
  } else {

  }
#line 619
  __mptr___1 = (struct list_head  const  *)dev->mode_config.encoder_list.next;
#line 619
  tmp_encoder = (struct drm_encoder *)__mptr___1 + 0xfffffffffffffff8UL;
#line 619
  goto ldv_39843;
  ldv_39842: ;
#line 621
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
#line 623
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
#line 625
    return (0);
  } else {

  }
#line 619
  __mptr___2 = (struct list_head  const  *)tmp_encoder->head.next;
#line 619
  tmp_encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_39843: ;
#line 619
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
#line 621
    goto ldv_39842;
  } else {

  }

#line 635
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 636
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
#line 637
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
#line 638
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
#line 639
    adjusted_mode->htotal = panel_fixed_mode->htotal;
#line 640
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
#line 641
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
#line 642
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
#line 643
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
#line 644
    adjusted_mode->clock = panel_fixed_mode->clock;
#line 645
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
#line 655
  return (1);
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 660
  dev = encoder->dev;
#line 661
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 662
  mode_dev = & dev_priv->mode_dev;
#line 664
  tmp = gma_power_begin(dev, 1);
#line 664
  if (tmp) {
#line 664
    tmp___0 = 0;
  } else {
#line 664
    tmp___0 = 1;
  }
#line 664
  if (tmp___0) {
#line 665
    return;
  } else {

  }
#line 667
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 668
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 671
  psb_intel_lvds_set_power(dev, 0);
#line 673
  gma_power_end(dev);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 678
  dev = encoder->dev;
#line 679
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 680
  mode_dev = & dev_priv->mode_dev;
#line 682
  if (mode_dev->backlight_duty_cycle == 0) {
#line 683
    tmp = psb_intel_lvds_get_max_backlight(dev);
#line 683
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 686
  psb_intel_lvds_set_power(dev, 1);
#line 687
  return;
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 pfit_control ;

  {
#line 693
  dev = encoder->dev;
#line 694
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 708
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 710
    pfit_control = 2147485280U;
  } else {
#line 714
    pfit_control = 0U;
  }
#line 716
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 717
    pfit_control = pfit_control | 8U;
  } else {

  }
#line 719
  REGISTER_WRITE(dev, 397872U, pfit_control);
#line 720
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static enum drm_connector_status psb_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 


  {
#line 732
  return (1);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static int psb_intel_lvds_get_modes(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
#line 740
  dev = connector->dev;
#line 741
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 742
  mode_dev = & dev_priv->mode_dev;
#line 743
  tmp = gma_attached_encoder(connector);
#line 743
  gma_encoder = tmp;
#line 744
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 745
  ret = 0;
#line 747
  if (((int )(dev->pdev)->device & 65520) != 16640) {
#line 748
    ret = psb_intel_ddc_get_modes(connector, & (lvds_priv->i2c_bus)->adapter);
  } else {

  }
#line 750
  if (ret != 0) {
#line 751
    return (ret);
  } else {

  }
#line 757
  connector->display_info.min_vfreq = 0U;
#line 758
  connector->display_info.max_vfreq = 200U;
#line 759
  connector->display_info.min_hfreq = 0U;
#line 760
  connector->display_info.max_hfreq = 200U;
#line 762
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 763
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
#line 763
    mode = tmp___0;
#line 765
    drm_mode_probed_add(connector, mode);
#line 766
    return (1);
  } else {

  }
#line 769
  return (0);
}
}
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void psb_intel_lvds_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;

  {
#line 781
  tmp = gma_attached_encoder(connector);
#line 781
  gma_encoder = tmp;
#line 782
  lvds_priv = (struct psb_intel_lvds_priv *)gma_encoder->dev_priv;
#line 784
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 785
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
#line 786
  drm_sysfs_connector_remove(connector);
#line 787
  drm_connector_cleanup(connector);
#line 788
  kfree((void const   *)connector);
#line 789
  return;
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curval ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs *hfuncs ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 795
  encoder = connector->encoder;
#line 797
  if ((unsigned long )encoder == (unsigned long )((struct drm_encoder *)0)) {
#line 798
    return (-1);
  } else {

  }
#line 800
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
#line 800
  if (tmp___6 == 0) {
#line 801
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 801
    crtc = (struct gma_crtc *)__mptr;
#line 804
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 805
      goto set_prop_error;
    } else {

    }
#line 807
    switch (value) {
    case 1ULL: ;
#line 809
    goto ldv_39896;
    case 2ULL: ;
#line 811
    goto ldv_39896;
    case 3ULL: ;
#line 813
    goto ldv_39896;
    default: ;
#line 815
    goto set_prop_error;
    }
    ldv_39896: 
#line 818
    tmp = drm_object_property_get_value(& connector->base, property, & curval);
#line 818
    if (tmp != 0) {
#line 821
      goto set_prop_error;
    } else {

    }
#line 823
    if (curval == value) {
#line 824
      goto set_prop_done;
    } else {

    }
#line 826
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 826
    if (tmp___0 != 0) {
#line 829
      goto set_prop_error;
    } else {

    }
#line 831
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 833
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 833
      if (tmp___1) {
#line 833
        tmp___2 = 0;
      } else {
#line 833
        tmp___2 = 1;
      }
#line 833
      if (tmp___2) {
#line 838
        goto set_prop_error;
      } else {

      }
    } else {

    }
  } else {
#line 840
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
#line 840
    if (tmp___5 == 0) {
#line 841
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
#line 841
      if (tmp___3 != 0) {
#line 844
        goto set_prop_error;
      } else {
#line 846
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
#line 847
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
#line 847
      if (tmp___4 == 0) {
#line 848
        hfuncs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
#line 850
        (*(hfuncs->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
  set_prop_done: ;
#line 854
  return (0);
  set_prop_error: ;
#line 856
  return (-1);
}
}
#line 859 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static struct drm_encoder_helper_funcs  const  psb_intel_lvds_helper_funcs  = 
#line 859
     {& psb_intel_lvds_encoder_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & psb_intel_lvds_prepare,
    & psb_intel_lvds_commit, & psb_intel_lvds_mode_set, 0, 0, 0};
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs  =    {& psb_intel_lvds_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& psb_intel_lvds_mode_valid),
    & gma_best_encoder};
#line 874 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs  = 
#line 874
     {& drm_helper_connector_dpms, & psb_intel_lvds_save, & psb_intel_lvds_restore,
    0, & psb_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & psb_intel_lvds_set_property,
    & psb_intel_lvds_destroy, 0};
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
static void psb_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 887
  drm_encoder_cleanup(encoder);
#line 888
  return;
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs  =    {0, & psb_intel_lvds_enc_destroy};
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 913
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 917
  tmp = kzalloc(152UL, 208U);
#line 917
  gma_encoder = (struct gma_encoder *)tmp;
#line 918
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 919
    dev_err((struct device  const  *)dev->dev, "gma_encoder allocation error\n");
#line 920
    return;
  } else {

  }
#line 923
  tmp___0 = kzalloc(728UL, 208U);
#line 923
  gma_connector = (struct gma_connector *)tmp___0;
#line 924
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 925
    dev_err((struct device  const  *)dev->dev, "gma_connector allocation error\n");
#line 926
    goto failed_encoder;
  } else {

  }
#line 929
  tmp___1 = kzalloc(48UL, 208U);
#line 929
  lvds_priv = (struct psb_intel_lvds_priv *)tmp___1;
#line 930
  if ((unsigned long )lvds_priv == (unsigned long )((struct psb_intel_lvds_priv *)0)) {
#line 931
    dev_err((struct device  const  *)dev->dev, "LVDS private allocation error\n");
#line 932
    goto failed_connector;
  } else {

  }
#line 935
  gma_encoder->dev_priv = (void *)lvds_priv;
#line 937
  connector = & gma_connector->base;
#line 938
  encoder = & gma_encoder->base;
#line 939
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
#line 943
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
#line 947
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 948
  gma_encoder->type = 4;
#line 950
  drm_encoder_helper_add(encoder, & psb_intel_lvds_helper_funcs);
#line 951
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
#line 953
  connector->display_info.subpixel_order = 1;
#line 954
  connector->interlace_allowed = 0;
#line 955
  connector->doublescan_allowed = 0;
#line 958
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 961
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 969
  lvds_priv->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
#line 970
  if ((unsigned long )lvds_priv->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 971
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
#line 973
    goto failed_blc_i2c;
  } else {

  }
#line 975
  (lvds_priv->i2c_bus)->slave_addr = 44U;
#line 976
  dev_priv->lvds_i2c_bus = lvds_priv->i2c_bus;
#line 989
  lvds_priv->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
#line 990
  if ((unsigned long )lvds_priv->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 991
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 993
    goto failed_ddc;
  } else {

  }
#line 1000
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
#line 1001
  psb_intel_ddc_get_modes(connector, & (lvds_priv->ddc_bus)->adapter);
#line 1002
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 1002
  scan = (struct drm_display_mode *)__mptr;
#line 1002
  goto ldv_39933;
  ldv_39932: ;
#line 1003
  if ((scan->type & 8U) != 0U) {
#line 1004
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 1006
    goto out;
  } else {

  }
#line 1002
  __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 1002
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_39933: ;
#line 1002
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 1004
    goto ldv_39932;
  } else {

  }

#line 1011
  if ((unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1012
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
#line 1015
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1016
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1017
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
#line 1026
  lvds = REGISTER_READ(dev, 397696U);
#line 1027
  pipe = (lvds & 1073741824U) != 0U;
#line 1028
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
#line 1030
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
#line 1031
    mode_dev->panel_fixed_mode = psb_intel_crtc_mode_get(dev, crtc);
#line 1033
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1034
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 1036
      goto out;
    } else {

    }
  } else {

  }
#line 1041
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1042
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
#line 1043
    goto failed_find;
  } else {

  }
  out: 
#line 1051
  mutex_unlock(& dev->mode_config.mutex);
#line 1052
  drm_sysfs_connector_add(connector);
#line 1053
  return;
  failed_find: 
#line 1056
  mutex_unlock(& dev->mode_config.mutex);
#line 1057
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 1058
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
  failed_ddc: ;
#line 1060
  if ((unsigned long )lvds_priv->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 1061
    psb_intel_i2c_destroy(lvds_priv->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
#line 1063
  drm_encoder_cleanup(encoder);
#line 1064
  drm_connector_cleanup(connector);
  failed_connector: 
#line 1066
  kfree((void const   *)gma_connector);
  failed_encoder: 
#line 1068
  kfree((void const   *)gma_encoder);
#line 1069
  return;
}
}
#line 1072
extern int ldv_probe_39(void) ;
#line 1073
extern int ldv_probe_38(void) ;
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_41(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1077
  tmp = ldv_zalloc(96UL);
#line 1077
  psb_intel_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 1078
  tmp___0 = ldv_zalloc(208UL);
#line 1078
  psb_intel_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 1079
  return;
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_funcs_39(void) 
{ 
  void *tmp ;

  {
#line 1082
  tmp = ldv_zalloc(720UL);
#line 1082
  psb_intel_lvds_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 1083
  return;
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_40(void) 
{ 
  void *tmp ;

  {
#line 1086
  tmp = ldv_zalloc(720UL);
#line 1086
  psb_intel_lvds_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 1087
  return;
}
}
#line 1089 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_38(void) 
{ 
  struct drm_encoder *ldvarg173 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1090
  tmp = ldv_zalloc(96UL);
#line 1090
  ldvarg173 = (struct drm_encoder *)tmp;
#line 1092
  tmp___0 = __VERIFIER_nondet_int();
#line 1092
  switch (tmp___0) {
  case 0: ;
#line 1095
  if (ldv_state_variable_38 == 2) {
#line 1097
    psb_intel_lvds_enc_destroy(ldvarg173);
#line 1099
    ldv_state_variable_38 = 1;
#line 1100
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1103
  goto ldv_39954;
  case 1: ;
#line 1106
  if (ldv_state_variable_38 == 1) {
#line 1108
    ldv_probe_38();
#line 1110
    ldv_state_variable_38 = 2;
#line 1111
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1114
  goto ldv_39954;
  default: 
#line 1115
  ldv_stop();
  }
  ldv_39954: ;
#line 1119
  return;
}
}
#line 1121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_39(void) 
{ 
  uint64_t ldvarg132 ;
  uint32_t ldvarg130 ;
  struct drm_property *ldvarg133 ;
  void *tmp ;
  int ldvarg135 ;
  int tmp___0 ;
  bool ldvarg134 ;
  uint32_t ldvarg131 ;
  int tmp___1 ;

  {
#line 1124
  tmp = ldv_zalloc(104UL);
#line 1124
  ldvarg133 = (struct drm_property *)tmp;
#line 1125
  tmp___0 = __VERIFIER_nondet_int();
#line 1125
  ldvarg135 = tmp___0;
#line 1122
  memset((void *)(& ldvarg132), 0, 8UL);
#line 1123
  memset((void *)(& ldvarg130), 0, 4UL);
#line 1126
  memset((void *)(& ldvarg134), 0, 1UL);
#line 1127
  memset((void *)(& ldvarg131), 0, 4UL);
#line 1129
  tmp___1 = __VERIFIER_nondet_int();
#line 1129
  switch (tmp___1) {
  case 0: ;
#line 1132
  if (ldv_state_variable_39 == 2) {
#line 1134
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg135);
#line 1136
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1139
  if (ldv_state_variable_39 == 1) {
#line 1141
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg135);
#line 1143
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1146
  goto ldv_39967;
  case 1: ;
#line 1149
  if (ldv_state_variable_39 == 2) {
#line 1151
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg134);
#line 1153
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1156
  if (ldv_state_variable_39 == 1) {
#line 1158
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg134);
#line 1160
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1163
  goto ldv_39967;
  case 2: ;
#line 1166
  if (ldv_state_variable_39 == 2) {
#line 1168
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg133,
                                ldvarg132);
#line 1170
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1173
  if (ldv_state_variable_39 == 1) {
#line 1175
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg133,
                                ldvarg132);
#line 1177
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1180
  goto ldv_39967;
  case 3: ;
#line 1183
  if (ldv_state_variable_39 == 2) {
#line 1185
    psb_intel_lvds_destroy(psb_intel_lvds_connector_funcs_group0);
#line 1187
    ldv_state_variable_39 = 1;
#line 1188
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1191
  goto ldv_39967;
  case 4: ;
#line 1194
  if (ldv_state_variable_39 == 2) {
#line 1196
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
#line 1198
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1201
  if (ldv_state_variable_39 == 1) {
#line 1203
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
#line 1205
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1208
  goto ldv_39967;
  case 5: ;
#line 1211
  if (ldv_state_variable_39 == 2) {
#line 1213
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
#line 1215
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1218
  if (ldv_state_variable_39 == 1) {
#line 1220
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
#line 1222
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1225
  goto ldv_39967;
  case 6: ;
#line 1228
  if (ldv_state_variable_39 == 2) {
#line 1230
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg131, ldvarg130);
#line 1232
    ldv_state_variable_39 = 2;
  } else {

  }
#line 1235
  if (ldv_state_variable_39 == 1) {
#line 1237
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg131, ldvarg130);
#line 1239
    ldv_state_variable_39 = 1;
  } else {

  }
#line 1242
  goto ldv_39967;
  case 7: ;
#line 1245
  if (ldv_state_variable_39 == 1) {
#line 1247
    ldv_probe_39();
#line 1249
    ldv_state_variable_39 = 2;
#line 1250
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1253
  goto ldv_39967;
  default: 
#line 1254
  ldv_stop();
  }
  ldv_39967: ;
#line 1258
  return;
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_40(void) 
{ 
  struct drm_display_mode *ldvarg53 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1261
  tmp = ldv_zalloc(208UL);
#line 1261
  ldvarg53 = (struct drm_display_mode *)tmp;
#line 1263
  tmp___0 = __VERIFIER_nondet_int();
#line 1263
  switch (tmp___0) {
  case 0: ;
#line 1266
  if (ldv_state_variable_40 == 1) {
#line 1268
    psb_intel_lvds_get_modes(psb_intel_lvds_connector_helper_funcs_group0);
#line 1270
    ldv_state_variable_40 = 1;
  } else {

  }
#line 1273
  goto ldv_39981;
  case 1: ;
#line 1276
  if (ldv_state_variable_40 == 1) {
#line 1278
    psb_intel_lvds_mode_valid(psb_intel_lvds_connector_helper_funcs_group0, ldvarg53);
#line 1280
    ldv_state_variable_40 = 1;
  } else {

  }
#line 1283
  goto ldv_39981;
  case 2: ;
#line 1286
  if (ldv_state_variable_40 == 1) {
#line 1288
    gma_best_encoder(psb_intel_lvds_connector_helper_funcs_group0);
#line 1290
    ldv_state_variable_40 = 1;
  } else {

  }
#line 1293
  goto ldv_39981;
  default: 
#line 1294
  ldv_stop();
  }
  ldv_39981: ;
#line 1298
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void ldv_main_exported_41(void) 
{ 
  struct drm_display_mode *ldvarg149 ;
  void *tmp ;
  int ldvarg151 ;
  int tmp___0 ;
  struct drm_display_mode *ldvarg150 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1301
  tmp = ldv_zalloc(208UL);
#line 1301
  ldvarg149 = (struct drm_display_mode *)tmp;
#line 1302
  tmp___0 = __VERIFIER_nondet_int();
#line 1302
  ldvarg151 = tmp___0;
#line 1303
  tmp___1 = ldv_zalloc(208UL);
#line 1303
  ldvarg150 = (struct drm_display_mode *)tmp___1;
#line 1305
  tmp___2 = __VERIFIER_nondet_int();
#line 1305
  switch (tmp___2) {
  case 0: ;
#line 1308
  if (ldv_state_variable_41 == 1) {
#line 1310
    psb_intel_lvds_encoder_dpms(psb_intel_lvds_helper_funcs_group0, ldvarg151);
#line 1312
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1315
  goto ldv_39992;
  case 1: ;
#line 1318
  if (ldv_state_variable_41 == 1) {
#line 1320
    psb_intel_lvds_mode_fixup(psb_intel_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg150,
                              psb_intel_lvds_helper_funcs_group1);
#line 1322
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1325
  goto ldv_39992;
  case 2: ;
#line 1328
  if (ldv_state_variable_41 == 1) {
#line 1330
    psb_intel_lvds_commit(psb_intel_lvds_helper_funcs_group0);
#line 1332
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1335
  goto ldv_39992;
  case 3: ;
#line 1338
  if (ldv_state_variable_41 == 1) {
#line 1340
    psb_intel_lvds_mode_set(psb_intel_lvds_helper_funcs_group0, psb_intel_lvds_helper_funcs_group1,
                            ldvarg149);
#line 1342
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1345
  goto ldv_39992;
  case 4: ;
#line 1348
  if (ldv_state_variable_41 == 1) {
#line 1350
    psb_intel_lvds_prepare(psb_intel_lvds_helper_funcs_group0);
#line 1352
    ldv_state_variable_41 = 1;
  } else {

  }
#line 1355
  goto ldv_39992;
  default: 
#line 1356
  ldv_stop();
  }
  ldv_39992: ;
#line 1360
  return;
}
}
#line 1488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_lvds.o.c.prepared"
void *ldv_kmem_cache_alloc_318(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1491
  ldv_check_alloc_flags(flags);
#line 1493
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1494
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_338(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 941 "include/drm/drm_crtc.h"
extern struct edid *drm_get_edid(struct drm_connector * , struct i2c_adapter * ) ;
#line 944
extern int drm_add_edid_modes(struct drm_connector * , struct edid * ) ;
#line 949
extern int drm_mode_connector_update_edid_property(struct drm_connector * , struct edid * ) ;
#line 210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) 
{ 
  u8 out_buf[2U] ;
  u8 buf[2U] ;
  int ret ;
  struct i2c_msg msgs[2U] ;

  {
#line 251
  out_buf[0] = 0U;
#line 251
  out_buf[1] = 0U;
#line 254
  msgs[0].addr = 80U;
#line 254
  msgs[0].flags = 0U;
#line 254
  msgs[0].len = 1U;
#line 254
  msgs[0].buf = (__u8 *)(& out_buf);
#line 254
  msgs[1].addr = 80U;
#line 254
  msgs[1].flags = 1U;
#line 254
  msgs[1].len = 1U;
#line 254
  msgs[1].buf = (__u8 *)(& buf);
#line 269
  ret = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
#line 270
  if (ret == 2) {
#line 271
    return (1);
  } else {

  }
#line 273
  return (0);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) 
{ 
  struct edid *edid ;
  int ret ;

  {
#line 286
  ret = 0;
#line 288
  edid = drm_get_edid(connector, adapter);
#line 289
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 290
    drm_mode_connector_update_edid_property(connector, edid);
#line 291
    ret = drm_add_edid_modes(connector, edid);
#line 292
    kfree((void const   *)edid);
  } else {

  }
#line 294
  return (ret);
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_modes.o.c.prepared"
void *ldv_kmem_cache_alloc_338(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 427
  ldv_check_alloc_flags(flags);
#line 429
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 430
  return ((void *)0);
}
}
#line 1 "<compiler builtins>"
void *__builtin_alloca(unsigned long  ) ;
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_358(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 181 "include/drm/drm_modes.h"
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
#line 988 "include/drm/drm_crtc.h"
extern struct drm_property *drm_property_create(struct drm_device * , int  , char const   * ,
                                                int  ) ;
#line 1006
extern void drm_property_destroy(struct drm_device * , struct drm_property * ) ;
#line 1007
extern int drm_property_add_enum(struct drm_property * , int  , uint64_t  , char const   * ) ;
#line 1068
extern bool drm_detect_hdmi_monitor(struct edid * ) ;
#line 1069
extern bool drm_detect_monitor_audio(struct edid * ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static void psb_intel_mode_set_pixel_multiplier(struct drm_display_mode *mode ,
                                                         int multiplier ) 
{ 


  {
#line 76
  mode->clock = mode->clock * multiplier;
#line 77
  mode->private_flags = mode->private_flags | multiplier;
#line 78
  return;
}
}
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
__inline static int psb_intel_mode_get_pixel_multiplier(struct drm_display_mode  const  *mode ) 
{ 


  {
#line 83
  return ((int )mode->private_flags & 15);
}
}
#line 215
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) ;
#line 826 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ_AUX(struct drm_device *dev , uint32_t reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned int tmp ;

  {
#line 828
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 829
  tmp = ioread32((void *)dev_priv->aux_reg + (unsigned long )reg);
#line 829
  return (tmp);
}
}
#line 836 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static uint32_t REGISTER_READ_WITH_AUX(struct drm_device *dev , uint32_t reg ,
                                                int aux ) 
{ 
  uint32_t val ;

  {
#line 841
  if (aux != 0) {
#line 842
    val = REGISTER_READ_AUX(dev, reg);
  } else {
#line 844
    val = REGISTER_READ(dev, reg);
  }
#line 846
  return (val);
}
}
#line 858 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE_AUX(struct drm_device *dev , uint32_t reg , uint32_t val ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 861
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 862
  iowrite32(val, (void *)dev_priv->aux_reg + (unsigned long )reg);
#line 863
  return;
}
}
#line 868 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
__inline static void REGISTER_WRITE_WITH_AUX(struct drm_device *dev , uint32_t reg ,
                                             uint32_t val , int aux ) 
{ 


  {
#line 871
  if (aux != 0) {
#line 872
    REGISTER_WRITE_AUX(dev, reg, val);
  } else {
#line 874
    REGISTER_WRITE(dev, reg, val);
  }
#line 875
  return;
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static char const   *tv_format_names[19U]  = 
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
  {      "NTSC_M",      "NTSC_J",      "NTSC_443",      "PAL_B", 
        "PAL_D",      "PAL_G",      "PAL_H",      "PAL_I", 
        "PAL_M",      "PAL_N",      "PAL_NC",      "PAL_60", 
        "SECAM_B",      "SECAM_D",      "SECAM_G",      "SECAM_K", 
        "SECAM_K1",      "SECAM_L",      "SECAM_60"};
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct psb_intel_sdvo *to_psb_intel_sdvo(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 418
  __mptr = (struct drm_encoder  const  *)encoder;
#line 418
  return ((struct psb_intel_sdvo *)__mptr);
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct psb_intel_sdvo *intel_attached_sdvo(struct drm_connector *connector ) 
{ 
  struct gma_encoder  const  *__mptr ;
  struct gma_encoder *tmp ;

  {
#line 423
  tmp = gma_attached_encoder(connector);
#line 423
  __mptr = (struct gma_encoder  const  *)tmp;
#line 423
  return ((struct psb_intel_sdvo *)__mptr);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct psb_intel_sdvo_connector *to_psb_intel_sdvo_connector(struct drm_connector *connector ) 
{ 
  struct gma_connector  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;

  {
#line 429
  __mptr___0 = (struct drm_connector  const  *)connector;
#line 429
  __mptr = (struct gma_connector  const  *)((struct gma_connector *)__mptr___0);
#line 429
  return ((struct psb_intel_sdvo_connector *)__mptr);
}
}
#line 433
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) ;
#line 435
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) ;
#line 439
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) ;
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_write_sdvox(struct psb_intel_sdvo *psb_intel_sdvo , u32 val ) 
{ 
  struct drm_device *dev ;
  u32 bval ;
  u32 cval ;
  int i ;
  int j ;
  int need_aux ;

  {
#line 449
  dev = psb_intel_sdvo->base.base.dev;
#line 450
  bval = val;
#line 450
  cval = val;
#line 452
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 454
  j = 0;
#line 454
  goto ldv_40256;
  ldv_40255: ;
#line 455
  if (psb_intel_sdvo->sdvo_reg == 397632) {
#line 456
    cval = REGISTER_READ_WITH_AUX(dev, 397664U, j);
  } else {
#line 458
    bval = REGISTER_READ_WITH_AUX(dev, 397632U, j);
  }
#line 465
  i = 0;
#line 465
  goto ldv_40253;
  ldv_40252: 
#line 466
  REGISTER_WRITE_WITH_AUX(dev, 397632U, bval, j);
#line 467
  REGISTER_READ_WITH_AUX(dev, 397632U, j);
#line 468
  REGISTER_WRITE_WITH_AUX(dev, 397664U, cval, j);
#line 469
  REGISTER_READ_WITH_AUX(dev, 397664U, j);
#line 465
  i = i + 1;
  ldv_40253: ;
#line 465
  if (i <= 1) {
#line 467
    goto ldv_40252;
  } else {

  }
#line 454
  j = j + 1;
  ldv_40256: ;
#line 454
  if (j <= need_aux) {
#line 456
    goto ldv_40255;
  } else {

  }

#line 461
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_read_byte(struct psb_intel_sdvo *psb_intel_sdvo , u8 addr ,
                                     u8 *ch ) 
{ 
  struct i2c_msg msgs[2U] ;
  int ret ;
  long tmp ;

  {
#line 476
  msgs[0].addr = (unsigned short )psb_intel_sdvo->slave_addr;
#line 476
  msgs[0].flags = 0U;
#line 476
  msgs[0].len = 1U;
#line 476
  msgs[0].buf = & addr;
#line 476
  msgs[1].addr = (unsigned short )psb_intel_sdvo->slave_addr;
#line 476
  msgs[1].flags = 1U;
#line 476
  msgs[1].len = 1U;
#line 476
  msgs[1].buf = ch;
#line 492
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), 2);
#line 492
  if (ret == 2) {
#line 493
    return (1);
  } else {

  }
#line 495
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 495
  if (tmp != 0L) {
#line 495
    drm_ut_debug_printk("psb_intel_sdvo_read_byte", "i2c transfer returned %d\n",
                        ret);
  } else {

  }
#line 496
  return (0);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct _sdvo_cmd_name  const  sdvo_cmd_names[107U]  = 
#line 504
  {      {1U, "SDVO_CMD_RESET"}, 
        {2U, "SDVO_CMD_GET_DEVICE_CAPS"}, 
        {134U, "SDVO_CMD_GET_FIRMWARE_REV"}, 
        {3U, "SDVO_CMD_GET_TRAINED_INPUTS"}, 
        {4U, "SDVO_CMD_GET_ACTIVE_OUTPUTS"}, 
        {5U, "SDVO_CMD_SET_ACTIVE_OUTPUTS"}, 
        {6U, "SDVO_CMD_GET_IN_OUT_MAP"}, 
        {7U, "SDVO_CMD_SET_IN_OUT_MAP"}, 
        {11U, "SDVO_CMD_GET_ATTACHED_DISPLAYS"}, 
        {12U, "SDVO_CMD_GET_HOT_PLUG_SUPPORT"}, 
        {13U, "SDVO_CMD_SET_ACTIVE_HOT_PLUG"}, 
        {14U, "SDVO_CMD_GET_ACTIVE_HOT_PLUG"}, 
        {15U, "SDVO_CMD_GET_INTERRUPT_EVENT_SOURCE"}, 
        {16U, "SDVO_CMD_SET_TARGET_INPUT"}, 
        {17U, "SDVO_CMD_SET_TARGET_OUTPUT"}, 
        {18U, "SDVO_CMD_GET_INPUT_TIMINGS_PART1"}, 
        {19U, "SDVO_CMD_GET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {21U, "SDVO_CMD_SET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {22U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART1"}, 
        {23U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART2"}, 
        {24U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART1"}, 
        {25U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART2"}, 
        {26U, "SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING"}, 
        {27U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1"}, 
        {28U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2"}, 
        {29U, "SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE"}, 
        {30U, "SDVO_CMD_GET_OUTPUT_PIXEL_CLOCK_RANGE"}, 
        {31U, "SDVO_CMD_GET_SUPPORTED_CLOCK_RATE_MULTS"}, 
        {32U, "SDVO_CMD_GET_CLOCK_RATE_MULT"}, 
        {33U, "SDVO_CMD_SET_CLOCK_RATE_MULT"}, 
        {39U, "SDVO_CMD_GET_SUPPORTED_TV_FORMATS"}, 
        {40U, "SDVO_CMD_GET_TV_FORMAT"}, 
        {41U, "SDVO_CMD_SET_TV_FORMAT"}, 
        {42U, "SDVO_CMD_GET_SUPPORTED_POWER_STATES"}, 
        {43U, "SDVO_CMD_GET_POWER_STATE"}, 
        {44U, "SDVO_CMD_SET_ENCODER_POWER_STATE"}, 
        {125U, "SDVO_CMD_SET_DISPLAY_POWER_STATE"}, 
        {122U, "SDVO_CMD_SET_CONTROL_BUS_SWITCH"}, 
        {131U, "SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT"}, 
        {133U, "SDVO_CMD_GET_SCALED_HDTV_RESOLUTION_SUPPORT"}, 
        {132U, "SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS"}, 
        {103U, "SDVO_CMD_GET_MAX_HPOS"}, 
        {104U, "SDVO_CMD_GET_HPOS"}, 
        {105U, "SDVO_CMD_SET_HPOS"}, 
        {106U, "SDVO_CMD_GET_MAX_VPOS"}, 
        {107U, "SDVO_CMD_GET_VPOS"}, 
        {108U, "SDVO_CMD_SET_VPOS"}, 
        {85U, "SDVO_CMD_GET_MAX_SATURATION"}, 
        {86U, "SDVO_CMD_GET_SATURATION"}, 
        {87U, "SDVO_CMD_SET_SATURATION"}, 
        {88U, "SDVO_CMD_GET_MAX_HUE"}, 
        {89U, "SDVO_CMD_GET_HUE"}, 
        {90U, "SDVO_CMD_SET_HUE"}, 
        {94U, "SDVO_CMD_GET_MAX_CONTRAST"}, 
        {95U, "SDVO_CMD_GET_CONTRAST"}, 
        {96U, "SDVO_CMD_SET_CONTRAST"}, 
        {91U, "SDVO_CMD_GET_MAX_BRIGHTNESS"}, 
        {92U, "SDVO_CMD_GET_BRIGHTNESS"}, 
        {93U, "SDVO_CMD_SET_BRIGHTNESS"}, 
        {97U, "SDVO_CMD_GET_MAX_OVERSCAN_H"}, 
        {98U, "SDVO_CMD_GET_OVERSCAN_H"}, 
        {99U, "SDVO_CMD_SET_OVERSCAN_H"}, 
        {100U, "SDVO_CMD_GET_MAX_OVERSCAN_V"}, 
        {101U, "SDVO_CMD_GET_OVERSCAN_V"}, 
        {102U, "SDVO_CMD_SET_OVERSCAN_V"}, 
        {77U, "SDVO_CMD_GET_MAX_FLICKER_FILTER"}, 
        {78U, "SDVO_CMD_GET_FLICKER_FILTER"}, 
        {79U, "SDVO_CMD_SET_FLICKER_FILTER"}, 
        {123U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE"}, 
        {80U, "SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE"}, 
        {81U, "SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE"}, 
        {82U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_2D"}, 
        {83U, "SDVO_CMD_GET_FLICKER_FILTER_2D"}, 
        {84U, "SDVO_CMD_SET_FLICKER_FILTER_2D"}, 
        {109U, "SDVO_CMD_GET_MAX_SHARPNESS"}, 
        {110U, "SDVO_CMD_GET_SHARPNESS"}, 
        {111U, "SDVO_CMD_SET_SHARPNESS"}, 
        {112U, "SDVO_CMD_GET_DOT_CRAWL"}, 
        {113U, "SDVO_CMD_SET_DOT_CRAWL"}, 
        {116U, "SDVO_CMD_GET_MAX_TV_CHROMA_FILTER"}, 
        {117U, "SDVO_CMD_GET_TV_CHROMA_FILTER"}, 
        {118U, "SDVO_CMD_SET_TV_CHROMA_FILTER"}, 
        {119U, "SDVO_CMD_GET_MAX_TV_LUMA_FILTER"}, 
        {120U, "SDVO_CMD_GET_TV_LUMA_FILTER"}, 
        {121U, "SDVO_CMD_SET_TV_LUMA_FILTER"}, 
        {157U, "SDVO_CMD_GET_SUPP_ENCODE"}, 
        {158U, "SDVO_CMD_GET_ENCODE"}, 
        {159U, "SDVO_CMD_SET_ENCODE"}, 
        {139U, "SDVO_CMD_SET_PIXEL_REPLI"}, 
        {140U, "SDVO_CMD_GET_PIXEL_REPLI"}, 
        {141U, "SDVO_CMD_GET_COLORIMETRY_CAP"}, 
        {142U, "SDVO_CMD_SET_COLORIMETRY"}, 
        {143U, "SDVO_CMD_GET_COLORIMETRY"}, 
        {144U, "SDVO_CMD_GET_AUDIO_ENCRYPT_PREFER"}, 
        {145U, "SDVO_CMD_SET_AUDIO_STAT"}, 
        {146U, "SDVO_CMD_GET_AUDIO_STAT"}, 
        {148U, "SDVO_CMD_GET_HBUF_INDEX"}, 
        {147U, "SDVO_CMD_SET_HBUF_INDEX"}, 
        {149U, "SDVO_CMD_GET_HBUF_INFO"}, 
        {151U, "SDVO_CMD_GET_HBUF_AV_SPLIT"}, 
        {150U, "SDVO_CMD_SET_HBUF_AV_SPLIT"}, 
        {155U, "SDVO_CMD_GET_HBUF_TXRATE"}, 
        {154U, "SDVO_CMD_SET_HBUF_TXRATE"}, 
        {152U, "SDVO_CMD_SET_HBUF_DATA"}, 
        {153U, "SDVO_CMD_GET_HBUF_DATA"}};
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_debug_write(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                       void const   *args , int args_len ) 
{ 
  int i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 626
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 626
  if (tmp != 0L) {
#line 626
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "%s: W: %02X ", psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                        (int )cmd);
  } else {

  }
#line 628
  i = 0;
#line 628
  goto ldv_40279;
  ldv_40278: 
#line 629
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 629
  if (tmp___0 != 0L) {
#line 629
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "%02X ", (int )*((u8 *)args + (unsigned long )i));
  } else {

  }
#line 628
  i = i + 1;
  ldv_40279: ;
#line 628
  if (i < args_len) {
#line 630
    goto ldv_40278;
  } else {

  }

#line 630
  goto ldv_40282;
  ldv_40281: 
#line 631
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 631
  if (tmp___1 != 0L) {
#line 631
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "   ");
  } else {

  }
#line 630
  i = i + 1;
  ldv_40282: ;
#line 630
  if (i <= 7) {
#line 632
    goto ldv_40281;
  } else {

  }
#line 632
  i = 0;
#line 632
  goto ldv_40288;
  ldv_40287: ;
#line 633
  if ((int )((unsigned char )sdvo_cmd_names[i].cmd) == (int )cmd) {
#line 634
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 634
    if (tmp___2 != 0L) {
#line 634
      drm_ut_debug_printk("psb_intel_sdvo_debug_write", "(%s)", sdvo_cmd_names[i].name);
    } else {

    }
#line 635
    goto ldv_40286;
  } else {

  }
#line 632
  i = i + 1;
  ldv_40288: ;
#line 632
  if ((unsigned int )i <= 106U) {
#line 634
    goto ldv_40287;
  } else {

  }
  ldv_40286: ;
#line 638
  if (i == 107) {
#line 639
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 639
    if (tmp___3 != 0L) {
#line 639
      drm_ut_debug_printk("psb_intel_sdvo_debug_write", "(%02X)", (int )cmd);
    } else {

    }
  } else {

  }
#line 640
  tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 640
  if (tmp___4 != 0L) {
#line 640
    drm_ut_debug_printk("psb_intel_sdvo_debug_write", "\n");
  } else {

  }
#line 641
  return;
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static char const   *cmd_status_names[7U]  = {      "Power on",      "Success",      "Not supported",      "Invalid arg", 
        "Pending",      "Target not specified",      "Scaling not supported"};
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *args , int args_len ) 
{ 
  u8 *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  u8 status ;
  struct i2c_msg *msgs ;
  unsigned long __lengthofmsgs ;
  void *tmp___0 ;
  int i ;
  int ret ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 656
  __lengthofbuf = (unsigned long )((long )((args_len + 1) * 2));
#line 656
  tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 656
  buf = (u8 *)tmp;
#line 657
  __lengthofmsgs = (unsigned long )((long )(args_len + 3));
#line 657
  tmp___0 = __builtin_alloca(sizeof(*msgs) * __lengthofmsgs);
#line 657
  msgs = (struct i2c_msg *)tmp___0;
#line 660
  psb_intel_sdvo_debug_write(psb_intel_sdvo, (int )cmd, args, args_len);
#line 662
  i = 0;
#line 662
  goto ldv_40304;
  ldv_40303: 
#line 663
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 664
  (msgs + i)->flags = 0U;
#line 665
  (msgs + i)->len = 2U;
#line 666
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
#line 667
  *(buf + i * 2) = 7U - (unsigned int )((u8 )i);
#line 668
  *(buf + (i * 2 + 1)) = *((u8 *)args + (unsigned long )i);
#line 662
  i = i + 1;
  ldv_40304: ;
#line 662
  if (i < args_len) {
#line 664
    goto ldv_40303;
  } else {

  }
#line 670
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 671
  (msgs + i)->flags = 0U;
#line 672
  (msgs + i)->len = 2U;
#line 673
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
#line 674
  *(buf + i * 2) = 8U;
#line 675
  *(buf + (i * 2 + 1)) = cmd;
#line 678
  status = 9U;
#line 679
  (msgs + (i + 1))->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 680
  (msgs + (i + 1))->flags = 0U;
#line 681
  (msgs + (i + 1))->len = 1U;
#line 682
  (msgs + (i + 1))->buf = & status;
#line 684
  (msgs + (i + 2))->addr = (__u16 )psb_intel_sdvo->slave_addr;
#line 685
  (msgs + (i + 2))->flags = 1U;
#line 686
  (msgs + (i + 2))->len = 1U;
#line 687
  (msgs + (i + 2))->buf = & status;
#line 689
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), i + 3);
#line 690
  if (ret < 0) {
#line 691
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 691
    if (tmp___1 != 0L) {
#line 691
      drm_ut_debug_printk("psb_intel_sdvo_write_cmd", "I2c transfer returned %d\n",
                          ret);
    } else {

    }
#line 692
    return (0);
  } else {

  }
#line 694
  if (i + 3 != ret) {
#line 696
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 696
    if (tmp___2 != 0L) {
#line 696
      drm_ut_debug_printk("psb_intel_sdvo_write_cmd", "I2c transfer returned %d/%d\n",
                          ret, i + 3);
    } else {

    }
#line 697
    return (0);
  } else {

  }
#line 700
  return (1);
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_read_response(struct psb_intel_sdvo *psb_intel_sdvo , void *response ,
                                         int response_len ) 
{ 
  u8 retry ;
  u8 status ;
  int i ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 706
  retry = 5U;
#line 710
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 710
  if (tmp != 0L) {
#line 710
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "%s: R: ", psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC");
  } else {

  }
#line 720
  tmp___0 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
#line 720
  if (tmp___0) {
#line 720
    tmp___1 = 0;
  } else {
#line 720
    tmp___1 = 1;
  }
#line 720
  if (tmp___1) {
#line 723
    goto log_fail;
  } else {

  }
#line 725
  goto ldv_40318;
  ldv_40317: 
#line 727
  __const_udelay(64425UL);
#line 728
  tmp___2 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
#line 728
  if (tmp___2) {
#line 728
    tmp___3 = 0;
  } else {
#line 728
    tmp___3 = 1;
  }
#line 728
  if (tmp___3) {
#line 731
    goto log_fail;
  } else {

  }
  ldv_40318: ;
#line 725
  if ((unsigned int )status == 4U || (unsigned int )status == 5U) {
#line 725
    tmp___4 = retry;
#line 725
    retry = (u8 )((int )retry - 1);
#line 725
    if ((unsigned int )tmp___4 != 0U) {
#line 728
      goto ldv_40317;
    } else {
#line 731
      goto ldv_40319;
    }
  } else {

  }
  ldv_40319: ;
#line 734
  if ((unsigned int )status <= 6U) {
#line 735
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 735
    if (tmp___5 != 0L) {
#line 735
      drm_ut_debug_printk("psb_intel_sdvo_read_response", "(%s)", cmd_status_names[(int )status]);
    } else {

    }
  } else {
#line 737
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 737
    if (tmp___6 != 0L) {
#line 737
      drm_ut_debug_printk("psb_intel_sdvo_read_response", "(??? %d)", (int )status);
    } else {

    }
  }
#line 739
  if ((unsigned int )status != 1U) {
#line 740
    goto log_fail;
  } else {

  }
#line 743
  i = 0;
#line 743
  goto ldv_40321;
  ldv_40320: 
#line 744
  tmp___7 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((unsigned int )((u8 )i) + 10U),
                                     (u8 *)response + (unsigned long )i);
#line 744
  if (tmp___7) {
#line 744
    tmp___8 = 0;
  } else {
#line 744
    tmp___8 = 1;
  }
#line 744
  if (tmp___8) {
#line 747
    goto log_fail;
  } else {

  }
#line 748
  tmp___9 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 748
  if (tmp___9 != 0L) {
#line 748
    drm_ut_debug_printk("psb_intel_sdvo_read_response", " %02X", (int )*((u8 *)response + (unsigned long )i));
  } else {

  }
#line 743
  i = i + 1;
  ldv_40321: ;
#line 743
  if (i < response_len) {
#line 745
    goto ldv_40320;
  } else {

  }
#line 750
  tmp___10 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 750
  if (tmp___10 != 0L) {
#line 750
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "\n");
  } else {

  }
#line 751
  return (1);
  log_fail: 
#line 754
  tmp___11 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 754
  if (tmp___11 != 0L) {
#line 754
    drm_ut_debug_printk("psb_intel_sdvo_read_response", "... failed\n");
  } else {

  }
#line 755
  return (0);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static int psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode ) 
{ 


  {
#line 760
  if (mode->clock > 99999) {
#line 761
    return (1);
  } else
#line 762
  if (mode->clock > 49999) {
#line 763
    return (2);
  } else {
#line 765
    return (4);
  }
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_control_bus_switch(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                  u8 ddc_bus ) 
{ 
  bool tmp ;

  {
#line 772
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 122, (void const   *)(& ddc_bus),
                                 1);
#line 772
  return (tmp);
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *data , int len ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 779
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, data, len);
#line 779
  if (tmp) {
#line 779
    tmp___0 = 0;
  } else {
#line 779
    tmp___0 = 1;
  }
#line 779
  if (tmp___0) {
#line 780
    return (0);
  } else {

  }
#line 782
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)0, 0);
#line 782
  return (tmp___1);
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_get_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void *value , int len ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 788
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, (void const   *)0, 0);
#line 788
  if (tmp) {
#line 788
    tmp___0 = 0;
  } else {
#line 788
    tmp___0 = 1;
  }
#line 788
  if (tmp___0) {
#line 789
    return (0);
  } else {

  }
#line 791
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, value, len);
#line 791
  return (tmp___1);
}
}
#line 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_target_input(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_set_target_input_args targets ;
  bool tmp ;

  {
#line 796
  targets.target_1 = 0U;
#line 796
  targets.pad = (unsigned char)0;
#line 797
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 16, (void const   *)(& targets),
                                 1);
#line 797
  return (tmp);
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              bool *input_1 , bool *input_2 ) 
{ 
  struct psb_intel_sdvo_get_trained_inputs_response response ;
  bool tmp ;
  int tmp___0 ;

  {
#line 813
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 3, (void *)(& response), 1);
#line 813
  if (tmp) {
#line 813
    tmp___0 = 0;
  } else {
#line 813
    tmp___0 = 1;
  }
#line 813
  if (tmp___0) {
#line 815
    return (0);
  } else {

  }
#line 817
  *input_1 = (int )response.input0_trained != 0;
#line 818
  *input_2 = (int )response.input1_trained != 0;
#line 819
  return (1);
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_active_outputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              u16 outputs ) 
{ 
  bool tmp ;

  {
#line 825
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 5, (void const   *)(& outputs), 2);
#line 825
  return (tmp);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                       int *clock_min , int *clock_max ) 
{ 
  struct psb_intel_sdvo_pixel_clock_range clocks ;
  bool tmp ;
  int tmp___0 ;

  {
#line 861
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 29, (void *)(& clocks), 4);
#line 861
  if (tmp) {
#line 861
    tmp___0 = 0;
  } else {
#line 861
    tmp___0 = 1;
  }
#line 861
  if (tmp___0) {
#line 864
    return (0);
  } else {

  }
#line 867
  *clock_min = (int )clocks.min * 10;
#line 868
  *clock_max = (int )clocks.max * 10;
#line 869
  return (1);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_target_output(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             u16 outputs ) 
{ 
  bool tmp ;

  {
#line 875
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 17, (void const   *)(& outputs),
                                 2);
#line 875
  return (tmp);
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_timing(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                      struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 883
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& dtd->part1),
                                 8);
#line 883
  if ((int )tmp) {
#line 883
    tmp___0 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )((unsigned int )cmd + 1U),
                                       (void const   *)(& dtd->part2), 8);
#line 883
    if ((int )tmp___0) {
#line 883
      tmp___1 = 1;
    } else {
#line 883
      tmp___1 = 0;
    }
  } else {
#line 883
    tmp___1 = 0;
  }
#line 883
  return ((bool )tmp___1);
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;

  {
#line 890
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 20, dtd);
#line 890
  return (tmp);
}
}
#line 894 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_output_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;

  {
#line 897
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 22, dtd);
#line 897
  return (tmp);
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_create_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                         uint16_t clock , uint16_t width ,
                                                         uint16_t height ) 
{ 
  struct psb_intel_sdvo_preferred_input_timing_args args ;
  bool tmp ;

  {
#line 909
  memset((void *)(& args), 0, 7UL);
#line 910
  args.clock = clock;
#line 911
  args.width = width;
#line 912
  args.height = height;
#line 913
  args.interlace = 0U;
#line 915
  if ((int )psb_intel_sdvo->is_lvds && ((psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay != (int )width || (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay != (int )height)) {
#line 918
    args.scaled = 1U;
  } else {

  }
#line 920
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 26, (void const   *)(& args), 7);
#line 920
  return (tmp);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_get_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_dtd *dtd ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 930
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 27, (void *)(& dtd->part1), 8);
#line 930
  if ((int )tmp) {
#line 930
    tmp___0 = psb_intel_sdvo_get_value(psb_intel_sdvo, 28, (void *)(& dtd->part2),
                                       8);
#line 930
    if ((int )tmp___0) {
#line 930
      tmp___1 = 1;
    } else {
#line 930
      tmp___1 = 0;
    }
  } else {
#line 930
    tmp___1 = 0;
  }
#line 930
  return ((bool )tmp___1);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_sdvo *psb_intel_sdvo ,
                                               u8 val ) 
{ 
  bool tmp ;

  {
#line 938
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 33, (void const   *)(& val), 1);
#line 938
  return (tmp);
}
}
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_get_dtd_from_mode(struct psb_intel_sdvo_dtd *dtd , struct drm_display_mode  const  *mode ) 
{ 
  uint16_t width ;
  uint16_t height ;
  uint16_t h_blank_len ;
  uint16_t h_sync_len ;
  uint16_t v_blank_len ;
  uint16_t v_sync_len ;
  uint16_t h_sync_offset ;
  uint16_t v_sync_offset ;

  {
#line 948
  width = (uint16_t )mode->crtc_hdisplay;
#line 949
  height = (uint16_t )mode->crtc_vdisplay;
#line 952
  h_blank_len = (int )((uint16_t )mode->crtc_hblank_end) - (int )((uint16_t )mode->crtc_hblank_start);
#line 953
  h_sync_len = (int )((uint16_t )mode->crtc_hsync_end) - (int )((uint16_t )mode->crtc_hsync_start);
#line 955
  v_blank_len = (int )((uint16_t )mode->crtc_vblank_end) - (int )((uint16_t )mode->crtc_vblank_start);
#line 956
  v_sync_len = (int )((uint16_t )mode->crtc_vsync_end) - (int )((uint16_t )mode->crtc_vsync_start);
#line 958
  h_sync_offset = (int )((uint16_t )mode->crtc_hsync_start) - (int )((uint16_t )mode->crtc_hblank_start);
#line 959
  v_sync_offset = (int )((uint16_t )mode->crtc_vsync_start) - (int )((uint16_t )mode->crtc_vblank_start);
#line 961
  dtd->part1.clock = (u16 )((int )mode->clock / 10);
#line 962
  dtd->part1.h_active = (u8 )width;
#line 963
  dtd->part1.h_blank = (u8 )h_blank_len;
#line 964
  dtd->part1.h_high = (u8 )((int )((signed char )(((int )width >> 8) << 4)) | ((int )((signed char )((int )h_blank_len >> 8)) & 15));
#line 966
  dtd->part1.v_active = (u8 )height;
#line 967
  dtd->part1.v_blank = (u8 )v_blank_len;
#line 968
  dtd->part1.v_high = (u8 )((int )((signed char )(((int )height >> 8) << 4)) | ((int )((signed char )((int )v_blank_len >> 8)) & 15));
#line 971
  dtd->part2.h_sync_off = (u8 )h_sync_offset;
#line 972
  dtd->part2.h_sync_width = (u8 )h_sync_len;
#line 973
  dtd->part2.v_sync_off_width = (u8 )((int )((signed char )((int )v_sync_offset << 4)) | ((int )((signed char )v_sync_len) & 15));
#line 975
  dtd->part2.sync_off_width_high = (u8 )((((int )((signed char )(((int )h_sync_offset & 768) >> 2)) | (int )((signed char )(((int )h_sync_len & 768) >> 4))) | (int )((signed char )(((int )v_sync_offset & 48) >> 2))) | (int )((signed char )(((int )v_sync_len & 48) >> 4)));
#line 979
  dtd->part2.dtd_flags = 24U;
#line 980
  if ((int )mode->flags & 1) {
#line 981
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 2U);
  } else {

  }
#line 982
  if (((unsigned int )mode->flags & 4U) != 0U) {
#line 983
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 4U);
  } else {

  }
#line 985
  dtd->part2.sdvo_flags = 0U;
#line 986
  dtd->part2.v_sync_off_high = (unsigned int )((u8 )v_sync_offset) & 192U;
#line 987
  dtd->part2.reserved = 0U;
#line 988
  return;
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_get_mode_from_dtd(struct drm_display_mode *mode , struct psb_intel_sdvo_dtd  const  *dtd ) 
{ 


  {
#line 993
  mode->hdisplay = (int )dtd->part1.h_active;
#line 994
  mode->hdisplay = mode->hdisplay + ((((int )((unsigned char )dtd->part1.h_high) >> 4) & 15) << 8);
#line 995
  mode->hsync_start = mode->hdisplay + (int )dtd->part2.h_sync_off;
#line 996
  mode->hsync_start = mode->hsync_start + (((int )dtd->part2.sync_off_width_high & 192) << 2);
#line 997
  mode->hsync_end = mode->hsync_start + (int )dtd->part2.h_sync_width;
#line 998
  mode->hsync_end = mode->hsync_end + (((int )dtd->part2.sync_off_width_high & 48) << 4);
#line 999
  mode->htotal = mode->hdisplay + (int )dtd->part1.h_blank;
#line 1000
  mode->htotal = mode->htotal + (((int )dtd->part1.h_high & 15) << 8);
#line 1002
  mode->vdisplay = (int )dtd->part1.v_active;
#line 1003
  mode->vdisplay = mode->vdisplay + ((((int )((unsigned char )dtd->part1.v_high) >> 4) & 15) << 8);
#line 1004
  mode->vsync_start = mode->vdisplay;
#line 1005
  mode->vsync_start = mode->vsync_start + (((int )((unsigned char )dtd->part2.v_sync_off_width) >> 4) & 15);
#line 1006
  mode->vsync_start = mode->vsync_start + (((int )dtd->part2.sync_off_width_high & 12) << 2);
#line 1007
  mode->vsync_start = mode->vsync_start + ((int )dtd->part2.v_sync_off_high & 192);
#line 1008
  mode->vsync_end = mode->vsync_start + ((int )dtd->part2.v_sync_off_width & 15);
#line 1010
  mode->vsync_end = mode->vsync_end + (((int )dtd->part2.sync_off_width_high & 3) << 4);
#line 1011
  mode->vtotal = mode->vdisplay + (int )dtd->part1.v_blank;
#line 1012
  mode->vtotal = mode->vtotal + (((int )dtd->part1.v_high & 15) << 8);
#line 1014
  mode->clock = (int )dtd->part1.clock * 10;
#line 1016
  mode->flags = mode->flags & 4294967290U;
#line 1017
  if (((int )dtd->part2.dtd_flags & 2) != 0) {
#line 1018
    mode->flags = mode->flags | 1U;
  } else {

  }
#line 1019
  if (((int )dtd->part2.dtd_flags & 4) != 0) {
#line 1020
    mode->flags = mode->flags | 4U;
  } else {

  }
#line 1021
  return;
}
}
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_check_supp_encode(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_encode encode ;
  bool tmp ;

  {
#line 1028
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 157, (void *)(& encode), 2);
#line 1028
  return (tmp);
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_encode(struct psb_intel_sdvo *psb_intel_sdvo , uint8_t mode ) 
{ 
  bool tmp ;

  {
#line 1036
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 159, (void const   *)(& mode), 1);
#line 1036
  return (tmp);
}
}
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_colorimetry(struct psb_intel_sdvo *psb_intel_sdvo ,
                                           uint8_t mode ) 
{ 
  bool tmp ;

  {
#line 1042
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 142, (void const   *)(& mode), 1);
#line 1042
  return (tmp);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_avi_infoframe(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 


  {
#line 1077
  printk("\016[drm] HDMI is not supported yet");
#line 1079
  return (0);
}
}
#line 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_tv_format(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  void *__ret ;
  bool tmp ;

  {
#line 1117
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
#line 1118
  memset((void *)(& format), 0, 6UL);
#line 1119
  _min1 = 6UL;
#line 1119
  _min2 = 4UL;
#line 1119
  __len = _min1 < _min2 ? _min1 : _min2;
#line 1119
  __ret = __builtin_memcpy((void *)(& format), (void const   *)(& format_map), __len);
#line 1122
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 41, (void const   *)(& format), 6);
#line 1122
  return (tmp);
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_output_timings_from_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct drm_display_mode  const  *mode ) 
{ 
  struct psb_intel_sdvo_dtd output_dtd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 1133
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1133
  if (tmp) {
#line 1133
    tmp___0 = 0;
  } else {
#line 1133
    tmp___0 = 1;
  }
#line 1133
  if (tmp___0) {
#line 1135
    return (0);
  } else {

  }
#line 1137
  psb_intel_sdvo_get_dtd_from_mode(& output_dtd, mode);
#line 1138
  tmp___1 = psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & output_dtd);
#line 1138
  if (tmp___1) {
#line 1138
    tmp___2 = 0;
  } else {
#line 1138
    tmp___2 = 1;
  }
#line 1138
  if (tmp___2) {
#line 1139
    return (0);
  } else {

  }
#line 1141
  return (1);
}
}
#line 1145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_set_input_timings_for_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct drm_display_mode  const  *mode ,
                                                      struct drm_display_mode *adjusted_mode ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 1150
  tmp = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 1150
  if (tmp) {
#line 1150
    tmp___0 = 0;
  } else {
#line 1150
    tmp___0 = 1;
  }
#line 1150
  if (tmp___0) {
#line 1151
    return (0);
  } else {

  }
#line 1153
  tmp___1 = psb_intel_sdvo_create_preferred_input_timing(psb_intel_sdvo, (int )((uint16_t )((int )mode->clock / 10)),
                                                         (int )((uint16_t )mode->hdisplay),
                                                         (int )((uint16_t )mode->vdisplay));
#line 1153
  if (tmp___1) {
#line 1153
    tmp___2 = 0;
  } else {
#line 1153
    tmp___2 = 1;
  }
#line 1153
  if (tmp___2) {
#line 1157
    return (0);
  } else {

  }
#line 1159
  tmp___3 = psb_intel_sdvo_get_preferred_input_timing(psb_intel_sdvo, & psb_intel_sdvo->input_dtd);
#line 1159
  if (tmp___3) {
#line 1159
    tmp___4 = 0;
  } else {
#line 1159
    tmp___4 = 1;
  }
#line 1159
  if (tmp___4) {
#line 1161
    return (0);
  } else {

  }
#line 1163
  psb_intel_sdvo_get_mode_from_dtd(adjusted_mode, (struct psb_intel_sdvo_dtd  const  *)(& psb_intel_sdvo->input_dtd));
#line 1165
  drm_mode_set_crtcinfo(adjusted_mode, 0);
#line 1166
  return (1);
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  int multiplier ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 1173
  tmp = to_psb_intel_sdvo(encoder);
#line 1173
  psb_intel_sdvo = tmp;
#line 1181
  if ((int )psb_intel_sdvo->is_tv) {
#line 1182
    tmp___0 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, mode);
#line 1182
    if (tmp___0) {
#line 1182
      tmp___1 = 0;
    } else {
#line 1182
      tmp___1 = 1;
    }
#line 1182
    if (tmp___1) {
#line 1183
      return (0);
    } else {

    }
#line 1185
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else
#line 1188
  if ((int )psb_intel_sdvo->is_lvds) {
#line 1189
    tmp___2 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, (struct drm_display_mode  const  *)psb_intel_sdvo->sdvo_lvds_fixed_mode);
#line 1189
    if (tmp___2) {
#line 1189
      tmp___3 = 0;
    } else {
#line 1189
      tmp___3 = 1;
    }
#line 1189
    if (tmp___3) {
#line 1191
      return (0);
    } else {

    }
#line 1193
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else {

  }
#line 1201
  multiplier = psb_intel_sdvo_get_pixel_multiplier(adjusted_mode);
#line 1202
  psb_intel_mode_set_pixel_multiplier(adjusted_mode, multiplier);
#line 1204
  return (1);
}
}
#line 1207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 sdvox ;
  struct psb_intel_sdvo_in_out_map in_out ;
  struct psb_intel_sdvo_dtd input_dtd ;
  int pixel_multiplier ;
  int tmp___0 ;
  int rate ;
  int need_aux ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
#line 1211
  dev = encoder->dev;
#line 1212
  crtc = encoder->crtc;
#line 1213
  __mptr = (struct drm_crtc  const  *)crtc;
#line 1213
  gma_crtc = (struct gma_crtc *)__mptr;
#line 1214
  tmp = to_psb_intel_sdvo(encoder);
#line 1214
  psb_intel_sdvo = tmp;
#line 1218
  tmp___0 = psb_intel_mode_get_pixel_multiplier((struct drm_display_mode  const  *)adjusted_mode);
#line 1218
  pixel_multiplier = tmp___0;
#line 1220
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 1222
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1223
    return;
  } else {

  }
#line 1231
  in_out.in0 = psb_intel_sdvo->attached_output;
#line 1232
  in_out.in1 = 0U;
#line 1234
  psb_intel_sdvo_set_value(psb_intel_sdvo, 7, (void const   *)(& in_out), 4);
#line 1239
  tmp___1 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1239
  if (tmp___1) {
#line 1239
    tmp___2 = 0;
  } else {
#line 1239
    tmp___2 = 1;
  }
#line 1239
  if (tmp___2) {
#line 1241
    return;
  } else {

  }
#line 1246
  if ((int )psb_intel_sdvo->is_tv || (int )psb_intel_sdvo->is_lvds) {
#line 1247
    input_dtd = psb_intel_sdvo->input_dtd;
  } else {
#line 1250
    tmp___3 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1250
    if (tmp___3) {
#line 1250
      tmp___4 = 0;
    } else {
#line 1250
      tmp___4 = 1;
    }
#line 1250
    if (tmp___4) {
#line 1252
      return;
    } else {

    }
#line 1254
    psb_intel_sdvo_get_dtd_from_mode(& input_dtd, (struct drm_display_mode  const  *)adjusted_mode);
#line 1255
    psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & input_dtd);
  }
#line 1259
  tmp___5 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 1259
  if (tmp___5) {
#line 1259
    tmp___6 = 0;
  } else {
#line 1259
    tmp___6 = 1;
  }
#line 1259
  if (tmp___6) {
#line 1260
    return;
  } else {

  }
#line 1262
  if ((int )psb_intel_sdvo->has_hdmi_monitor) {
#line 1263
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 1);
#line 1264
    psb_intel_sdvo_set_colorimetry(psb_intel_sdvo, 0);
#line 1266
    psb_intel_sdvo_set_avi_infoframe(psb_intel_sdvo);
  } else {
#line 1268
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 0);
  }
#line 1270
  if ((int )psb_intel_sdvo->is_tv) {
#line 1270
    tmp___7 = psb_intel_sdvo_set_tv_format(psb_intel_sdvo);
#line 1270
    if (tmp___7) {
#line 1270
      tmp___8 = 0;
    } else {
#line 1270
      tmp___8 = 1;
    }
#line 1270
    if (tmp___8) {
#line 1272
      return;
    } else {

    }
  } else {

  }
#line 1274
  psb_intel_sdvo_set_input_timing(psb_intel_sdvo, & input_dtd);
#line 1276
  switch (pixel_multiplier) {
  default: ;
  case 1: 
#line 1278
  rate = 1;
#line 1278
  goto ldv_40485;
  case 2: 
#line 1279
  rate = 2;
#line 1279
  goto ldv_40485;
  case 4: 
#line 1280
  rate = 8;
#line 1280
  goto ldv_40485;
  }
  ldv_40485: 
#line 1282
  tmp___9 = psb_intel_sdvo_set_clock_rate_mult(psb_intel_sdvo, (int )((u8 )rate));
#line 1282
  if (tmp___9) {
#line 1282
    tmp___10 = 0;
  } else {
#line 1282
    tmp___10 = 1;
  }
#line 1282
  if (tmp___10) {
#line 1283
    return;
  } else {

  }
#line 1286
  if (need_aux != 0) {
#line 1287
    sdvox = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
  } else {
#line 1289
    sdvox = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
  }
#line 1291
  switch (psb_intel_sdvo->sdvo_reg) {
  case 397632: 
#line 1293
  sdvox = sdvox & 212992U;
#line 1294
  goto ldv_40489;
  case 397664: 
#line 1296
  sdvox = sdvox & 131072U;
#line 1297
  goto ldv_40489;
  }
  ldv_40489: 
#line 1299
  sdvox = sdvox | 4718720U;
#line 1301
  if (gma_crtc->pipe == 1) {
#line 1302
    sdvox = sdvox | 1073741824U;
  } else {

  }
#line 1303
  if ((int )psb_intel_sdvo->has_hdmi_audio) {
#line 1304
    sdvox = sdvox | 64U;
  } else {

  }
#line 1310
  if ((int )((signed char )input_dtd.part2.sdvo_flags) < 0) {
#line 1311
    sdvox = sdvox | 536870912U;
  } else {

  }
#line 1312
  psb_intel_sdvo_write_sdvox(psb_intel_sdvo, sdvox);
#line 1313
  return;
}
}
#line 1315 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 temp ;
  int i ;
  int need_aux ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool input1 ;
  bool input2 ;
  u8 status ;
  bool tmp___3 ;
  long tmp___4 ;

  {
#line 1317
  dev = encoder->dev;
#line 1318
  tmp = to_psb_intel_sdvo(encoder);
#line 1318
  psb_intel_sdvo = tmp;
#line 1321
  need_aux = ((int )(dev->pdev)->device & 65520) == 16640;
#line 1323
  switch (mode) {
  case 0: 
#line 1325
  tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1325
  if (tmp___0 != 0L) {
#line 1325
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS_ON");
  } else {

  }
#line 1326
  goto ldv_40502;
  case 3: 
#line 1328
  tmp___1 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1328
  if (tmp___1 != 0L) {
#line 1328
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS_OFF");
  } else {

  }
#line 1329
  goto ldv_40502;
  default: 
#line 1331
  tmp___2 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 1331
  if (tmp___2 != 0L) {
#line 1331
    drm_ut_debug_printk("psb_intel_sdvo_dpms", "DPMS: %d", mode);
  } else {

  }
  }
  ldv_40502: ;
#line 1334
  if (mode != 0) {
#line 1335
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, 0);
#line 1339
    if (mode == 3) {
#line 1340
      if (need_aux != 0) {
#line 1341
        temp = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
      } else {
#line 1343
        temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
      }
#line 1345
      if ((int )temp < 0) {
#line 1346
        psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp & 2147483647U);
      } else {

      }
    } else {

    }
  } else {
#line 1353
    if (need_aux != 0) {
#line 1354
      temp = REGISTER_READ_AUX(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
    } else {
#line 1356
      temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
    }
#line 1358
    if ((int )temp >= 0) {
#line 1359
      psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp | 2147483648U);
    } else {

    }
#line 1361
    i = 0;
#line 1361
    goto ldv_40509;
    ldv_40508: 
#line 1362
    gma_wait_for_vblank(dev);
#line 1361
    i = i + 1;
    ldv_40509: ;
#line 1361
    if (i <= 1) {
#line 1363
      goto ldv_40508;
    } else {

    }
#line 1364
    tmp___3 = psb_intel_sdvo_get_trained_inputs(psb_intel_sdvo, & input1, & input2);
#line 1364
    status = (u8 )tmp___3;
#line 1369
    if ((unsigned int )status == 1U && ! input1) {
#line 1370
      tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1370
      if (tmp___4 != 0L) {
#line 1370
        drm_ut_debug_printk("psb_intel_sdvo_dpms", "First %s output reported failure to sync\n",
                            psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC");
      } else {

      }
    } else {

    }
#line 1376
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  }
#line 1378
  return;
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static int psb_intel_sdvo_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
#line 1384
  tmp = intel_attached_sdvo(connector);
#line 1384
  psb_intel_sdvo = tmp;
#line 1386
  if ((mode->flags & 32U) != 0U) {
#line 1387
    return (8);
  } else {

  }
#line 1389
  if (psb_intel_sdvo->pixel_clock_min > mode->clock) {
#line 1390
    return (16);
  } else {

  }
#line 1392
  if (psb_intel_sdvo->pixel_clock_max < mode->clock) {
#line 1393
    return (15);
  } else {

  }
#line 1395
  if ((int )psb_intel_sdvo->is_lvds) {
#line 1396
    if (mode->hdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay) {
#line 1397
      return (29);
    } else {

    }
#line 1399
    if (mode->vdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay) {
#line 1400
      return (29);
    } else {

    }
  } else {

  }
#line 1403
  return (0);
}
}
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_get_capabilities(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_caps *caps ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1409
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 2, (void *)caps, 8);
#line 1409
  if (tmp) {
#line 1409
    tmp___0 = 0;
  } else {
#line 1409
    tmp___0 = 1;
  }
#line 1409
  if (tmp___0) {
#line 1412
    return (0);
  } else {

  }
#line 1414
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1414
  if (tmp___1 != 0L) {
#line 1414
    drm_ut_debug_printk("psb_intel_sdvo_get_capabilities", "SDVO capabilities:\n  vendor_id: %d\n  device_id: %d\n  device_rev_id: %d\n  sdvo_version_major: %d\n  sdvo_version_minor: %d\n  sdvo_inputs_mask: %d\n  smooth_scaling: %d\n  sharp_scaling: %d\n  up_scaling: %d\n  down_scaling: %d\n  stall_support: %d\n  output_flags: %d\n",
                        (int )caps->vendor_id, (int )caps->device_id, (int )caps->device_rev_id,
                        (int )caps->sdvo_version_major, (int )caps->sdvo_version_minor,
                        (int )caps->sdvo_inputs_mask, (int )caps->smooth_scaling,
                        (int )caps->sharp_scaling, (int )caps->up_scaling, (int )caps->down_scaling,
                        (int )caps->stall_support, (int )caps->output_flags);
  } else {

  }
#line 1440
  return (1);
}
}
#line 1513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_multifunc_encoder(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 
  int caps ;

  {
#line 1516
  caps = (int )psb_intel_sdvo->caps.output_flags & 15;
#line 1517
  return ((- caps & caps) != 0);
}
}
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct edid *psb_intel_sdvo_get_edid(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *tmp___0 ;

  {
#line 1523
  tmp = intel_attached_sdvo(connector);
#line 1523
  sdvo = tmp;
#line 1524
  tmp___0 = drm_get_edid(connector, & sdvo->ddc);
#line 1524
  return (tmp___0);
}
}
#line 1529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct edid *psb_intel_sdvo_get_analog_edid(struct drm_connector *connector ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct edid *tmp ;

  {
#line 1531
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1533
  tmp = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
#line 1533
  return (tmp);
}
}
#line 1538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static enum drm_connector_status psb_intel_sdvo_hdmi_sink_detect(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  u8 ddc ;
  u8 saved_ddc ;
  bool tmp___0 ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___1 ;

  {
#line 1540
  tmp = intel_attached_sdvo(connector);
#line 1540
  psb_intel_sdvo = tmp;
#line 1544
  edid = psb_intel_sdvo_get_edid(connector);
#line 1546
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1546
    tmp___0 = psb_intel_sdvo_multifunc_encoder(psb_intel_sdvo);
#line 1546
    if ((int )tmp___0) {
#line 1547
      saved_ddc = psb_intel_sdvo->ddc_bus;
#line 1553
      ddc = (u8 )((int )psb_intel_sdvo->ddc_bus >> 1);
#line 1553
      goto ldv_40543;
      ldv_40542: 
#line 1554
      psb_intel_sdvo->ddc_bus = ddc;
#line 1555
      edid = psb_intel_sdvo_get_edid(connector);
#line 1556
      if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1557
        goto ldv_40541;
      } else {

      }
#line 1553
      ddc = (u8 )((int )ddc >> 1);
      ldv_40543: ;
#line 1553
      if ((unsigned int )ddc > 1U) {
#line 1555
        goto ldv_40542;
      } else {

      }
      ldv_40541: ;
#line 1563
      if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1564
        psb_intel_sdvo->ddc_bus = saved_ddc;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1571
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1572
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
#line 1574
  status = 3;
#line 1575
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1577
    if ((int )((signed char )edid->input) < 0) {
#line 1578
      status = 1;
#line 1579
      if ((int )psb_intel_sdvo->is_hdmi) {
#line 1580
        psb_intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);
#line 1581
        psb_intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);
      } else {

      }
    } else {
#line 1584
      status = 2;
    }
#line 1585
    kfree((void const   *)edid);
  } else {

  }
#line 1588
  if ((unsigned int )status == 1U) {
#line 1589
    tmp___1 = to_psb_intel_sdvo_connector(connector);
#line 1589
    psb_intel_sdvo_connector = tmp___1;
#line 1590
    if (psb_intel_sdvo_connector->force_audio != 0) {
#line 1591
      psb_intel_sdvo->has_hdmi_audio = psb_intel_sdvo_connector->force_audio > 0;
    } else {

    }
  } else {

  }
#line 1594
  return (status);
}
}
#line 1598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static enum drm_connector_status psb_intel_sdvo_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 
  uint16_t response ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  enum drm_connector_status ret ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  struct edid *edid ;

  {
#line 1601
  tmp = intel_attached_sdvo(connector);
#line 1601
  psb_intel_sdvo = tmp;
#line 1602
  tmp___0 = to_psb_intel_sdvo_connector(connector);
#line 1602
  psb_intel_sdvo_connector = tmp___0;
#line 1605
  tmp___1 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 11, (void const   *)0, 0);
#line 1605
  if (tmp___1) {
#line 1605
    tmp___2 = 0;
  } else {
#line 1605
    tmp___2 = 1;
  }
#line 1605
  if (tmp___2) {
#line 1607
    return (3);
  } else {

  }
#line 1610
  if (((int )psb_intel_sdvo->caps.output_flags & 12) != 0) {
#line 1612
    __ms = 30UL;
#line 1612
    goto ldv_40555;
    ldv_40554: 
#line 1612
    __const_udelay(4295000UL);
    ldv_40555: 
#line 1612
    tmp___3 = __ms;
#line 1612
    __ms = __ms - 1UL;
#line 1612
    if (tmp___3 != 0UL) {
#line 1614
      goto ldv_40554;
    } else {

    }

  } else {

  }
#line 1614
  tmp___4 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& response), 2);
#line 1614
  if (tmp___4) {
#line 1614
    tmp___5 = 0;
  } else {
#line 1614
    tmp___5 = 1;
  }
#line 1614
  if (tmp___5) {
#line 1615
    return (3);
  } else {

  }
#line 1617
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1617
  if (tmp___6 != 0L) {
#line 1617
    drm_ut_debug_printk("psb_intel_sdvo_detect", "SDVO response %d %d [%x]\n", (int )response & 255,
                        (int )response >> 8, (int )psb_intel_sdvo_connector->output_flag);
  } else {

  }
#line 1621
  if ((unsigned int )response == 0U) {
#line 1622
    return (2);
  } else {

  }
#line 1624
  psb_intel_sdvo->attached_output = response;
#line 1626
  psb_intel_sdvo->has_hdmi_monitor = 0;
#line 1627
  psb_intel_sdvo->has_hdmi_audio = 0;
#line 1629
  if ((unsigned int )((int )psb_intel_sdvo_connector->output_flag & (int )response) == 0U) {
#line 1630
    ret = 2;
  } else
#line 1631
  if (((int )psb_intel_sdvo_connector->output_flag & 257) != 0) {
#line 1632
    ret = psb_intel_sdvo_hdmi_sink_detect(connector);
  } else {
#line 1637
    edid = psb_intel_sdvo_get_edid(connector);
#line 1638
    if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1639
      edid = psb_intel_sdvo_get_analog_edid(connector);
    } else {

    }
#line 1640
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1641
      if ((int )((signed char )edid->input) < 0) {
#line 1642
        ret = 2;
      } else {
#line 1644
        ret = 1;
      }
#line 1645
      kfree((void const   *)edid);
    } else {
#line 1647
      ret = 1;
    }
  }
#line 1651
  if ((unsigned int )ret == 1U) {
#line 1652
    psb_intel_sdvo->is_tv = 0;
#line 1653
    psb_intel_sdvo->is_lvds = 0;
#line 1654
    psb_intel_sdvo->base.needs_tv_clock = 0;
#line 1656
    if (((int )response & 12) != 0) {
#line 1657
      psb_intel_sdvo->is_tv = 1;
#line 1658
      psb_intel_sdvo->base.needs_tv_clock = 1;
    } else {

    }
#line 1660
    if (((int )response & 16448) != 0) {
#line 1661
      psb_intel_sdvo->is_lvds = (unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0);
    } else {

    }
  } else {

  }
#line 1664
  return (ret);
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_get_ddc_modes(struct drm_connector *connector ) 
{ 
  struct edid *edid ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  bool monitor_is_digital ;
  bool connector_is_digital ;

  {
#line 1672
  edid = psb_intel_sdvo_get_edid(connector);
#line 1680
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
#line 1681
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
#line 1683
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1684
    tmp = to_psb_intel_sdvo_connector(connector);
#line 1684
    psb_intel_sdvo_connector = tmp;
#line 1685
    monitor_is_digital = (int )((signed char )edid->input) < 0;
#line 1686
    connector_is_digital = ((int )psb_intel_sdvo_connector->output_flag & 257) != 0;
#line 1688
    if ((int )connector_is_digital == (int )monitor_is_digital) {
#line 1689
      drm_mode_connector_update_edid_property(connector, edid);
#line 1690
      drm_add_edid_modes(connector, edid);
    } else {

    }
#line 1693
    kfree((void const   *)edid);
  } else {

  }
#line 1695
  return;
}
}
#line 1702 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct drm_display_mode  const  sdvo_tv_modes[19U]  = 
#line 1702
  {      {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '0', '0', '\000'}, 0,
      64U, 5815, 320, 321, 384, 416, 0, 200, 201, 232, 233, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '4', '0', '\000'}, 0,
      64U, 6814, 320, 321, 384, 416, 0, 240, 241, 272, 273, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'4', '0', '0', 'x', '3', '0', '0', '\000'}, 0,
      64U, 9910, 400, 401, 464, 496, 0, 300, 301, 332, 333, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 16913, 640, 641, 704, 736, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 19121, 640, 641, 704, 736, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 22654, 640, 641, 704, 736, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '4', '8', '0', '\000'}, 0,
      64U, 24624, 704, 705, 768, 800, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29232, 704, 705, 768, 800, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 18751, 720, 721, 784, 816, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 21199, 720, 721, 784, 816, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 25116, 720, 721, 784, 816, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '4', '0', '\000'}, 0,
      64U, 28054, 720, 721, 784, 816, 0, 540, 541, 572, 573, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29816, 720, 721, 784, 816, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '6', '8', 'x', '5', '7', '6', '\000'}, 0,
      64U, 31570, 768, 769, 832, 864, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0,
      64U, 34030, 800, 801, 864, 896, 0, 600, 601, 632, 633, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '3', '2', 'x', '6', '2', '4', '\000'}, 0,
      64U, 36581, 832, 833, 896, 928, 0, 624, 625, 656, 657, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'9', '2', '0', 'x', '7', '6', '6', '\000'}, 0,
      64U, 48707, 920, 921, 984, 1016, 0, 766, 767, 798, 799, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 53827, 1024, 1025, 1088, 1120, 0, 768, 769, 800, 801, 0, 5U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4',
                                     '\000'}, 0, 64U, 87265, 1280, 1281, 1344, 1376,
      0, 1024, 1025, 1056, 1057, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0}};
#line 1762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_get_tv_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_sdtv_resolution_request tv_res ;
  uint32_t reply ;
  uint32_t format_map ;
  int i ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  void *__ret ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  struct drm_display_mode *nmode ;

  {
#line 1764
  tmp = intel_attached_sdvo(connector);
#line 1764
  psb_intel_sdvo = tmp;
#line 1766
  reply = 0U;
#line 1766
  format_map = 0U;
#line 1772
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
#line 1773
  _min1 = 4UL;
#line 1773
  _min2 = 3UL;
#line 1773
  __len = _min1 < _min2 ? _min1 : _min2;
#line 1773
  __ret = __builtin_memcpy((void *)(& tv_res), (void const   *)(& format_map), __len);
#line 1776
  tmp___0 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
#line 1776
  if (tmp___0) {
#line 1776
    tmp___1 = 0;
  } else {
#line 1776
    tmp___1 = 1;
  }
#line 1776
  if (tmp___1) {
#line 1777
    return;
  } else {

  }
#line 1780
  tmp___2 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 131, (void const   *)(& tv_res),
                                     3);
#line 1780
  if (tmp___2) {
#line 1780
    tmp___3 = 0;
  } else {
#line 1780
    tmp___3 = 1;
  }
#line 1780
  if (tmp___3) {
#line 1783
    return;
  } else {

  }
#line 1784
  tmp___4 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& reply), 3);
#line 1784
  if (tmp___4) {
#line 1784
    tmp___5 = 0;
  } else {
#line 1784
    tmp___5 = 1;
  }
#line 1784
  if (tmp___5) {
#line 1785
    return;
  } else {

  }
#line 1787
  i = 0;
#line 1787
  goto ldv_40588;
  ldv_40587: ;
#line 1788
  if (((uint32_t )(1 << i) & reply) != 0U) {
#line 1790
    nmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)(& sdvo_tv_modes) + (unsigned long )i);
#line 1792
    if ((unsigned long )nmode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1793
      drm_mode_probed_add(connector, nmode);
    } else {

    }
  } else {

  }
#line 1787
  i = i + 1;
  ldv_40588: ;
#line 1787
  if ((unsigned int )i <= 18U) {
#line 1789
    goto ldv_40587;
  } else {

  }

#line 1794
  return;
}
}
#line 1797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_get_lvds_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1799
  tmp = intel_attached_sdvo(connector);
#line 1799
  psb_intel_sdvo = tmp;
#line 1800
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1808
  psb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);
#line 1809
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
#line 1809
  if (tmp___0 == 0) {
#line 1810
    goto end;
  } else {

  }
#line 1813
  if ((unsigned long )dev_priv->sdvo_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1814
    newmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)dev_priv->sdvo_lvds_vbt_mode);
#line 1816
    if ((unsigned long )newmode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1818
      newmode->type = 72U;
#line 1820
      drm_mode_probed_add(connector, newmode);
    } else {

    }
  } else {

  }
  end: 
#line 1825
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 1825
  newmode = (struct drm_display_mode *)__mptr;
#line 1825
  goto ldv_40603;
  ldv_40602: ;
#line 1826
  if ((newmode->type & 8U) != 0U) {
#line 1827
    psb_intel_sdvo->sdvo_lvds_fixed_mode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)newmode);
#line 1830
    drm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode, 0);
#line 1833
    psb_intel_sdvo->is_lvds = 1;
#line 1834
    goto ldv_40601;
  } else {

  }
#line 1825
  __mptr___0 = (struct list_head  const  *)newmode->head.next;
#line 1825
  newmode = (struct drm_display_mode *)__mptr___0;
  ldv_40603: ;
#line 1825
  if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
#line 1827
    goto ldv_40602;
  } else {

  }
  ldv_40601: ;
#line 1832
  return;
}
}
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static int psb_intel_sdvo_get_modes(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  int tmp___0 ;

  {
#line 1842
  tmp = to_psb_intel_sdvo_connector(connector);
#line 1842
  psb_intel_sdvo_connector = tmp;
#line 1844
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
#line 1845
    psb_intel_sdvo_get_tv_modes(connector);
  } else
#line 1846
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
#line 1847
    psb_intel_sdvo_get_lvds_modes(connector);
  } else {
#line 1849
    psb_intel_sdvo_get_ddc_modes(connector);
  }
#line 1851
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
#line 1851
  return (tmp___0 == 0);
}
}
#line 1855 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_destroy_enhance_property(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  struct drm_device *dev ;

  {
#line 1857
  tmp = to_psb_intel_sdvo_connector(connector);
#line 1857
  psb_intel_sdvo_connector = tmp;
#line 1858
  dev = connector->dev;
#line 1860
  if ((unsigned long )psb_intel_sdvo_connector->left != (unsigned long )((struct drm_property *)0)) {
#line 1861
    drm_property_destroy(dev, psb_intel_sdvo_connector->left);
  } else {

  }
#line 1862
  if ((unsigned long )psb_intel_sdvo_connector->right != (unsigned long )((struct drm_property *)0)) {
#line 1863
    drm_property_destroy(dev, psb_intel_sdvo_connector->right);
  } else {

  }
#line 1864
  if ((unsigned long )psb_intel_sdvo_connector->top != (unsigned long )((struct drm_property *)0)) {
#line 1865
    drm_property_destroy(dev, psb_intel_sdvo_connector->top);
  } else {

  }
#line 1866
  if ((unsigned long )psb_intel_sdvo_connector->bottom != (unsigned long )((struct drm_property *)0)) {
#line 1867
    drm_property_destroy(dev, psb_intel_sdvo_connector->bottom);
  } else {

  }
#line 1868
  if ((unsigned long )psb_intel_sdvo_connector->hpos != (unsigned long )((struct drm_property *)0)) {
#line 1869
    drm_property_destroy(dev, psb_intel_sdvo_connector->hpos);
  } else {

  }
#line 1870
  if ((unsigned long )psb_intel_sdvo_connector->vpos != (unsigned long )((struct drm_property *)0)) {
#line 1871
    drm_property_destroy(dev, psb_intel_sdvo_connector->vpos);
  } else {

  }
#line 1872
  if ((unsigned long )psb_intel_sdvo_connector->saturation != (unsigned long )((struct drm_property *)0)) {
#line 1873
    drm_property_destroy(dev, psb_intel_sdvo_connector->saturation);
  } else {

  }
#line 1874
  if ((unsigned long )psb_intel_sdvo_connector->contrast != (unsigned long )((struct drm_property *)0)) {
#line 1875
    drm_property_destroy(dev, psb_intel_sdvo_connector->contrast);
  } else {

  }
#line 1876
  if ((unsigned long )psb_intel_sdvo_connector->hue != (unsigned long )((struct drm_property *)0)) {
#line 1877
    drm_property_destroy(dev, psb_intel_sdvo_connector->hue);
  } else {

  }
#line 1878
  if ((unsigned long )psb_intel_sdvo_connector->sharpness != (unsigned long )((struct drm_property *)0)) {
#line 1879
    drm_property_destroy(dev, psb_intel_sdvo_connector->sharpness);
  } else {

  }
#line 1880
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter != (unsigned long )((struct drm_property *)0)) {
#line 1881
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter);
  } else {

  }
#line 1882
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d != (unsigned long )((struct drm_property *)0)) {
#line 1883
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_2d);
  } else {

  }
#line 1884
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive != (unsigned long )((struct drm_property *)0)) {
#line 1885
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_adaptive);
  } else {

  }
#line 1886
  if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter != (unsigned long )((struct drm_property *)0)) {
#line 1887
    drm_property_destroy(dev, psb_intel_sdvo_connector->tv_luma_filter);
  } else {

  }
#line 1888
  if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter != (unsigned long )((struct drm_property *)0)) {
#line 1889
    drm_property_destroy(dev, psb_intel_sdvo_connector->tv_chroma_filter);
  } else {

  }
#line 1890
  if ((unsigned long )psb_intel_sdvo_connector->dot_crawl != (unsigned long )((struct drm_property *)0)) {
#line 1891
    drm_property_destroy(dev, psb_intel_sdvo_connector->dot_crawl);
  } else {

  }
#line 1892
  if ((unsigned long )psb_intel_sdvo_connector->brightness != (unsigned long )((struct drm_property *)0)) {
#line 1893
    drm_property_destroy(dev, psb_intel_sdvo_connector->brightness);
  } else {

  }
#line 1894
  return;
}
}
#line 1896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_destroy(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;

  {
#line 1898
  tmp = to_psb_intel_sdvo_connector(connector);
#line 1898
  psb_intel_sdvo_connector = tmp;
#line 1900
  if ((unsigned long )psb_intel_sdvo_connector->tv_format != (unsigned long )((struct drm_property *)0)) {
#line 1901
    drm_property_destroy(connector->dev, psb_intel_sdvo_connector->tv_format);
  } else {

  }
#line 1904
  psb_intel_sdvo_destroy_enhance_property(connector);
#line 1905
  drm_sysfs_connector_remove(connector);
#line 1906
  drm_connector_cleanup(connector);
#line 1907
  kfree((void const   *)connector);
#line 1908
  return;
}
}
#line 1910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_detect_hdmi_audio(struct drm_connector *connector ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *edid ;
  bool has_audio ;

  {
#line 1912
  tmp = intel_attached_sdvo(connector);
#line 1912
  psb_intel_sdvo = tmp;
#line 1914
  has_audio = 0;
#line 1916
  if (! psb_intel_sdvo->is_hdmi) {
#line 1917
    return (0);
  } else {

  }
#line 1919
  edid = psb_intel_sdvo_get_edid(connector);
#line 1920
  if ((unsigned long )edid != (unsigned long )((struct edid *)0) && (int )((signed char )edid->input) < 0) {
#line 1921
    has_audio = drm_detect_monitor_audio(edid);
  } else {

  }
#line 1923
  return (has_audio);
}
}
#line 1927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static int psb_intel_sdvo_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t val ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  struct drm_psb_private *dev_priv ;
  uint16_t temp_value ;
  uint8_t cmd ;
  int ret ;
  int i ;
  bool has_audio ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_crtc *crtc ;

  {
#line 1931
  tmp = intel_attached_sdvo(connector);
#line 1931
  psb_intel_sdvo = tmp;
#line 1932
  tmp___0 = to_psb_intel_sdvo_connector(connector);
#line 1932
  psb_intel_sdvo_connector = tmp___0;
#line 1933
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1938
  ret = drm_object_property_set_value(& connector->base, property, val);
#line 1939
  if (ret != 0) {
#line 1940
    return (ret);
  } else {

  }
#line 1942
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
#line 1943
    i = (int )val;
#line 1946
    if (psb_intel_sdvo_connector->force_audio == i) {
#line 1947
      return (0);
    } else {

    }
#line 1949
    psb_intel_sdvo_connector->force_audio = i;
#line 1951
    if (i == 0) {
#line 1952
      has_audio = psb_intel_sdvo_detect_hdmi_audio(connector);
    } else {
#line 1954
      has_audio = i > 0;
    }
#line 1956
    if ((int )psb_intel_sdvo->has_hdmi_audio == (int )has_audio) {
#line 1957
      return (0);
    } else {

    }
#line 1959
    psb_intel_sdvo->has_hdmi_audio = has_audio;
#line 1960
    goto done;
  } else {

  }
#line 1963
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
#line 1964
    if ((uint64_t )(psb_intel_sdvo->color_range != 0U) == val) {
#line 1965
      return (0);
    } else {

    }
#line 1967
    psb_intel_sdvo->color_range = val != 0ULL ? 256U : 0U;
#line 1968
    goto done;
  } else {

  }
#line 1980
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )property) {
#line 1981
    if (val > 18ULL) {
#line 1982
      return (-22);
    } else {

    }
#line 1984
    if (psb_intel_sdvo->tv_format_index == (int )psb_intel_sdvo_connector->tv_format_supported[val]) {
#line 1986
      return (0);
    } else {

    }
#line 1988
    psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[val];
#line 1989
    goto done;
  } else
#line 1990
  if (((int )psb_intel_sdvo_connector->output_flag & 16460) != 0) {
#line 1991
    temp_value = (uint16_t )val;
#line 1992
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )property) {
#line 1993
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->right,
                                    val);
#line 1995
      if (psb_intel_sdvo_connector->left_margin == (u32 )temp_value) {
#line 1996
        return (0);
      } else {

      }
#line 1998
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
#line 1999
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
#line 2000
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
#line 2002
      cmd = 99U;
#line 2003
      goto set_value;
    } else
#line 2004
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )property) {
#line 2005
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->left,
                                    val);
#line 2007
      if (psb_intel_sdvo_connector->right_margin == (u32 )temp_value) {
#line 2008
        return (0);
      } else {

      }
#line 2010
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
#line 2011
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
#line 2012
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
#line 2014
      cmd = 99U;
#line 2015
      goto set_value;
    } else
#line 2016
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )property) {
#line 2017
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->bottom,
                                    val);
#line 2019
      if (psb_intel_sdvo_connector->top_margin == (u32 )temp_value) {
#line 2020
        return (0);
      } else {

      }
#line 2022
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
#line 2023
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
#line 2024
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
#line 2026
      cmd = 102U;
#line 2027
      goto set_value;
    } else
#line 2028
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )property) {
#line 2029
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->top,
                                    val);
#line 2031
      if (psb_intel_sdvo_connector->bottom_margin == (u32 )temp_value) {
#line 2032
        return (0);
      } else {

      }
#line 2034
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
#line 2035
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
#line 2036
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
#line 2038
      cmd = 102U;
#line 2039
      goto set_value;
    } else {

    }
#line 2041
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )property) {
#line 2041
      if (psb_intel_sdvo_connector->cur_hpos == (u32 )temp_value) {
#line 2041
        return (0);
      } else {

      }
#line 2041
      if (psb_intel_sdvo_connector->max_hpos < (u32 )temp_value) {
#line 2041
        return (-22);
      } else {

      }
#line 2041
      cmd = 105U;
#line 2041
      psb_intel_sdvo_connector->cur_hpos = (u32 )temp_value;
#line 2041
      goto set_value;
    } else {

    }
#line 2042
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )property) {
#line 2042
      if (psb_intel_sdvo_connector->cur_vpos == (u32 )temp_value) {
#line 2042
        return (0);
      } else {

      }
#line 2042
      if (psb_intel_sdvo_connector->max_vpos < (u32 )temp_value) {
#line 2042
        return (-22);
      } else {

      }
#line 2042
      cmd = 108U;
#line 2042
      psb_intel_sdvo_connector->cur_vpos = (u32 )temp_value;
#line 2042
      goto set_value;
    } else {

    }
#line 2043
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )property) {
#line 2043
      if (psb_intel_sdvo_connector->cur_saturation == (u32 )temp_value) {
#line 2043
        return (0);
      } else {

      }
#line 2043
      if (psb_intel_sdvo_connector->max_saturation < (u32 )temp_value) {
#line 2043
        return (-22);
      } else {

      }
#line 2043
      cmd = 87U;
#line 2043
      psb_intel_sdvo_connector->cur_saturation = (u32 )temp_value;
#line 2043
      goto set_value;
    } else {

    }
#line 2044
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )property) {
#line 2044
      if (psb_intel_sdvo_connector->cur_contrast == (u32 )temp_value) {
#line 2044
        return (0);
      } else {

      }
#line 2044
      if (psb_intel_sdvo_connector->max_contrast < (u32 )temp_value) {
#line 2044
        return (-22);
      } else {

      }
#line 2044
      cmd = 96U;
#line 2044
      psb_intel_sdvo_connector->cur_contrast = (u32 )temp_value;
#line 2044
      goto set_value;
    } else {

    }
#line 2045
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )property) {
#line 2045
      if (psb_intel_sdvo_connector->cur_hue == (u32 )temp_value) {
#line 2045
        return (0);
      } else {

      }
#line 2045
      if (psb_intel_sdvo_connector->max_hue < (u32 )temp_value) {
#line 2045
        return (-22);
      } else {

      }
#line 2045
      cmd = 90U;
#line 2045
      psb_intel_sdvo_connector->cur_hue = (u32 )temp_value;
#line 2045
      goto set_value;
    } else {

    }
#line 2046
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )property) {
#line 2046
      if (psb_intel_sdvo_connector->cur_brightness == (u32 )temp_value) {
#line 2046
        return (0);
      } else {

      }
#line 2046
      if (psb_intel_sdvo_connector->max_brightness < (u32 )temp_value) {
#line 2046
        return (-22);
      } else {

      }
#line 2046
      cmd = 93U;
#line 2046
      psb_intel_sdvo_connector->cur_brightness = (u32 )temp_value;
#line 2046
      goto set_value;
    } else {

    }
#line 2047
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )property) {
#line 2047
      if (psb_intel_sdvo_connector->cur_sharpness == (u32 )temp_value) {
#line 2047
        return (0);
      } else {

      }
#line 2047
      if (psb_intel_sdvo_connector->max_sharpness < (u32 )temp_value) {
#line 2047
        return (-22);
      } else {

      }
#line 2047
      cmd = 111U;
#line 2047
      psb_intel_sdvo_connector->cur_sharpness = (u32 )temp_value;
#line 2047
      goto set_value;
    } else {

    }
#line 2048
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )property) {
#line 2048
      if (psb_intel_sdvo_connector->cur_flicker_filter == (u32 )temp_value) {
#line 2048
        return (0);
      } else {

      }
#line 2048
      if (psb_intel_sdvo_connector->max_flicker_filter < (u32 )temp_value) {
#line 2048
        return (-22);
      } else {

      }
#line 2048
      cmd = 79U;
#line 2048
      psb_intel_sdvo_connector->cur_flicker_filter = (u32 )temp_value;
#line 2048
      goto set_value;
    } else {

    }
#line 2049
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )property) {
#line 2049
      if (psb_intel_sdvo_connector->cur_flicker_filter_2d == (u32 )temp_value) {
#line 2049
        return (0);
      } else {

      }
#line 2049
      if (psb_intel_sdvo_connector->max_flicker_filter_2d < (u32 )temp_value) {
#line 2049
        return (-22);
      } else {

      }
#line 2049
      cmd = 84U;
#line 2049
      psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )temp_value;
#line 2049
      goto set_value;
    } else {

    }
#line 2050
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )property) {
#line 2050
      if (psb_intel_sdvo_connector->cur_flicker_filter_adaptive == (u32 )temp_value) {
#line 2050
        return (0);
      } else {

      }
#line 2050
      if (psb_intel_sdvo_connector->max_flicker_filter_adaptive < (u32 )temp_value) {
#line 2050
        return (-22);
      } else {

      }
#line 2050
      cmd = 81U;
#line 2050
      psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )temp_value;
#line 2050
      goto set_value;
    } else {

    }
#line 2051
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )property) {
#line 2051
      if (psb_intel_sdvo_connector->cur_tv_chroma_filter == (u32 )temp_value) {
#line 2051
        return (0);
      } else {

      }
#line 2051
      if (psb_intel_sdvo_connector->max_tv_chroma_filter < (u32 )temp_value) {
#line 2051
        return (-22);
      } else {

      }
#line 2051
      cmd = 118U;
#line 2051
      psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )temp_value;
#line 2051
      goto set_value;
    } else {

    }
#line 2052
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )property) {
#line 2052
      if (psb_intel_sdvo_connector->cur_tv_luma_filter == (u32 )temp_value) {
#line 2052
        return (0);
      } else {

      }
#line 2052
      if (psb_intel_sdvo_connector->max_tv_luma_filter < (u32 )temp_value) {
#line 2052
        return (-22);
      } else {

      }
#line 2052
      cmd = 121U;
#line 2052
      psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )temp_value;
#line 2052
      goto set_value;
    } else {

    }
#line 2053
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )property) {
#line 2053
      if (psb_intel_sdvo_connector->cur_dot_crawl == (u32 )temp_value) {
#line 2053
        return (0);
      } else {

      }
#line 2053
      if (psb_intel_sdvo_connector->max_dot_crawl < (u32 )temp_value) {
#line 2053
        return (-22);
      } else {

      }
#line 2053
      cmd = 113U;
#line 2053
      psb_intel_sdvo_connector->cur_dot_crawl = (u32 )temp_value;
#line 2053
      goto set_value;
    } else {

    }
  } else {

  }
#line 2056
  return (-22);
  set_value: 
#line 2059
  tmp___1 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& temp_value),
                                     2);
#line 2059
  if (tmp___1) {
#line 2059
    tmp___2 = 0;
  } else {
#line 2059
    tmp___2 = 1;
  }
#line 2059
  if (tmp___2) {
#line 2060
    return (-5);
  } else {

  }
  done: ;
#line 2064
  if ((unsigned long )psb_intel_sdvo->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
#line 2065
    crtc = psb_intel_sdvo->base.base.crtc;
#line 2066
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (crtc->primary)->fb);
  } else {

  }
#line 2070
  return (0);
}
}
#line 2074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp___0 ;

  {
#line 2076
  dev = connector->dev;
#line 2077
  tmp = gma_attached_encoder(connector);
#line 2077
  gma_encoder = tmp;
#line 2078
  tmp___0 = to_psb_intel_sdvo(& gma_encoder->base);
#line 2078
  sdvo = tmp___0;
#line 2080
  sdvo->saveSDVO = REGISTER_READ(dev, (uint32_t )sdvo->sdvo_reg);
#line 2081
  return;
}
}
#line 2083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp___0 ;
  struct drm_crtc *crtc ;

  {
#line 2085
  dev = connector->dev;
#line 2086
  tmp = gma_attached_encoder(connector);
#line 2086
  encoder = & tmp->base;
#line 2087
  tmp___0 = to_psb_intel_sdvo(encoder);
#line 2087
  sdvo = tmp___0;
#line 2088
  crtc = encoder->crtc;
#line 2090
  REGISTER_WRITE(dev, (uint32_t )sdvo->sdvo_reg, sdvo->saveSDVO);
#line 2094
  if ((unsigned int )connector->status == 1U) {
#line 2095
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (struct drm_framebuffer *)0);
  } else {

  }
#line 2096
  return;
}
}
#line 2099 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct drm_encoder_helper_funcs  const  psb_intel_sdvo_helper_funcs  = 
#line 2099
     {& psb_intel_sdvo_dpms, 0, 0, & psb_intel_sdvo_mode_fixup, & gma_encoder_prepare,
    & gma_encoder_commit, & psb_intel_sdvo_mode_set, 0, 0, 0};
#line 2107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct drm_connector_funcs  const  psb_intel_sdvo_connector_funcs  = 
#line 2107
     {& drm_helper_connector_dpms, & psb_intel_sdvo_save, & psb_intel_sdvo_restore,
    0, & psb_intel_sdvo_detect, & drm_helper_probe_single_connector_modes, & psb_intel_sdvo_set_property,
    & psb_intel_sdvo_destroy, 0};
#line 2117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct drm_connector_helper_funcs  const  psb_intel_sdvo_connector_helper_funcs  =    {& psb_intel_sdvo_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& psb_intel_sdvo_mode_valid),
    & gma_best_encoder};
#line 2123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder ) 
{ 
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
#line 2125
  tmp = to_psb_intel_sdvo(encoder);
#line 2125
  psb_intel_sdvo = tmp;
#line 2127
  if ((unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2128
    drm_mode_destroy(encoder->dev, psb_intel_sdvo->sdvo_lvds_fixed_mode);
  } else {

  }
#line 2131
  i2c_del_adapter(& psb_intel_sdvo->ddc);
#line 2132
  gma_encoder_destroy(encoder);
#line 2133
  return;
}
}
#line 2135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct drm_encoder_funcs  const  psb_intel_sdvo_enc_funcs  =    {0, & psb_intel_sdvo_enc_destroy};
#line 2140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_guess_ddc_bus(struct psb_intel_sdvo *sdvo ) 
{ 


  {
#line 2146
  sdvo->ddc_bus = 2U;
#line 2147
  return;
}
}
#line 2191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_select_ddc_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ 
  struct sdvo_device_mapping *mapping ;

  {
#line 2196
  if (reg == 397632U) {
#line 2197
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
#line 2199
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
#line 2201
  if ((unsigned int )mapping->initialized != 0U) {
#line 2202
    sdvo->ddc_bus = (uint8_t )(1 << ((int )mapping->ddc_pin >> 4));
  } else {
#line 2204
    psb_intel_sdvo_guess_ddc_bus(sdvo);
  }
#line 2205
  return;
}
}
#line 2208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_select_i2c_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ 
  struct sdvo_device_mapping *mapping ;
  u8 pin ;
  u8 speed ;

  {
#line 2214
  if (reg == 397632U) {
#line 2215
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
#line 2217
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
#line 2219
  pin = 5U;
#line 2220
  speed = 3U;
#line 2221
  if ((unsigned int )mapping->initialized != 0U) {
#line 2222
    pin = mapping->i2c_pin;
#line 2223
    speed = mapping->i2c_speed;
  } else {

  }
#line 2226
  if ((unsigned int )pin <= 7U) {
#line 2227
    sdvo->i2c = & (dev_priv->gmbus + (unsigned long )pin)->adapter;
#line 2228
    gma_intel_gmbus_set_speed(sdvo->i2c, (int )speed);
#line 2229
    gma_intel_gmbus_force_bit(sdvo->i2c, 1);
  } else {
#line 2231
    sdvo->i2c = & (dev_priv->gmbus + 5UL)->adapter;
  }
#line 2232
  return;
}
}
#line 2235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_is_hdmi_connector(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             int device ) 
{ 
  bool tmp ;

  {
#line 2237
  tmp = psb_intel_sdvo_check_supp_encode(psb_intel_sdvo);
#line 2237
  return (tmp);
}
}
#line 2241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static u8 psb_intel_sdvo_get_slave_addr(struct drm_device *dev , int sdvo_reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct sdvo_device_mapping *my_mapping ;
  struct sdvo_device_mapping *other_mapping ;

  {
#line 2243
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 2246
  if (sdvo_reg == 397632) {
#line 2247
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
#line 2248
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  } else {
#line 2250
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
#line 2251
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  }
#line 2255
  if ((unsigned int )my_mapping->slave_addr != 0U) {
#line 2256
    return (my_mapping->slave_addr);
  } else {

  }
#line 2261
  if ((unsigned int )other_mapping->slave_addr != 0U) {
#line 2262
    if ((unsigned int )other_mapping->slave_addr == 112U) {
#line 2263
      return (114U);
    } else {
#line 2265
      return (112U);
    }
  } else {

  }
#line 2271
  if (sdvo_reg == 397632) {
#line 2272
    return (112U);
  } else {
#line 2274
    return (114U);
  }
}
}
#line 2278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_connector_init(struct psb_intel_sdvo_connector *connector ,
                                          struct psb_intel_sdvo *encoder ) 
{ 


  {
#line 2281
  drm_connector_init(encoder->base.base.dev, & connector->base.base, & psb_intel_sdvo_connector_funcs,
                     connector->base.base.connector_type);
#line 2286
  drm_connector_helper_add(& connector->base.base, & psb_intel_sdvo_connector_helper_funcs);
#line 2289
  connector->base.base.interlace_allowed = 0;
#line 2290
  connector->base.base.doublescan_allowed = 0;
#line 2291
  connector->base.base.display_info.subpixel_order = 1;
#line 2293
  gma_connector_attach_encoder(& connector->base, & encoder->base);
#line 2294
  drm_sysfs_connector_add(& connector->base.base);
#line 2295
  return;
}
}
#line 2298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static void psb_intel_sdvo_add_hdmi_properties(struct psb_intel_sdvo_connector *connector ) 
{ 


  {
#line 2300
  return;
}
}
#line 2309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_dvi_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 2311
  encoder = & psb_intel_sdvo->base.base;
#line 2316
  tmp = kzalloc(1032UL, 208U);
#line 2316
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2317
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2318
    return (0);
  } else {

  }
#line 2320
  if (device == 0) {
#line 2321
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 1U);
#line 2322
    psb_intel_sdvo_connector->output_flag = 1U;
  } else
#line 2323
  if (device == 1) {
#line 2324
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 256U);
#line 2325
    psb_intel_sdvo_connector->output_flag = 256U;
  } else {

  }
#line 2328
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2329
  connector = & intel_connector->base;
#line 2331
  encoder->encoder_type = 2;
#line 2332
  connector->connector_type = 3;
#line 2334
  tmp___0 = psb_intel_sdvo_is_hdmi_connector(psb_intel_sdvo, device);
#line 2334
  if ((int )tmp___0) {
#line 2335
    connector->connector_type = 11;
#line 2336
    psb_intel_sdvo->is_hdmi = 1;
  } else {

  }
#line 2338
  psb_intel_sdvo->base.clone_mask = 576;
#line 2341
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2342
  if ((int )psb_intel_sdvo->is_hdmi) {
#line 2343
    psb_intel_sdvo_add_hdmi_properties(psb_intel_sdvo_connector);
  } else {

  }
#line 2345
  return (1);
}
}
#line 2349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_tv_init(struct psb_intel_sdvo *psb_intel_sdvo , int type ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2351
  encoder = & psb_intel_sdvo->base.base;
#line 2356
  tmp = kzalloc(1032UL, 208U);
#line 2356
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2357
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2358
    return (0);
  } else {

  }
#line 2360
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2361
  connector = & intel_connector->base;
#line 2362
  encoder->encoder_type = 4;
#line 2363
  connector->connector_type = 6;
#line 2365
  psb_intel_sdvo->controlled_output = (uint16_t )((int )((short )psb_intel_sdvo->controlled_output) | (int )((short )type));
#line 2366
  psb_intel_sdvo_connector->output_flag = (uint16_t )type;
#line 2368
  psb_intel_sdvo->is_tv = 1;
#line 2369
  psb_intel_sdvo->base.needs_tv_clock = 1;
#line 2370
  psb_intel_sdvo->base.clone_mask = 128;
#line 2372
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2374
  tmp___0 = psb_intel_sdvo_tv_create_property(psb_intel_sdvo, psb_intel_sdvo_connector,
                                              type);
#line 2374
  if (tmp___0) {
#line 2374
    tmp___1 = 0;
  } else {
#line 2374
    tmp___1 = 1;
  }
#line 2374
  if (tmp___1) {
#line 2375
    goto err;
  } else {

  }
#line 2377
  tmp___2 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
#line 2377
  if (tmp___2) {
#line 2377
    tmp___3 = 0;
  } else {
#line 2377
    tmp___3 = 1;
  }
#line 2377
  if (tmp___3) {
#line 2378
    goto err;
  } else {

  }
#line 2380
  return (1);
  err: 
#line 2383
  psb_intel_sdvo_destroy(connector);
#line 2384
  return (0);
}
}
#line 2388 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_analog_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;

  {
#line 2390
  encoder = & psb_intel_sdvo->base.base;
#line 2395
  tmp = kzalloc(1032UL, 208U);
#line 2395
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2396
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2397
    return (0);
  } else {

  }
#line 2399
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2400
  connector = & intel_connector->base;
#line 2401
  connector->polled = 2U;
#line 2402
  encoder->encoder_type = 1;
#line 2403
  connector->connector_type = 1;
#line 2405
  if (device == 0) {
#line 2406
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 2U);
#line 2407
    psb_intel_sdvo_connector->output_flag = 2U;
  } else
#line 2408
  if (device == 1) {
#line 2409
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 512U);
#line 2410
    psb_intel_sdvo_connector->output_flag = 512U;
  } else {

  }
#line 2413
  psb_intel_sdvo->base.clone_mask = 576;
#line 2416
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2418
  return (1);
}
}
#line 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_lvds_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ 
  struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct gma_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 2424
  encoder = & psb_intel_sdvo->base.base;
#line 2429
  tmp = kzalloc(1032UL, 208U);
#line 2429
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
#line 2430
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
#line 2431
    return (0);
  } else {

  }
#line 2433
  intel_connector = & psb_intel_sdvo_connector->base;
#line 2434
  connector = & intel_connector->base;
#line 2435
  encoder->encoder_type = 3;
#line 2436
  connector->connector_type = 7;
#line 2438
  if (device == 0) {
#line 2439
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 64U);
#line 2440
    psb_intel_sdvo_connector->output_flag = 64U;
  } else
#line 2441
  if (device == 1) {
#line 2442
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 16384U);
#line 2443
    psb_intel_sdvo_connector->output_flag = 16384U;
  } else {

  }
#line 2446
  psb_intel_sdvo->base.clone_mask = 768;
#line 2449
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
#line 2450
  tmp___0 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
#line 2450
  if (tmp___0) {
#line 2450
    tmp___1 = 0;
  } else {
#line 2450
    tmp___1 = 1;
  }
#line 2450
  if (tmp___1) {
#line 2451
    goto err;
  } else {

  }
#line 2453
  return (1);
  err: 
#line 2456
  psb_intel_sdvo_destroy(connector);
#line 2457
  return (0);
}
}
#line 2461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  unsigned char bytes[2U] ;
  size_t __len ;
  void *__ret ;
  long tmp___15 ;

  {
#line 2463
  psb_intel_sdvo->is_tv = 0;
#line 2464
  psb_intel_sdvo->base.needs_tv_clock = 0;
#line 2465
  psb_intel_sdvo->is_lvds = 0;
#line 2469
  if ((int )flags & 1) {
#line 2470
    tmp = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 0);
#line 2470
    if (tmp) {
#line 2470
      tmp___0 = 0;
    } else {
#line 2470
      tmp___0 = 1;
    }
#line 2470
    if (tmp___0) {
#line 2471
      return (0);
    } else {

    }
  } else {

  }
#line 2473
  if (((int )flags & 257) == 257) {
#line 2474
    tmp___1 = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 1);
#line 2474
    if (tmp___1) {
#line 2474
      tmp___2 = 0;
    } else {
#line 2474
      tmp___2 = 1;
    }
#line 2474
    if (tmp___2) {
#line 2475
      return (0);
    } else {

    }
  } else {

  }
#line 2478
  if (((int )flags & 8) != 0) {
#line 2479
    tmp___3 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 8);
#line 2479
    if (tmp___3) {
#line 2479
      tmp___4 = 0;
    } else {
#line 2479
      tmp___4 = 1;
    }
#line 2479
    if (tmp___4) {
#line 2480
      return (0);
    } else {

    }
  } else {

  }
#line 2482
  if (((int )flags & 4) != 0) {
#line 2483
    tmp___5 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 4);
#line 2483
    if (tmp___5) {
#line 2483
      tmp___6 = 0;
    } else {
#line 2483
      tmp___6 = 1;
    }
#line 2483
    if (tmp___6) {
#line 2484
      return (0);
    } else {

    }
  } else {

  }
#line 2486
  if (((int )flags & 2) != 0) {
#line 2487
    tmp___7 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 0);
#line 2487
    if (tmp___7) {
#line 2487
      tmp___8 = 0;
    } else {
#line 2487
      tmp___8 = 1;
    }
#line 2487
    if (tmp___8) {
#line 2488
      return (0);
    } else {

    }
  } else {

  }
#line 2490
  if (((int )flags & 514) == 514) {
#line 2491
    tmp___9 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 1);
#line 2491
    if (tmp___9) {
#line 2491
      tmp___10 = 0;
    } else {
#line 2491
      tmp___10 = 1;
    }
#line 2491
    if (tmp___10) {
#line 2492
      return (0);
    } else {

    }
  } else {

  }
#line 2494
  if (((int )flags & 64) != 0) {
#line 2495
    tmp___11 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 0);
#line 2495
    if (tmp___11) {
#line 2495
      tmp___12 = 0;
    } else {
#line 2495
      tmp___12 = 1;
    }
#line 2495
    if (tmp___12) {
#line 2496
      return (0);
    } else {

    }
  } else {

  }
#line 2498
  if (((int )flags & 16448) == 16448) {
#line 2499
    tmp___13 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 1);
#line 2499
    if (tmp___13) {
#line 2499
      tmp___14 = 0;
    } else {
#line 2499
      tmp___14 = 1;
    }
#line 2499
    if (tmp___14) {
#line 2500
      return (0);
    } else {

    }
  } else {

  }
#line 2502
  if (((int )flags & 17231) == 0) {
#line 2505
    psb_intel_sdvo->controlled_output = 0U;
#line 2506
    __len = 2UL;
#line 2506
    if (__len > 63UL) {
#line 2506
      __ret = __memcpy((void *)(& bytes), (void const   *)(& psb_intel_sdvo->caps.output_flags),
                       __len);
    } else {
#line 2506
      __ret = __builtin_memcpy((void *)(& bytes), (void const   *)(& psb_intel_sdvo->caps.output_flags),
                               __len);
    }
#line 2507
    tmp___15 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2507
    if (tmp___15 != 0L) {
#line 2507
      drm_ut_debug_printk("psb_intel_sdvo_output_setup", "%s: Unknown SDVO output type (0x%02x%02x)\n",
                          psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                          (int )bytes[0], (int )bytes[1]);
    } else {

    }
#line 2510
    return (0);
  } else {

  }
#line 2512
  psb_intel_sdvo->base.crtc_mask = 3;
#line 2514
  return (1);
}
}
#line 2517 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) 
{ 
  struct drm_device *dev ;
  struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  uint32_t i ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  void *__ret ;
  int tmp___3 ;

  {
#line 2521
  dev = psb_intel_sdvo->base.base.dev;
#line 2525
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )((u16 )type));
#line 2525
  if (tmp) {
#line 2525
    tmp___0 = 0;
  } else {
#line 2525
    tmp___0 = 1;
  }
#line 2525
  if (tmp___0) {
#line 2526
    return (0);
  } else {

  }
#line 2529
  tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 39, (void *)(& format), 6);
#line 2529
  if (tmp___1) {
#line 2529
    tmp___2 = 0;
  } else {
#line 2529
    tmp___2 = 1;
  }
#line 2529
  if (tmp___2) {
#line 2532
    return (0);
  } else {

  }
#line 2534
  _min1 = 4UL;
#line 2534
  _min2 = 6UL;
#line 2534
  __len = _min1 < _min2 ? _min1 : _min2;
#line 2534
  __ret = __builtin_memcpy((void *)(& format_map), (void const   *)(& format), __len);
#line 2536
  if (format_map == 0U) {
#line 2537
    return (0);
  } else {

  }
#line 2539
  psb_intel_sdvo_connector->format_supported_num = 0;
#line 2540
  i = 0U;
#line 2540
  goto ldv_40757;
  ldv_40756: ;
#line 2541
  if (((uint32_t )(1 << (int )i) & format_map) != 0U) {
#line 2542
    tmp___3 = psb_intel_sdvo_connector->format_supported_num;
#line 2542
    psb_intel_sdvo_connector->format_supported_num = psb_intel_sdvo_connector->format_supported_num + 1;
#line 2542
    psb_intel_sdvo_connector->tv_format_supported[tmp___3] = (u8 )i;
  } else {

  }
#line 2540
  i = i + 1U;
  ldv_40757: ;
#line 2540
  if (i <= 18U) {
#line 2542
    goto ldv_40756;
  } else {

  }
#line 2545
  psb_intel_sdvo_connector->tv_format = drm_property_create(dev, 8, "mode", psb_intel_sdvo_connector->format_supported_num);
#line 2548
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )((struct drm_property *)0)) {
#line 2549
    return (0);
  } else {

  }
#line 2551
  i = 0U;
#line 2551
  goto ldv_40760;
  ldv_40759: 
#line 2552
  drm_property_add_enum(psb_intel_sdvo_connector->tv_format, (int )i, (uint64_t )i,
                        tv_format_names[(int )psb_intel_sdvo_connector->tv_format_supported[i]]);
#line 2551
  i = i + 1U;
  ldv_40760: ;
#line 2551
  if ((uint32_t )psb_intel_sdvo_connector->format_supported_num > i) {
#line 2553
    goto ldv_40759;
  } else {

  }
#line 2556
  psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[0];
#line 2557
  drm_object_attach_property(& psb_intel_sdvo_connector->base.base.base, psb_intel_sdvo_connector->tv_format,
                             0ULL);
#line 2559
  return (1);
}
}
#line 2582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_create_enhance_property_tv(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                      struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ 
  struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;
  bool tmp___24 ;
  int tmp___25 ;
  bool tmp___26 ;
  int tmp___27 ;
  long tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  bool tmp___31 ;
  int tmp___32 ;
  long tmp___33 ;
  bool tmp___34 ;
  int tmp___35 ;
  bool tmp___36 ;
  int tmp___37 ;
  long tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  bool tmp___41 ;
  int tmp___42 ;
  long tmp___43 ;
  bool tmp___44 ;
  int tmp___45 ;
  bool tmp___46 ;
  int tmp___47 ;
  long tmp___48 ;
  bool tmp___49 ;
  int tmp___50 ;
  bool tmp___51 ;
  int tmp___52 ;
  long tmp___53 ;
  bool tmp___54 ;
  int tmp___55 ;
  bool tmp___56 ;
  int tmp___57 ;
  long tmp___58 ;
  bool tmp___59 ;
  int tmp___60 ;
  bool tmp___61 ;
  int tmp___62 ;
  long tmp___63 ;
  bool tmp___64 ;
  int tmp___65 ;
  bool tmp___66 ;
  int tmp___67 ;
  long tmp___68 ;
  bool tmp___69 ;
  int tmp___70 ;
  long tmp___71 ;

  {
#line 2586
  dev = psb_intel_sdvo->base.base.dev;
#line 2587
  connector = & psb_intel_sdvo_connector->base.base;
#line 2591
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2592
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 97, (void *)(& data_value), 4);
#line 2592
    if (tmp) {
#line 2592
      tmp___0 = 0;
    } else {
#line 2592
      tmp___0 = 1;
    }
#line 2592
    if (tmp___0) {
#line 2595
      return (0);
    } else {

    }
#line 2597
    tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 98, (void *)(& response), 2);
#line 2597
    if (tmp___1) {
#line 2597
      tmp___2 = 0;
    } else {
#line 2597
      tmp___2 = 1;
    }
#line 2597
    if (tmp___2) {
#line 2600
      return (0);
    } else {

    }
#line 2602
    psb_intel_sdvo_connector->max_hscan = (u32 )data_value[0];
#line 2603
    psb_intel_sdvo_connector->left_margin = (u32 )((int )data_value[0] - (int )response);
#line 2604
    psb_intel_sdvo_connector->right_margin = psb_intel_sdvo_connector->left_margin;
#line 2605
    psb_intel_sdvo_connector->left = drm_property_create_range(dev, 0, "left_margin",
                                                               0ULL, (uint64_t )data_value[0]);
#line 2607
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )((struct drm_property *)0)) {
#line 2608
      return (0);
    } else {

    }
#line 2610
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->left,
                               (uint64_t )psb_intel_sdvo_connector->left_margin);
#line 2614
    psb_intel_sdvo_connector->right = drm_property_create_range(dev, 0, "right_margin",
                                                                0ULL, (uint64_t )data_value[0]);
#line 2616
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )((struct drm_property *)0)) {
#line 2617
      return (0);
    } else {

    }
#line 2619
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->right,
                               (uint64_t )psb_intel_sdvo_connector->right_margin);
#line 2622
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2622
    if (tmp___3 != 0L) {
#line 2622
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "h_overscan: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2627
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2628
    tmp___4 = psb_intel_sdvo_get_value(psb_intel_sdvo, 100, (void *)(& data_value),
                                       4);
#line 2628
    if (tmp___4) {
#line 2628
      tmp___5 = 0;
    } else {
#line 2628
      tmp___5 = 1;
    }
#line 2628
    if (tmp___5) {
#line 2631
      return (0);
    } else {

    }
#line 2633
    tmp___6 = psb_intel_sdvo_get_value(psb_intel_sdvo, 101, (void *)(& response),
                                       2);
#line 2633
    if (tmp___6) {
#line 2633
      tmp___7 = 0;
    } else {
#line 2633
      tmp___7 = 1;
    }
#line 2633
    if (tmp___7) {
#line 2636
      return (0);
    } else {

    }
#line 2638
    psb_intel_sdvo_connector->max_vscan = (u32 )data_value[0];
#line 2639
    psb_intel_sdvo_connector->top_margin = (u32 )((int )data_value[0] - (int )response);
#line 2640
    psb_intel_sdvo_connector->bottom_margin = psb_intel_sdvo_connector->top_margin;
#line 2641
    psb_intel_sdvo_connector->top = drm_property_create_range(dev, 0, "top_margin",
                                                              0ULL, (uint64_t )data_value[0]);
#line 2643
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )((struct drm_property *)0)) {
#line 2644
      return (0);
    } else {

    }
#line 2646
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->top, (uint64_t )psb_intel_sdvo_connector->top_margin);
#line 2650
    psb_intel_sdvo_connector->bottom = drm_property_create_range(dev, 0, "bottom_margin",
                                                                 0ULL, (uint64_t )data_value[0]);
#line 2652
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )((struct drm_property *)0)) {
#line 2653
      return (0);
    } else {

    }
#line 2655
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->bottom,
                               (uint64_t )psb_intel_sdvo_connector->bottom_margin);
#line 2658
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2658
    if (tmp___8 != 0L) {
#line 2658
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "v_overscan: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2663
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2663
    tmp___9 = psb_intel_sdvo_get_value(psb_intel_sdvo, 103, (void *)(& data_value),
                                       4);
#line 2663
    if (tmp___9) {
#line 2663
      tmp___10 = 0;
    } else {
#line 2663
      tmp___10 = 1;
    }
#line 2663
    if (tmp___10) {
#line 2663
      return (0);
    } else {
#line 2663
      tmp___11 = psb_intel_sdvo_get_value(psb_intel_sdvo, 104, (void *)(& response),
                                          2);
#line 2663
      if (tmp___11) {
#line 2663
        tmp___12 = 0;
      } else {
#line 2663
        tmp___12 = 1;
      }
#line 2663
      if (tmp___12) {
#line 2663
        return (0);
      } else {

      }
    }
#line 2663
    psb_intel_sdvo_connector->max_hpos = (u32 )data_value[0];
#line 2663
    psb_intel_sdvo_connector->cur_hpos = (u32 )response;
#line 2663
    psb_intel_sdvo_connector->hpos = drm_property_create_range(dev, 0, "hpos", 0ULL,
                                                               (uint64_t )data_value[0]);
#line 2663
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )((struct drm_property *)0)) {
#line 2663
      return (0);
    } else {

    }
#line 2663
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_hpos);
#line 2663
    tmp___13 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2663
    if (tmp___13 != 0L) {
#line 2663
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "hpos: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2664
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2664
    tmp___14 = psb_intel_sdvo_get_value(psb_intel_sdvo, 106, (void *)(& data_value),
                                        4);
#line 2664
    if (tmp___14) {
#line 2664
      tmp___15 = 0;
    } else {
#line 2664
      tmp___15 = 1;
    }
#line 2664
    if (tmp___15) {
#line 2664
      return (0);
    } else {
#line 2664
      tmp___16 = psb_intel_sdvo_get_value(psb_intel_sdvo, 107, (void *)(& response),
                                          2);
#line 2664
      if (tmp___16) {
#line 2664
        tmp___17 = 0;
      } else {
#line 2664
        tmp___17 = 1;
      }
#line 2664
      if (tmp___17) {
#line 2664
        return (0);
      } else {

      }
    }
#line 2664
    psb_intel_sdvo_connector->max_vpos = (u32 )data_value[0];
#line 2664
    psb_intel_sdvo_connector->cur_vpos = (u32 )response;
#line 2664
    psb_intel_sdvo_connector->vpos = drm_property_create_range(dev, 0, "vpos", 0ULL,
                                                               (uint64_t )data_value[0]);
#line 2664
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )((struct drm_property *)0)) {
#line 2664
      return (0);
    } else {

    }
#line 2664
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->vpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_vpos);
#line 2664
    tmp___18 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2664
    if (tmp___18 != 0L) {
#line 2664
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "vpos: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2665
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2665
    tmp___19 = psb_intel_sdvo_get_value(psb_intel_sdvo, 85, (void *)(& data_value),
                                        4);
#line 2665
    if (tmp___19) {
#line 2665
      tmp___20 = 0;
    } else {
#line 2665
      tmp___20 = 1;
    }
#line 2665
    if (tmp___20) {
#line 2665
      return (0);
    } else {
#line 2665
      tmp___21 = psb_intel_sdvo_get_value(psb_intel_sdvo, 86, (void *)(& response),
                                          2);
#line 2665
      if (tmp___21) {
#line 2665
        tmp___22 = 0;
      } else {
#line 2665
        tmp___22 = 1;
      }
#line 2665
      if (tmp___22) {
#line 2665
        return (0);
      } else {

      }
    }
#line 2665
    psb_intel_sdvo_connector->max_saturation = (u32 )data_value[0];
#line 2665
    psb_intel_sdvo_connector->cur_saturation = (u32 )response;
#line 2665
    psb_intel_sdvo_connector->saturation = drm_property_create_range(dev, 0, "saturation",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2665
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )((struct drm_property *)0)) {
#line 2665
      return (0);
    } else {

    }
#line 2665
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->saturation,
                               (uint64_t )psb_intel_sdvo_connector->cur_saturation);
#line 2665
    tmp___23 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2665
    if (tmp___23 != 0L) {
#line 2665
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "saturation: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2666
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2666
    tmp___24 = psb_intel_sdvo_get_value(psb_intel_sdvo, 94, (void *)(& data_value),
                                        4);
#line 2666
    if (tmp___24) {
#line 2666
      tmp___25 = 0;
    } else {
#line 2666
      tmp___25 = 1;
    }
#line 2666
    if (tmp___25) {
#line 2666
      return (0);
    } else {
#line 2666
      tmp___26 = psb_intel_sdvo_get_value(psb_intel_sdvo, 95, (void *)(& response),
                                          2);
#line 2666
      if (tmp___26) {
#line 2666
        tmp___27 = 0;
      } else {
#line 2666
        tmp___27 = 1;
      }
#line 2666
      if (tmp___27) {
#line 2666
        return (0);
      } else {

      }
    }
#line 2666
    psb_intel_sdvo_connector->max_contrast = (u32 )data_value[0];
#line 2666
    psb_intel_sdvo_connector->cur_contrast = (u32 )response;
#line 2666
    psb_intel_sdvo_connector->contrast = drm_property_create_range(dev, 0, "contrast",
                                                                   0ULL, (uint64_t )data_value[0]);
#line 2666
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )((struct drm_property *)0)) {
#line 2666
      return (0);
    } else {

    }
#line 2666
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->contrast,
                               (uint64_t )psb_intel_sdvo_connector->cur_contrast);
#line 2666
    tmp___28 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2666
    if (tmp___28 != 0L) {
#line 2666
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "contrast: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2667
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2667
    tmp___29 = psb_intel_sdvo_get_value(psb_intel_sdvo, 88, (void *)(& data_value),
                                        4);
#line 2667
    if (tmp___29) {
#line 2667
      tmp___30 = 0;
    } else {
#line 2667
      tmp___30 = 1;
    }
#line 2667
    if (tmp___30) {
#line 2667
      return (0);
    } else {
#line 2667
      tmp___31 = psb_intel_sdvo_get_value(psb_intel_sdvo, 89, (void *)(& response),
                                          2);
#line 2667
      if (tmp___31) {
#line 2667
        tmp___32 = 0;
      } else {
#line 2667
        tmp___32 = 1;
      }
#line 2667
      if (tmp___32) {
#line 2667
        return (0);
      } else {

      }
    }
#line 2667
    psb_intel_sdvo_connector->max_hue = (u32 )data_value[0];
#line 2667
    psb_intel_sdvo_connector->cur_hue = (u32 )response;
#line 2667
    psb_intel_sdvo_connector->hue = drm_property_create_range(dev, 0, "hue", 0ULL,
                                                              (uint64_t )data_value[0]);
#line 2667
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )((struct drm_property *)0)) {
#line 2667
      return (0);
    } else {

    }
#line 2667
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hue, (uint64_t )psb_intel_sdvo_connector->cur_hue);
#line 2667
    tmp___33 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2667
    if (tmp___33 != 0L) {
#line 2667
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "hue: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2668
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2668
    tmp___34 = psb_intel_sdvo_get_value(psb_intel_sdvo, 109, (void *)(& data_value),
                                        4);
#line 2668
    if (tmp___34) {
#line 2668
      tmp___35 = 0;
    } else {
#line 2668
      tmp___35 = 1;
    }
#line 2668
    if (tmp___35) {
#line 2668
      return (0);
    } else {
#line 2668
      tmp___36 = psb_intel_sdvo_get_value(psb_intel_sdvo, 110, (void *)(& response),
                                          2);
#line 2668
      if (tmp___36) {
#line 2668
        tmp___37 = 0;
      } else {
#line 2668
        tmp___37 = 1;
      }
#line 2668
      if (tmp___37) {
#line 2668
        return (0);
      } else {

      }
    }
#line 2668
    psb_intel_sdvo_connector->max_sharpness = (u32 )data_value[0];
#line 2668
    psb_intel_sdvo_connector->cur_sharpness = (u32 )response;
#line 2668
    psb_intel_sdvo_connector->sharpness = drm_property_create_range(dev, 0, "sharpness",
                                                                    0ULL, (uint64_t )data_value[0]);
#line 2668
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )((struct drm_property *)0)) {
#line 2668
      return (0);
    } else {

    }
#line 2668
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->sharpness,
                               (uint64_t )psb_intel_sdvo_connector->cur_sharpness);
#line 2668
    tmp___38 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2668
    if (tmp___38 != 0L) {
#line 2668
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "sharpness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2669
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2669
    tmp___39 = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value),
                                        4);
#line 2669
    if (tmp___39) {
#line 2669
      tmp___40 = 0;
    } else {
#line 2669
      tmp___40 = 1;
    }
#line 2669
    if (tmp___40) {
#line 2669
      return (0);
    } else {
#line 2669
      tmp___41 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                          2);
#line 2669
      if (tmp___41) {
#line 2669
        tmp___42 = 0;
      } else {
#line 2669
        tmp___42 = 1;
      }
#line 2669
      if (tmp___42) {
#line 2669
        return (0);
      } else {

      }
    }
#line 2669
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
#line 2669
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
#line 2669
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2669
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
#line 2669
      return (0);
    } else {

    }
#line 2669
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
#line 2669
    tmp___43 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2669
    if (tmp___43 != 0L) {
#line 2669
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "brightness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2670
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2670
    tmp___44 = psb_intel_sdvo_get_value(psb_intel_sdvo, 77, (void *)(& data_value),
                                        4);
#line 2670
    if (tmp___44) {
#line 2670
      tmp___45 = 0;
    } else {
#line 2670
      tmp___45 = 1;
    }
#line 2670
    if (tmp___45) {
#line 2670
      return (0);
    } else {
#line 2670
      tmp___46 = psb_intel_sdvo_get_value(psb_intel_sdvo, 78, (void *)(& response),
                                          2);
#line 2670
      if (tmp___46) {
#line 2670
        tmp___47 = 0;
      } else {
#line 2670
        tmp___47 = 1;
      }
#line 2670
      if (tmp___47) {
#line 2670
        return (0);
      } else {

      }
    }
#line 2670
    psb_intel_sdvo_connector->max_flicker_filter = (u32 )data_value[0];
#line 2670
    psb_intel_sdvo_connector->cur_flicker_filter = (u32 )response;
#line 2670
    psb_intel_sdvo_connector->flicker_filter = drm_property_create_range(dev, 0, "flicker_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
#line 2670
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )((struct drm_property *)0)) {
#line 2670
      return (0);
    } else {

    }
#line 2670
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter);
#line 2670
    tmp___48 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2670
    if (tmp___48 != 0L) {
#line 2670
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2671
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2671
    tmp___49 = psb_intel_sdvo_get_value(psb_intel_sdvo, 123, (void *)(& data_value),
                                        4);
#line 2671
    if (tmp___49) {
#line 2671
      tmp___50 = 0;
    } else {
#line 2671
      tmp___50 = 1;
    }
#line 2671
    if (tmp___50) {
#line 2671
      return (0);
    } else {
#line 2671
      tmp___51 = psb_intel_sdvo_get_value(psb_intel_sdvo, 80, (void *)(& response),
                                          2);
#line 2671
      if (tmp___51) {
#line 2671
        tmp___52 = 0;
      } else {
#line 2671
        tmp___52 = 1;
      }
#line 2671
      if (tmp___52) {
#line 2671
        return (0);
      } else {

      }
    }
#line 2671
    psb_intel_sdvo_connector->max_flicker_filter_adaptive = (u32 )data_value[0];
#line 2671
    psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )response;
#line 2671
    psb_intel_sdvo_connector->flicker_filter_adaptive = drm_property_create_range(dev,
                                                                                  0,
                                                                                  "flicker_filter_adaptive",
                                                                                  0ULL,
                                                                                  (uint64_t )data_value[0]);
#line 2671
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )((struct drm_property *)0)) {
#line 2671
      return (0);
    } else {

    }
#line 2671
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_adaptive,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_adaptive);
#line 2671
    tmp___53 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2671
    if (tmp___53 != 0L) {
#line 2671
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_adaptive: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2672
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2672
    tmp___54 = psb_intel_sdvo_get_value(psb_intel_sdvo, 82, (void *)(& data_value),
                                        4);
#line 2672
    if (tmp___54) {
#line 2672
      tmp___55 = 0;
    } else {
#line 2672
      tmp___55 = 1;
    }
#line 2672
    if (tmp___55) {
#line 2672
      return (0);
    } else {
#line 2672
      tmp___56 = psb_intel_sdvo_get_value(psb_intel_sdvo, 83, (void *)(& response),
                                          2);
#line 2672
      if (tmp___56) {
#line 2672
        tmp___57 = 0;
      } else {
#line 2672
        tmp___57 = 1;
      }
#line 2672
      if (tmp___57) {
#line 2672
        return (0);
      } else {

      }
    }
#line 2672
    psb_intel_sdvo_connector->max_flicker_filter_2d = (u32 )data_value[0];
#line 2672
    psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )response;
#line 2672
    psb_intel_sdvo_connector->flicker_filter_2d = drm_property_create_range(dev, 0,
                                                                            "flicker_filter_2d",
                                                                            0ULL,
                                                                            (uint64_t )data_value[0]);
#line 2672
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )((struct drm_property *)0)) {
#line 2672
      return (0);
    } else {

    }
#line 2672
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_2d,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_2d);
#line 2672
    tmp___58 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2672
    if (tmp___58 != 0L) {
#line 2672
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_2d: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2673
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2673
    tmp___59 = psb_intel_sdvo_get_value(psb_intel_sdvo, 116, (void *)(& data_value),
                                        4);
#line 2673
    if (tmp___59) {
#line 2673
      tmp___60 = 0;
    } else {
#line 2673
      tmp___60 = 1;
    }
#line 2673
    if (tmp___60) {
#line 2673
      return (0);
    } else {
#line 2673
      tmp___61 = psb_intel_sdvo_get_value(psb_intel_sdvo, 117, (void *)(& response),
                                          2);
#line 2673
      if (tmp___61) {
#line 2673
        tmp___62 = 0;
      } else {
#line 2673
        tmp___62 = 1;
      }
#line 2673
      if (tmp___62) {
#line 2673
        return (0);
      } else {

      }
    }
#line 2673
    psb_intel_sdvo_connector->max_tv_chroma_filter = (u32 )data_value[0];
#line 2673
    psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )response;
#line 2673
    psb_intel_sdvo_connector->tv_chroma_filter = drm_property_create_range(dev, 0,
                                                                           "tv_chroma_filter",
                                                                           0ULL, (uint64_t )data_value[0]);
#line 2673
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )((struct drm_property *)0)) {
#line 2673
      return (0);
    } else {

    }
#line 2673
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_chroma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_chroma_filter);
#line 2673
    tmp___63 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2673
    if (tmp___63 != 0L) {
#line 2673
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "tv_chroma_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2674
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2674
    tmp___64 = psb_intel_sdvo_get_value(psb_intel_sdvo, 119, (void *)(& data_value),
                                        4);
#line 2674
    if (tmp___64) {
#line 2674
      tmp___65 = 0;
    } else {
#line 2674
      tmp___65 = 1;
    }
#line 2674
    if (tmp___65) {
#line 2674
      return (0);
    } else {
#line 2674
      tmp___66 = psb_intel_sdvo_get_value(psb_intel_sdvo, 120, (void *)(& response),
                                          2);
#line 2674
      if (tmp___66) {
#line 2674
        tmp___67 = 0;
      } else {
#line 2674
        tmp___67 = 1;
      }
#line 2674
      if (tmp___67) {
#line 2674
        return (0);
      } else {

      }
    }
#line 2674
    psb_intel_sdvo_connector->max_tv_luma_filter = (u32 )data_value[0];
#line 2674
    psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )response;
#line 2674
    psb_intel_sdvo_connector->tv_luma_filter = drm_property_create_range(dev, 0, "tv_luma_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
#line 2674
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )((struct drm_property *)0)) {
#line 2674
      return (0);
    } else {

    }
#line 2674
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_luma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_luma_filter);
#line 2674
    tmp___68 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2674
    if (tmp___68 != 0L) {
#line 2674
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "tv_luma_filter: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2676
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
#line 2677
    tmp___69 = psb_intel_sdvo_get_value(psb_intel_sdvo, 112, (void *)(& response),
                                        2);
#line 2677
    if (tmp___69) {
#line 2677
      tmp___70 = 0;
    } else {
#line 2677
      tmp___70 = 1;
    }
#line 2677
    if (tmp___70) {
#line 2678
      return (0);
    } else {

    }
#line 2680
    psb_intel_sdvo_connector->max_dot_crawl = 1U;
#line 2681
    psb_intel_sdvo_connector->cur_dot_crawl = (u32 )response & 1U;
#line 2682
    psb_intel_sdvo_connector->dot_crawl = drm_property_create_range(dev, 0, "dot_crawl",
                                                                    0ULL, 1ULL);
#line 2684
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )((struct drm_property *)0)) {
#line 2685
      return (0);
    } else {

    }
#line 2687
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->dot_crawl,
                               (uint64_t )psb_intel_sdvo_connector->cur_dot_crawl);
#line 2690
    tmp___71 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2690
    if (tmp___71 != 0L) {
#line 2690
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_tv", "dot crawl: current %d\n",
                          (int )response);
    } else {

    }
  } else {

  }
#line 2693
  return (1);
}
}
#line 2697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_create_enhance_property_lvds(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                        struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ 
  struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 2701
  dev = psb_intel_sdvo->base.base.dev;
#line 2702
  connector = & psb_intel_sdvo_connector->base.base;
#line 2705
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
#line 2705
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value), 4);
#line 2705
    if (tmp) {
#line 2705
      tmp___0 = 0;
    } else {
#line 2705
      tmp___0 = 1;
    }
#line 2705
    if (tmp___0) {
#line 2705
      return (0);
    } else {
#line 2705
      tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                         2);
#line 2705
      if (tmp___1) {
#line 2705
        tmp___2 = 0;
      } else {
#line 2705
        tmp___2 = 1;
      }
#line 2705
      if (tmp___2) {
#line 2705
        return (0);
      } else {

      }
    }
#line 2705
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
#line 2705
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
#line 2705
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
#line 2705
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
#line 2705
      return (0);
    } else {

    }
#line 2705
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
#line 2705
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2705
    if (tmp___3 != 0L) {
#line 2705
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property_lvds", "brightness: max %d, default %d, current %d\n",
                          (int )data_value[0], (int )data_value[1], (int )response);
    } else {

    }
  } else {

  }
#line 2707
  return (1);
}
}
#line 2711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) 
{ 
  union __anonunion_enhancements_227 enhancements ;
  long tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2721
  enhancements.response = 0U;
#line 2722
  psb_intel_sdvo_get_value(psb_intel_sdvo, 132, (void *)(& enhancements), 2);
#line 2725
  if ((unsigned int )enhancements.response == 0U) {
#line 2726
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2726
    if (tmp != 0L) {
#line 2726
      drm_ut_debug_printk("psb_intel_sdvo_create_enhance_property", "No enhancement is supported\n");
    } else {

    }
#line 2727
    return (1);
  } else {

  }
#line 2730
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
#line 2731
    tmp___0 = psb_intel_sdvo_create_enhance_property_tv(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                        enhancements.reply);
#line 2731
    return (tmp___0);
  } else
#line 2732
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
#line 2733
    tmp___1 = psb_intel_sdvo_create_enhance_property_lvds(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                          enhancements.reply);
#line 2733
    return (tmp___1);
  } else {
#line 2735
    return (1);
  }
}
}
#line 2738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static int psb_intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs ,
                                         int num ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2742
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
#line 2744
  tmp = psb_intel_sdvo_set_control_bus_switch(sdvo, (int )sdvo->ddc_bus);
#line 2744
  if (tmp) {
#line 2744
    tmp___0 = 0;
  } else {
#line 2744
    tmp___0 = 1;
  }
#line 2744
  if (tmp___0) {
#line 2745
    return (-5);
  } else {

  }
#line 2747
  tmp___1 = (*(((sdvo->i2c)->algo)->master_xfer))(sdvo->i2c, msgs, num);
#line 2747
  return (tmp___1);
}
}
#line 2750 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static u32 psb_intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter ) 
{ 
  struct psb_intel_sdvo *sdvo ;
  u32 tmp ;

  {
#line 2752
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
#line 2753
  tmp = (*(((sdvo->i2c)->algo)->functionality))(sdvo->i2c);
#line 2753
  return (tmp);
}
}
#line 2756 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static struct i2c_algorithm  const  psb_intel_sdvo_ddc_proxy  =    {& psb_intel_sdvo_ddc_proxy_xfer, 0, & psb_intel_sdvo_ddc_proxy_func};
#line 2762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
static bool psb_intel_sdvo_init_ddc_proxy(struct psb_intel_sdvo *sdvo , struct drm_device *dev ) 
{ 
  int tmp ;

  {
#line 2765
  sdvo->ddc.owner = & __this_module;
#line 2766
  sdvo->ddc.class = 8U;
#line 2767
  snprintf((char *)(& sdvo->ddc.name), 20UL, "SDVO DDC proxy");
#line 2768
  sdvo->ddc.dev.parent = & (dev->pdev)->dev;
#line 2769
  sdvo->ddc.algo_data = (void *)sdvo;
#line 2770
  sdvo->ddc.algo = & psb_intel_sdvo_ddc_proxy;
#line 2772
  tmp = i2c_add_adapter(& sdvo->ddc);
#line 2772
  return (tmp == 0);
}
}
#line 2775 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  int i ;
  void *tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u8 byte ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;

  {
#line 2777
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 2782
  tmp = kzalloc(2184UL, 208U);
#line 2782
  psb_intel_sdvo = (struct psb_intel_sdvo *)tmp;
#line 2783
  if ((unsigned long )psb_intel_sdvo == (unsigned long )((struct psb_intel_sdvo *)0)) {
#line 2784
    return (0);
  } else {

  }
#line 2786
  psb_intel_sdvo->sdvo_reg = sdvo_reg;
#line 2787
  tmp___0 = psb_intel_sdvo_get_slave_addr(dev, sdvo_reg);
#line 2787
  psb_intel_sdvo->slave_addr = (u8 )((int )tmp___0 >> 1);
#line 2788
  psb_intel_sdvo_select_i2c_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
#line 2789
  tmp___1 = psb_intel_sdvo_init_ddc_proxy(psb_intel_sdvo, dev);
#line 2789
  if (tmp___1) {
#line 2789
    tmp___2 = 0;
  } else {
#line 2789
    tmp___2 = 1;
  }
#line 2789
  if (tmp___2) {
#line 2790
    kfree((void const   *)psb_intel_sdvo);
#line 2791
    return (0);
  } else {

  }
#line 2795
  gma_encoder = & psb_intel_sdvo->base;
#line 2796
  gma_encoder->type = 3;
#line 2797
  drm_encoder_init(dev, & gma_encoder->base, & psb_intel_sdvo_enc_funcs, 0);
#line 2800
  i = 0;
#line 2800
  goto ldv_40818;
  ldv_40817: 
#line 2803
  tmp___4 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((u8 )i), & byte);
#line 2803
  if (tmp___4) {
#line 2803
    tmp___5 = 0;
  } else {
#line 2803
    tmp___5 = 1;
  }
#line 2803
  if (tmp___5) {
#line 2804
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2804
    if (tmp___3 != 0L) {
#line 2804
      drm_ut_debug_printk("psb_intel_sdvo_init", "No SDVO device found on SDVO%c\n",
                          sdvo_reg == 397632 ? 66 : 67);
    } else {

    }
#line 2806
    goto err;
  } else {

  }
#line 2800
  i = i + 1;
  ldv_40818: ;
#line 2800
  if (i <= 63) {
#line 2802
    goto ldv_40817;
  } else {

  }

#line 2810
  if (sdvo_reg == 397632) {
#line 2811
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 64U;
  } else {
#line 2813
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 128U;
  }
#line 2815
  drm_encoder_helper_add(& gma_encoder->base, & psb_intel_sdvo_helper_funcs);
#line 2818
  tmp___6 = psb_intel_sdvo_get_capabilities(psb_intel_sdvo, & psb_intel_sdvo->caps);
#line 2818
  if (tmp___6) {
#line 2818
    tmp___7 = 0;
  } else {
#line 2818
    tmp___7 = 1;
  }
#line 2818
  if (tmp___7) {
#line 2819
    goto err;
  } else {

  }
#line 2821
  tmp___9 = psb_intel_sdvo_output_setup(psb_intel_sdvo, (int )psb_intel_sdvo->caps.output_flags);
#line 2821
  if (tmp___9) {
#line 2821
    tmp___10 = 0;
  } else {
#line 2821
    tmp___10 = 1;
  }
#line 2821
  if (tmp___10) {
#line 2823
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2823
    if (tmp___8 != 0L) {
#line 2823
      drm_ut_debug_printk("psb_intel_sdvo_init", "SDVO output failed to setup on SDVO%c\n",
                          sdvo_reg == 397632 ? 66 : 67);
    } else {

    }
#line 2825
    goto err;
  } else {

  }
#line 2828
  psb_intel_sdvo_select_ddc_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
#line 2831
  tmp___11 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
#line 2831
  if (tmp___11) {
#line 2831
    tmp___12 = 0;
  } else {
#line 2831
    tmp___12 = 1;
  }
#line 2831
  if (tmp___12) {
#line 2832
    goto err;
  } else {

  }
#line 2834
  tmp___13 = psb_intel_sdvo_get_input_pixel_clock_range(psb_intel_sdvo, & psb_intel_sdvo->pixel_clock_min,
                                                        & psb_intel_sdvo->pixel_clock_max);
#line 2834
  if (tmp___13) {
#line 2834
    tmp___14 = 0;
  } else {
#line 2834
    tmp___14 = 1;
  }
#line 2834
  if (tmp___14) {
#line 2837
    goto err;
  } else {

  }
#line 2839
  tmp___15 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2839
  if (tmp___15 != 0L) {
#line 2839
    drm_ut_debug_printk("psb_intel_sdvo_init", "%s device VID/DID: %02X:%02X.%02X, clock range %dMHz - %dMHz, input 1: %c, input 2: %c, output 1: %c, output 2: %c\n",
                        psb_intel_sdvo->sdvo_reg == 397632 ? (char *)"SDVOB" : (char *)"SDVOC",
                        (int )psb_intel_sdvo->caps.vendor_id, (int )psb_intel_sdvo->caps.device_id,
                        (int )psb_intel_sdvo->caps.device_rev_id, psb_intel_sdvo->pixel_clock_min / 1000,
                        psb_intel_sdvo->pixel_clock_max / 1000, (int )psb_intel_sdvo->caps.sdvo_inputs_mask & 1 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.sdvo_inputs_mask & 2) != 0 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.output_flags & 3) != 0 ? 89 : 78,
                        ((int )psb_intel_sdvo->caps.output_flags & 768) != 0 ? 89 : 78);
  } else {

  }
#line 2855
  return (1);
  err: 
#line 2858
  drm_encoder_cleanup(& gma_encoder->base);
#line 2859
  i2c_del_adapter(& psb_intel_sdvo->ddc);
#line 2860
  kfree((void const   *)psb_intel_sdvo);
#line 2862
  return (0);
}
}
#line 2865
extern int ldv_probe_34(void) ;
#line 2866
extern int ldv_probe_36(void) ;
#line 2869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_35(void) 
{ 
  void *tmp ;

  {
#line 2870
  tmp = ldv_zalloc(720UL);
#line 2870
  psb_intel_sdvo_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 2871
  return;
}
}
#line 2873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_connector_funcs_36(void) 
{ 
  void *tmp ;

  {
#line 2874
  tmp = ldv_zalloc(720UL);
#line 2874
  psb_intel_sdvo_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 2875
  return;
}
}
#line 2877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_i2c_algorithm_33(void) 
{ 
  void *tmp ;

  {
#line 2878
  tmp = ldv_zalloc(1936UL);
#line 2878
  psb_intel_sdvo_ddc_proxy_group0 = (struct i2c_adapter *)tmp;
#line 2879
  return;
}
}
#line 2881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_37(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2882
  tmp = ldv_zalloc(96UL);
#line 2882
  psb_intel_sdvo_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 2883
  tmp___0 = ldv_zalloc(208UL);
#line 2883
  psb_intel_sdvo_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 2884
  return;
}
}
#line 2886 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  struct drm_display_mode *ldvarg88 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2887
  tmp = ldv_zalloc(208UL);
#line 2887
  ldvarg88 = (struct drm_display_mode *)tmp;
#line 2889
  tmp___0 = __VERIFIER_nondet_int();
#line 2889
  switch (tmp___0) {
  case 0: ;
#line 2892
  if (ldv_state_variable_35 == 1) {
#line 2894
    psb_intel_sdvo_get_modes(psb_intel_sdvo_connector_helper_funcs_group0);
#line 2896
    ldv_state_variable_35 = 1;
  } else {

  }
#line 2899
  goto ldv_40841;
  case 1: ;
#line 2902
  if (ldv_state_variable_35 == 1) {
#line 2904
    psb_intel_sdvo_mode_valid(psb_intel_sdvo_connector_helper_funcs_group0, ldvarg88);
#line 2906
    ldv_state_variable_35 = 1;
  } else {

  }
#line 2909
  goto ldv_40841;
  case 2: ;
#line 2912
  if (ldv_state_variable_35 == 1) {
#line 2914
    gma_best_encoder(psb_intel_sdvo_connector_helper_funcs_group0);
#line 2916
    ldv_state_variable_35 = 1;
  } else {

  }
#line 2919
  goto ldv_40841;
  default: 
#line 2920
  ldv_stop();
  }
  ldv_40841: ;
#line 2924
  return;
}
}
#line 2926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  int ldvarg0 ;
  int tmp ;
  struct i2c_msg *ldvarg1 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2927
  tmp = __VERIFIER_nondet_int();
#line 2927
  ldvarg0 = tmp;
#line 2928
  tmp___0 = ldv_zalloc(16UL);
#line 2928
  ldvarg1 = (struct i2c_msg *)tmp___0;
#line 2930
  tmp___1 = __VERIFIER_nondet_int();
#line 2930
  switch (tmp___1) {
  case 0: ;
#line 2933
  if (ldv_state_variable_33 == 1) {
#line 2935
    psb_intel_sdvo_ddc_proxy_xfer(psb_intel_sdvo_ddc_proxy_group0, ldvarg1, ldvarg0);
#line 2937
    ldv_state_variable_33 = 1;
  } else {

  }
#line 2940
  goto ldv_40851;
  case 1: ;
#line 2943
  if (ldv_state_variable_33 == 1) {
#line 2945
    psb_intel_sdvo_ddc_proxy_func(psb_intel_sdvo_ddc_proxy_group0);
#line 2947
    ldv_state_variable_33 = 1;
  } else {

  }
#line 2950
  goto ldv_40851;
  default: 
#line 2951
  ldv_stop();
  }
  ldv_40851: ;
#line 2955
  return;
}
}
#line 2957 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  struct drm_encoder *ldvarg178 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2958
  tmp = ldv_zalloc(96UL);
#line 2958
  ldvarg178 = (struct drm_encoder *)tmp;
#line 2960
  tmp___0 = __VERIFIER_nondet_int();
#line 2960
  switch (tmp___0) {
  case 0: ;
#line 2963
  if (ldv_state_variable_34 == 2) {
#line 2965
    psb_intel_sdvo_enc_destroy(ldvarg178);
#line 2967
    ldv_state_variable_34 = 1;
#line 2968
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2971
  goto ldv_40859;
  case 1: ;
#line 2974
  if (ldv_state_variable_34 == 1) {
#line 2976
    ldv_probe_34();
#line 2978
    ldv_state_variable_34 = 2;
#line 2979
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2982
  goto ldv_40859;
  default: 
#line 2983
  ldv_stop();
  }
  ldv_40859: ;
#line 2987
  return;
}
}
#line 2989 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_36(void) 
{ 
  struct drm_property *ldvarg139 ;
  void *tmp ;
  int ldvarg141 ;
  int tmp___0 ;
  uint32_t ldvarg137 ;
  bool ldvarg140 ;
  uint64_t ldvarg138 ;
  uint32_t ldvarg136 ;
  int tmp___1 ;

  {
#line 2990
  tmp = ldv_zalloc(104UL);
#line 2990
  ldvarg139 = (struct drm_property *)tmp;
#line 2991
  tmp___0 = __VERIFIER_nondet_int();
#line 2991
  ldvarg141 = tmp___0;
#line 2992
  memset((void *)(& ldvarg137), 0, 4UL);
#line 2993
  memset((void *)(& ldvarg140), 0, 1UL);
#line 2994
  memset((void *)(& ldvarg138), 0, 8UL);
#line 2995
  memset((void *)(& ldvarg136), 0, 4UL);
#line 2997
  tmp___1 = __VERIFIER_nondet_int();
#line 2997
  switch (tmp___1) {
  case 0: ;
#line 3000
  if (ldv_state_variable_36 == 2) {
#line 3002
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg141);
#line 3004
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3007
  if (ldv_state_variable_36 == 1) {
#line 3009
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg141);
#line 3011
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3014
  goto ldv_40872;
  case 1: ;
#line 3017
  if (ldv_state_variable_36 == 2) {
#line 3019
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg140);
#line 3021
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3024
  if (ldv_state_variable_36 == 1) {
#line 3026
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg140);
#line 3028
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3031
  goto ldv_40872;
  case 2: ;
#line 3034
  if (ldv_state_variable_36 == 2) {
#line 3036
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg139,
                                ldvarg138);
#line 3038
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3041
  if (ldv_state_variable_36 == 1) {
#line 3043
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg139,
                                ldvarg138);
#line 3045
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3048
  goto ldv_40872;
  case 3: ;
#line 3051
  if (ldv_state_variable_36 == 2) {
#line 3053
    psb_intel_sdvo_destroy(psb_intel_sdvo_connector_funcs_group0);
#line 3055
    ldv_state_variable_36 = 1;
#line 3056
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3059
  goto ldv_40872;
  case 4: ;
#line 3062
  if (ldv_state_variable_36 == 2) {
#line 3064
    psb_intel_sdvo_save(psb_intel_sdvo_connector_funcs_group0);
#line 3066
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3069
  if (ldv_state_variable_36 == 1) {
#line 3071
    psb_intel_sdvo_save(psb_intel_sdvo_connector_funcs_group0);
#line 3073
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3076
  goto ldv_40872;
  case 5: ;
#line 3079
  if (ldv_state_variable_36 == 2) {
#line 3081
    psb_intel_sdvo_restore(psb_intel_sdvo_connector_funcs_group0);
#line 3083
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3086
  if (ldv_state_variable_36 == 1) {
#line 3088
    psb_intel_sdvo_restore(psb_intel_sdvo_connector_funcs_group0);
#line 3090
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3093
  goto ldv_40872;
  case 6: ;
#line 3096
  if (ldv_state_variable_36 == 2) {
#line 3098
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg137, ldvarg136);
#line 3100
    ldv_state_variable_36 = 2;
  } else {

  }
#line 3103
  if (ldv_state_variable_36 == 1) {
#line 3105
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg137, ldvarg136);
#line 3107
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3110
  goto ldv_40872;
  case 7: ;
#line 3113
  if (ldv_state_variable_36 == 1) {
#line 3115
    ldv_probe_36();
#line 3117
    ldv_state_variable_36 = 2;
#line 3118
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3121
  goto ldv_40872;
  default: 
#line 3122
  ldv_stop();
  }
  ldv_40872: ;
#line 3126
  return;
}
}
#line 3128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void ldv_main_exported_37(void) 
{ 
  struct drm_display_mode *ldvarg182 ;
  void *tmp ;
  struct drm_display_mode *ldvarg181 ;
  void *tmp___0 ;
  int ldvarg183 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3129
  tmp = ldv_zalloc(208UL);
#line 3129
  ldvarg182 = (struct drm_display_mode *)tmp;
#line 3130
  tmp___0 = ldv_zalloc(208UL);
#line 3130
  ldvarg181 = (struct drm_display_mode *)tmp___0;
#line 3131
  tmp___1 = __VERIFIER_nondet_int();
#line 3131
  ldvarg183 = tmp___1;
#line 3133
  tmp___2 = __VERIFIER_nondet_int();
#line 3133
  switch (tmp___2) {
  case 0: ;
#line 3136
  if (ldv_state_variable_37 == 1) {
#line 3138
    psb_intel_sdvo_dpms(psb_intel_sdvo_helper_funcs_group0, ldvarg183);
#line 3140
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3143
  goto ldv_40888;
  case 1: ;
#line 3146
  if (ldv_state_variable_37 == 1) {
#line 3148
    psb_intel_sdvo_mode_fixup(psb_intel_sdvo_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg182,
                              psb_intel_sdvo_helper_funcs_group1);
#line 3150
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3153
  goto ldv_40888;
  case 2: ;
#line 3156
  if (ldv_state_variable_37 == 1) {
#line 3158
    gma_encoder_commit(psb_intel_sdvo_helper_funcs_group0);
#line 3160
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3163
  goto ldv_40888;
  case 3: ;
#line 3166
  if (ldv_state_variable_37 == 1) {
#line 3168
    psb_intel_sdvo_mode_set(psb_intel_sdvo_helper_funcs_group0, psb_intel_sdvo_helper_funcs_group1,
                            ldvarg181);
#line 3170
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3173
  goto ldv_40888;
  case 4: ;
#line 3176
  if (ldv_state_variable_37 == 1) {
#line 3178
    gma_encoder_prepare(psb_intel_sdvo_helper_funcs_group0);
#line 3180
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3183
  goto ldv_40888;
  default: 
#line 3184
  ldv_stop();
  }
  ldv_40888: ;
#line 3188
  return;
}
}
#line 3316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_intel_sdvo.o.c.prepared"
void *ldv_kmem_cache_alloc_358(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 3319
  ldv_check_alloc_flags(flags);
#line 3321
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 3322
  return ((void *)0);
}
}
#line 372 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 169 "include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 171
  return ((unsigned long )timer->entry.next != (unsigned long )((struct list_head */* const  */)0));
}
}
#line 240
extern void add_timer(struct timer_list * ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 248
int ldv_del_timer_sync_382(struct timer_list *ldv_func_arg1 ) ;
#line 56 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 56
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_378(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 180
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 197
void choose_timer_2(struct timer_list *timer ) ;
#line 198
int reg_timer_2(struct timer_list *timer ) ;
#line 708 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) ;
#line 709
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
static void psb_lid_timer_func(unsigned long data ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  u32 *lid_state ;
  u32 pp_status ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 248
  dev_priv = (struct drm_psb_private *)data;
#line 249
  dev = dev_priv->dev;
#line 250
  lid_timer = & dev_priv->lid_timer;
#line 252
  lid_state = dev_priv->opregion.lid_state;
#line 255
  tmp = readl((void const volatile   *)lid_state);
#line 255
  if (tmp == dev_priv->lid_last_state) {
#line 256
    goto lid_timer_schedule;
  } else {

  }
#line 258
  tmp___4 = readl((void const volatile   *)lid_state);
#line 258
  if ((int )tmp___4 & 1) {
#line 260
    tmp___0 = REGISTER_READ(dev, 397828U);
#line 260
    REGISTER_WRITE(dev, 397828U, tmp___0 | 1U);
    ldv_39743: 
#line 262
    pp_status = REGISTER_READ(dev, 397824U);
#line 264
    if ((int )pp_status >= 0 && (pp_status & 805306368U) != 0U) {
#line 266
      goto ldv_39743;
    } else {

    }
#line 266
    tmp___2 = REGISTER_READ(dev, 397824U);
#line 266
    if ((int )tmp___2 < 0) {
#line 268
      psb_intel_lvds_set_brightness(dev, 100);
    } else {
#line 270
      tmp___1 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 270
      if (tmp___1 != 0L) {
#line 270
        drm_ut_debug_printk("psb_lid_timer_func", "LVDS panel never powered up");
      } else {

      }
#line 271
      return;
    }
  } else {
#line 274
    psb_intel_lvds_set_brightness(dev, 0);
#line 276
    tmp___3 = REGISTER_READ(dev, 397828U);
#line 276
    REGISTER_WRITE(dev, 397828U, tmp___3 & 4294967294U);
    ldv_39746: 
#line 278
    pp_status = REGISTER_READ(dev, 397824U);
#line 279
    if ((int )pp_status >= 0) {
#line 281
      goto ldv_39746;
    } else {

    }

  }
#line 281
  dev_priv->lid_last_state = readl((void const volatile   *)lid_state);
  lid_timer_schedule: 
#line 284
  ldv_spin_lock();
#line 285
  tmp___5 = timer_pending((struct timer_list  const  *)lid_timer);
#line 285
  if (tmp___5 == 0) {
#line 286
    lid_timer->expires = (unsigned long )jiffies + 25UL;
#line 287
    add_timer(lid_timer);
  } else {

  }
#line 289
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
#line 290
  return;
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) 
{ 
  struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  struct lock_class_key __key ;

  {
#line 294
  lid_timer = & dev_priv->lid_timer;
#line 297
  spinlock_check(& dev_priv->lid_lock);
#line 297
  __raw_spin_lock_init(& dev_priv->lid_lock.ldv_6347.rlock, "&(&dev_priv->lid_lock)->rlock",
                       & __key);
#line 298
  ldv_spin_lock();
#line 300
  reg_timer_2(lid_timer);
#line 302
  lid_timer->data = (unsigned long )dev_priv;
#line 303
  lid_timer->function = & psb_lid_timer_func;
#line 304
  lid_timer->expires = (unsigned long )jiffies + 25UL;
#line 306
  add_timer(lid_timer);
#line 307
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
#line 308
  return;
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) 
{ 


  {
#line 312
  ldv_del_timer_sync_382(& dev_priv->lid_timer);
#line 313
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 317
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 318
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 319
      ldv_timer_list_2 = timer;
#line 320
      ldv_timer_list_2->data = data;
#line 321
      ldv_timer_state_2 = 1;
    } else {

    }
#line 323
    return;
  } else {

  }
#line 325
  reg_timer_2(timer);
#line 326
  ldv_timer_list_2->data = data;
#line 327
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 331
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 332
    ldv_timer_state_2 = 0;
#line 333
    return;
  } else {

  }
#line 335
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 339
  LDV_IN_INTERRUPT = 2;
#line 340
  (*(timer->function))(timer->data);
#line 341
  LDV_IN_INTERRUPT = 1;
#line 342
  ldv_timer_state_2 = 2;
#line 343
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 347
  ldv_timer_list_2 = timer;
#line 348
  ldv_timer_state_2 = 1;
#line 349
  return (0);
}
}
#line 478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
void *ldv_kmem_cache_alloc_378(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 481
  ldv_check_alloc_flags(flags);
#line 483
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 484
  return ((void *)0);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_lid.o.c.prepared"
int ldv_del_timer_sync_382(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 510
  tmp = del_timer_sync(ldv_func_arg1);
#line 510
  ldv_func_res = tmp;
#line 512
  disable_suitable_timer_2(ldv_func_arg1);
#line 514
  return (ldv_func_res);
}
}
#line 301 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) ;
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_400(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 1353 "include/drm/drmP.h"
extern bool drm_handle_vblank(struct drm_device * , int  ) ;
#line 26 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_asle_intr(struct drm_device *dev ) ;
#line 676 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
int psb_irq_enable_dpst(struct drm_device *dev ) ;
#line 677
int psb_irq_disable_dpst(struct drm_device *dev ) ;
#line 681
void psb_irq_turn_on_dpst(struct drm_device *dev ) ;
#line 682
void psb_irq_turn_off_dpst(struct drm_device *dev ) ;
#line 690
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
#line 693
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_irq.h"
int mdfld_enable_te(struct drm_device *dev , int pipe ) ;
#line 46
void mdfld_disable_te(struct drm_device *dev , int pipe ) ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
__inline static u32 psb_pipestat(int pipe ) 
{ 


  {
#line 260
  if (pipe == 0) {
#line 261
    return (458788U);
  } else {

  }
#line 262
  if (pipe == 1) {
#line 263
    return (462884U);
  } else {

  }
#line 264
  if (pipe == 2) {
#line 265
    return (466980U);
  } else {

  }
#line 266
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"),
                       "i" (266), "i" (12UL));
  ldv_39812: ;
#line 266
  goto ldv_39812;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
__inline static u32 mid_pipe_event(int pipe ) 
{ 


  {
#line 272
  if (pipe == 0) {
#line 273
    return (64U);
  } else {

  }
#line 274
  if (pipe == 1) {
#line 275
    return (16U);
  } else {

  }
#line 276
  if (pipe == 2) {
#line 277
    return (4U);
  } else {

  }
#line 278
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"),
                       "i" (278), "i" (12UL));
  ldv_39816: ;
#line 278
  goto ldv_39816;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
__inline static u32 mid_pipeconf(int pipe ) 
{ 


  {
#line 296
  if (pipe == 0) {
#line 297
    return (458760U);
  } else {

  }
#line 298
  if (pipe == 1) {
#line 299
    return (462856U);
  } else {

  }
#line 300
  if (pipe == 2) {
#line 301
    return (466952U);
  } else {

  }
#line 302
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"),
                       "i" (302), "i" (12UL));
  ldv_39824: ;
#line 302
  goto ldv_39824;
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ 
  u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 308
  if ((dev_priv->pipestat[pipe] & mask) != mask) {
#line 309
    tmp = psb_pipestat(pipe);
#line 309
    reg = tmp;
#line 310
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] | mask;
#line 312
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
#line 312
    if ((int )tmp___1) {
#line 313
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 313
      writeVal = tmp___0;
#line 314
      writeVal = ((mask >> 16) | mask) | writeVal;
#line 315
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 316
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 317
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 320
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ 
  u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 325
  if ((dev_priv->pipestat[pipe] & mask) != 0U) {
#line 326
    tmp = psb_pipestat(pipe);
#line 326
    reg = tmp;
#line 327
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] & ~ mask;
#line 328
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
#line 328
    if ((int )tmp___1) {
#line 329
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 329
      writeVal = tmp___0;
#line 330
      writeVal = ~ mask & writeVal;
#line 331
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 332
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
#line 333
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 336
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
static void mid_enable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ 
  u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 340
  tmp___0 = gma_power_begin(dev_priv->dev, 0);
#line 340
  if ((int )tmp___0) {
#line 341
    tmp = mid_pipe_event(pipe);
#line 341
    pipe_event = tmp;
#line 342
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | pipe_event;
#line 343
    iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 344
    iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 345
    gma_power_end(dev_priv->dev);
  } else {

  }
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
static void mid_disable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ 
  u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 351
  if (dev_priv->pipestat[pipe] == 0U) {
#line 352
    tmp___0 = gma_power_begin(dev_priv->dev, 0);
#line 352
    if ((int )tmp___0) {
#line 353
      tmp = mid_pipe_event(pipe);
#line 353
      pipe_event = tmp;
#line 354
      dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & ~ pipe_event;
#line 355
      iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 356
      iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 357
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
#line 359
  return;
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
static void mid_pipe_event_handler(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t pipe_stat_val ;
  uint32_t pipe_stat_reg ;
  u32 tmp ;
  uint32_t pipe_enable ;
  uint32_t pipe_status ;
  uint32_t pipe_clear ;
  uint32_t i ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 368
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 371
  pipe_stat_val = 0U;
#line 372
  tmp = psb_pipestat(pipe);
#line 372
  pipe_stat_reg = tmp;
#line 373
  pipe_enable = dev_priv->pipestat[pipe];
#line 374
  pipe_status = dev_priv->pipestat[pipe] >> 16;
#line 376
  i = 0U;
#line 378
  spin_lock(& dev_priv->irqmask_lock);
#line 380
  pipe_stat_val = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 381
  pipe_stat_val = (pipe_enable | pipe_status) & pipe_stat_val;
#line 382
  pipe_stat_val = (pipe_stat_val >> 16) & pipe_stat_val;
#line 384
  spin_unlock(& dev_priv->irqmask_lock);
#line 388
  i = 0U;
#line 388
  goto ldv_39862;
  ldv_39861: 
#line 389
  tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 389
  iowrite32(tmp___0, (void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 390
  tmp___1 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 390
  pipe_clear = tmp___1 & pipe_status;
#line 392
  if (pipe_clear == 0U) {
#line 393
    goto ldv_39860;
  } else {

  }
#line 388
  i = i + 1U;
  ldv_39862: ;
#line 388
  if (i <= 65534U) {
#line 390
    goto ldv_39861;
  } else {

  }
  ldv_39860: ;
#line 396
  if (pipe_clear != 0U) {
#line 397
    tmp___2 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
#line 397
    dev_err((struct device  const  *)dev->dev, "%s, can\'t clear status bits for pipe %d, its value = 0x%x.\n",
            "mid_pipe_event_handler", pipe, tmp___2);
  } else {

  }
#line 401
  if ((pipe_stat_val & 2U) != 0U) {
#line 402
    drm_handle_vblank(dev, pipe);
  } else {

  }
#line 404
  if (((unsigned long )pipe_stat_val & 64UL) != 0UL) {
#line 405
    drm_handle_vblank(dev, pipe);
  } else {

  }
#line 406
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
static void psb_vdc_interrupt(struct drm_device *dev , uint32_t vdc_stat ) 
{ 


  {
#line 413
  if ((int )vdc_stat & 1) {
#line 414
    psb_intel_opregion_asle_intr(dev);
  } else {

  }
#line 416
  if ((vdc_stat & 128U) != 0U) {
#line 417
    mid_pipe_event_handler(dev, 0);
  } else {

  }
#line 419
  if ((vdc_stat & 32U) != 0U) {
#line 420
    mid_pipe_event_handler(dev, 1);
  } else {

  }
#line 421
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
static void psb_sgx_interrupt(struct drm_device *dev , u32 stat_1 , u32 stat_2 ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 val ;
  u32 addr ;
  int error ;

  {
#line 428
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 430
  error = 0;
#line 432
  if ((stat_1 & 134217728U) != 0U) {
#line 433
    val = ioread32((void *)dev_priv->sgx_reg + 3588U);
  } else {

  }
#line 435
  if ((stat_2 & 16U) != 0U) {
#line 436
    val = ioread32((void *)dev_priv->sgx_reg + 3076U);
#line 437
    addr = ioread32((void *)dev_priv->sgx_reg + 3080U);
#line 438
    if (val != 0U) {
#line 439
      if ((val & 16384U) != 0U) {
#line 440
        drm_err("psb_sgx_interrupt", "SGX MMU page fault:");
      } else {
#line 442
        drm_err("psb_sgx_interrupt", "SGX MMU read / write protection fault:");
      }
#line 444
      if ((val & 2U) != 0U) {
#line 445
        drm_err("psb_sgx_interrupt", "\tCache requestor");
      } else {

      }
#line 446
      if ((val & 4U) != 0U) {
#line 447
        drm_err("psb_sgx_interrupt", "\tTA requestor");
      } else {

      }
#line 448
      if ((val & 8U) != 0U) {
#line 449
        drm_err("psb_sgx_interrupt", "\tVDM requestor");
      } else {

      }
#line 450
      if ((val & 16U) != 0U) {
#line 451
        drm_err("psb_sgx_interrupt", "\t2D requestor");
      } else {

      }
#line 452
      if ((val & 32U) != 0U) {
#line 453
        drm_err("psb_sgx_interrupt", "\tPBE requestor");
      } else {

      }
#line 454
      if ((val & 64U) != 0U) {
#line 455
        drm_err("psb_sgx_interrupt", "\tTSP requestor");
      } else {

      }
#line 456
      if ((val & 128U) != 0U) {
#line 457
        drm_err("psb_sgx_interrupt", "\tISP requestor");
      } else {

      }
#line 458
      if ((val & 256U) != 0U) {
#line 459
        drm_err("psb_sgx_interrupt", "\tUSSEPDS requestor");
      } else {

      }
#line 460
      if ((val & 512U) != 0U) {
#line 461
        drm_err("psb_sgx_interrupt", "\tHost requestor");
      } else {

      }
#line 463
      drm_err("psb_sgx_interrupt", "\tMMU failing address is 0x%08x.\n", addr);
#line 465
      error = 1;
    } else {

    }
  } else {

  }
#line 470
  iowrite32(stat_1, (void *)dev_priv->sgx_reg + 308U);
#line 471
  iowrite32(stat_2, (void *)dev_priv->sgx_reg + 276U);
#line 472
  ioread32((void *)dev_priv->sgx_reg + 276U);
#line 473
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
irqreturn_t psb_irq_handler(int irq , void *arg ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t vdc_stat ;
  uint32_t dsp_int ;
  uint32_t sgx_int ;
  uint32_t hotplug_int ;
  u32 sgx_stat_1 ;
  u32 sgx_stat_2 ;
  int handled ;
  bool tmp ;
  uint32_t tmp___0 ;

  {
#line 477
  dev = (struct drm_device *)arg;
#line 478
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 479
  dsp_int = 0U;
#line 479
  sgx_int = 0U;
#line 479
  hotplug_int = 0U;
#line 481
  handled = 0;
#line 483
  spin_lock(& dev_priv->irqmask_lock);
#line 485
  vdc_stat = ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 487
  if ((vdc_stat & 161U) != 0U) {
#line 488
    dsp_int = 1U;
  } else {

  }
#line 495
  if ((vdc_stat & 262144U) != 0U) {
#line 496
    sgx_int = 1U;
  } else {

  }
#line 497
  if ((vdc_stat & 131072U) != 0U) {
#line 498
    hotplug_int = 1U;
  } else {

  }
#line 500
  vdc_stat = dev_priv->vdc_irq_mask & vdc_stat;
#line 501
  spin_unlock(& dev_priv->irqmask_lock);
#line 503
  if (dsp_int != 0U) {
#line 503
    tmp = gma_power_is_on(dev);
#line 503
    if ((int )tmp) {
#line 504
      psb_vdc_interrupt(dev, vdc_stat);
#line 505
      handled = 1;
    } else {

    }
  } else {

  }
#line 508
  if (sgx_int != 0U) {
#line 509
    sgx_stat_1 = ioread32((void *)dev_priv->sgx_reg + 300U);
#line 510
    sgx_stat_2 = ioread32((void *)dev_priv->sgx_reg + 280U);
#line 511
    psb_sgx_interrupt(dev, sgx_stat_1, sgx_stat_2);
#line 512
    handled = 1;
  } else {

  }
#line 517
  if (hotplug_int != 0U && (unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
#line 518
    handled = (*((dev_priv->ops)->hotplug))(dev);
#line 519
    tmp___0 = REGISTER_READ(dev, 397588U);
#line 519
    REGISTER_WRITE(dev, 397588U, tmp___0);
  } else {

  }
#line 522
  iowrite32(vdc_stat, (void *)dev_priv->vdc_reg + 8356U);
#line 523
  ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 524
  __asm__  volatile   ("lfence": : : "memory");
#line 526
  if (handled == 0) {
#line 527
    return (0);
  } else {

  }
#line 529
  return (1);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_irq_preinstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  bool tmp ;

  {
#line 534
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 538
  ldv_spin_lock();
#line 540
  tmp = gma_power_is_on(dev);
#line 540
  if ((int )tmp) {
#line 541
    iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 542
    iowrite32(0U, (void *)dev_priv->vdc_reg + 8360U);
#line 543
    iowrite32(0U, (void *)dev_priv->vdc_reg + 8352U);
#line 544
    iowrite32(0U, (void *)dev_priv->sgx_reg + 304U);
#line 545
    ioread32((void *)dev_priv->sgx_reg + 304U);
  } else {

  }
#line 547
  if ((int )(dev->vblank)->enabled) {
#line 548
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else {

  }
#line 549
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 550
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
#line 560
  if ((unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
#line 561
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 131072U;
  } else {

  }
#line 562
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 262145U;
#line 565
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 566
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 567
  return;
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int psb_irq_postinstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;

  {
#line 571
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 574
  ldv_spin_lock();
#line 577
  iowrite32(16U, (void *)dev_priv->sgx_reg + 272U);
#line 578
  iowrite32(134217728U, (void *)dev_priv->sgx_reg + 304U);
#line 579
  ioread32((void *)dev_priv->sgx_reg + 304U);
#line 582
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 583
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 585
  if ((int )(dev->vblank)->enabled) {
#line 586
    psb_enable_pipestat(dev_priv, 0, 131072U);
  } else {
#line 588
    psb_disable_pipestat(dev_priv, 0, 131072U);
  }
#line 590
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 591
    psb_enable_pipestat(dev_priv, 1, 131072U);
  } else {
#line 593
    psb_disable_pipestat(dev_priv, 1, 131072U);
  }
#line 595
  if ((int )(dev->vblank + 2UL)->enabled) {
#line 596
    psb_enable_pipestat(dev_priv, 2, 131072U);
  } else {
#line 598
    psb_disable_pipestat(dev_priv, 2, 131072U);
  }
#line 600
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
#line 601
    (*((dev_priv->ops)->hotplug_enable))(dev, 1);
  } else {

  }
#line 603
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 604
  return (0);
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_irq_uninstall(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  unsigned int tmp ;

  {
#line 609
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 612
  ldv_spin_lock();
#line 614
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
#line 615
    (*((dev_priv->ops)->hotplug_enable))(dev, 0);
  } else {

  }
#line 617
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
#line 619
  if ((int )(dev->vblank)->enabled) {
#line 620
    psb_disable_pipestat(dev_priv, 0, 131072U);
  } else {

  }
#line 622
  if ((int )(dev->vblank + 1UL)->enabled) {
#line 623
    psb_disable_pipestat(dev_priv, 1, 131072U);
  } else {

  }
#line 625
  if ((int )(dev->vblank + 2UL)->enabled) {
#line 626
    psb_disable_pipestat(dev_priv, 2, 131072U);
  } else {

  }
#line 628
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 1835008U;
#line 633
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 634
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 636
  __asm__  volatile   ("sfence": : : "memory");
#line 639
  tmp = ioread32((void *)dev_priv->vdc_reg + 8356U);
#line 639
  iowrite32(tmp, (void *)dev_priv->vdc_reg + 8356U);
#line 640
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 641
  return;
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_irq_turn_on_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
#line 645
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 650
  tmp = gma_power_begin(dev, 0);
#line 650
  if ((int )tmp) {
#line 651
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397920U);
#line 652
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397920U);
#line 653
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397928U);
#line 654
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 656
    iowrite32(2147549440U, (void *)dev_priv->vdc_reg + 397904U);
#line 657
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 658
    iowrite32(pwm_reg | 50331648U, (void *)dev_priv->vdc_reg + 397904U);
#line 661
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 663
    psb_enable_pipestat(dev_priv, 0, 8388608U);
#line 665
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 666
    iowrite32(hist_reg | 1073741824U, (void *)dev_priv->vdc_reg + 397928U);
#line 668
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 669
    iowrite32(pwm_reg | 2181103872U, (void *)dev_priv->vdc_reg + 397904U);
#line 672
    gma_power_end(dev);
  } else {

  }
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int psb_irq_enable_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;

  {
#line 678
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 682
  ldv_spin_lock();
#line 685
  mid_enable_pipe_event(dev_priv, 0);
#line 686
  psb_irq_turn_on_dpst(dev);
#line 688
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 689
  return (0);
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_irq_turn_off_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
#line 694
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 699
  tmp = gma_power_begin(dev, 0);
#line 699
  if ((int )tmp) {
#line 700
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397928U);
#line 701
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 703
    psb_disable_pipestat(dev_priv, 0, 8388608U);
#line 705
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 706
    iowrite32(pwm_reg & 4278190079U, (void *)dev_priv->vdc_reg + 397904U);
#line 708
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 710
    gma_power_end(dev);
  } else {

  }
#line 712
  return;
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int psb_irq_disable_dpst(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;

  {
#line 716
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 720
  ldv_spin_lock();
#line 722
  mid_disable_pipe_event(dev_priv, 0);
#line 723
  psb_irq_turn_off_dpst(dev);
#line 725
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 727
  return (0);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int psb_enable_vblank(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 735
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 737
  reg_val = 0U;
#line 738
  tmp = mid_pipeconf(pipe);
#line 738
  pipeconf_reg = tmp;
#line 742
  if (((int )(dev->pdev)->device & 65528) == 304) {
#line 743
    tmp___0 = mdfld_enable_te(dev, pipe);
#line 743
    return (tmp___0);
  } else {

  }
#line 745
  tmp___1 = gma_power_begin(dev, 0);
#line 745
  if ((int )tmp___1) {
#line 746
    reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 747
    gma_power_end(dev);
  } else {

  }
#line 750
  if ((int )reg_val >= 0) {
#line 751
    return (-22);
  } else {

  }
#line 753
  ldv_spin_lock();
#line 755
  if (pipe == 0) {
#line 756
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else
#line 757
  if (pipe == 1) {
#line 758
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
#line 760
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 761
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 762
  psb_enable_pipestat(dev_priv, pipe, 131072U);
#line 764
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 766
  return (0);
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void psb_disable_vblank(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;

  {
#line 774
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 777
  if (((int )(dev->pdev)->device & 65528) == 304) {
#line 778
    mdfld_disable_te(dev, pipe);
  } else {

  }
#line 779
  ldv_spin_lock();
#line 781
  if (pipe == 0) {
#line 782
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967167U;
  } else
#line 783
  if (pipe == 1) {
#line 784
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967263U;
  } else {

  }
#line 786
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
#line 787
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
#line 788
  psb_disable_pipestat(dev_priv, pipe, 131072U);
#line 790
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 791
  return;
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
int mdfld_enable_te(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  bool tmp___0 ;

  {
#line 798
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 801
  reg_val = 0U;
#line 802
  tmp = mid_pipeconf(pipe);
#line 802
  pipeconf_reg = tmp;
#line 804
  tmp___0 = gma_power_begin(dev, 0);
#line 804
  if ((int )tmp___0) {
#line 805
    reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 806
    gma_power_end(dev);
  } else {

  }
#line 809
  if ((int )reg_val >= 0) {
#line 810
    return (-22);
  } else {

  }
#line 812
  ldv_spin_lock();
#line 814
  mid_enable_pipe_event(dev_priv, pipe);
#line 815
  psb_enable_pipestat(dev_priv, pipe, 4194304U);
#line 817
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 819
  return (0);
}
}
#line 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void mdfld_disable_te(struct drm_device *dev , int pipe ) 
{ 
  struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;

  {
#line 827
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 831
  if (! dev_priv->dsr_enable) {
#line 832
    return;
  } else {

  }
#line 834
  ldv_spin_lock();
#line 836
  mid_disable_pipe_event(dev_priv, pipe);
#line 837
  psb_disable_pipestat(dev_priv, pipe, 4194304U);
#line 839
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
#line 840
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) 
{ 
  uint32_t high_frame ;
  uint32_t low_frame ;
  uint32_t pipeconf_reg ;
  uint32_t reg_val ;
  uint32_t high1 ;
  uint32_t high2 ;
  uint32_t low ;
  uint32_t count ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 847
  high_frame = 458816U;
#line 848
  low_frame = 458820U;
#line 849
  pipeconf_reg = 458760U;
#line 850
  reg_val = 0U;
#line 851
  high1 = 0U;
#line 851
  high2 = 0U;
#line 851
  low = 0U;
#line 851
  count = 0U;
#line 853
  switch (pipe) {
  case 0: ;
#line 855
  goto ldv_39969;
  case 1: 
#line 857
  high_frame = 462912U;
#line 858
  low_frame = 462916U;
#line 859
  pipeconf_reg = 462856U;
#line 860
  goto ldv_39969;
  case 2: 
#line 862
  high_frame = 467008U;
#line 863
  low_frame = 467012U;
#line 864
  pipeconf_reg = 466952U;
#line 865
  goto ldv_39969;
  default: 
#line 867
  dev_err((struct device  const  *)dev->dev, "%s, invalid pipe.\n", "psb_get_vblank_counter");
#line 868
  return (0U);
  }
  ldv_39969: 
#line 871
  tmp = gma_power_begin(dev, 0);
#line 871
  if (tmp) {
#line 871
    tmp___0 = 0;
  } else {
#line 871
    tmp___0 = 1;
  }
#line 871
  if (tmp___0) {
#line 872
    return (0U);
  } else {

  }
#line 874
  reg_val = REGISTER_READ(dev, pipeconf_reg);
#line 876
  if ((int )reg_val >= 0) {
#line 877
    dev_err((struct device  const  *)dev->dev, "trying to get vblank count for disabled pipe %d\n",
            pipe);
#line 879
    goto psb_get_vblank_counter_exit;
  } else {

  }
  ldv_39975: 
#line 888
  tmp___1 = REGISTER_READ(dev, high_frame);
#line 888
  high1 = tmp___1 & 65535U;
#line 890
  tmp___2 = REGISTER_READ(dev, low_frame);
#line 890
  low = tmp___2 >> 24;
#line 892
  tmp___3 = REGISTER_READ(dev, high_frame);
#line 892
  high2 = tmp___3 & 65535U;
#line 894
  if (high1 != high2) {
#line 896
    goto ldv_39975;
  } else {

  }
#line 896
  count = (high1 << 8) | low;
  psb_get_vblank_counter_exit: 
#line 900
  gma_power_end(dev);
#line 902
  return (count);
}
}
#line 1032 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_irq.o.c.prepared"
void *ldv_kmem_cache_alloc_400(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1035
  ldv_check_alloc_flags(flags);
#line 1037
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1038
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_420(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 212 "include/drm/drm_crtc.h"
extern void drm_modeset_lock_all(struct drm_device * ) ;
#line 213
extern void drm_modeset_unlock_all(struct drm_device * ) ;
#line 134 "include/drm/drm_crtc_helper.h"
extern bool drm_helper_crtc_in_use(struct drm_crtc * ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/opregion.h"
void psb_intel_opregion_init(struct drm_device *dev ) ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 253
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 254
  psb_intel_lvds_init(dev, & dev_priv->mode_dev);
#line 255
  psb_intel_sdvo_init(dev, 397632);
#line 256
  return (0);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static void psb_init_pm(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 gating ;
  unsigned int tmp ;

  {
#line 384
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 386
  tmp = ioread32((void *)dev_priv->sgx_reg);
#line 386
  gating = tmp;
#line 387
  gating = gating & 4294967292U;
#line 388
  gating = gating | 1U;
#line 389
  iowrite32(gating, (void *)dev_priv->sgx_reg);
#line 390
  ioread32((void *)dev_priv->sgx_reg);
#line 391
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 402
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 405
  regs = & dev_priv->regs.ldv_40416.psb;
#line 408
  regs->saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
#line 409
  regs->saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
#line 410
  regs->saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
#line 411
  regs->saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
#line 412
  regs->saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
#line 413
  regs->saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
#line 414
  regs->saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
#line 415
  regs->saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
#line 418
  drm_modeset_lock_all(dev);
#line 419
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 419
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 419
  goto ldv_39753;
  ldv_39752: 
#line 420
  tmp = drm_helper_crtc_in_use(crtc);
#line 420
  if ((int )tmp) {
#line 421
    (*((crtc->funcs)->save))(crtc);
  } else {

  }
#line 419
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 419
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_39753: ;
#line 419
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 421
    goto ldv_39752;
  } else {

  }
#line 424
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 424
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
#line 424
  goto ldv_39760;
  ldv_39759: ;
#line 425
  if ((unsigned long )(connector->funcs)->save != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
#line 426
    (*((connector->funcs)->save))(connector);
  } else {

  }
#line 424
  __mptr___2 = (struct list_head  const  *)connector->head.next;
#line 424
  connector = (struct drm_connector *)__mptr___2 + 0xffffffffffffffe8UL;
  ldv_39760: ;
#line 424
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 426
    goto ldv_39759;
  } else {

  }
#line 428
  drm_modeset_unlock_all(dev);
#line 429
  return (0);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 440
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 443
  regs = & dev_priv->regs.ldv_40416.psb;
#line 446
  iowrite32(regs->saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
#line 447
  iowrite32(regs->saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
#line 448
  iowrite32(regs->saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
#line 449
  iowrite32(regs->saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
#line 450
  iowrite32(regs->saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
#line 451
  iowrite32(regs->saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
#line 452
  iowrite32(regs->saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
#line 453
  iowrite32(regs->saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
#line 456
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
#line 458
  drm_modeset_lock_all(dev);
#line 459
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 459
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 459
  goto ldv_39774;
  ldv_39773: 
#line 460
  tmp = drm_helper_crtc_in_use(crtc);
#line 460
  if ((int )tmp) {
#line 461
    (*((crtc->funcs)->restore))(crtc);
  } else {

  }
#line 459
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 459
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_39774: ;
#line 459
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 461
    goto ldv_39773;
  } else {

  }
#line 463
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 463
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
#line 463
  goto ldv_39781;
  ldv_39780: ;
#line 464
  if ((unsigned long )(connector->funcs)->restore != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
#line 465
    (*((connector->funcs)->restore))(connector);
  } else {

  }
#line 463
  __mptr___2 = (struct list_head  const  *)connector->head.next;
#line 463
  connector = (struct drm_connector *)__mptr___2 + 0xffffffffffffffe8UL;
  ldv_39781: ;
#line 463
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 465
    goto ldv_39780;
  } else {

  }
#line 467
  drm_modeset_unlock_all(dev);
#line 468
  return (0);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_power_down(struct drm_device *dev ) 
{ 


  {
#line 473
  return (0);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_power_up(struct drm_device *dev ) 
{ 


  {
#line 478
  return (0);
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static struct psb_offset  const  psb_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U, 459140U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static int psb_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 535
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 536
  dev_priv->regmap = (struct psb_offset  const  *)(& psb_regmap);
#line 537
  gma_get_core_freq(dev);
#line 538
  gma_intel_setup_gmbus(dev);
#line 539
  psb_intel_opregion_init(dev);
#line 540
  psb_intel_init_bios(dev);
#line 541
  return (0);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
static void psb_chip_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 546
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 547
  psb_lid_timer_takedown(dev_priv);
#line 548
  gma_intel_teardown_gmbus(dev);
#line 549
  return;
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
struct psb_ops  const  psb_chip_ops  = 
#line 551
     {"Poulsbo", 1U, 2, 2, 262144, 1, 2, 1, 1, & psb_intel_helper_funcs, & psb_intel_crtc_funcs,
    & psb_clock_funcs, & psb_chip_setup, & psb_chip_teardown, 0, & psb_output_init,
    0, 0, & psb_init_pm, & psb_save_display_registers, & psb_restore_display_registers,
    & psb_power_up, & psb_power_down, 0, 0, 0, 0};
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_initialize_psb_ops_32(void) 
{ 
  void *tmp ;

  {
#line 584
  tmp = ldv_zalloc(2992UL);
#line 584
  psb_chip_ops_group0 = (struct drm_device *)tmp;
#line 585
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  int tmp ;

  {
#line 589
  tmp = __VERIFIER_nondet_int();
#line 589
  switch (tmp) {
  case 0: ;
#line 592
  if (ldv_state_variable_32 == 1) {
#line 594
    psb_chip_teardown(psb_chip_ops_group0);
#line 596
    ldv_state_variable_32 = 1;
  } else {

  }
#line 599
  goto ldv_39806;
  case 1: ;
#line 602
  if (ldv_state_variable_32 == 1) {
#line 604
    psb_chip_setup(psb_chip_ops_group0);
#line 606
    ldv_state_variable_32 = 1;
  } else {

  }
#line 609
  goto ldv_39806;
  case 2: ;
#line 612
  if (ldv_state_variable_32 == 1) {
#line 614
    psb_init_pm(psb_chip_ops_group0);
#line 616
    ldv_state_variable_32 = 1;
  } else {

  }
#line 619
  goto ldv_39806;
  case 3: ;
#line 622
  if (ldv_state_variable_32 == 1) {
#line 624
    psb_save_display_registers(psb_chip_ops_group0);
#line 626
    ldv_state_variable_32 = 1;
  } else {

  }
#line 629
  goto ldv_39806;
  case 4: ;
#line 632
  if (ldv_state_variable_32 == 1) {
#line 634
    psb_restore_display_registers(psb_chip_ops_group0);
#line 636
    ldv_state_variable_32 = 1;
  } else {

  }
#line 639
  goto ldv_39806;
  case 5: ;
#line 642
  if (ldv_state_variable_32 == 1) {
#line 644
    psb_power_down(psb_chip_ops_group0);
#line 646
    ldv_state_variable_32 = 1;
  } else {

  }
#line 649
  goto ldv_39806;
  case 6: ;
#line 652
  if (ldv_state_variable_32 == 1) {
#line 654
    psb_output_init(psb_chip_ops_group0);
#line 656
    ldv_state_variable_32 = 1;
  } else {

  }
#line 659
  goto ldv_39806;
  case 7: ;
#line 662
  if (ldv_state_variable_32 == 1) {
#line 664
    psb_power_up(psb_chip_ops_group0);
#line 666
    ldv_state_variable_32 = 1;
  } else {

  }
#line 669
  goto ldv_39806;
  default: 
#line 670
  ldv_stop();
  }
  ldv_39806: ;
#line 674
  return;
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/psb_device.o.c.prepared"
void *ldv_kmem_cache_alloc_420(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 805
  ldv_check_alloc_flags(flags);
#line 807
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 808
  return ((void *)0);
}
}
#line 210 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 212
  __len = count;
#line 212
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 214
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_440(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 1044 "include/linux/device.h"
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/mid_bios.h"
int mid_chip_setup(struct drm_device *dev ) ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static void mid_get_fuse_settings(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  uint32_t fuse_value ;
  uint32_t fuse_value_tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
#line 254
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 255
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 255
  pci_root = tmp;
#line 256
  fuse_value = 0U;
#line 257
  fuse_value_tmp = 0U;
#line 268
  if ((unsigned long )pci_root == (unsigned long )((struct pci_dev *)0)) {
#line 269
    __ret_warn_on = 1;
#line 269
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 269
    if (tmp___0 != 0L) {
#line 269
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared",
                         269);
    } else {

    }
#line 269
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 270
    return;
  } else {

  }
#line 274
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498116608U);
#line 275
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
#line 278
  if (((int )(dev->pdev)->device & 65520) == 16640) {
#line 279
    dev_priv->iLVDS_enable = fuse_value & 2048U;
  } else {

  }
#line 281
  printk("\016[drm] internal display is %s\n", dev_priv->iLVDS_enable != 0U ? (char *)"LVDS display" : (char *)"MIPI display");
#line 285
  if (dev_priv->iLVDS_enable != 0U) {
#line 286
    dev_priv->is_lvds_on = 1;
#line 287
    dev_priv->is_mipi_on = 0;
  } else {
#line 289
    dev_priv->is_mipi_on = 1;
#line 290
    dev_priv->is_lvds_on = 0;
  }
#line 293
  dev_priv->video_device_fuse = fuse_value;
#line 295
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498117376U);
#line 296
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
#line 298
  descriptor.modname = "gma500_gfx";
#line 298
  descriptor.function = "mid_get_fuse_settings";
#line 298
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared";
#line 298
  descriptor.format = "SKU values is 0x%x.\n";
#line 298
  descriptor.lineno = 298U;
#line 298
  descriptor.flags = 0U;
#line 298
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 298
  if (tmp___1 != 0L) {
#line 298
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "SKU values is 0x%x.\n",
                      fuse_value);
  } else {

  }
#line 299
  fuse_value_tmp = (fuse_value & 28672U) >> 12;
#line 301
  dev_priv->fuse_reg_value = fuse_value;
#line 303
  switch (fuse_value_tmp) {
  case 0U: 
#line 305
  dev_priv->core_freq = 200U;
#line 306
  goto ldv_39715;
  case 1U: 
#line 308
  dev_priv->core_freq = 100U;
#line 309
  goto ldv_39715;
  case 2U: 
#line 311
  dev_priv->core_freq = 166U;
#line 312
  goto ldv_39715;
  default: 
#line 314
  dev_warn((struct device  const  *)dev->dev, "Invalid SKU values, SKU value = 0x%08x\n",
           fuse_value_tmp);
#line 316
  dev_priv->core_freq = 0U;
  }
  ldv_39715: 
#line 318
  descriptor___0.modname = "gma500_gfx";
#line 318
  descriptor___0.function = "mid_get_fuse_settings";
#line 318
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared";
#line 318
  descriptor___0.format = "LNC core clk is %dMHz.\n";
#line 318
  descriptor___0.lineno = 318U;
#line 318
  descriptor___0.flags = 0U;
#line 318
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 318
  if (tmp___2 != 0L) {
#line 318
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "LNC core clk is %dMHz.\n",
                      dev_priv->core_freq);
  } else {

  }
#line 319
  pci_dev_put(pci_root);
#line 320
  return;
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static void mid_get_pci_revID(struct drm_psb_private *dev_priv ) 
{ 
  uint32_t platform_rev_id ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 327
  platform_rev_id = 0U;
#line 328
  tmp = pci_get_bus_and_slot(0U, 16U);
#line 328
  pci_gfx_root = tmp;
#line 330
  if ((unsigned long )pci_gfx_root == (unsigned long )((struct pci_dev *)0)) {
#line 331
    __ret_warn_on = 1;
#line 331
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 331
    if (tmp___0 != 0L) {
#line 331
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared",
                         331);
    } else {

    }
#line 331
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 332
    return;
  } else {

  }
#line 334
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 8, & platform_rev_id);
#line 335
  dev_priv->platform_rev_id = (unsigned char )platform_rev_id;
#line 336
  pci_dev_put(pci_gfx_root);
#line 337
  descriptor.modname = "gma500_gfx";
#line 337
  descriptor.function = "mid_get_pci_revID";
#line 337
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared";
#line 337
  descriptor.format = "platform_rev_id is %x\n";
#line 337
  descriptor.lineno = 338U;
#line 337
  descriptor.flags = 0U;
#line 337
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 337
  if (tmp___1 != 0L) {
#line 337
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                      "platform_rev_id is %x\n", (int )dev_priv->platform_rev_id);
  } else {

  }
#line 339
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static int read_vbt_r0(u32 addr , struct vbt_r0 *vbt ) 
{ 
  void *vbt_virtual ;

  {
#line 367
  vbt_virtual = ioremap((resource_size_t )addr, 7UL);
#line 368
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
#line 369
    return (-1);
  } else {

  }
#line 371
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 7UL);
#line 372
  iounmap((void volatile   *)vbt_virtual);
#line 374
  return (0);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static int read_vbt_r10(u32 addr , struct vbt_r10 *vbt ) 
{ 
  void *vbt_virtual ;

  {
#line 381
  vbt_virtual = ioremap((resource_size_t )addr, 16UL);
#line 382
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
#line 383
    return (-1);
  } else {

  }
#line 385
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 16UL);
#line 386
  iounmap((void volatile   *)vbt_virtual);
#line 388
  return (0);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static int mid_get_vbt_data_r0(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r0 gct ;
  u8 bpi ;
  int tmp ;

  {
#line 398
  tmp = read_vbt_r0(addr, & vbt);
#line 398
  if (tmp != 0) {
#line 399
    return (-1);
  } else {

  }
#line 401
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
#line 402
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 403
    return (-1);
  } else {

  }
#line 404
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 161UL);
#line 405
  iounmap((void volatile   *)gct_virtual);
#line 407
  bpi = gct.ldv_39025.PD.BootPanelIndex;
#line 408
  dev_priv->gct_data.bpi = bpi;
#line 409
  dev_priv->gct_data.pt = gct.ldv_39025.PD.PanelType;
#line 410
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
#line 411
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
#line 413
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
#line 416
  return (0);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static int mid_get_vbt_data_r1(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r1 gct ;
  u8 bpi ;
  int tmp ;

  {
#line 426
  tmp = read_vbt_r0(addr, & vbt);
#line 426
  if (tmp != 0) {
#line 427
    return (-1);
  } else {

  }
#line 429
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
#line 430
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 431
    return (-1);
  } else {

  }
#line 432
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 153UL);
#line 433
  iounmap((void volatile   *)gct_virtual);
#line 435
  bpi = gct.ldv_39036.PD.BootPanelIndex;
#line 436
  dev_priv->gct_data.bpi = bpi;
#line 437
  dev_priv->gct_data.pt = gct.ldv_39036.PD.PanelType;
#line 438
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
#line 439
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
#line 441
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
#line 444
  return (0);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static int mid_get_vbt_data_r10(struct drm_psb_private *dev_priv , u32 addr ) 
{ 
  struct vbt_r10 vbt ;
  void *gct_virtual ;
  struct gct_r10 *gct ;
  struct oaktrail_timing_info *dp_ti ;
  struct gct_r10_timing_info *ti ;
  int ret ;
  int tmp ;
  void *tmp___0 ;

  {
#line 452
  dp_ti = & dev_priv->gct_data.DTD;
#line 454
  ret = -1;
#line 456
  tmp = read_vbt_r10(addr, & vbt);
#line 456
  if (tmp != 0) {
#line 457
    return (-1);
  } else {

  }
#line 459
  tmp___0 = kmalloc((unsigned long )vbt.panel_count * 28UL, 208U);
#line 459
  gct = (struct gct_r10 *)tmp___0;
#line 460
  if ((unsigned long )gct == (unsigned long )((struct gct_r10 *)0)) {
#line 461
    return (-1);
  } else {

  }
#line 463
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 16UL), (unsigned long )vbt.panel_count * 28UL);
#line 465
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
#line 466
    goto out;
  } else {

  }
#line 467
  memcpy_fromio((void *)gct, (void const volatile   *)gct_virtual, 28UL);
#line 468
  iounmap((void volatile   *)gct_virtual);
#line 470
  dev_priv->gct_data.bpi = vbt.primary_panel_idx;
#line 471
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = (gct + (unsigned long )vbt.primary_panel_idx)->Panel_MIPI_Display_Descriptor;
#line 474
  ti = & (gct + (unsigned long )vbt.primary_panel_idx)->DTD;
#line 475
  dp_ti->pixel_clock = ti->pixel_clock;
#line 476
  dp_ti->hactive_hi = ti->hactive_hi;
#line 477
  dp_ti->hactive_lo = ti->hactive_lo;
#line 478
  dp_ti->hblank_hi = ti->hblank_hi;
#line 479
  dp_ti->hblank_lo = ti->hblank_lo;
#line 480
  dp_ti->hsync_offset_hi = ti->hsync_offset_hi;
#line 481
  dp_ti->hsync_offset_lo = ti->hsync_offset_lo;
#line 482
  dp_ti->hsync_pulse_width_hi = ti->hsync_pulse_width_hi;
#line 483
  dp_ti->hsync_pulse_width_lo = ti->hsync_pulse_width_lo;
#line 484
  dp_ti->vactive_hi = ti->vactive_hi;
#line 485
  dp_ti->vactive_lo = ti->vactive_lo;
#line 486
  dp_ti->vblank_hi = ti->vblank_hi;
#line 487
  dp_ti->vblank_lo = ti->vblank_lo;
#line 488
  dp_ti->vsync_offset_hi = ti->vsync_offset_hi;
#line 489
  dp_ti->vsync_offset_lo = ti->vsync_offset_lo;
#line 490
  dp_ti->vsync_pulse_width_hi = ti->vsync_pulse_width_hi;
#line 491
  dp_ti->vsync_pulse_width_lo = ti->vsync_pulse_width_lo;
#line 493
  ret = 0;
  out: 
#line 495
  kfree((void const   *)gct);
#line 496
  return (ret);
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
static void mid_get_vbt_data(struct drm_psb_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  u32 addr ;
  u8 *vbt_virtual ;
  struct mid_vbt_header vbt_header ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
#line 501
  dev = dev_priv->dev;
#line 505
  tmp = pci_get_bus_and_slot(0U, 16U);
#line 505
  pci_gfx_root = tmp;
#line 506
  ret = -1;
#line 509
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 252, & addr);
#line 510
  pci_dev_put(pci_gfx_root);
#line 512
  descriptor.modname = "gma500_gfx";
#line 512
  descriptor.function = "mid_get_vbt_data";
#line 512
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared";
#line 512
  descriptor.format = "drm platform config address is %x\n";
#line 512
  descriptor.lineno = 512U;
#line 512
  descriptor.flags = 0U;
#line 512
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 512
  if (tmp___0 != 0L) {
#line 512
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "drm platform config address is %x\n",
                      addr);
  } else {

  }
#line 514
  if (addr == 0U) {
#line 515
    goto out;
  } else {

  }
#line 518
  tmp___1 = ioremap((resource_size_t )addr, 5UL);
#line 518
  vbt_virtual = (u8 *)tmp___1;
#line 519
  if ((unsigned long )vbt_virtual == (unsigned long )((u8 *)0U)) {
#line 520
    goto out;
  } else {

  }
#line 522
  memcpy_fromio((void *)(& vbt_header), (void const volatile   *)vbt_virtual, 5UL);
#line 523
  iounmap((void volatile   *)vbt_virtual);
#line 525
  tmp___2 = memcmp((void const   *)(& vbt_header.signature), (void const   *)"$GCT",
                   4UL);
#line 525
  if (tmp___2 != 0) {
#line 526
    goto out;
  } else {

  }
#line 528
  descriptor___0.modname = "gma500_gfx";
#line 528
  descriptor___0.function = "mid_get_vbt_data";
#line 528
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared";
#line 528
  descriptor___0.format = "GCT revision is %02x\n";
#line 528
  descriptor___0.lineno = 528U;
#line 528
  descriptor___0.flags = 0U;
#line 528
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 528
  if (tmp___3 != 0L) {
#line 528
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GCT revision is %02x\n",
                      (int )vbt_header.revision);
  } else {

  }
#line 530
  switch ((int )vbt_header.revision) {
  case 0: 
#line 532
  ret = mid_get_vbt_data_r0(dev_priv, addr);
#line 533
  goto ldv_39795;
  case 1: 
#line 535
  ret = mid_get_vbt_data_r1(dev_priv, addr);
#line 536
  goto ldv_39795;
  case 16: 
#line 538
  ret = mid_get_vbt_data_r10(dev_priv, addr);
#line 539
  goto ldv_39795;
  default: 
#line 541
  dev_err((struct device  const  *)dev->dev, "Unknown revision of GCT!\n");
  }
  ldv_39795: ;
  out: ;
#line 545
  if (ret != 0) {
#line 546
    dev_err((struct device  const  *)dev->dev, "Unable to read GCT!");
  } else {
#line 548
    dev_priv->has_gct = 1;
  }
#line 549
  return;
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
int mid_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 553
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 554
  mid_get_fuse_settings(dev);
#line 555
  mid_get_vbt_data(dev_priv);
#line 556
  mid_get_pci_revID(dev_priv);
#line 557
  return (0);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/mid_bios.o.c.prepared"
void *ldv_kmem_cache_alloc_440(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 690
  ldv_check_alloc_flags(flags);
#line 692
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 693
  return ((void *)0);
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 180 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 355
extern struct workqueue_struct *system_wq ;
#line 431
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 447
extern bool cancel_work_sync(struct work_struct * ) ;
#line 471 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 474
  tmp = queue_work_on(8192, wq, work);
#line 474
  return (tmp);
}
}
#line 530 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 532
  tmp = queue_work(system_wq, work);
#line 532
  return (tmp);
}
}
#line 176 "./arch/x86/include/asm/io.h"
extern void *ioremap_cache(resource_size_t  , unsigned long  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_460(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 416 "include/acpi/acpi_bus.h"
extern int register_acpi_notifier(struct notifier_block * ) ;
#line 417
extern int unregister_acpi_notifier(struct notifier_block * ) ;
#line 6 "include/acpi/acpi_io.h"
__inline static void *acpi_os_ioremap(acpi_physical_address phys , acpi_size size ) 
{ 
  void *tmp ;

  {
#line 9
  tmp = ioremap_cache(phys, (unsigned long )size);
#line 9
  return (tmp);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
static struct psb_intel_opregion *system_opregion  ;
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
static u32 asle_set_backlight(struct drm_device *dev , u32 bclp ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;
  struct backlight_device *bd ;
  long tmp ;

  {
#line 370
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 371
  asle = dev_priv->opregion.asle;
#line 372
  bd = dev_priv->backlight_device;
#line 374
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 374
  if (tmp != 0L) {
#line 374
    drm_ut_debug_printk("asle_set_backlight", "asle set backlight %x\n", bclp);
  } else {

  }
#line 376
  if ((int )bclp >= 0) {
#line 377
    return (4096U);
  } else {

  }
#line 379
  if ((unsigned long )bd == (unsigned long )((struct backlight_device *)0)) {
#line 380
    return (4096U);
  } else {

  }
#line 382
  bclp = bclp & 2147483647U;
#line 383
  if (bclp > 255U) {
#line 384
    return (4096U);
  } else {

  }
#line 391
  asle->cblv = (bclp * 100U) / 255U | 2147483648U;
#line 393
  return (0U);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
static void psb_intel_opregion_asle_work(struct work_struct *work ) 
{ 
  struct psb_intel_opregion *opregion ;
  struct work_struct  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion  const  *__mptr___0 ;
  struct opregion_asle *asle ;
  u32 asle_stat ;
  u32 asle_req ;
  long tmp ;
  u32 tmp___0 ;

  {
#line 399
  __mptr = (struct work_struct  const  *)work;
#line 399
  opregion = (struct psb_intel_opregion *)__mptr + 0xffffffffffffffd0UL;
#line 401
  __mptr___0 = (struct psb_intel_opregion  const  *)opregion;
#line 401
  dev_priv = (struct drm_psb_private *)__mptr___0 + 0xffffffffffffed40UL;
#line 402
  asle = opregion->asle;
#line 403
  asle_stat = 0U;
#line 406
  if ((unsigned long )asle == (unsigned long )((struct opregion_asle *)0)) {
#line 407
    return;
  } else {

  }
#line 409
  asle_req = asle->aslc & 15U;
#line 410
  if (asle_req == 0U) {
#line 411
    tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 411
    if (tmp != 0L) {
#line 411
      drm_ut_debug_printk("psb_intel_opregion_asle_work", "non asle set request??\n");
    } else {

    }
#line 412
    return;
  } else {

  }
#line 415
  if ((asle_req & 2U) != 0U) {
#line 416
    tmp___0 = asle_set_backlight(dev_priv->dev, asle->bclp);
#line 416
    asle_stat = tmp___0 | asle_stat;
  } else {

  }
#line 418
  asle->aslc = asle_stat;
#line 419
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void psb_intel_opregion_asle_intr(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 424
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 426
  if ((unsigned long )dev_priv->opregion.asle != (unsigned long )((struct opregion_asle *)0)) {
#line 427
    schedule_work(& dev_priv->opregion.asle_work);
  } else {

  }
#line 428
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void psb_intel_opregion_enable_asle(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;

  {
#line 437
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 438
  asle = dev_priv->opregion.asle;
#line 440
  if ((unsigned long )asle != (unsigned long )((struct opregion_asle *)0) && (unsigned long )system_opregion != (unsigned long )((struct psb_intel_opregion *)0)) {
#line 443
    psb_enable_pipestat(dev_priv, 0, 4194304U);
#line 444
    psb_enable_pipestat(dev_priv, 1, 4194304U);
#line 446
    asle->tche = 15U;
#line 448
    asle->ardy = 1U;
  } else {

  }
#line 450
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
static int psb_intel_opregion_video_event(struct notifier_block *nb , unsigned long val ,
                                          void *data ) 
{ 
  struct opregion_acpi *acpi ;

  {
#line 469
  if ((unsigned long )system_opregion == (unsigned long )((struct psb_intel_opregion *)0)) {
#line 470
    return (0);
  } else {

  }
#line 472
  acpi = system_opregion->acpi;
#line 473
  acpi->csts = 0U;
#line 475
  return (1);
}
}
#line 478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
static struct notifier_block psb_intel_opregion_notifier  =    {& psb_intel_opregion_video_event, 0, 0};
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void psb_intel_opregion_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
#line 484
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 485
  opregion = & dev_priv->opregion;
#line 487
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
#line 488
    return;
  } else {

  }
#line 490
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
#line 494
    (opregion->acpi)->csts = 0U;
#line 495
    (opregion->acpi)->drdy = 1U;
#line 497
    system_opregion = opregion;
#line 498
    register_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
#line 500
  return;
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void psb_intel_opregion_fini(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
#line 504
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 505
  opregion = & dev_priv->opregion;
#line 507
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
#line 508
    return;
  } else {

  }
#line 510
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
#line 511
    (opregion->acpi)->drdy = 0U;
#line 513
    system_opregion = (struct psb_intel_opregion *)0;
#line 514
    unregister_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
#line 517
  cancel_work_sync(& opregion->asle_work);
#line 520
  iounmap((void volatile   *)opregion->header);
#line 521
  opregion->header = (struct opregion_header *)0;
#line 522
  opregion->acpi = (struct opregion_acpi *)0;
#line 523
  opregion->swsci = (struct opregion_swsci *)0;
#line 524
  opregion->asle = (struct opregion_asle *)0;
#line 525
  opregion->vbt = (void *)0;
#line 526
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
int psb_intel_opregion_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;
  u32 opregion_phy ;
  u32 mboxes ;
  void *base ;
  int err ;
  long tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 530
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 531
  opregion = & dev_priv->opregion;
#line 534
  err = 0;
#line 536
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 252, & opregion_phy);
#line 537
  if (opregion_phy == 0U) {
#line 538
    tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 538
    if (tmp != 0L) {
#line 538
      drm_ut_debug_printk("psb_intel_opregion_setup", "ACPI Opregion not supported\n");
    } else {

    }
#line 539
    return (-524);
  } else {

  }
#line 542
  __init_work(& opregion->asle_work, 0);
#line 542
  __constr_expr_0.counter = 137438953408L;
#line 542
  opregion->asle_work.data = __constr_expr_0;
#line 542
  lockdep_init_map(& opregion->asle_work.lockdep_map, "(&opregion->asle_work)", & __key,
                   0);
#line 542
  INIT_LIST_HEAD(& opregion->asle_work.entry);
#line 542
  opregion->asle_work.func = & psb_intel_opregion_asle_work;
#line 544
  tmp___0 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 544
  if (tmp___0 != 0L) {
#line 544
    drm_ut_debug_printk("psb_intel_opregion_setup", "OpRegion detected at 0x%8x\n",
                        opregion_phy);
  } else {

  }
#line 545
  base = acpi_os_ioremap((acpi_physical_address )opregion_phy, 8192ULL);
#line 546
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 547
    return (-12);
  } else {

  }
#line 549
  tmp___2 = memcmp((void const   *)base, (void const   *)"IntelGraphicsMem", 16UL);
#line 549
  if (tmp___2 != 0) {
#line 550
    tmp___1 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 550
    if (tmp___1 != 0L) {
#line 550
      drm_ut_debug_printk("psb_intel_opregion_setup", "opregion signature mismatch\n");
    } else {

    }
#line 551
    err = -22;
#line 552
    goto err_out;
  } else {

  }
#line 555
  opregion->header = (struct opregion_header *)base;
#line 556
  opregion->vbt = base + 1024UL;
#line 558
  opregion->lid_state = (u32 *)base + 428U;
#line 560
  mboxes = (opregion->header)->mboxes;
#line 561
  if ((int )mboxes & 1) {
#line 562
    tmp___3 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 562
    if (tmp___3 != 0L) {
#line 562
      drm_ut_debug_printk("psb_intel_opregion_setup", "Public ACPI methods supported\n");
    } else {

    }
#line 563
    opregion->acpi = (struct opregion_acpi *)base + 256U;
  } else {

  }
#line 566
  if ((mboxes & 4U) != 0U) {
#line 567
    tmp___4 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 567
    if (tmp___4 != 0L) {
#line 567
      drm_ut_debug_printk("psb_intel_opregion_setup", "ASLE supported\n");
    } else {

    }
#line 568
    opregion->asle = (struct opregion_asle *)base + 768U;
  } else {

  }
#line 571
  return (0);
  err_out: 
#line 574
  iounmap((void volatile   *)base);
#line 575
  return (err);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  void *ldvarg86 ;
  void *tmp ;
  unsigned long ldvarg87 ;
  unsigned long tmp___0 ;
  struct notifier_block *ldvarg85 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 581
  tmp = ldv_zalloc(1UL);
#line 581
  ldvarg86 = tmp;
#line 582
  tmp___0 = __VERIFIER_nondet_ulong();
#line 582
  ldvarg87 = tmp___0;
#line 583
  tmp___1 = ldv_zalloc(24UL);
#line 583
  ldvarg85 = (struct notifier_block *)tmp___1;
#line 585
  tmp___2 = __VERIFIER_nondet_int();
#line 585
  switch (tmp___2) {
  case 0: ;
#line 588
  if (ldv_state_variable_31 == 1) {
#line 590
    psb_intel_opregion_video_event(ldvarg85, ldvarg87, ldvarg86);
#line 592
    ldv_state_variable_31 = 1;
  } else {

  }
#line 595
  goto ldv_43166;
  default: 
#line 596
  ldv_stop();
  }
  ldv_43166: ;
#line 600
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/opregion.o.c.prepared"
void *ldv_kmem_cache_alloc_460(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 731
  ldv_check_alloc_flags(flags);
#line 733
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 734
  return ((void *)0);
}
}
#line 309 "./arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 


  {
#line 309
  __asm__  volatile   ("outb %b0, %w1": : "a" (value), "Nd" (port));
#line 310
  return;
}
}
#line 309 "./arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ 
  unsigned char value ;

  {
#line 309
  __asm__  volatile   ("inb %w1, %b0": "=a" (value): "Nd" (port));
#line 309
  return (value);
}
}
#line 311 "./arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 311
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 312
  return;
}
}
#line 311 "./arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
#line 311
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 311
  return (value);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_480(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 842 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 848
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 856 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 858
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 858
  return (tmp);
}
}
#line 869 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 871
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 871
  return (tmp);
}
}
#line 1192
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
#line 1193 "include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1195
  tmp = pci_enable_msi_range(dev, nvec, nvec);
#line 1195
  rc = tmp;
#line 1196
  if (rc < 0) {
#line 1197
    return (rc);
  } else {

  }
#line 1198
  return (0);
}
}
#line 946 "include/drm/drm_crtc.h"
extern void drm_mode_config_reset(struct drm_device * ) ;
#line 162 "include/drm/drm_crtc_helper.h"
extern void drm_helper_resume_force_mode(struct drm_device * ) ;
#line 174
extern bool drm_helper_hpd_irq_event(struct drm_device * ) ;
#line 270 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) ;
#line 282
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) ;
#line 283
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) ;
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs ;
#line 19
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs ;
#line 20
struct gma_clock_funcs  const  cdv_clock_funcs ;
#line 21
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 23
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 25
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) ;
#line 29
void cdv_update_wm(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 30
void cdv_disable_sr(struct drm_device *dev ) ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static void cdv_disable_vga(struct drm_device *dev ) 
{ 
  u8 sr1 ;
  u32 vga_reg ;

  {
#line 259
  vga_reg = 463872U;
#line 261
  outb(1, 964);
#line 262
  sr1 = inb(965);
#line 263
  outb((int )((unsigned int )sr1 | 32U), 965);
#line 264
  __const_udelay(1288500UL);
#line 266
  REGISTER_WRITE(dev, vga_reg, 2147483648U);
#line 267
  REGISTER_READ(dev, vga_reg);
#line 268
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 272
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 274
  drm_mode_create_scaling_mode_property(dev);
#line 276
  cdv_disable_vga(dev);
#line 278
  cdv_intel_crt_init(dev, & dev_priv->mode_dev);
#line 279
  cdv_intel_lvds_init(dev, & dev_priv->mode_dev);
#line 282
  tmp___0 = REGISTER_READ(dev, 397632U);
#line 282
  if ((tmp___0 & 4U) != 0U) {
#line 283
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397632);
#line 284
    tmp = REGISTER_READ(dev, 409856U);
#line 284
    if ((tmp & 4U) != 0U) {
#line 285
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 409856);
    } else {

    }
  } else {

  }
#line 288
  tmp___2 = REGISTER_READ(dev, 397664U);
#line 288
  if ((tmp___2 & 4U) != 0U) {
#line 289
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397664);
#line 290
    tmp___1 = REGISTER_READ(dev, 410112U);
#line 290
    if ((tmp___1 & 4U) != 0U) {
#line 291
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 410112);
    } else {

    }
  } else {

  }
#line 293
  return (0);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
__inline static u32 CDV_MSG_READ32(uint port , uint offset ) 
{ 
  int mcr ;
  uint32_t ret_val ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
#line 410
  mcr = (int )(((port << 16) | (offset << 8)) | 268435456U);
#line 411
  ret_val = 0U;
#line 412
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 412
  pci_root = tmp;
#line 413
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
#line 414
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & ret_val);
#line 415
  pci_dev_put(pci_root);
#line 416
  return (ret_val);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
__inline static void CDV_MSG_WRITE32(uint port , uint offset , u32 value ) 
{ 
  int mcr ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
#line 421
  mcr = (int )(((port << 16) | (offset << 8)) | 285212912U);
#line 422
  tmp = pci_get_bus_and_slot(0U, 0U);
#line 422
  pci_root = tmp;
#line 423
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 212, value);
#line 424
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
#line 425
  pci_dev_put(pci_root);
#line 426
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static void cdv_init_pm(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  int i ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 pwr_sts ;
  unsigned int tmp___1 ;

  {
#line 437
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 441
  tmp = CDV_MSG_READ32(4U, 122U);
#line 441
  dev_priv->apm_base = (uint16_t )tmp;
#line 443
  tmp___0 = CDV_MSG_READ32(4U, 120U);
#line 443
  dev_priv->ospm_base = tmp___0 & 65535U;
#line 447
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 450
  pwr_cnt = pwr_cnt & 4294967292U;
#line 451
  pwr_cnt = pwr_cnt | 2U;
#line 452
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 455
  i = 0;
#line 455
  goto ldv_39783;
  ldv_39782: 
#line 456
  tmp___1 = inl((int )dev_priv->apm_base + 4);
#line 456
  pwr_sts = tmp___1;
#line 457
  if ((pwr_sts & 3U) == 0U) {
#line 458
    return;
  } else {

  }
#line 459
  __const_udelay(42950UL);
#line 455
  i = i + 1;
  ldv_39783: ;
#line 455
  if (i <= 4) {
#line 457
    goto ldv_39782;
  } else {

  }
#line 461
  dev_err((struct device  const  *)dev->dev, "GPU: power management timed out.\n");
#line 462
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static void cdv_errata(struct drm_device *dev ) 
{ 


  {
#line 474
  CDV_MSG_WRITE32(3U, 48U, 134377736U);
#line 475
  return;
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 486
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 487
  regs = & dev_priv->regs;
#line 490
  descriptor.modname = "gma500_gfx";
#line 490
  descriptor.function = "cdv_save_display_registers";
#line 490
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared";
#line 490
  descriptor.format = "Saving GPU registers.\n";
#line 490
  descriptor.lineno = 490U;
#line 490
  descriptor.flags = 0U;
#line 490
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 490
  if (tmp != 0L) {
#line 490
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Saving GPU registers.\n");
  } else {

  }
#line 492
  pci_read_config_byte((struct pci_dev  const  *)dev->pdev, 244, & regs->ldv_40416.cdv.saveLBB);
#line 494
  regs->ldv_40416.cdv.saveDSPCLK_GATE_D = REGISTER_READ(dev, 25088U);
#line 495
  regs->ldv_40416.cdv.saveRAMCLK_GATE_D = REGISTER_READ(dev, 25104U);
#line 497
  regs->ldv_40416.cdv.saveDSPARB = REGISTER_READ(dev, 458800U);
#line 498
  regs->ldv_40416.cdv.saveDSPFW[0] = REGISTER_READ(dev, 458804U);
#line 499
  regs->ldv_40416.cdv.saveDSPFW[1] = REGISTER_READ(dev, 458808U);
#line 500
  regs->ldv_40416.cdv.saveDSPFW[2] = REGISTER_READ(dev, 458812U);
#line 501
  regs->ldv_40416.cdv.saveDSPFW[3] = REGISTER_READ(dev, 458832U);
#line 502
  regs->ldv_40416.cdv.saveDSPFW[4] = REGISTER_READ(dev, 458836U);
#line 503
  regs->ldv_40416.cdv.saveDSPFW[5] = REGISTER_READ(dev, 458840U);
#line 505
  regs->ldv_40416.cdv.saveADPA = REGISTER_READ(dev, 397568U);
#line 507
  regs->ldv_40416.cdv.savePP_CONTROL = REGISTER_READ(dev, 397828U);
#line 508
  regs->ldv_40416.cdv.savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
#line 509
  regs->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 510
  regs->saveBLC_PWM_CTL2 = REGISTER_READ(dev, 397904U);
#line 511
  regs->ldv_40416.cdv.saveLVDS = REGISTER_READ(dev, 397696U);
#line 513
  regs->ldv_40416.cdv.savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
#line 515
  regs->ldv_40416.cdv.savePP_ON_DELAYS = REGISTER_READ(dev, 397832U);
#line 516
  regs->ldv_40416.cdv.savePP_OFF_DELAYS = REGISTER_READ(dev, 397836U);
#line 517
  regs->ldv_40416.cdv.savePP_CYCLE = REGISTER_READ(dev, 397840U);
#line 519
  regs->ldv_40416.cdv.saveVGACNTRL = REGISTER_READ(dev, 463872U);
#line 521
  regs->ldv_40416.cdv.saveIER = REGISTER_READ(dev, 8352U);
#line 522
  regs->ldv_40416.cdv.saveIMR = REGISTER_READ(dev, 8360U);
#line 524
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 524
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 524
  goto ldv_39801;
  ldv_39800: 
#line 525
  (*((connector->funcs)->dpms))(connector, 3);
#line 524
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 524
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_39801: ;
#line 524
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 526
    goto ldv_39800;
  } else {

  }

#line 527
  return (0);
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  u32 temp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 540
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 541
  regs = & dev_priv->regs;
#line 545
  pci_write_config_byte((struct pci_dev  const  *)dev->pdev, 244, (int )regs->ldv_40416.cdv.saveLBB);
#line 547
  REGISTER_WRITE(dev, 25088U, regs->ldv_40416.cdv.saveDSPCLK_GATE_D);
#line 548
  REGISTER_WRITE(dev, 25104U, regs->ldv_40416.cdv.saveRAMCLK_GATE_D);
#line 551
  REGISTER_WRITE(dev, 8464U, 0U);
#line 552
  REGISTER_WRITE(dev, 8464U, 5U);
#line 554
  temp = REGISTER_READ(dev, 24596U);
#line 555
  if ((temp & 536870912U) == 0U) {
#line 556
    REGISTER_WRITE(dev, 24596U, temp | 536870912U);
#line 557
    REGISTER_READ(dev, 24596U);
  } else {

  }
#line 560
  temp = REGISTER_READ(dev, 24600U);
#line 561
  if ((temp & 536870912U) == 0U) {
#line 562
    REGISTER_WRITE(dev, 24600U, temp | 536870912U);
#line 563
    REGISTER_READ(dev, 24600U);
  } else {

  }
#line 566
  __const_udelay(2147500UL);
#line 568
  REGISTER_WRITE(dev, 458804U, regs->ldv_40416.cdv.saveDSPFW[0]);
#line 569
  REGISTER_WRITE(dev, 458808U, regs->ldv_40416.cdv.saveDSPFW[1]);
#line 570
  REGISTER_WRITE(dev, 458812U, regs->ldv_40416.cdv.saveDSPFW[2]);
#line 571
  REGISTER_WRITE(dev, 458832U, regs->ldv_40416.cdv.saveDSPFW[3]);
#line 572
  REGISTER_WRITE(dev, 458836U, regs->ldv_40416.cdv.saveDSPFW[4]);
#line 573
  REGISTER_WRITE(dev, 458840U, regs->ldv_40416.cdv.saveDSPFW[5]);
#line 575
  REGISTER_WRITE(dev, 458800U, regs->ldv_40416.cdv.saveDSPARB);
#line 576
  REGISTER_WRITE(dev, 397568U, regs->ldv_40416.cdv.saveADPA);
#line 578
  REGISTER_WRITE(dev, 397904U, regs->saveBLC_PWM_CTL2);
#line 579
  REGISTER_WRITE(dev, 397696U, regs->ldv_40416.cdv.saveLVDS);
#line 580
  REGISTER_WRITE(dev, 397872U, regs->ldv_40416.cdv.savePFIT_CONTROL);
#line 581
  REGISTER_WRITE(dev, 397876U, regs->ldv_40416.cdv.savePFIT_PGM_RATIOS);
#line 582
  REGISTER_WRITE(dev, 397908U, regs->saveBLC_PWM_CTL);
#line 583
  REGISTER_WRITE(dev, 397832U, regs->ldv_40416.cdv.savePP_ON_DELAYS);
#line 584
  REGISTER_WRITE(dev, 397836U, regs->ldv_40416.cdv.savePP_OFF_DELAYS);
#line 585
  REGISTER_WRITE(dev, 397840U, regs->ldv_40416.cdv.savePP_CYCLE);
#line 586
  REGISTER_WRITE(dev, 397828U, regs->ldv_40416.cdv.savePP_CONTROL);
#line 588
  REGISTER_WRITE(dev, 463872U, regs->ldv_40416.cdv.saveVGACNTRL);
#line 590
  REGISTER_WRITE(dev, 8352U, regs->ldv_40416.cdv.saveIER);
#line 591
  REGISTER_WRITE(dev, 8360U, regs->ldv_40416.cdv.saveIMR);
#line 594
  cdv_errata(dev);
#line 596
  drm_mode_config_reset(dev);
#line 598
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 598
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 598
  goto ldv_39815;
  ldv_39814: 
#line 599
  (*((connector->funcs)->dpms))(connector, 0);
#line 598
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 598
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_39815: ;
#line 598
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 600
    goto ldv_39814;
  } else {

  }
#line 602
  drm_helper_resume_force_mode(dev);
#line 603
  return (0);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_power_down(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
#line 608
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 610
  tries = 5;
#line 612
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 613
  pwr_cnt = pwr_cnt & 4294967292U;
#line 614
  pwr_cnt = pwr_cnt | 1U;
#line 615
  pwr_mask = 3U;
#line 617
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 619
  goto ldv_39826;
  ldv_39825: 
#line 620
  pwr_sts = inl((int )dev_priv->apm_base + 4);
#line 621
  if ((pwr_sts & pwr_mask) == 3U) {
#line 622
    return (0);
  } else {

  }
#line 623
  __const_udelay(42950UL);
  ldv_39826: 
#line 619
  tmp = tries;
#line 619
  tries = tries - 1;
#line 619
  if (tmp != 0) {
#line 621
    goto ldv_39825;
  } else {

  }

#line 625
  return (0);
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_power_up(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
#line 630
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 632
  tries = 5;
#line 634
  pwr_cnt = inl((int )dev_priv->apm_base);
#line 635
  pwr_cnt = pwr_cnt & 4294967292U;
#line 636
  pwr_cnt = pwr_cnt | 2U;
#line 637
  pwr_mask = 3U;
#line 639
  outl(pwr_cnt, (int )dev_priv->apm_base);
#line 641
  goto ldv_39837;
  ldv_39836: 
#line 642
  pwr_sts = inl((int )dev_priv->apm_base + 4);
#line 643
  if ((pwr_sts & pwr_mask) == 0U) {
#line 644
    return (0);
  } else {

  }
#line 645
  __const_udelay(42950UL);
  ldv_39837: 
#line 641
  tmp = tries;
#line 641
  tries = tries - 1;
#line 641
  if (tmp != 0) {
#line 643
    goto ldv_39836;
  } else {

  }

#line 647
  return (0);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static void cdv_hotplug_work_func(struct work_struct *work ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct work_struct  const  *__mptr ;
  struct drm_device *dev ;

  {
#line 652
  __mptr = (struct work_struct  const  *)work;
#line 652
  dev_priv = (struct drm_psb_private *)__mptr + 0xffffffffffffee58UL;
#line 654
  dev = dev_priv->dev;
#line 657
  drm_helper_hpd_irq_event(dev);
#line 658
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_hotplug_event(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  uint32_t tmp ;

  {
#line 665
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 666
  schedule_work(& dev_priv->hotplug_work);
#line 667
  tmp = REGISTER_READ(dev, 397588U);
#line 667
  REGISTER_WRITE(dev, 397588U, tmp);
#line 668
  return (1);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static void cdv_hotplug_enable(struct drm_device *dev , bool on ) 
{ 
  u32 hotplug ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 673
  if ((int )on) {
#line 674
    tmp = REGISTER_READ(dev, 397584U);
#line 674
    hotplug = tmp;
#line 675
    hotplug = hotplug | 939524608U;
#line 677
    REGISTER_WRITE(dev, 397584U, hotplug);
  } else {
#line 679
    REGISTER_WRITE(dev, 397584U, 0U);
#line 680
    tmp___0 = REGISTER_READ(dev, 397588U);
#line 680
    REGISTER_WRITE(dev, 397588U, tmp___0);
  }
#line 682
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static char const   *force_audio_names[3U]  = {      "off",      "auto",      "on"};
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
#line 692
  dev = connector->dev;
#line 693
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 697
  prop = dev_priv->force_audio_property;
#line 698
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 699
    prop = drm_property_create(dev, 8, "audio", 3);
#line 702
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 703
      return;
    } else {

    }
#line 705
    i = 0;
#line 705
    goto ldv_39868;
    ldv_39867: 
#line 706
    drm_property_add_enum(prop, i, (uint64_t )(i + -1), force_audio_names[i]);
#line 705
    i = i + 1;
    ldv_39868: ;
#line 705
    if ((unsigned int )i <= 2U) {
#line 707
      goto ldv_39867;
    } else {

    }
#line 708
    dev_priv->force_audio_property = prop;
  } else {

  }
#line 710
  drm_object_attach_property(& connector->base, prop, 0ULL);
#line 711
  return;
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static char const   *broadcast_rgb_names[2U]  = {      "Full",      "Limited 16:235"};
#line 719 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
#line 721
  dev = connector->dev;
#line 722
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 726
  prop = dev_priv->broadcast_rgb_property;
#line 727
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 728
    prop = drm_property_create(dev, 8, "Broadcast RGB", 2);
#line 731
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
#line 732
      return;
    } else {

    }
#line 734
    i = 0;
#line 734
    goto ldv_39883;
    ldv_39882: 
#line 735
    drm_property_add_enum(prop, i, (uint64_t )i, broadcast_rgb_names[i]);
#line 734
    i = i + 1;
    ldv_39883: ;
#line 734
    if ((unsigned int )i <= 1U) {
#line 736
      goto ldv_39882;
    } else {

    }
#line 737
    dev_priv->broadcast_rgb_property = prop;
  } else {

  }
#line 740
  drm_object_attach_property(& connector->base, prop, 0ULL);
#line 741
  return;
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static struct psb_offset  const  cdv_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 24604U, 393216U, 393220U,
      393224U, 393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U,
      459140U, 458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 24608U, 397312U, 397316U,
      397320U, 397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U,
      463236U, 462884U, 463236U, 463268U, 43008U}};
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
static int cdv_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  int tmp ;

  {
#line 799
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 800
  __init_work(& dev_priv->hotplug_work, 0);
#line 800
  __constr_expr_0.counter = 137438953408L;
#line 800
  dev_priv->hotplug_work.data = __constr_expr_0;
#line 800
  lockdep_init_map(& dev_priv->hotplug_work.lockdep_map, "(&dev_priv->hotplug_work)",
                   & __key, 0);
#line 800
  INIT_LIST_HEAD(& dev_priv->hotplug_work.entry);
#line 800
  dev_priv->hotplug_work.func = & cdv_hotplug_work_func;
#line 802
  tmp = pci_enable_msi_exact(dev->pdev, 1);
#line 802
  if (tmp != 0) {
#line 803
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
#line 804
  dev_priv->regmap = (struct psb_offset  const  *)(& cdv_regmap);
#line 805
  gma_get_core_freq(dev);
#line 806
  psb_intel_opregion_init(dev);
#line 807
  psb_intel_init_bios(dev);
#line 808
  cdv_hotplug_enable(dev, 0);
#line 809
  return (0);
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
struct psb_ops  const  cdv_chip_ops  = 
#line 814
     {"GMA3600/3650", 0U, 2, 2, 524288, 3, 2, 1, 0, & cdv_intel_helper_funcs, & cdv_intel_crtc_funcs,
    & cdv_clock_funcs, & cdv_chip_setup, 0, & cdv_errata, & cdv_output_init, & cdv_hotplug_event,
    & cdv_hotplug_enable, & cdv_init_pm, & cdv_save_display_registers, & cdv_restore_display_registers,
    & cdv_power_up, & cdv_power_down, & cdv_update_wm, & cdv_disable_sr, 0, 0};
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_initialize_psb_ops_30(void) 
{ 
  void *tmp ;

  {
#line 850
  tmp = ldv_zalloc(2992UL);
#line 850
  cdv_chip_ops_group0 = (struct drm_device *)tmp;
#line 851
  return;
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void ldv_main_exported_30(void) 
{ 
  bool ldvarg15 ;
  struct drm_crtc *ldvarg14 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 855
  tmp = ldv_zalloc(1048UL);
#line 855
  ldvarg14 = (struct drm_crtc *)tmp;
#line 854
  memset((void *)(& ldvarg15), 0, 1UL);
#line 857
  tmp___0 = __VERIFIER_nondet_int();
#line 857
  switch (tmp___0) {
  case 0: ;
#line 860
  if (ldv_state_variable_30 == 1) {
#line 862
    cdv_chip_setup(cdv_chip_ops_group0);
#line 864
    ldv_state_variable_30 = 1;
  } else {

  }
#line 867
  goto ldv_39902;
  case 1: ;
#line 870
  if (ldv_state_variable_30 == 1) {
#line 872
    cdv_errata(cdv_chip_ops_group0);
#line 874
    ldv_state_variable_30 = 1;
  } else {

  }
#line 877
  goto ldv_39902;
  case 2: ;
#line 880
  if (ldv_state_variable_30 == 1) {
#line 882
    cdv_init_pm(cdv_chip_ops_group0);
#line 884
    ldv_state_variable_30 = 1;
  } else {

  }
#line 887
  goto ldv_39902;
  case 3: ;
#line 890
  if (ldv_state_variable_30 == 1) {
#line 892
    cdv_disable_sr(cdv_chip_ops_group0);
#line 894
    ldv_state_variable_30 = 1;
  } else {

  }
#line 897
  goto ldv_39902;
  case 4: ;
#line 900
  if (ldv_state_variable_30 == 1) {
#line 902
    cdv_hotplug_enable(cdv_chip_ops_group0, (int )ldvarg15);
#line 904
    ldv_state_variable_30 = 1;
  } else {

  }
#line 907
  goto ldv_39902;
  case 5: ;
#line 910
  if (ldv_state_variable_30 == 1) {
#line 912
    cdv_hotplug_event(cdv_chip_ops_group0);
#line 914
    ldv_state_variable_30 = 1;
  } else {

  }
#line 917
  goto ldv_39902;
  case 6: ;
#line 920
  if (ldv_state_variable_30 == 1) {
#line 922
    cdv_save_display_registers(cdv_chip_ops_group0);
#line 924
    ldv_state_variable_30 = 1;
  } else {

  }
#line 927
  goto ldv_39902;
  case 7: ;
#line 930
  if (ldv_state_variable_30 == 1) {
#line 932
    cdv_restore_display_registers(cdv_chip_ops_group0);
#line 934
    ldv_state_variable_30 = 1;
  } else {

  }
#line 937
  goto ldv_39902;
  case 8: ;
#line 940
  if (ldv_state_variable_30 == 1) {
#line 942
    cdv_update_wm(cdv_chip_ops_group0, ldvarg14);
#line 944
    ldv_state_variable_30 = 1;
  } else {

  }
#line 947
  goto ldv_39902;
  case 9: ;
#line 950
  if (ldv_state_variable_30 == 1) {
#line 952
    cdv_power_down(cdv_chip_ops_group0);
#line 954
    ldv_state_variable_30 = 1;
  } else {

  }
#line 957
  goto ldv_39902;
  case 10: ;
#line 960
  if (ldv_state_variable_30 == 1) {
#line 962
    cdv_output_init(cdv_chip_ops_group0);
#line 964
    ldv_state_variable_30 = 1;
  } else {

  }
#line 967
  goto ldv_39902;
  case 11: ;
#line 970
  if (ldv_state_variable_30 == 1) {
#line 972
    cdv_power_up(cdv_chip_ops_group0);
#line 974
    ldv_state_variable_30 = 1;
  } else {

  }
#line 977
  goto ldv_39902;
  default: 
#line 978
  ldv_stop();
  }
  ldv_39902: ;
#line 982
  return;
}
}
#line 1110 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_device.o.c.prepared"
void *ldv_kmem_cache_alloc_480(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1113
  ldv_check_alloc_flags(flags);
#line 1115
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1116
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_500(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static void cdv_intel_crt_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  u32 temp ;
  u32 reg ;

  {
#line 261
  dev = encoder->dev;
#line 263
  reg = 397568U;
#line 265
  temp = REGISTER_READ(dev, reg);
#line 266
  temp = temp & 4294964223U;
#line 267
  temp = temp & 2147483647U;
#line 269
  switch (mode) {
  case 0: 
#line 271
  temp = temp | 2147483648U;
#line 272
  goto ldv_39758;
  case 1: 
#line 274
  temp = temp | 2147484672U;
#line 275
  goto ldv_39758;
  case 2: 
#line 277
  temp = temp | 2147485696U;
#line 278
  goto ldv_39758;
  case 3: 
#line 280
  temp = temp | 3072U;
#line 281
  goto ldv_39758;
  }
  ldv_39758: 
#line 284
  REGISTER_WRITE(dev, reg, temp);
#line 285
  return;
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static int cdv_intel_crt_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 290
  if ((mode->flags & 32U) != 0U) {
#line 291
    return (8);
  } else {

  }
#line 294
  if (mode->clock <= 19999) {
#line 295
    return (16);
  } else {

  }
#line 298
  if (mode->clock > 355000) {
#line 299
    return (15);
  } else {

  }
#line 301
  return (0);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static void cdv_intel_crt_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int dpll_md_reg ;
  u32 adpa ;
  u32 dpll_md ;
  u32 adpa_reg ;

  {
#line 309
  dev = encoder->dev;
#line 310
  crtc = encoder->crtc;
#line 311
  __mptr = (struct drm_crtc  const  *)crtc;
#line 311
  gma_crtc = (struct gma_crtc *)__mptr;
#line 316
  if (gma_crtc->pipe == 0) {
#line 317
    dpll_md_reg = 24604;
  } else {
#line 319
    dpll_md_reg = 24608;
  }
#line 321
  adpa_reg = 397568U;
#line 328
  dpll_md = REGISTER_READ(dev, (uint32_t )dpll_md_reg);
#line 329
  REGISTER_WRITE(dev, (uint32_t )dpll_md_reg, dpll_md & 4294951167U);
#line 333
  adpa = 0U;
#line 334
  if ((int )adjusted_mode->flags & 1) {
#line 335
    adpa = adpa | 8U;
  } else {

  }
#line 336
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 337
    adpa = adpa | 16U;
  } else {

  }
#line 339
  if (gma_crtc->pipe == 0) {
#line 340
    adpa = adpa;
  } else {
#line 342
    adpa = adpa | 1073741824U;
  }
#line 344
  REGISTER_WRITE(dev, adpa_reg, adpa);
#line 345
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static bool cdv_intel_crt_detect_hotplug(struct drm_connector *connector , bool force ) 
{ 
  struct drm_device *dev ;
  u32 hotplug_en ;
  int i ;
  int tries ;
  int ret ;
  u32 orig ;
  unsigned long timeout ;
  unsigned long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 357
  dev = connector->dev;
#line 359
  tries = 0;
#line 359
  ret = 0;
#line 366
  tries = 2;
#line 368
  hotplug_en = REGISTER_READ(dev, 397584U);
#line 368
  orig = hotplug_en;
#line 369
  hotplug_en = hotplug_en & 4294967047U;
#line 370
  hotplug_en = hotplug_en | 8U;
#line 372
  hotplug_en = hotplug_en | 256U;
#line 373
  hotplug_en = hotplug_en | 32U;
#line 375
  i = 0;
#line 375
  goto ldv_39800;
  ldv_39799: 
#line 378
  REGISTER_WRITE(dev, 397584U, hotplug_en);
#line 379
  tmp = msecs_to_jiffies(1000U);
#line 379
  timeout = tmp + (unsigned long )jiffies;
  ldv_39798: 
#line 382
  tmp___0 = REGISTER_READ(dev, 397584U);
#line 382
  if ((tmp___0 & 8U) == 0U) {
#line 384
    goto ldv_39791;
  } else {

  }
#line 385
  msleep(1U);
#line 386
  if ((long )((unsigned long )jiffies - timeout) < 0L) {
#line 388
    goto ldv_39798;
  } else {

  }
  ldv_39791: 
#line 375
  i = i + 1;
  ldv_39800: ;
#line 375
  if (i < tries) {
#line 377
    goto ldv_39799;
  } else {

  }
#line 389
  tmp___1 = REGISTER_READ(dev, 397588U);
#line 389
  if ((tmp___1 & 768U) != 0U) {
#line 391
    ret = 1;
  } else {

  }
#line 394
  REGISTER_WRITE(dev, 397588U, 2048U);
#line 397
  REGISTER_WRITE(dev, 397584U, orig);
#line 398
  return (ret != 0);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static enum drm_connector_status cdv_intel_crt_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ 
  bool tmp ;

  {
#line 404
  tmp = cdv_intel_crt_detect_hotplug(connector, (int )force);
#line 404
  if ((int )tmp) {
#line 405
    return (1);
  } else {
#line 407
    return (2);
  }
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static void cdv_intel_crt_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 412
  tmp = gma_attached_encoder(connector);
#line 412
  gma_encoder = tmp;
#line 414
  psb_intel_i2c_destroy(gma_encoder->ddc_bus);
#line 415
  drm_sysfs_connector_remove(connector);
#line 416
  drm_connector_cleanup(connector);
#line 417
  kfree((void const   *)connector);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static int cdv_intel_crt_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  int tmp___0 ;

  {
#line 422
  tmp = gma_attached_encoder(connector);
#line 422
  gma_encoder = tmp;
#line 423
  tmp___0 = psb_intel_ddc_get_modes(connector, & (gma_encoder->ddc_bus)->adapter);
#line 423
  return (tmp___0);
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static int cdv_intel_crt_set_property(struct drm_connector *connector , struct drm_property *property ,
                                      uint64_t value ) 
{ 


  {
#line 431
  return (0);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static struct drm_encoder_helper_funcs  const  cdv_intel_crt_helper_funcs  = 
#line 438
     {& cdv_intel_crt_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & cdv_intel_crt_mode_set, 0, 0, 0};
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static struct drm_connector_funcs  const  cdv_intel_crt_connector_funcs  = 
#line 446
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_crt_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_crt_set_property, & cdv_intel_crt_destroy, 0};
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static struct drm_connector_helper_funcs  const  cdv_intel_crt_connector_helper_funcs  =    {& cdv_intel_crt_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_crt_mode_valid),
    & gma_best_encoder};
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static void cdv_intel_crt_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 463
  drm_encoder_cleanup(encoder);
#line 464
  return;
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
static struct drm_encoder_funcs  const  cdv_intel_crt_enc_funcs  =    {0, & cdv_intel_crt_enc_destroy};
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_connector *gma_connector ;
  struct gma_encoder *gma_encoder ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  u32 i2c_reg ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 481
  tmp = kzalloc(152UL, 208U);
#line 481
  gma_encoder = (struct gma_encoder *)tmp;
#line 482
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 483
    return;
  } else {

  }
#line 485
  tmp___0 = kzalloc(728UL, 208U);
#line 485
  gma_connector = (struct gma_connector *)tmp___0;
#line 486
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 487
    goto failed_connector;
  } else {

  }
#line 489
  connector = & gma_connector->base;
#line 490
  connector->polled = 1U;
#line 491
  drm_connector_init(dev, connector, & cdv_intel_crt_connector_funcs, 1);
#line 494
  encoder = & gma_encoder->base;
#line 495
  drm_encoder_init(dev, encoder, & cdv_intel_crt_enc_funcs, 1);
#line 498
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 501
  i2c_reg = 20496U;
#line 507
  gma_encoder->ddc_bus = psb_intel_i2c_create(dev, i2c_reg, "CRTDDC_A");
#line 509
  if ((unsigned long )gma_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 510
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 512
    goto failed_ddc;
  } else {

  }
#line 515
  gma_encoder->type = 1;
#line 520
  connector->interlace_allowed = 0;
#line 521
  connector->doublescan_allowed = 0;
#line 523
  drm_encoder_helper_add(encoder, & cdv_intel_crt_helper_funcs);
#line 524
  drm_connector_helper_add(connector, & cdv_intel_crt_connector_helper_funcs);
#line 527
  drm_sysfs_connector_add(connector);
#line 529
  return;
  failed_ddc: 
#line 531
  drm_encoder_cleanup(& gma_encoder->base);
#line 532
  drm_connector_cleanup(& gma_connector->base);
#line 533
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 535
  kfree((void const   *)gma_encoder);
#line 536
  return;
}
}
#line 539
extern int ldv_probe_28(void) ;
#line 540
extern int ldv_probe_26(void) ;
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_connector_funcs_28(void) 
{ 
  void *tmp ;

  {
#line 544
  tmp = ldv_zalloc(720UL);
#line 544
  cdv_intel_crt_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_27(void) 
{ 
  void *tmp ;

  {
#line 548
  tmp = ldv_zalloc(720UL);
#line 548
  cdv_intel_crt_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 549
  return;
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_29(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 552
  tmp = ldv_zalloc(96UL);
#line 552
  cdv_intel_crt_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 553
  tmp___0 = ldv_zalloc(208UL);
#line 553
  cdv_intel_crt_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 554
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_27(void) 
{ 
  struct drm_display_mode *ldvarg37 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 557
  tmp = ldv_zalloc(208UL);
#line 557
  ldvarg37 = (struct drm_display_mode *)tmp;
#line 559
  tmp___0 = __VERIFIER_nondet_int();
#line 559
  switch (tmp___0) {
  case 0: ;
#line 562
  if (ldv_state_variable_27 == 1) {
#line 564
    cdv_intel_crt_get_modes(cdv_intel_crt_connector_helper_funcs_group0);
#line 566
    ldv_state_variable_27 = 1;
  } else {

  }
#line 569
  goto ldv_39855;
  case 1: ;
#line 572
  if (ldv_state_variable_27 == 1) {
#line 574
    cdv_intel_crt_mode_valid(cdv_intel_crt_connector_helper_funcs_group0, ldvarg37);
#line 576
    ldv_state_variable_27 = 1;
  } else {

  }
#line 579
  goto ldv_39855;
  case 2: ;
#line 582
  if (ldv_state_variable_27 == 1) {
#line 584
    gma_best_encoder(cdv_intel_crt_connector_helper_funcs_group0);
#line 586
    ldv_state_variable_27 = 1;
  } else {

  }
#line 589
  goto ldv_39855;
  default: 
#line 590
  ldv_stop();
  }
  ldv_39855: ;
#line 594
  return;
}
}
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_28(void) 
{ 
  uint32_t ldvarg46 ;
  uint64_t ldvarg47 ;
  int ldvarg50 ;
  int tmp ;
  bool ldvarg49 ;
  uint32_t ldvarg45 ;
  struct drm_property *ldvarg48 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 599
  tmp = __VERIFIER_nondet_int();
#line 599
  ldvarg50 = tmp;
#line 602
  tmp___0 = ldv_zalloc(104UL);
#line 602
  ldvarg48 = (struct drm_property *)tmp___0;
#line 597
  memset((void *)(& ldvarg46), 0, 4UL);
#line 598
  memset((void *)(& ldvarg47), 0, 8UL);
#line 600
  memset((void *)(& ldvarg49), 0, 1UL);
#line 601
  memset((void *)(& ldvarg45), 0, 4UL);
#line 604
  tmp___1 = __VERIFIER_nondet_int();
#line 604
  switch (tmp___1) {
  case 0: ;
#line 607
  if (ldv_state_variable_28 == 1) {
#line 609
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg50);
#line 611
    ldv_state_variable_28 = 1;
  } else {

  }
#line 614
  if (ldv_state_variable_28 == 2) {
#line 616
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg50);
#line 618
    ldv_state_variable_28 = 2;
  } else {

  }
#line 621
  goto ldv_39869;
  case 1: ;
#line 624
  if (ldv_state_variable_28 == 1) {
#line 626
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg49);
#line 628
    ldv_state_variable_28 = 1;
  } else {

  }
#line 631
  if (ldv_state_variable_28 == 2) {
#line 633
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg49);
#line 635
    ldv_state_variable_28 = 2;
  } else {

  }
#line 638
  goto ldv_39869;
  case 2: ;
#line 641
  if (ldv_state_variable_28 == 1) {
#line 643
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg48, ldvarg47);
#line 645
    ldv_state_variable_28 = 1;
  } else {

  }
#line 648
  if (ldv_state_variable_28 == 2) {
#line 650
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg48, ldvarg47);
#line 652
    ldv_state_variable_28 = 2;
  } else {

  }
#line 655
  goto ldv_39869;
  case 3: ;
#line 658
  if (ldv_state_variable_28 == 2) {
#line 660
    cdv_intel_crt_destroy(cdv_intel_crt_connector_funcs_group0);
#line 662
    ldv_state_variable_28 = 1;
#line 663
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 666
  goto ldv_39869;
  case 4: ;
#line 669
  if (ldv_state_variable_28 == 1) {
#line 671
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg46, ldvarg45);
#line 673
    ldv_state_variable_28 = 1;
  } else {

  }
#line 676
  if (ldv_state_variable_28 == 2) {
#line 678
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg46, ldvarg45);
#line 680
    ldv_state_variable_28 = 2;
  } else {

  }
#line 683
  goto ldv_39869;
  case 5: ;
#line 686
  if (ldv_state_variable_28 == 1) {
#line 688
    ldv_probe_28();
#line 690
    ldv_state_variable_28 = 2;
#line 691
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 694
  goto ldv_39869;
  default: 
#line 695
  ldv_stop();
  }
  ldv_39869: ;
#line 699
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_26(void) 
{ 
  struct drm_encoder *ldvarg6 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 702
  tmp = ldv_zalloc(96UL);
#line 702
  ldvarg6 = (struct drm_encoder *)tmp;
#line 704
  tmp___0 = __VERIFIER_nondet_int();
#line 704
  switch (tmp___0) {
  case 0: ;
#line 707
  if (ldv_state_variable_26 == 2) {
#line 709
    cdv_intel_crt_enc_destroy(ldvarg6);
#line 711
    ldv_state_variable_26 = 1;
#line 712
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 715
  goto ldv_39881;
  case 1: ;
#line 718
  if (ldv_state_variable_26 == 1) {
#line 720
    ldv_probe_26();
#line 722
    ldv_state_variable_26 = 2;
#line 723
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 726
  goto ldv_39881;
  default: 
#line 727
  ldv_stop();
  }
  ldv_39881: ;
#line 731
  return;
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void ldv_main_exported_29(void) 
{ 
  int ldvarg126 ;
  int tmp ;
  struct drm_display_mode *ldvarg125 ;
  void *tmp___0 ;
  struct drm_display_mode *ldvarg124 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 734
  tmp = __VERIFIER_nondet_int();
#line 734
  ldvarg126 = tmp;
#line 735
  tmp___0 = ldv_zalloc(208UL);
#line 735
  ldvarg125 = (struct drm_display_mode *)tmp___0;
#line 736
  tmp___1 = ldv_zalloc(208UL);
#line 736
  ldvarg124 = (struct drm_display_mode *)tmp___1;
#line 738
  tmp___2 = __VERIFIER_nondet_int();
#line 738
  switch (tmp___2) {
  case 0: ;
#line 741
  if (ldv_state_variable_29 == 1) {
#line 743
    cdv_intel_crt_dpms(cdv_intel_crt_helper_funcs_group0, ldvarg126);
#line 745
    ldv_state_variable_29 = 1;
  } else {

  }
#line 748
  goto ldv_39891;
  case 1: ;
#line 751
  if (ldv_state_variable_29 == 1) {
#line 753
    gma_encoder_mode_fixup(cdv_intel_crt_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg125,
                           cdv_intel_crt_helper_funcs_group1);
#line 755
    ldv_state_variable_29 = 1;
  } else {

  }
#line 758
  goto ldv_39891;
  case 2: ;
#line 761
  if (ldv_state_variable_29 == 1) {
#line 763
    gma_encoder_commit(cdv_intel_crt_helper_funcs_group0);
#line 765
    ldv_state_variable_29 = 1;
  } else {

  }
#line 768
  goto ldv_39891;
  case 3: ;
#line 771
  if (ldv_state_variable_29 == 1) {
#line 773
    cdv_intel_crt_mode_set(cdv_intel_crt_helper_funcs_group0, cdv_intel_crt_helper_funcs_group1,
                           ldvarg124);
#line 775
    ldv_state_variable_29 = 1;
  } else {

  }
#line 778
  goto ldv_39891;
  case 4: ;
#line 781
  if (ldv_state_variable_29 == 1) {
#line 783
    gma_encoder_prepare(cdv_intel_crt_helper_funcs_group0);
#line 785
    ldv_state_variable_29 = 1;
  } else {

  }
#line 788
  goto ldv_39891;
  default: 
#line 789
  ldv_stop();
  }
  ldv_39891: ;
#line 793
  return;
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_crt.o.c.prepared"
void *ldv_kmem_cache_alloc_500(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 924
  ldv_check_alloc_flags(flags);
#line 926
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 927
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_520(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 271 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) ;
#line 278
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) ;
#line 279
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) ;
#line 280
void cdv_sb_reset(struct drm_device *dev ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/cdv_device.h"
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static bool cdv_intel_find_dp_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static struct gma_limit_t  const  cdv_intel_limits[6U]  = {      {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & gma_find_best_pll}, 
        {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & gma_find_best_pll}, 
        {{20000, 400000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130}, {5,
                                                                                  90},
      {1, 9}, {225000, 10, 5}, & gma_find_best_pll}, 
        {{20000, 400000}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {5,
                                                                                  100},
      {1, 10}, {225000, 10, 5}, & gma_find_best_pll}, 
        {{160000, 272000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130},
      {5, 90}, {1, 9}, {225000, 10, 10}, & cdv_intel_find_dp_pll}, 
        {{160000, 272000}, {1800000, 3600000}, {2, 6}, {60, 164}, {0, 0}, {58, 162},
      {5, 100}, {1, 10}, {225000, 10, 10}, & cdv_intel_find_dp_pll}};
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) 
{ 
  int ret ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___2 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 363
  tmp = msecs_to_jiffies(1000U);
#line 363
  timeout__ = tmp + (unsigned long )jiffies;
#line 363
  ret__ = 0;
#line 363
  goto ldv_39924;
  ldv_39923: ;
#line 363
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 363
    ret__ = -110;
#line 363
    goto ldv_39881;
  } else {

  }
#line 363
  __vpp_verify = (void const   *)0;
#line 363
  switch (4UL) {
  case 1UL: ;
#line 363
  switch (4UL) {
  case 1UL: 
#line 363
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 363
  goto ldv_39887;
  case 2UL: 
#line 363
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 363
  goto ldv_39887;
  case 4UL: 
#line 363
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 363
  goto ldv_39887;
  case 8UL: 
#line 363
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 363
  goto ldv_39887;
  default: 
#line 363
  __bad_percpu_size();
  }
  ldv_39887: 
#line 363
  pscr_ret__ = pfo_ret__;
#line 363
  goto ldv_39893;
  case 2UL: ;
#line 363
  switch (4UL) {
  case 1UL: 
#line 363
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 363
  goto ldv_39897;
  case 2UL: 
#line 363
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 363
  goto ldv_39897;
  case 4UL: 
#line 363
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 363
  goto ldv_39897;
  case 8UL: 
#line 363
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 363
  goto ldv_39897;
  default: 
#line 363
  __bad_percpu_size();
  }
  ldv_39897: 
#line 363
  pscr_ret__ = pfo_ret_____0;
#line 363
  goto ldv_39893;
  case 4UL: ;
#line 363
  switch (4UL) {
  case 1UL: 
#line 363
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 363
  goto ldv_39906;
  case 2UL: 
#line 363
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 363
  goto ldv_39906;
  case 4UL: 
#line 363
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 363
  goto ldv_39906;
  case 8UL: 
#line 363
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 363
  goto ldv_39906;
  default: 
#line 363
  __bad_percpu_size();
  }
  ldv_39906: 
#line 363
  pscr_ret__ = pfo_ret_____1;
#line 363
  goto ldv_39893;
  case 8UL: ;
#line 363
  switch (4UL) {
  case 1UL: 
#line 363
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 363
  goto ldv_39915;
  case 2UL: 
#line 363
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 363
  goto ldv_39915;
  case 4UL: 
#line 363
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 363
  goto ldv_39915;
  case 8UL: 
#line 363
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 363
  goto ldv_39915;
  default: 
#line 363
  __bad_percpu_size();
  }
  ldv_39915: 
#line 363
  pscr_ret__ = pfo_ret_____2;
#line 363
  goto ldv_39893;
  default: 
#line 363
  __bad_size_call_parameter();
#line 363
  goto ldv_39893;
  }
  ldv_39893: 
#line 363
  tmp___0 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 363
  if (pscr_ret__ != tmp___0) {
#line 363
    msleep(1U);
  } else {

  }
  ldv_39924: 
#line 363
  tmp___1 = REGISTER_READ(dev, 8448U);
#line 363
  if ((int )tmp___1 & 1) {
#line 365
    goto ldv_39923;
  } else {

  }
  ldv_39881: 
#line 363
  ret = ret__;
#line 364
  if (ret != 0) {
#line 365
    drm_err("cdv_sb_read", "timeout waiting for SB to idle before read\n");
#line 366
    return (ret);
  } else {

  }
#line 369
  REGISTER_WRITE(dev, 8456U, reg);
#line 370
  REGISTER_WRITE(dev, 8448U, 35056U);
#line 375
  tmp___2 = msecs_to_jiffies(1000U);
#line 375
  timeout_____0 = tmp___2 + (unsigned long )jiffies;
#line 375
  ret_____0 = 0;
#line 375
  goto ldv_39978;
  ldv_39977: ;
#line 375
  if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 375
    ret_____0 = -110;
#line 375
    goto ldv_39935;
  } else {

  }
#line 375
  __vpp_verify___0 = (void const   *)0;
#line 375
  switch (4UL) {
  case 1UL: ;
#line 375
  switch (4UL) {
  case 1UL: 
#line 375
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 375
  goto ldv_39941;
  case 2UL: 
#line 375
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 375
  goto ldv_39941;
  case 4UL: 
#line 375
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 375
  goto ldv_39941;
  case 8UL: 
#line 375
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 375
  goto ldv_39941;
  default: 
#line 375
  __bad_percpu_size();
  }
  ldv_39941: 
#line 375
  pscr_ret_____0 = pfo_ret_____3;
#line 375
  goto ldv_39947;
  case 2UL: ;
#line 375
  switch (4UL) {
  case 1UL: 
#line 375
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 375
  goto ldv_39951;
  case 2UL: 
#line 375
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 375
  goto ldv_39951;
  case 4UL: 
#line 375
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 375
  goto ldv_39951;
  case 8UL: 
#line 375
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 375
  goto ldv_39951;
  default: 
#line 375
  __bad_percpu_size();
  }
  ldv_39951: 
#line 375
  pscr_ret_____0 = pfo_ret_____4;
#line 375
  goto ldv_39947;
  case 4UL: ;
#line 375
  switch (4UL) {
  case 1UL: 
#line 375
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 375
  goto ldv_39960;
  case 2UL: 
#line 375
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 375
  goto ldv_39960;
  case 4UL: 
#line 375
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 375
  goto ldv_39960;
  case 8UL: 
#line 375
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 375
  goto ldv_39960;
  default: 
#line 375
  __bad_percpu_size();
  }
  ldv_39960: 
#line 375
  pscr_ret_____0 = pfo_ret_____5;
#line 375
  goto ldv_39947;
  case 8UL: ;
#line 375
  switch (4UL) {
  case 1UL: 
#line 375
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 375
  goto ldv_39969;
  case 2UL: 
#line 375
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 375
  goto ldv_39969;
  case 4UL: 
#line 375
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 375
  goto ldv_39969;
  case 8UL: 
#line 375
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 375
  goto ldv_39969;
  default: 
#line 375
  __bad_percpu_size();
  }
  ldv_39969: 
#line 375
  pscr_ret_____0 = pfo_ret_____6;
#line 375
  goto ldv_39947;
  default: 
#line 375
  __bad_size_call_parameter();
#line 375
  goto ldv_39947;
  }
  ldv_39947: 
#line 375
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 375
  if (pscr_ret_____0 != tmp___3) {
#line 375
    msleep(1U);
  } else {

  }
  ldv_39978: 
#line 375
  tmp___4 = REGISTER_READ(dev, 8448U);
#line 375
  if ((int )tmp___4 & 1) {
#line 377
    goto ldv_39977;
  } else {

  }
  ldv_39935: 
#line 375
  ret = ret_____0;
#line 376
  if (ret != 0) {
#line 377
    drm_err("cdv_sb_read", "timeout waiting for SB to idle after read\n");
#line 378
    return (ret);
  } else {

  }
#line 381
  *val = REGISTER_READ(dev, 8452U);
#line 383
  return (0);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) 
{ 
  int ret ;
  bool dpio_debug ;
  u32 temp ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long timeout__ ;
  unsigned long tmp___2 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___5 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___6 ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 389
  dpio_debug = 1;
#line 392
  if ((int )dpio_debug) {
#line 393
    tmp___0 = cdv_sb_read(dev, reg, & temp);
#line 393
    if (tmp___0 == 0) {
#line 394
      tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 394
      if (tmp != 0L) {
#line 394
        drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x (before)\n", reg, temp);
      } else {

      }
    } else {

    }
#line 395
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 395
    if (tmp___1 != 0L) {
#line 395
      drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x\n", reg, val);
    } else {

    }
  } else {

  }
#line 398
  tmp___2 = msecs_to_jiffies(1000U);
#line 398
  timeout__ = tmp___2 + (unsigned long )jiffies;
#line 398
  ret__ = 0;
#line 398
  goto ldv_40040;
  ldv_40039: ;
#line 398
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 398
    ret__ = -110;
#line 398
    goto ldv_39997;
  } else {

  }
#line 398
  __vpp_verify = (void const   *)0;
#line 398
  switch (4UL) {
  case 1UL: ;
#line 398
  switch (4UL) {
  case 1UL: 
#line 398
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 398
  goto ldv_40003;
  case 2UL: 
#line 398
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 398
  goto ldv_40003;
  case 4UL: 
#line 398
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 398
  goto ldv_40003;
  case 8UL: 
#line 398
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 398
  goto ldv_40003;
  default: 
#line 398
  __bad_percpu_size();
  }
  ldv_40003: 
#line 398
  pscr_ret__ = pfo_ret__;
#line 398
  goto ldv_40009;
  case 2UL: ;
#line 398
  switch (4UL) {
  case 1UL: 
#line 398
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 398
  goto ldv_40013;
  case 2UL: 
#line 398
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 398
  goto ldv_40013;
  case 4UL: 
#line 398
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 398
  goto ldv_40013;
  case 8UL: 
#line 398
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 398
  goto ldv_40013;
  default: 
#line 398
  __bad_percpu_size();
  }
  ldv_40013: 
#line 398
  pscr_ret__ = pfo_ret_____0;
#line 398
  goto ldv_40009;
  case 4UL: ;
#line 398
  switch (4UL) {
  case 1UL: 
#line 398
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 398
  goto ldv_40022;
  case 2UL: 
#line 398
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 398
  goto ldv_40022;
  case 4UL: 
#line 398
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 398
  goto ldv_40022;
  case 8UL: 
#line 398
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 398
  goto ldv_40022;
  default: 
#line 398
  __bad_percpu_size();
  }
  ldv_40022: 
#line 398
  pscr_ret__ = pfo_ret_____1;
#line 398
  goto ldv_40009;
  case 8UL: ;
#line 398
  switch (4UL) {
  case 1UL: 
#line 398
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 398
  goto ldv_40031;
  case 2UL: 
#line 398
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 398
  goto ldv_40031;
  case 4UL: 
#line 398
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 398
  goto ldv_40031;
  case 8UL: 
#line 398
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 398
  goto ldv_40031;
  default: 
#line 398
  __bad_percpu_size();
  }
  ldv_40031: 
#line 398
  pscr_ret__ = pfo_ret_____2;
#line 398
  goto ldv_40009;
  default: 
#line 398
  __bad_size_call_parameter();
#line 398
  goto ldv_40009;
  }
  ldv_40009: 
#line 398
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 398
  if (pscr_ret__ != tmp___3) {
#line 398
    msleep(1U);
  } else {

  }
  ldv_40040: 
#line 398
  tmp___4 = REGISTER_READ(dev, 8448U);
#line 398
  if ((int )tmp___4 & 1) {
#line 400
    goto ldv_40039;
  } else {

  }
  ldv_39997: 
#line 398
  ret = ret__;
#line 399
  if (ret != 0) {
#line 400
    drm_err("cdv_sb_write", "timeout waiting for SB to idle before write\n");
#line 401
    return (ret);
  } else {

  }
#line 404
  REGISTER_WRITE(dev, 8456U, reg);
#line 405
  REGISTER_WRITE(dev, 8452U, val);
#line 406
  REGISTER_WRITE(dev, 8448U, 100592U);
#line 411
  tmp___5 = msecs_to_jiffies(1000U);
#line 411
  timeout_____0 = tmp___5 + (unsigned long )jiffies;
#line 411
  ret_____0 = 0;
#line 411
  goto ldv_40093;
  ldv_40092: ;
#line 411
  if ((long )(timeout_____0 - (unsigned long )jiffies) < 0L) {
#line 411
    ret_____0 = -110;
#line 411
    goto ldv_40050;
  } else {

  }
#line 411
  __vpp_verify___0 = (void const   *)0;
#line 411
  switch (4UL) {
  case 1UL: ;
#line 411
  switch (4UL) {
  case 1UL: 
#line 411
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 411
  goto ldv_40056;
  case 2UL: 
#line 411
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 411
  goto ldv_40056;
  case 4UL: 
#line 411
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 411
  goto ldv_40056;
  case 8UL: 
#line 411
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 411
  goto ldv_40056;
  default: 
#line 411
  __bad_percpu_size();
  }
  ldv_40056: 
#line 411
  pscr_ret_____0 = pfo_ret_____3;
#line 411
  goto ldv_40062;
  case 2UL: ;
#line 411
  switch (4UL) {
  case 1UL: 
#line 411
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 411
  goto ldv_40066;
  case 2UL: 
#line 411
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 411
  goto ldv_40066;
  case 4UL: 
#line 411
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 411
  goto ldv_40066;
  case 8UL: 
#line 411
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 411
  goto ldv_40066;
  default: 
#line 411
  __bad_percpu_size();
  }
  ldv_40066: 
#line 411
  pscr_ret_____0 = pfo_ret_____4;
#line 411
  goto ldv_40062;
  case 4UL: ;
#line 411
  switch (4UL) {
  case 1UL: 
#line 411
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 411
  goto ldv_40075;
  case 2UL: 
#line 411
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 411
  goto ldv_40075;
  case 4UL: 
#line 411
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 411
  goto ldv_40075;
  case 8UL: 
#line 411
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 411
  goto ldv_40075;
  default: 
#line 411
  __bad_percpu_size();
  }
  ldv_40075: 
#line 411
  pscr_ret_____0 = pfo_ret_____5;
#line 411
  goto ldv_40062;
  case 8UL: ;
#line 411
  switch (4UL) {
  case 1UL: 
#line 411
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 411
  goto ldv_40084;
  case 2UL: 
#line 411
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 411
  goto ldv_40084;
  case 4UL: 
#line 411
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 411
  goto ldv_40084;
  case 8UL: 
#line 411
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 411
  goto ldv_40084;
  default: 
#line 411
  __bad_percpu_size();
  }
  ldv_40084: 
#line 411
  pscr_ret_____0 = pfo_ret_____6;
#line 411
  goto ldv_40062;
  default: 
#line 411
  __bad_size_call_parameter();
#line 411
  goto ldv_40062;
  }
  ldv_40062: 
#line 411
  tmp___6 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 411
  if (pscr_ret_____0 != tmp___6) {
#line 411
    msleep(1U);
  } else {

  }
  ldv_40093: 
#line 411
  tmp___7 = REGISTER_READ(dev, 8448U);
#line 411
  if ((int )tmp___7 & 1) {
#line 413
    goto ldv_40092;
  } else {

  }
  ldv_40050: 
#line 411
  ret = ret_____0;
#line 412
  if (ret != 0) {
#line 413
    drm_err("cdv_sb_write", "timeout waiting for SB to idle after write\n");
#line 414
    return (ret);
  } else {

  }
#line 417
  if ((int )dpio_debug) {
#line 418
    tmp___9 = cdv_sb_read(dev, reg, & temp);
#line 418
    if (tmp___9 == 0) {
#line 419
      tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 419
      if (tmp___8 != 0L) {
#line 419
        drm_ut_debug_printk("cdv_sb_write", "0x%08x: 0x%08x (after)\n", reg, temp);
      } else {

      }
    } else {

    }
  } else {

  }
#line 422
  return (0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void cdv_sb_reset(struct drm_device *dev ) 
{ 


  {
#line 431
  REGISTER_WRITE(dev, 8464U, 0U);
#line 432
  REGISTER_READ(dev, 8464U);
#line 433
  REGISTER_WRITE(dev, 8464U, 5U);
#line 434
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static int cdv_dpll_set_clock_cdv(struct drm_device *dev , struct drm_crtc *crtc ,
                                  struct gma_clock_t *clock , bool is_lvds , u32 ddi_select ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  u32 m ;
  u32 n_vco ;
  u32 p ;
  int ret ;
  int dpll_reg ;
  int ref_sfr ;
  u32 ref_value ;
  u32 lane_reg ;
  u32 lane_value ;
  long tmp ;
  long tmp___0 ;

  {
#line 445
  __mptr = (struct drm_crtc  const  *)crtc;
#line 445
  gma_crtc = (struct gma_crtc *)__mptr;
#line 446
  pipe = gma_crtc->pipe;
#line 448
  ret = 0;
#line 449
  dpll_reg = pipe == 0 ? 24596 : 24600;
#line 450
  ref_sfr = pipe == 0 ? 32784 : 32816;
#line 454
  cdv_sb_reset(dev);
#line 456
  REGISTER_WRITE(dev, (uint32_t )dpll_reg, 805306368U);
#line 458
  __const_udelay(429500UL);
#line 461
  ref_value = 6858497U;
#line 463
  cdv_sb_write(dev, (u32 )(pipe * 32 + 32792), ref_value);
#line 480
  ret = cdv_sb_read(dev, (u32 )ref_sfr, & ref_value);
#line 481
  if (ret != 0) {
#line 482
    return (ret);
  } else {

  }
#line 483
  ref_value = ref_value & 4294942719U;
#line 486
  if ((pipe == 1 && ! is_lvds) && (ddi_select & 32768U) == 0U) {
#line 487
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 487
    if (tmp != 0L) {
#line 487
      drm_ut_debug_printk("cdv_dpll_set_clock_cdv", "use DPLLA for pipe B\n");
    } else {

    }
#line 488
    ref_value = ref_value | 16384U;
  } else {
#line 490
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 490
    if (tmp___0 != 0L) {
#line 490
      drm_ut_debug_printk("cdv_dpll_set_clock_cdv", "use their DPLL for pipe A/B\n");
    } else {

    }
#line 491
    ref_value = ref_value | 8192U;
  }
#line 493
  ret = cdv_sb_write(dev, (u32 )ref_sfr, ref_value);
#line 494
  if (ret != 0) {
#line 495
    return (ret);
  } else {

  }
#line 497
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32776), & m);
#line 498
  if (ret != 0) {
#line 499
    return (ret);
  } else {

  }
#line 500
  m = m & 16777215U;
#line 501
  m = (u32 )(clock->m2 << 24) | m;
#line 502
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32776), m);
#line 503
  if (ret != 0) {
#line 504
    return (ret);
  } else {

  }
#line 506
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32788), & n_vco);
#line 507
  if (ret != 0) {
#line 508
    return (ret);
  } else {

  }
#line 511
  n_vco = n_vco & 65535U;
#line 512
  n_vco = n_vco | 263U;
#line 513
  n_vco = n_vco & 16777215U;
#line 517
  n_vco = (u32 )(clock->n << 26) | n_vco;
#line 519
  if (clock->vco <= 2249999) {
#line 520
    n_vco = n_vco | 33554432U;
#line 521
    n_vco = n_vco;
  } else
#line 522
  if (clock->vco <= 2749999) {
#line 523
    n_vco = n_vco | 16777216U;
#line 524
    n_vco = n_vco | 1073741824U;
  } else
#line 525
  if (clock->vco <= 3299999) {
#line 526
    n_vco = n_vco;
#line 527
    n_vco = n_vco | 2147483648U;
  } else {
#line 529
    n_vco = n_vco;
#line 530
    n_vco = n_vco | 3221225472U;
  }
#line 533
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32788), n_vco);
#line 534
  if (ret != 0) {
#line 535
    return (ret);
  } else {

  }
#line 537
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32796), & p);
#line 538
  if (ret != 0) {
#line 539
    return (ret);
  } else {

  }
#line 540
  p = p & 1073680383U;
#line 541
  p = ((u32 )(clock->p1 << 12) & 65535U) | p;
#line 542
  switch (clock->p2) {
  case 5: 
#line 544
  p = p | 1073741824U;
#line 545
  goto ldv_40120;
  case 10: 
#line 547
  p = p;
#line 548
  goto ldv_40120;
  case 14: 
#line 550
  p = p | 2147483648U;
#line 551
  goto ldv_40120;
  case 7: 
#line 553
  p = p | 3221225472U;
#line 554
  goto ldv_40120;
  default: 
#line 556
  drm_err("cdv_dpll_set_clock_cdv", "Bad P2 clock: %d\n", clock->p2);
#line 557
  return (-22);
  }
  ldv_40120: 
#line 559
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32796), p);
#line 560
  if (ret != 0) {
#line 561
    return (ret);
  } else {

  }
#line 563
  if (ddi_select != 0U) {
#line 564
    if ((ddi_select & 3U) == 1U) {
#line 565
      lane_reg = 288U;
#line 566
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 567
      lane_value = lane_value & 4287627263U;
#line 568
      lane_value = lane_value | 3145728U;
#line 569
      cdv_sb_write(dev, lane_reg, lane_value);
#line 571
      lane_reg = 544U;
#line 572
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 573
      lane_value = lane_value & 4287627263U;
#line 574
      lane_value = lane_value | 3145728U;
#line 575
      cdv_sb_write(dev, lane_reg, lane_value);
    } else {
#line 577
      lane_reg = 8992U;
#line 578
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 579
      lane_value = lane_value & 4287627263U;
#line 580
      lane_value = lane_value | 3145728U;
#line 581
      cdv_sb_write(dev, lane_reg, lane_value);
#line 583
      lane_reg = 9248U;
#line 584
      cdv_sb_read(dev, lane_reg, & lane_value);
#line 585
      lane_value = lane_value & 4287627263U;
#line 586
      lane_value = lane_value | 3145728U;
#line 587
      cdv_sb_write(dev, lane_reg, lane_value);
    }
  } else {

  }
#line 590
  return (0);
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static struct gma_limit_t  const  *cdv_intel_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 597
  tmp___1 = gma_pipe_has_type(crtc, 4);
#line 597
  if ((int )tmp___1) {
#line 602
    if (refclk == 96000) {
#line 603
      limit = (struct gma_limit_t  const  *)(& cdv_intel_limits);
    } else {
#line 605
      limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 1UL;
    }
  } else {
#line 606
    tmp = gma_pipe_has_type(crtc, 9);
#line 606
    if ((int )tmp) {
#line 606
      goto _L;
    } else {
#line 606
      tmp___0 = gma_pipe_has_type(crtc, 10);
#line 606
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
#line 608
        if (refclk == 27000) {
#line 609
          limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 4UL;
        } else {
#line 611
          limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 5UL;
        }
      } else
#line 613
      if (refclk == 27000) {
#line 614
        limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 2UL;
      } else {
#line 616
        limit = (struct gma_limit_t  const  *)(& cdv_intel_limits) + 3UL;
      }
    }
  }
#line 618
  return (limit);
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static void cdv_intel_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 624
  clock->m = clock->m2 + 2;
#line 625
  clock->p = clock->p1 * clock->p2;
#line 626
  clock->vco = (clock->m * refclk) / clock->n;
#line 627
  clock->dot = clock->vco / clock->p;
#line 628
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static bool cdv_intel_find_dp_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct gma_clock_t clock ;
  size_t __len ;
  void *__ret ;

  {
#line 635
  __mptr = (struct drm_crtc  const  *)crtc;
#line 635
  gma_crtc = (struct gma_crtc *)__mptr;
#line 638
  switch (refclk) {
  case 27000: ;
#line 640
  if (target <= 199999) {
#line 641
    clock.p1 = 2;
#line 642
    clock.p2 = 10;
#line 643
    clock.n = 1;
#line 644
    clock.m1 = 0;
#line 645
    clock.m2 = 118;
  } else {
#line 647
    clock.p1 = 1;
#line 648
    clock.p2 = 10;
#line 649
    clock.n = 1;
#line 650
    clock.m1 = 0;
#line 651
    clock.m2 = 98;
  }
#line 653
  goto ldv_40146;
  case 100000: ;
#line 656
  if (target <= 199999) {
#line 657
    clock.p1 = 2;
#line 658
    clock.p2 = 10;
#line 659
    clock.n = 5;
#line 660
    clock.m1 = 0;
#line 661
    clock.m2 = 160;
  } else {
#line 663
    clock.p1 = 1;
#line 664
    clock.p2 = 10;
#line 665
    clock.n = 5;
#line 666
    clock.m1 = 0;
#line 667
    clock.m2 = 133;
  }
#line 669
  goto ldv_40146;
  default: ;
#line 672
  return (0);
  }
  ldv_40146: 
#line 675
  (*((gma_crtc->clock_funcs)->clock))(refclk, & clock);
#line 676
  __len = 36UL;
#line 676
  if (__len > 63UL) {
#line 676
    __ret = __memcpy((void *)best_clock, (void const   *)(& clock), __len);
  } else {
#line 676
    __ret = __builtin_memcpy((void *)best_clock, (void const   *)(& clock), __len);
  }
#line 677
  return (1);
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static bool cdv_intel_pipe_enabled(struct drm_device *dev , int pipe ) 
{ 
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
#line 686
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 687
  gma_crtc = (struct gma_crtc *)0;
#line 689
  crtc = dev_priv->pipe_to_crtc_mapping[pipe];
#line 690
  __mptr = (struct drm_crtc  const  *)crtc;
#line 690
  gma_crtc = (struct gma_crtc *)__mptr;
#line 692
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0) || ! gma_crtc->active) {
#line 693
    return (0);
  } else {

  }
#line 694
  return (1);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void cdv_disable_sr(struct drm_device *dev ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 699
  tmp___0 = REGISTER_READ(dev, 8416U);
#line 699
  if ((tmp___0 & 32768U) != 0U) {
#line 702
    tmp = REGISTER_READ(dev, 8416U);
#line 702
    REGISTER_WRITE(dev, 8416U, tmp & 4294934527U);
#line 703
    REGISTER_READ(dev, 8416U);
#line 705
    gma_wait_for_vblank(dev);
#line 710
    REGISTER_WRITE(dev, 196608U, 0U);
#line 711
    REGISTER_READ(dev, 196608U);
#line 713
    gma_wait_for_vblank(dev);
  } else {

  }
#line 715
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void cdv_update_wm(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  u32 fw ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 720
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 721
  __mptr = (struct drm_crtc  const  *)crtc;
#line 721
  gma_crtc = (struct gma_crtc *)__mptr;
#line 724
  tmp___0 = cdv_intel_pipe_enabled(dev, 0);
#line 724
  tmp___1 = cdv_intel_pipe_enabled(dev, 1);
#line 724
  if ((int )tmp___0 != (int )tmp___1) {
#line 727
    fw = REGISTER_READ(dev, 458804U);
#line 728
    fw = fw & 8388607U;
#line 729
    fw = fw | 1056964608U;
#line 730
    fw = fw & 4290838527U;
#line 731
    fw = fw | 262144U;
#line 732
    REGISTER_WRITE(dev, 458804U, fw);
#line 734
    fw = REGISTER_READ(dev, 458808U);
#line 735
    fw = fw & 4294951167U;
#line 736
    fw = fw | 1536U;
#line 737
    fw = fw & 4294967168U;
#line 738
    fw = fw | 8U;
#line 739
    REGISTER_WRITE(dev, 458808U, fw);
#line 741
    REGISTER_WRITE(dev, 458812U, 905969664U);
#line 746
    if (gma_crtc->pipe == 1) {
#line 746
      tmp = gma_pipe_has_type(crtc, 4);
#line 746
      if ((int )tmp) {
#line 748
        REGISTER_WRITE(dev, 458836U, 262960U);
      } else {
#line 750
        fw = 50594564U;
#line 754
        REGISTER_WRITE(dev, 458836U, fw);
      }
    } else {
#line 750
      fw = 50594564U;
#line 754
      REGISTER_WRITE(dev, 458836U, fw);
    }
#line 757
    REGISTER_WRITE(dev, 458840U, 16U);
#line 759
    gma_wait_for_vblank(dev);
#line 762
    REGISTER_WRITE(dev, 8416U, 32768U);
#line 763
    REGISTER_READ(dev, 8416U);
#line 764
    gma_wait_for_vblank(dev);
  } else {
#line 769
    REGISTER_WRITE(dev, 458804U, 1065879560U);
#line 770
    REGISTER_WRITE(dev, 458808U, 184680962U);
#line 771
    REGISTER_WRITE(dev, 458812U, 603979776U);
#line 772
    REGISTER_WRITE(dev, 458832U, 134414850U);
#line 773
    REGISTER_WRITE(dev, 458836U, 16843009U);
#line 774
    REGISTER_WRITE(dev, 458840U, 464U);
#line 776
    gma_wait_for_vblank(dev);
#line 778
    (*((dev_priv->ops)->disable_sr))(dev);
  }
#line 780
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static int cdv_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 790
  pfit_control = REGISTER_READ(dev, 397872U);
#line 793
  if ((int )pfit_control >= 0) {
#line 794
    return (-1);
  } else {

  }
#line 795
  return ((int )(pfit_control >> 29) & 3);
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static int cdv_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  u32 dpll ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_crt ;
  bool is_lvds ;
  bool is_tv ;
  bool is_hdmi ;
  bool is_dp ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct gma_limit_t  const  *limit ;
  u32 ddi_select ;
  bool is_edp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  u32 lvds ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  int sdvo_pixel_multiply ;
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
#line 804
  dev = crtc->dev;
#line 805
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 806
  __mptr = (struct drm_crtc  const  *)crtc;
#line 806
  gma_crtc = (struct gma_crtc *)__mptr;
#line 807
  pipe = gma_crtc->pipe;
#line 808
  map = dev_priv->regmap + (unsigned long )pipe;
#line 811
  dpll = 0U;
#line 813
  is_crt = 0;
#line 813
  is_lvds = 0;
#line 813
  is_tv = 0;
#line 814
  is_hdmi = 0;
#line 814
  is_dp = 0;
#line 815
  mode_config = & dev->mode_config;
#line 818
  ddi_select = 0U;
#line 819
  is_edp___0 = 0;
#line 821
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 821
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 821
  goto ldv_40224;
  ldv_40223: 
#line 822
  tmp = gma_attached_encoder(connector);
#line 822
  gma_encoder = tmp;
#line 825
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 827
    goto ldv_40213;
  } else {

  }
#line 829
  ddi_select = gma_encoder->ddi_select;
#line 830
  switch (gma_encoder->type) {
  case 4: 
#line 832
  is_lvds = 1;
#line 833
  goto ldv_40215;
  case 5: 
#line 835
  is_tv = 1;
#line 836
  goto ldv_40215;
  case 1: 
#line 838
  is_crt = 1;
#line 839
  goto ldv_40215;
  case 6: 
#line 841
  is_hdmi = 1;
#line 842
  goto ldv_40215;
  case 9: 
#line 844
  is_dp = 1;
#line 845
  goto ldv_40215;
  case 10: 
#line 847
  is_edp___0 = 1;
#line 848
  goto ldv_40215;
  default: 
#line 850
  drm_err("cdv_intel_crtc_mode_set", "invalid output type.\n");
#line 851
  return (0);
  }
  ldv_40215: ;
  ldv_40213: 
#line 821
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 821
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_40224: ;
#line 821
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 823
    goto ldv_40223;
  } else {

  }

#line 855
  if ((int )dev_priv->dplla_96mhz) {
#line 857
    refclk = 96000;
  } else {
#line 860
    refclk = 27000;
  }
#line 861
  if ((int )is_dp || (int )is_edp___0) {
#line 870
    if (pipe == 0) {
#line 871
      refclk = 27000;
    } else {
#line 873
      refclk = 100000;
    }
  } else {

  }
#line 876
  if ((int )is_lvds && (unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 877
    refclk = dev_priv->lvds_ssc_freq * 1000;
#line 878
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 878
    if (tmp___0 != 0L) {
#line 878
      drm_ut_debug_printk("cdv_intel_crtc_mode_set", "Use SSC reference clock %d Mhz\n",
                          dev_priv->lvds_ssc_freq);
    } else {

    }
  } else {

  }
#line 881
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)adjusted_mode);
#line 883
  limit = (*((gma_crtc->clock_funcs)->limit))(crtc, refclk);
#line 885
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 887
  if (! ok) {
#line 888
    drm_err("cdv_intel_crtc_mode_set", "Couldn\'t find PLL settings for mode! target: %d, actual: %d",
            adjusted_mode->clock, clock.dot);
#line 890
    return (0);
  } else {

  }
#line 893
  dpll = 268435456U;
#line 894
  if ((int )is_tv) {
#line 897
    dpll = dpll | 3U;
  } else {

  }
#line 901
  if ((int )is_dp || (int )is_edp___0) {
#line 902
    cdv_intel_dp_set_m_n(crtc, mode, adjusted_mode);
  } else {
#line 904
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), 0U);
#line 905
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), 0U);
#line 906
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), 0U);
#line 907
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), 0U);
  }
#line 910
  dpll = dpll | 536870912U;
#line 918
  pipeconf = REGISTER_READ(dev, map->conf);
#line 920
  pipeconf = pipeconf & 4294967071U;
#line 921
  if ((int )is_edp___0) {
#line 922
    switch (dev_priv->edp.bpp) {
    case 24: 
#line 924
    pipeconf = pipeconf;
#line 925
    goto ldv_40227;
    case 18: 
#line 927
    pipeconf = pipeconf | 64U;
#line 928
    goto ldv_40227;
    case 30: 
#line 930
    pipeconf = pipeconf | 32U;
#line 931
    goto ldv_40227;
    default: 
#line 933
    pipeconf = pipeconf;
#line 934
    goto ldv_40227;
    }
    ldv_40227: ;
  } else
#line 936
  if ((int )is_lvds) {
#line 938
    tmp___1 = REGISTER_READ(dev, 397696U);
#line 938
    if ((tmp___1 & 192U) == 192U) {
#line 939
      pipeconf = pipeconf;
    } else {
#line 941
      pipeconf = pipeconf | 64U;
    }
  } else {
#line 943
    pipeconf = pipeconf;
  }
#line 946
  dspcntr = 1073741824U;
#line 948
  if (pipe == 0) {
#line 949
    dspcntr = dspcntr;
  } else {
#line 951
    dspcntr = dspcntr | 16777216U;
  }
#line 953
  dspcntr = dspcntr | 2147483648U;
#line 954
  pipeconf = pipeconf | 2147483648U;
#line 956
  REGISTER_WRITE(dev, map->dpll, dpll | 805306368U);
#line 957
  REGISTER_READ(dev, map->dpll);
#line 959
  cdv_dpll_set_clock_cdv(dev, crtc, & clock, (int )is_lvds, ddi_select);
#line 961
  __const_udelay(644250UL);
#line 968
  if ((int )is_lvds) {
#line 969
    tmp___2 = REGISTER_READ(dev, 397696U);
#line 969
    lvds = tmp___2;
#line 971
    lvds = lvds | 3221226240U;
#line 978
    if (clock.p2 == 7) {
#line 979
      lvds = lvds | 60U;
    } else {
#line 981
      lvds = lvds & 4294967235U;
    }
#line 988
    REGISTER_WRITE(dev, 397696U, lvds);
#line 989
    REGISTER_READ(dev, 397696U);
  } else {

  }
#line 992
  dpll = dpll | 2147483648U;
#line 995
  tmp___3 = cdv_intel_panel_fitter_pipe(dev);
#line 995
  if (tmp___3 == pipe) {
#line 996
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 998
  tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 998
  if (tmp___4 != 0L) {
#line 998
    drm_ut_debug_printk("cdv_intel_crtc_mode_set", "Mode for pipe %c:\n", pipe == 0 ? 65 : 66);
  } else {

  }
#line 999
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
#line 1001
  tmp___5 = REGISTER_READ(dev, map->dpll);
#line 1001
  REGISTER_WRITE(dev, map->dpll, (tmp___5 & 2147450879U) | 2147483648U);
#line 1003
  REGISTER_READ(dev, map->dpll);
#line 1005
  __const_udelay(644250UL);
#line 1007
  tmp___6 = REGISTER_READ(dev, map->dpll);
#line 1007
  if ((tmp___6 & 32768U) == 0U) {
#line 1008
    dev_err((struct device  const  *)dev->dev, "Failed to get DPLL lock\n");
#line 1009
    return (-16);
  } else {

  }
#line 1013
  sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 1014
  REGISTER_WRITE(dev, map->dpll_md, (uint32_t )((sdvo_pixel_multiply + -1) << 8));
#line 1017
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 1019
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 1021
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 1023
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 1025
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 1027
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 1032
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 1034
  REGISTER_WRITE(dev, map->pos, 0U);
#line 1035
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
#line 1037
  REGISTER_WRITE(dev, map->conf, pipeconf);
#line 1038
  REGISTER_READ(dev, map->conf);
#line 1040
  gma_wait_for_vblank(dev);
#line 1042
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 1046
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 1048
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 1051
  gma_wait_for_vblank(dev);
#line 1053
  return (0);
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static void i8xx_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 1062
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
#line 1063
  clock->p = clock->p1 * clock->p2;
#line 1064
  clock->vco = (clock->m * refclk) / (clock->n + 2);
#line 1065
  clock->dot = clock->vco / clock->p;
#line 1066
  return;
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
static int cdv_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct gma_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 1072
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1073
  __mptr = (struct drm_crtc  const  *)crtc;
#line 1073
  gma_crtc = (struct gma_crtc *)__mptr;
#line 1074
  pipe = gma_crtc->pipe;
#line 1075
  map = dev_priv->regmap + (unsigned long )pipe;
#line 1080
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 1082
  tmp___1 = gma_power_begin(dev, 0);
#line 1082
  if ((int )tmp___1) {
#line 1083
    dpll = REGISTER_READ(dev, map->dpll);
#line 1084
    if ((dpll & 256U) == 0U) {
#line 1085
      fp = REGISTER_READ(dev, map->fp0);
    } else {
#line 1087
      fp = REGISTER_READ(dev, map->fp1);
    }
#line 1088
    if (pipe == 1) {
#line 1088
      tmp = REGISTER_READ(dev, 397696U);
#line 1088
      if ((int )tmp < 0) {
#line 1088
        tmp___0 = 1;
      } else {
#line 1088
        tmp___0 = 0;
      }
    } else {
#line 1088
      tmp___0 = 0;
    }
#line 1088
    is_lvds = (bool )tmp___0;
#line 1089
    gma_power_end(dev);
  } else {
#line 1091
    dpll = p->dpll;
#line 1092
    if ((dpll & 256U) == 0U) {
#line 1093
      fp = p->fp0;
    } else {
#line 1095
      fp = p->fp1;
    }
#line 1097
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.ldv_40416.psb.saveLVDS < 0);
  }
#line 1101
  clock.m1 = (int )((fp & 16128U) >> 8);
#line 1102
  clock.m2 = (int )fp & 63;
#line 1103
  clock.n = (int )((fp & 4128768U) >> 16);
#line 1105
  if ((int )is_lvds) {
#line 1106
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
#line 1110
    if (clock.p1 == 0) {
#line 1111
      clock.p1 = 4;
#line 1112
      dev_err((struct device  const  *)dev->dev, "PLL %d\n", dpll);
    } else {

    }
#line 1114
    clock.p2 = 14;
#line 1116
    if ((dpll & 24576U) == 24576U) {
#line 1119
      i8xx_clock(66000, & clock);
    } else {
#line 1121
      i8xx_clock(48000, & clock);
    }
  } else {
#line 1123
    if ((dpll & 2097152U) != 0U) {
#line 1124
      clock.p1 = 2;
    } else {
#line 1126
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
#line 1131
    if ((dpll & 8388608U) != 0U) {
#line 1132
      clock.p2 = 4;
    } else {
#line 1134
      clock.p2 = 2;
    }
#line 1136
    i8xx_clock(48000, & clock);
  }
#line 1144
  return (clock.dot);
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ 
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
#line 1151
  __mptr = (struct drm_crtc  const  *)crtc;
#line 1151
  gma_crtc = (struct gma_crtc *)__mptr;
#line 1152
  pipe = gma_crtc->pipe;
#line 1153
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1154
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
#line 1155
  map = dev_priv->regmap + (unsigned long )pipe;
#line 1162
  tmp___3 = gma_power_begin(dev, 0);
#line 1162
  if ((int )tmp___3) {
#line 1163
    tmp = REGISTER_READ(dev, map->htotal);
#line 1163
    htot = (int )tmp;
#line 1164
    tmp___0 = REGISTER_READ(dev, map->hsync);
#line 1164
    hsync = (int )tmp___0;
#line 1165
    tmp___1 = REGISTER_READ(dev, map->vtotal);
#line 1165
    vtot = (int )tmp___1;
#line 1166
    tmp___2 = REGISTER_READ(dev, map->vsync);
#line 1166
    vsync = (int )tmp___2;
#line 1167
    gma_power_end(dev);
  } else {
#line 1169
    htot = (int )p->htotal;
#line 1170
    hsync = (int )p->hsync;
#line 1171
    vtot = (int )p->vtotal;
#line 1172
    vsync = (int )p->vsync;
  }
#line 1175
  tmp___4 = kzalloc(208UL, 208U);
#line 1175
  mode = (struct drm_display_mode *)tmp___4;
#line 1176
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1177
    return ((struct drm_display_mode *)0);
  } else {

  }
#line 1179
  mode->clock = cdv_intel_crtc_clock_get(dev, crtc);
#line 1180
  mode->hdisplay = (htot & 65535) + 1;
#line 1181
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
#line 1182
  mode->hsync_start = (hsync & 65535) + 1;
#line 1183
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
#line 1184
  mode->vdisplay = (vtot & 65535) + 1;
#line 1185
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
#line 1186
  mode->vsync_start = (vsync & 65535) + 1;
#line 1187
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
#line 1189
  drm_mode_set_name(mode);
#line 1190
  drm_mode_set_crtcinfo(mode, 0);
#line 1192
  return (mode);
}
}
#line 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs  = 
#line 1195
     {& gma_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & cdv_intel_crtc_mode_set, & gma_pipe_set_base, 0, 0, & gma_crtc_disable};
#line 1205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs  = 
#line 1205
     {& gma_crtc_save, & gma_crtc_restore, 0, & gma_crtc_cursor_set, 0, & gma_crtc_cursor_move,
    & gma_crtc_gamma_set, & gma_crtc_destroy, & gma_crtc_set_config, 0, 0};
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
struct gma_clock_funcs  const  cdv_clock_funcs  =    {& cdv_intel_clock, & cdv_intel_limit, & gma_pll_is_valid};
#line 1221
extern int ldv_release_25(void) ;
#line 1222
extern int ldv_connect_25(void) ;
#line 1223
extern int ldv_probe_24(void) ;
#line 1224
extern int ldv_bind_25(void) ;
#line 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_funcs_24(void) 
{ 
  void *tmp ;

  {
#line 1228
  tmp = ldv_zalloc(1048UL);
#line 1228
  cdv_intel_crtc_funcs_group0 = (struct drm_crtc *)tmp;
#line 1229
  return;
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_25(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1232
  tmp = ldv_zalloc(136UL);
#line 1232
  cdv_intel_helper_funcs_group0 = (struct drm_framebuffer *)tmp;
#line 1233
  tmp___0 = ldv_zalloc(1048UL);
#line 1233
  cdv_intel_helper_funcs_group1 = (struct drm_crtc *)tmp___0;
#line 1234
  tmp___1 = ldv_zalloc(208UL);
#line 1234
  cdv_intel_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 1235
  return;
}
}
#line 1237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_initialize_gma_clock_funcs_23(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1238
  tmp = ldv_zalloc(1048UL);
#line 1238
  cdv_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 1239
  tmp___0 = ldv_zalloc(36UL);
#line 1239
  cdv_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 1240
  return;
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_25(void) 
{ 
  int ldvarg44 ;
  int tmp ;
  int ldvarg38 ;
  int tmp___0 ;
  int ldvarg40 ;
  int tmp___1 ;
  int ldvarg42 ;
  int tmp___2 ;
  int ldvarg43 ;
  int tmp___3 ;
  struct drm_display_mode *ldvarg41 ;
  void *tmp___4 ;
  struct drm_display_mode *ldvarg39 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 1243
  tmp = __VERIFIER_nondet_int();
#line 1243
  ldvarg44 = tmp;
#line 1244
  tmp___0 = __VERIFIER_nondet_int();
#line 1244
  ldvarg38 = tmp___0;
#line 1245
  tmp___1 = __VERIFIER_nondet_int();
#line 1245
  ldvarg40 = tmp___1;
#line 1246
  tmp___2 = __VERIFIER_nondet_int();
#line 1246
  ldvarg42 = tmp___2;
#line 1247
  tmp___3 = __VERIFIER_nondet_int();
#line 1247
  ldvarg43 = tmp___3;
#line 1248
  tmp___4 = ldv_zalloc(208UL);
#line 1248
  ldvarg41 = (struct drm_display_mode *)tmp___4;
#line 1249
  tmp___5 = ldv_zalloc(208UL);
#line 1249
  ldvarg39 = (struct drm_display_mode *)tmp___5;
#line 1251
  tmp___6 = __VERIFIER_nondet_int();
#line 1251
  switch (tmp___6) {
  case 0: ;
#line 1254
  if (ldv_state_variable_25 == 1) {
#line 1256
    gma_pipe_set_base(cdv_intel_helper_funcs_group1, ldvarg44, ldvarg43, cdv_intel_helper_funcs_group0);
#line 1258
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1261
  if (ldv_state_variable_25 == 3) {
#line 1263
    gma_pipe_set_base(cdv_intel_helper_funcs_group1, ldvarg44, ldvarg43, cdv_intel_helper_funcs_group0);
#line 1265
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1268
  if (ldv_state_variable_25 == 2) {
#line 1270
    gma_pipe_set_base(cdv_intel_helper_funcs_group1, ldvarg44, ldvarg43, cdv_intel_helper_funcs_group0);
#line 1272
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1275
  goto ldv_40300;
  case 1: ;
#line 1278
  if (ldv_state_variable_25 == 1) {
#line 1280
    gma_crtc_dpms(cdv_intel_helper_funcs_group1, ldvarg42);
#line 1282
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1285
  if (ldv_state_variable_25 == 3) {
#line 1287
    gma_crtc_dpms(cdv_intel_helper_funcs_group1, ldvarg42);
#line 1289
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1292
  if (ldv_state_variable_25 == 2) {
#line 1294
    gma_crtc_dpms(cdv_intel_helper_funcs_group1, ldvarg42);
#line 1296
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1299
  goto ldv_40300;
  case 2: ;
#line 1302
  if (ldv_state_variable_25 == 1) {
#line 1304
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg41,
                        cdv_intel_helper_funcs_group2);
#line 1306
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1309
  if (ldv_state_variable_25 == 3) {
#line 1311
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg41,
                        cdv_intel_helper_funcs_group2);
#line 1313
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1316
  if (ldv_state_variable_25 == 2) {
#line 1318
    gma_crtc_mode_fixup(cdv_intel_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg41,
                        cdv_intel_helper_funcs_group2);
#line 1320
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1323
  goto ldv_40300;
  case 3: ;
#line 1326
  if (ldv_state_variable_25 == 1) {
#line 1328
    gma_crtc_commit(cdv_intel_helper_funcs_group1);
#line 1330
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1333
  if (ldv_state_variable_25 == 3) {
#line 1335
    gma_crtc_commit(cdv_intel_helper_funcs_group1);
#line 1337
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1340
  if (ldv_state_variable_25 == 2) {
#line 1342
    gma_crtc_commit(cdv_intel_helper_funcs_group1);
#line 1344
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1347
  goto ldv_40300;
  case 4: ;
#line 1350
  if (ldv_state_variable_25 == 1) {
#line 1352
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group1, cdv_intel_helper_funcs_group2,
                            ldvarg39, ldvarg38, ldvarg40, cdv_intel_helper_funcs_group0);
#line 1354
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1357
  if (ldv_state_variable_25 == 3) {
#line 1359
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group1, cdv_intel_helper_funcs_group2,
                            ldvarg39, ldvarg38, ldvarg40, cdv_intel_helper_funcs_group0);
#line 1361
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1364
  if (ldv_state_variable_25 == 2) {
#line 1366
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group1, cdv_intel_helper_funcs_group2,
                            ldvarg39, ldvarg38, ldvarg40, cdv_intel_helper_funcs_group0);
#line 1368
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1371
  goto ldv_40300;
  case 5: ;
#line 1374
  if (ldv_state_variable_25 == 3) {
#line 1376
    gma_crtc_disable(cdv_intel_helper_funcs_group1);
#line 1377
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1380
  goto ldv_40300;
  case 6: ;
#line 1383
  if (ldv_state_variable_25 == 1) {
#line 1385
    gma_crtc_prepare(cdv_intel_helper_funcs_group1);
#line 1387
    ldv_state_variable_25 = 1;
  } else {

  }
#line 1390
  if (ldv_state_variable_25 == 3) {
#line 1392
    gma_crtc_prepare(cdv_intel_helper_funcs_group1);
#line 1394
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1397
  if (ldv_state_variable_25 == 2) {
#line 1399
    gma_crtc_prepare(cdv_intel_helper_funcs_group1);
#line 1401
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1404
  goto ldv_40300;
  case 7: ;
#line 1407
  if (ldv_state_variable_25 == 2) {
#line 1409
    ldv_release_25();
#line 1410
    ldv_state_variable_25 = 1;
#line 1411
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1414
  goto ldv_40300;
  case 8: ;
#line 1417
  if (ldv_state_variable_25 == 1) {
#line 1419
    ldv_bind_25();
#line 1420
    ldv_state_variable_25 = 2;
#line 1421
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1424
  goto ldv_40300;
  case 9: ;
#line 1427
  if (ldv_state_variable_25 == 2) {
#line 1429
    ldv_connect_25();
#line 1430
    ldv_state_variable_25 = 3;
  } else {

  }
#line 1433
  goto ldv_40300;
  default: 
#line 1434
  ldv_stop();
  }
  ldv_40300: ;
#line 1438
  return;
}
}
#line 1440 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  uint32_t ldvarg75 ;
  struct drm_file *ldvarg74 ;
  void *tmp ;
  int ldvarg76 ;
  int tmp___0 ;
  struct drm_mode_set *ldvarg66 ;
  void *tmp___1 ;
  u16 *ldvarg69 ;
  void *tmp___2 ;
  uint32_t ldvarg72 ;
  u16 *ldvarg68 ;
  void *tmp___3 ;
  uint32_t ldvarg71 ;
  uint32_t ldvarg67 ;
  u16 *ldvarg70 ;
  void *tmp___4 ;
  uint32_t ldvarg73 ;
  int ldvarg77 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1442
  tmp = ldv_zalloc(744UL);
#line 1442
  ldvarg74 = (struct drm_file *)tmp;
#line 1443
  tmp___0 = __VERIFIER_nondet_int();
#line 1443
  ldvarg76 = tmp___0;
#line 1444
  tmp___1 = ldv_zalloc(48UL);
#line 1444
  ldvarg66 = (struct drm_mode_set *)tmp___1;
#line 1445
  tmp___2 = ldv_zalloc(2UL);
#line 1445
  ldvarg69 = (u16 *)tmp___2;
#line 1447
  tmp___3 = ldv_zalloc(2UL);
#line 1447
  ldvarg68 = (u16 *)tmp___3;
#line 1450
  tmp___4 = ldv_zalloc(2UL);
#line 1450
  ldvarg70 = (u16 *)tmp___4;
#line 1452
  tmp___5 = __VERIFIER_nondet_int();
#line 1452
  ldvarg77 = tmp___5;
#line 1441
  memset((void *)(& ldvarg75), 0, 4UL);
#line 1446
  memset((void *)(& ldvarg72), 0, 4UL);
#line 1448
  memset((void *)(& ldvarg71), 0, 4UL);
#line 1449
  memset((void *)(& ldvarg67), 0, 4UL);
#line 1451
  memset((void *)(& ldvarg73), 0, 4UL);
#line 1454
  tmp___6 = __VERIFIER_nondet_int();
#line 1454
  switch (tmp___6) {
  case 0: ;
#line 1457
  if (ldv_state_variable_24 == 2) {
#line 1459
    gma_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg77, ldvarg76);
#line 1461
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1464
  if (ldv_state_variable_24 == 1) {
#line 1466
    gma_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg77, ldvarg76);
#line 1468
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1471
  goto ldv_40327;
  case 1: ;
#line 1474
  if (ldv_state_variable_24 == 2) {
#line 1476
    gma_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg74, ldvarg73, ldvarg72,
                        ldvarg75);
#line 1478
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1481
  if (ldv_state_variable_24 == 1) {
#line 1483
    gma_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg74, ldvarg73, ldvarg72,
                        ldvarg75);
#line 1485
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1488
  goto ldv_40327;
  case 2: ;
#line 1491
  if (ldv_state_variable_24 == 2) {
#line 1493
    gma_crtc_destroy(cdv_intel_crtc_funcs_group0);
#line 1495
    ldv_state_variable_24 = 1;
#line 1496
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1499
  goto ldv_40327;
  case 3: ;
#line 1502
  if (ldv_state_variable_24 == 2) {
#line 1504
    gma_crtc_save(cdv_intel_crtc_funcs_group0);
#line 1506
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1509
  if (ldv_state_variable_24 == 1) {
#line 1511
    gma_crtc_save(cdv_intel_crtc_funcs_group0);
#line 1513
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1516
  goto ldv_40327;
  case 4: ;
#line 1519
  if (ldv_state_variable_24 == 2) {
#line 1521
    gma_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg70, ldvarg69, ldvarg68,
                       ldvarg71, ldvarg67);
#line 1523
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1526
  if (ldv_state_variable_24 == 1) {
#line 1528
    gma_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg70, ldvarg69, ldvarg68,
                       ldvarg71, ldvarg67);
#line 1530
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1533
  goto ldv_40327;
  case 5: ;
#line 1536
  if (ldv_state_variable_24 == 2) {
#line 1538
    gma_crtc_restore(cdv_intel_crtc_funcs_group0);
#line 1540
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1543
  if (ldv_state_variable_24 == 1) {
#line 1545
    gma_crtc_restore(cdv_intel_crtc_funcs_group0);
#line 1547
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1550
  goto ldv_40327;
  case 6: ;
#line 1553
  if (ldv_state_variable_24 == 2) {
#line 1555
    gma_crtc_set_config(ldvarg66);
#line 1557
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1560
  if (ldv_state_variable_24 == 1) {
#line 1562
    gma_crtc_set_config(ldvarg66);
#line 1564
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1567
  goto ldv_40327;
  case 7: ;
#line 1570
  if (ldv_state_variable_24 == 1) {
#line 1572
    ldv_probe_24();
#line 1574
    ldv_state_variable_24 = 2;
#line 1575
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1578
  goto ldv_40327;
  default: 
#line 1579
  ldv_stop();
  }
  ldv_40327: ;
#line 1583
  return;
}
}
#line 1585 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  int ldvarg122 ;
  int tmp ;
  int ldvarg121 ;
  int tmp___0 ;
  struct gma_limit_t *ldvarg123 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1586
  tmp = __VERIFIER_nondet_int();
#line 1586
  ldvarg122 = tmp;
#line 1587
  tmp___0 = __VERIFIER_nondet_int();
#line 1587
  ldvarg121 = tmp___0;
#line 1588
  tmp___1 = ldv_zalloc(88UL);
#line 1588
  ldvarg123 = (struct gma_limit_t *)tmp___1;
#line 1590
  tmp___2 = __VERIFIER_nondet_int();
#line 1590
  switch (tmp___2) {
  case 0: ;
#line 1593
  if (ldv_state_variable_23 == 1) {
#line 1595
    gma_pll_is_valid(cdv_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg123,
                     cdv_clock_funcs_group1);
#line 1597
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1600
  goto ldv_40343;
  case 1: ;
#line 1603
  if (ldv_state_variable_23 == 1) {
#line 1605
    cdv_intel_clock(ldvarg122, cdv_clock_funcs_group1);
#line 1607
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1610
  goto ldv_40343;
  case 2: ;
#line 1613
  if (ldv_state_variable_23 == 1) {
#line 1615
    cdv_intel_limit(cdv_clock_funcs_group0, ldvarg121);
#line 1617
    ldv_state_variable_23 = 1;
  } else {

  }
#line 1620
  goto ldv_40343;
  default: 
#line 1621
  ldv_stop();
  }
  ldv_40343: ;
#line 1625
  return;
}
}
#line 1753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_display.o.c.prepared"
void *ldv_kmem_cache_alloc_520(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1756
  ldv_check_alloc_flags(flags);
#line 1758
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1759
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_540(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static void cdv_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;

  {
#line 286
  dev = encoder->dev;
#line 287
  __mptr = (struct drm_encoder  const  *)encoder;
#line 287
  gma_encoder = (struct gma_encoder *)__mptr;
#line 288
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 290
  crtc = encoder->crtc;
#line 291
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 291
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 293
  hdmib = 2048U;
#line 295
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 296
    hdmib = hdmib | 16U;
  } else {

  }
#line 297
  if ((int )adjusted_mode->flags & 1) {
#line 298
    hdmib = hdmib | 8U;
  } else {

  }
#line 300
  if (gma_crtc->pipe == 1) {
#line 301
    hdmib = hdmib | 1073741824U;
  } else {

  }
#line 303
  if ((int )hdmi_priv->has_hdmi_audio) {
#line 304
    hdmib = hdmib | 64U;
#line 305
    hdmib = hdmib | 512U;
  } else {

  }
#line 308
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib);
#line 309
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 310
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static void cdv_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;

  {
#line 314
  dev = encoder->dev;
#line 315
  __mptr = (struct drm_encoder  const  *)encoder;
#line 315
  gma_encoder = (struct gma_encoder *)__mptr;
#line 316
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 319
  hdmib = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 321
  if (mode != 0) {
#line 322
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib & 2147483647U);
  } else {
#line 324
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib | 2147483648U);
  }
#line 325
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 326
  return;
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static void cdv_hdmi_save(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
#line 330
  dev = connector->dev;
#line 331
  tmp = gma_attached_encoder(connector);
#line 331
  gma_encoder = tmp;
#line 332
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 334
  hdmi_priv->save_HDMIB = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 335
  return;
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static void cdv_hdmi_restore(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
#line 339
  dev = connector->dev;
#line 340
  tmp = gma_attached_encoder(connector);
#line 340
  gma_encoder = tmp;
#line 341
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 343
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmi_priv->save_HDMIB);
#line 344
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static enum drm_connector_status cdv_hdmi_detect(struct drm_connector *connector ,
                                                 bool force ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  struct edid *edid ;
  enum drm_connector_status status ;

  {
#line 350
  tmp = gma_attached_encoder(connector);
#line 350
  gma_encoder = tmp;
#line 351
  hdmi_priv = (struct mid_intel_hdmi_priv *)gma_encoder->dev_priv;
#line 352
  edid = (struct edid *)0;
#line 353
  status = 2;
#line 355
  edid = drm_get_edid(connector, & (gma_encoder->i2c_bus)->adapter);
#line 357
  hdmi_priv->has_hdmi_sink = 0;
#line 358
  hdmi_priv->has_hdmi_audio = 0;
#line 359
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 360
    if ((int )((signed char )edid->input) < 0) {
#line 361
      status = 1;
#line 362
      hdmi_priv->has_hdmi_sink = drm_detect_hdmi_monitor(edid);
#line 364
      hdmi_priv->has_hdmi_audio = drm_detect_monitor_audio(edid);
    } else {

    }
#line 367
    kfree((void const   *)edid);
  } else {

  }
#line 369
  return (status);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static int cdv_hdmi_set_property(struct drm_connector *connector , struct drm_property *property ,
                                 uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  bool centre ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_encoder_helper_funcs *helpers ;
  int tmp___3 ;

  {
#line 376
  encoder = connector->encoder;
#line 378
  tmp___3 = strcmp((char const   *)(& property->name), "scaling mode");
#line 378
  if (tmp___3 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 379
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 379
    crtc = (struct gma_crtc *)__mptr;
#line 383
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 384
      return (-1);
    } else {

    }
#line 386
    switch (value) {
    case 1ULL: ;
#line 388
    goto ldv_39954;
    case 2ULL: ;
#line 390
    goto ldv_39954;
    case 3ULL: ;
#line 392
    goto ldv_39954;
    default: ;
#line 394
    return (-1);
    }
    ldv_39954: 
#line 397
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
#line 397
    if (tmp != 0) {
#line 399
      return (-1);
    } else {

    }
#line 401
    if (curValue == value) {
#line 402
      return (0);
    } else {

    }
#line 404
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 404
    if (tmp___0 != 0) {
#line 406
      return (-1);
    } else {

    }
#line 408
    centre = (bool )(curValue == 2ULL || value == 2ULL);
#line 411
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 413
      if ((int )centre) {
#line 414
        tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                           (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 414
        if (tmp___1) {
#line 414
          tmp___2 = 0;
        } else {
#line 414
          tmp___2 = 1;
        }
#line 414
        if (tmp___2) {
#line 416
          return (-1);
        } else {

        }
      } else {
#line 418
        helpers = (struct drm_encoder_helper_funcs *)encoder->helper_private;
#line 420
        (*(helpers->mode_set))(encoder, & crtc->saved_mode, & crtc->saved_adjusted_mode);
      }
    } else {

    }
  } else {

  }
#line 425
  return (0);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static int cdv_hdmi_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct edid *edid ;
  int ret ;

  {
#line 433
  tmp = gma_attached_encoder(connector);
#line 433
  gma_encoder = tmp;
#line 434
  edid = (struct edid *)0;
#line 435
  ret = 0;
#line 437
  edid = drm_get_edid(connector, & (gma_encoder->i2c_bus)->adapter);
#line 438
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 439
    drm_mode_connector_update_edid_property(connector, edid);
#line 440
    ret = drm_add_edid_modes(connector, edid);
#line 441
    kfree((void const   *)edid);
  } else {

  }
#line 443
  return (ret);
}
}
#line 446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static int cdv_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 449
  if (mode->clock > 165000) {
#line 450
    return (15);
  } else {

  }
#line 451
  if (mode->clock <= 19999) {
#line 452
    return (15);
  } else {

  }
#line 455
  if ((mode->flags & 32U) != 0U) {
#line 456
    return (8);
  } else {

  }
#line 459
  if ((mode->flags & 16U) != 0U) {
#line 460
    return (7);
  } else {

  }
#line 462
  return (0);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static void cdv_hdmi_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 467
  tmp = gma_attached_encoder(connector);
#line 467
  gma_encoder = tmp;
#line 469
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 470
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
#line 471
  drm_sysfs_connector_remove(connector);
#line 472
  drm_connector_cleanup(connector);
#line 473
  kfree((void const   *)connector);
#line 474
  return;
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static struct drm_encoder_helper_funcs  const  cdv_hdmi_helper_funcs  = 
#line 476
     {& cdv_hdmi_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & cdv_hdmi_mode_set, 0, 0, 0};
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static struct drm_connector_helper_funcs  const  cdv_hdmi_connector_helper_funcs  =    {& cdv_hdmi_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_hdmi_mode_valid),
    & gma_best_encoder};
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
static struct drm_connector_funcs  const  cdv_hdmi_connector_funcs  = 
#line 491
     {& drm_helper_connector_dpms, & cdv_hdmi_save, & cdv_hdmi_restore, 0, & cdv_hdmi_detect,
    & drm_helper_probe_single_connector_modes, & cdv_hdmi_set_property, & cdv_hdmi_destroy,
    0};
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  int ddc_bus ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 511
  tmp = kzalloc(152UL, 208U);
#line 511
  gma_encoder = (struct gma_encoder *)tmp;
#line 513
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 514
    return;
  } else {

  }
#line 516
  tmp___0 = kzalloc(728UL, 208U);
#line 516
  gma_connector = (struct gma_connector *)tmp___0;
#line 519
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 520
    goto err_connector;
  } else {

  }
#line 522
  tmp___1 = kzalloc(40UL, 208U);
#line 522
  hdmi_priv = (struct mid_intel_hdmi_priv *)tmp___1;
#line 524
  if ((unsigned long )hdmi_priv == (unsigned long )((struct mid_intel_hdmi_priv *)0)) {
#line 525
    goto err_priv;
  } else {

  }
#line 527
  connector = & gma_connector->base;
#line 528
  connector->polled = 1U;
#line 529
  encoder = & gma_encoder->base;
#line 530
  drm_connector_init(dev, connector, & cdv_hdmi_connector_funcs, 3);
#line 534
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 2);
#line 537
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 538
  gma_encoder->type = 6;
#line 539
  hdmi_priv->hdmi_reg = (u32 )reg;
#line 540
  hdmi_priv->has_hdmi_sink = 0;
#line 541
  gma_encoder->dev_priv = (void *)hdmi_priv;
#line 543
  drm_encoder_helper_add(encoder, & cdv_hdmi_helper_funcs);
#line 544
  drm_connector_helper_add(connector, & cdv_hdmi_connector_helper_funcs);
#line 546
  connector->display_info.subpixel_order = 1;
#line 547
  connector->interlace_allowed = 0;
#line 548
  connector->doublescan_allowed = 0;
#line 550
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 554
  switch (reg) {
  case 397632: 
#line 556
  ddc_bus = 20512;
#line 557
  gma_encoder->ddi_select = 1U;
#line 558
  goto ldv_39990;
  case 397664: 
#line 560
  ddc_bus = 20508;
#line 561
  gma_encoder->ddi_select = 2U;
#line 562
  goto ldv_39990;
  default: 
#line 564
  drm_err("cdv_hdmi_init", "unknown reg 0x%x for HDMI\n", reg);
#line 565
  goto failed_ddc;
  }
  ldv_39990: 
#line 569
  gma_encoder->i2c_bus = psb_intel_i2c_create(dev, (u32 const   )ddc_bus, reg == 397632 ? "HDMIB" : "HDMIC");
#line 572
  if ((unsigned long )gma_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 573
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
#line 574
    goto failed_ddc;
  } else {

  }
#line 577
  hdmi_priv->hdmi_i2c_adapter = & (gma_encoder->i2c_bus)->adapter;
#line 578
  hdmi_priv->dev = dev;
#line 579
  drm_sysfs_connector_add(connector);
#line 580
  return;
  failed_ddc: 
#line 583
  drm_encoder_cleanup(encoder);
#line 584
  drm_connector_cleanup(connector);
  err_priv: 
#line 586
  kfree((void const   *)gma_connector);
  err_connector: 
#line 588
  kfree((void const   *)gma_encoder);
#line 589
  return;
}
}
#line 591
extern int ldv_probe_20(void) ;
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_22(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 595
  tmp = ldv_zalloc(96UL);
#line 595
  cdv_hdmi_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 596
  tmp___0 = ldv_zalloc(208UL);
#line 596
  cdv_hdmi_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 597
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_funcs_20(void) 
{ 
  void *tmp ;

  {
#line 600
  tmp = ldv_zalloc(720UL);
#line 600
  cdv_hdmi_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 601
  return;
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_21(void) 
{ 
  void *tmp ;

  {
#line 604
  tmp = ldv_zalloc(720UL);
#line 604
  cdv_hdmi_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 605
  return;
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct drm_display_mode *ldvarg107 ;
  void *tmp ;
  struct drm_display_mode *ldvarg106 ;
  void *tmp___0 ;
  int ldvarg108 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 608
  tmp = ldv_zalloc(208UL);
#line 608
  ldvarg107 = (struct drm_display_mode *)tmp;
#line 609
  tmp___0 = ldv_zalloc(208UL);
#line 609
  ldvarg106 = (struct drm_display_mode *)tmp___0;
#line 610
  tmp___1 = __VERIFIER_nondet_int();
#line 610
  ldvarg108 = tmp___1;
#line 612
  tmp___2 = __VERIFIER_nondet_int();
#line 612
  switch (tmp___2) {
  case 0: ;
#line 615
  if (ldv_state_variable_22 == 1) {
#line 617
    cdv_hdmi_dpms(cdv_hdmi_helper_funcs_group0, ldvarg108);
#line 619
    ldv_state_variable_22 = 1;
  } else {

  }
#line 622
  goto ldv_40013;
  case 1: ;
#line 625
  if (ldv_state_variable_22 == 1) {
#line 627
    gma_encoder_mode_fixup(cdv_hdmi_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg107,
                           cdv_hdmi_helper_funcs_group1);
#line 629
    ldv_state_variable_22 = 1;
  } else {

  }
#line 632
  goto ldv_40013;
  case 2: ;
#line 635
  if (ldv_state_variable_22 == 1) {
#line 637
    gma_encoder_commit(cdv_hdmi_helper_funcs_group0);
#line 639
    ldv_state_variable_22 = 1;
  } else {

  }
#line 642
  goto ldv_40013;
  case 3: ;
#line 645
  if (ldv_state_variable_22 == 1) {
#line 647
    cdv_hdmi_mode_set(cdv_hdmi_helper_funcs_group0, cdv_hdmi_helper_funcs_group1,
                      ldvarg106);
#line 649
    ldv_state_variable_22 = 1;
  } else {

  }
#line 652
  goto ldv_40013;
  case 4: ;
#line 655
  if (ldv_state_variable_22 == 1) {
#line 657
    gma_encoder_prepare(cdv_hdmi_helper_funcs_group0);
#line 659
    ldv_state_variable_22 = 1;
  } else {

  }
#line 662
  goto ldv_40013;
  default: 
#line 663
  ldv_stop();
  }
  ldv_40013: ;
#line 667
  return;
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  struct drm_display_mode *ldvarg2 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 670
  tmp = ldv_zalloc(208UL);
#line 670
  ldvarg2 = (struct drm_display_mode *)tmp;
#line 672
  tmp___0 = __VERIFIER_nondet_int();
#line 672
  switch (tmp___0) {
  case 0: ;
#line 675
  if (ldv_state_variable_21 == 1) {
#line 677
    cdv_hdmi_get_modes(cdv_hdmi_connector_helper_funcs_group0);
#line 679
    ldv_state_variable_21 = 1;
  } else {

  }
#line 682
  goto ldv_40024;
  case 1: ;
#line 685
  if (ldv_state_variable_21 == 1) {
#line 687
    cdv_hdmi_mode_valid(cdv_hdmi_connector_helper_funcs_group0, ldvarg2);
#line 689
    ldv_state_variable_21 = 1;
  } else {

  }
#line 692
  goto ldv_40024;
  case 2: ;
#line 695
  if (ldv_state_variable_21 == 1) {
#line 697
    gma_best_encoder(cdv_hdmi_connector_helper_funcs_group0);
#line 699
    ldv_state_variable_21 = 1;
  } else {

  }
#line 702
  goto ldv_40024;
  default: 
#line 703
  ldv_stop();
  }
  ldv_40024: ;
#line 707
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  uint64_t ldvarg56 ;
  int ldvarg59 ;
  int tmp ;
  uint32_t ldvarg55 ;
  uint32_t ldvarg54 ;
  bool ldvarg58 ;
  struct drm_property *ldvarg57 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 711
  tmp = __VERIFIER_nondet_int();
#line 711
  ldvarg59 = tmp;
#line 715
  tmp___0 = ldv_zalloc(104UL);
#line 715
  ldvarg57 = (struct drm_property *)tmp___0;
#line 710
  memset((void *)(& ldvarg56), 0, 8UL);
#line 712
  memset((void *)(& ldvarg55), 0, 4UL);
#line 713
  memset((void *)(& ldvarg54), 0, 4UL);
#line 714
  memset((void *)(& ldvarg58), 0, 1UL);
#line 717
  tmp___1 = __VERIFIER_nondet_int();
#line 717
  switch (tmp___1) {
  case 0: ;
#line 720
  if (ldv_state_variable_20 == 1) {
#line 722
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg59);
#line 724
    ldv_state_variable_20 = 1;
  } else {

  }
#line 727
  if (ldv_state_variable_20 == 2) {
#line 729
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg59);
#line 731
    ldv_state_variable_20 = 2;
  } else {

  }
#line 734
  goto ldv_40038;
  case 1: ;
#line 737
  if (ldv_state_variable_20 == 1) {
#line 739
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg58);
#line 741
    ldv_state_variable_20 = 1;
  } else {

  }
#line 744
  if (ldv_state_variable_20 == 2) {
#line 746
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg58);
#line 748
    ldv_state_variable_20 = 2;
  } else {

  }
#line 751
  goto ldv_40038;
  case 2: ;
#line 754
  if (ldv_state_variable_20 == 1) {
#line 756
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg57, ldvarg56);
#line 758
    ldv_state_variable_20 = 1;
  } else {

  }
#line 761
  if (ldv_state_variable_20 == 2) {
#line 763
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg57, ldvarg56);
#line 765
    ldv_state_variable_20 = 2;
  } else {

  }
#line 768
  goto ldv_40038;
  case 3: ;
#line 771
  if (ldv_state_variable_20 == 2) {
#line 773
    cdv_hdmi_destroy(cdv_hdmi_connector_funcs_group0);
#line 775
    ldv_state_variable_20 = 1;
#line 776
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 779
  goto ldv_40038;
  case 4: ;
#line 782
  if (ldv_state_variable_20 == 1) {
#line 784
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
#line 786
    ldv_state_variable_20 = 1;
  } else {

  }
#line 789
  if (ldv_state_variable_20 == 2) {
#line 791
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
#line 793
    ldv_state_variable_20 = 2;
  } else {

  }
#line 796
  goto ldv_40038;
  case 5: ;
#line 799
  if (ldv_state_variable_20 == 1) {
#line 801
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
#line 803
    ldv_state_variable_20 = 1;
  } else {

  }
#line 806
  if (ldv_state_variable_20 == 2) {
#line 808
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
#line 810
    ldv_state_variable_20 = 2;
  } else {

  }
#line 813
  goto ldv_40038;
  case 6: ;
#line 816
  if (ldv_state_variable_20 == 1) {
#line 818
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg55,
                                            ldvarg54);
#line 820
    ldv_state_variable_20 = 1;
  } else {

  }
#line 823
  if (ldv_state_variable_20 == 2) {
#line 825
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg55,
                                            ldvarg54);
#line 827
    ldv_state_variable_20 = 2;
  } else {

  }
#line 830
  goto ldv_40038;
  case 7: ;
#line 833
  if (ldv_state_variable_20 == 1) {
#line 835
    ldv_probe_20();
#line 837
    ldv_state_variable_20 = 2;
#line 838
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 841
  goto ldv_40038;
  default: 
#line 842
  ldv_stop();
  }
  ldv_40038: ;
#line 846
  return;
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_hdmi.o.c.prepared"
void *ldv_kmem_cache_alloc_540(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 977
  ldv_check_alloc_flags(flags);
#line 979
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 980
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_560(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static u32 cdv_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 retval ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 291
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 294
  tmp___0 = gma_power_begin(dev, 0);
#line 294
  if ((int )tmp___0) {
#line 295
    tmp = REGISTER_READ(dev, 397908U);
#line 295
    retval = (tmp >> 17) * 2U;
#line 299
    gma_power_end(dev);
  } else {
#line 301
    retval = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
#line 305
  return (retval);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 398
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 401
  tmp___0 = gma_power_begin(dev, 0);
#line 401
  if ((int )tmp___0) {
#line 402
    tmp = REGISTER_READ(dev, 397908U);
#line 402
    blc_pwm_ctl = tmp & 4294901760U;
#line 404
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
#line 407
    gma_power_end(dev);
  } else {
#line 409
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
#line 411
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
#line 413
  return;
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_set_power(struct drm_device *dev , struct drm_encoder *encoder ,
                                     bool on ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 422
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 425
  tmp = gma_power_begin(dev, 1);
#line 425
  if (tmp) {
#line 425
    tmp___0 = 0;
  } else {
#line 425
    tmp___0 = 1;
  }
#line 425
  if (tmp___0) {
#line 426
    return;
  } else {

  }
#line 428
  if ((int )on) {
#line 429
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 429
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_39890: 
#line 432
    pp_status = REGISTER_READ(dev, 397824U);
#line 433
    if ((int )pp_status >= 0) {
#line 435
      goto ldv_39890;
    } else {

    }
#line 435
    cdv_intel_lvds_set_backlight(dev, dev_priv->mode_dev.backlight_duty_cycle);
  } else {
#line 438
    cdv_intel_lvds_set_backlight(dev, 0);
#line 440
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 440
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_39892: 
#line 443
    pp_status = REGISTER_READ(dev, 397824U);
#line 444
    if ((int )pp_status < 0) {
#line 446
      goto ldv_39892;
    } else {

    }

  }
#line 446
  gma_power_end(dev);
#line 447
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;

  {
#line 451
  dev = encoder->dev;
#line 452
  if (mode == 0) {
#line 453
    cdv_intel_lvds_set_power(dev, encoder, 1);
  } else {
#line 455
    cdv_intel_lvds_set_power(dev, encoder, 0);
  }
#line 456
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_save(struct drm_connector *connector ) 
{ 


  {
#line 461
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_restore(struct drm_connector *connector ) 
{ 


  {
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static int cdv_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *fixed_mode ;

  {
#line 470
  dev = connector->dev;
#line 471
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 472
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
#line 476
  if ((mode->flags & 32U) != 0U) {
#line 477
    return (8);
  } else {

  }
#line 480
  if ((mode->flags & 16U) != 0U) {
#line 481
    return (7);
  } else {

  }
#line 483
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 484
    if (mode->hdisplay > fixed_mode->hdisplay) {
#line 485
      return (29);
    } else {

    }
#line 486
    if (mode->vdisplay > fixed_mode->vdisplay) {
#line 487
      return (29);
    } else {

    }
  } else {

  }
#line 489
  return (0);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static bool cdv_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 496
  dev = encoder->dev;
#line 497
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 498
  mode_dev = & dev_priv->mode_dev;
#line 500
  panel_fixed_mode = mode_dev->panel_fixed_mode;
#line 503
  __mptr = (struct list_head  const  *)dev->mode_config.encoder_list.next;
#line 503
  tmp_encoder = (struct drm_encoder *)__mptr + 0xfffffffffffffff8UL;
#line 503
  goto ldv_39927;
  ldv_39926: ;
#line 505
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
#line 507
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
#line 509
    return (0);
  } else {

  }
#line 503
  __mptr___0 = (struct list_head  const  *)tmp_encoder->head.next;
#line 503
  tmp_encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_39927: ;
#line 503
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
#line 505
    goto ldv_39926;
  } else {

  }

#line 519
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 520
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
#line 521
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
#line 522
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
#line 523
    adjusted_mode->htotal = panel_fixed_mode->htotal;
#line 524
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
#line 525
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
#line 526
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
#line 527
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
#line 528
    adjusted_mode->clock = panel_fixed_mode->clock;
#line 529
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
#line 539
  return (1);
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 544
  dev = encoder->dev;
#line 545
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 546
  mode_dev = & dev_priv->mode_dev;
#line 548
  tmp = gma_power_begin(dev, 1);
#line 548
  if (tmp) {
#line 548
    tmp___0 = 0;
  } else {
#line 548
    tmp___0 = 1;
  }
#line 548
  if (tmp___0) {
#line 549
    return;
  } else {

  }
#line 551
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 552
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 555
  cdv_intel_lvds_set_power(dev, encoder, 0);
#line 557
  gma_power_end(dev);
#line 558
  return;
}
}
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 562
  dev = encoder->dev;
#line 563
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 564
  mode_dev = & dev_priv->mode_dev;
#line 566
  if (mode_dev->backlight_duty_cycle == 0) {
#line 567
    tmp = cdv_intel_lvds_get_max_backlight(dev);
#line 567
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 570
  cdv_intel_lvds_set_power(dev, encoder, 1);
#line 571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  u32 pfit_control ;

  {
#line 577
  dev = encoder->dev;
#line 578
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 579
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 579
  gma_crtc = (struct gma_crtc *)__mptr;
#line 593
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 595
    pfit_control = 2147485280U;
  } else {
#line 599
    pfit_control = 0U;
  }
#line 601
  pfit_control = (u32 )(gma_crtc->pipe << 29) | pfit_control;
#line 603
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 604
    pfit_control = pfit_control | 8U;
  } else {

  }
#line 606
  REGISTER_WRITE(dev, 397872U, pfit_control);
#line 607
  return;
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static enum drm_connector_status cdv_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 


  {
#line 619
  return (1);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static int cdv_intel_lvds_get_modes(struct drm_connector *connector ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct psb_intel_mode_device *mode_dev ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
#line 627
  dev = connector->dev;
#line 628
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 629
  tmp = gma_attached_encoder(connector);
#line 629
  gma_encoder = tmp;
#line 630
  mode_dev = & dev_priv->mode_dev;
#line 633
  ret = psb_intel_ddc_get_modes(connector, & (gma_encoder->i2c_bus)->adapter);
#line 635
  if (ret != 0) {
#line 636
    return (ret);
  } else {

  }
#line 642
  connector->display_info.min_vfreq = 0U;
#line 643
  connector->display_info.max_vfreq = 200U;
#line 644
  connector->display_info.min_hfreq = 0U;
#line 645
  connector->display_info.max_hfreq = 200U;
#line 646
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 647
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
#line 647
    mode = tmp___0;
#line 649
    drm_mode_probed_add(connector, mode);
#line 650
    return (1);
  } else {

  }
#line 653
  return (0);
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;

  {
#line 665
  tmp = gma_attached_encoder(connector);
#line 665
  gma_encoder = tmp;
#line 667
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 668
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
#line 669
  drm_sysfs_connector_remove(connector);
#line 670
  drm_connector_cleanup(connector);
#line 671
  kfree((void const   *)connector);
#line 672
  return;
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static int cdv_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t value ) 
{ 
  struct drm_encoder *encoder ;
  struct gma_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs *helpers ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 678
  encoder = connector->encoder;
#line 680
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
#line 680
  if (tmp___6 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 681
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
#line 681
    crtc = (struct gma_crtc *)__mptr;
#line 684
    if ((unsigned long )crtc == (unsigned long )((struct gma_crtc *)0)) {
#line 685
      return (-1);
    } else {

    }
#line 687
    switch (value) {
    case 1ULL: ;
#line 689
    goto ldv_39980;
    case 2ULL: ;
#line 691
    goto ldv_39980;
    case 3ULL: ;
#line 693
    goto ldv_39980;
    default: ;
#line 695
    return (-1);
    }
    ldv_39980: 
#line 698
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
#line 698
    if (tmp != 0) {
#line 701
      return (-1);
    } else {

    }
#line 703
    if (curValue == value) {
#line 704
      return (0);
    } else {

    }
#line 706
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
#line 706
    if (tmp___0 != 0) {
#line 709
      return (-1);
    } else {

    }
#line 711
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
#line 713
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, ((encoder->crtc)->primary)->fb);
#line 713
      if (tmp___1) {
#line 713
        tmp___2 = 0;
      } else {
#line 713
        tmp___2 = 1;
      }
#line 713
      if (tmp___2) {
#line 718
        return (-1);
      } else {

      }
    } else {

    }
  } else {
#line 720
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
#line 720
    if (tmp___5 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 721
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
#line 721
      if (tmp___3 != 0) {
#line 724
        return (-1);
      } else {
#line 726
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
#line 727
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
#line 727
      if (tmp___4 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
#line 728
        helpers = (struct drm_encoder_helper_funcs *)encoder->helper_private;
#line 730
        (*(helpers->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
#line 732
  return (0);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static struct drm_encoder_helper_funcs  const  cdv_intel_lvds_helper_funcs  = 
#line 736
     {& cdv_intel_lvds_encoder_dpms, 0, 0, & cdv_intel_lvds_mode_fixup, & cdv_intel_lvds_prepare,
    & cdv_intel_lvds_commit, & cdv_intel_lvds_mode_set, 0, 0, 0};
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static struct drm_connector_helper_funcs  const  cdv_intel_lvds_connector_helper_funcs  =    {& cdv_intel_lvds_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_lvds_mode_valid),
    & gma_best_encoder};
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static struct drm_connector_funcs  const  cdv_intel_lvds_connector_funcs  = 
#line 751
     {& drm_helper_connector_dpms, & cdv_intel_lvds_save, & cdv_intel_lvds_restore,
    0, & cdv_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & cdv_intel_lvds_set_property,
    & cdv_intel_lvds_destroy, 0};
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static void cdv_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 764
  drm_encoder_cleanup(encoder);
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static struct drm_encoder_funcs  const  cdv_intel_lvds_enc_funcs  =    {0, & cdv_intel_lvds_enc_destroy};
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
static bool lvds_is_present_in_vbt(struct drm_device *dev , u8 *i2c_pin ) 
{ 
  struct drm_psb_private *dev_priv ;
  int i ;
  struct child_device_config *child ;

  {
#line 781
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 784
  if (dev_priv->child_dev_num == 0) {
#line 785
    return (1);
  } else {

  }
#line 787
  i = 0;
#line 787
  goto ldv_40001;
  ldv_40000: 
#line 788
  child = dev_priv->child_dev + (unsigned long )i;
#line 794
  if ((unsigned int )child->device_type != 4130U && (unsigned int )child->device_type != 34U) {
#line 796
    goto ldv_39999;
  } else {

  }
#line 798
  if ((unsigned int )child->i2c_pin != 0U) {
#line 799
    *i2c_pin = child->i2c_pin;
  } else {

  }
#line 806
  if ((unsigned int )child->addin_offset != 0U) {
#line 807
    return (1);
  } else {

  }
#line 814
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
#line 815
    return (1);
  } else {

  }
  ldv_39999: 
#line 787
  i = i + 1;
  ldv_40001: ;
#line 787
  if (dev_priv->child_dev_num > i) {
#line 789
    goto ldv_40000;
  } else {

  }

#line 818
  return (0);
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct cdv_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  u8 pin ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  long tmp___5 ;
  u32 pwm ;

  {
#line 838
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 843
  pin = 3U;
#line 844
  tmp___0 = lvds_is_present_in_vbt(dev, & pin);
#line 844
  if (tmp___0) {
#line 844
    tmp___1 = 0;
  } else {
#line 844
    tmp___1 = 1;
  }
#line 844
  if (tmp___1) {
#line 845
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 845
    if (tmp != 0L) {
#line 845
      drm_ut_debug_printk("cdv_intel_lvds_init", "LVDS is not present in VBT\n");
    } else {

    }
#line 846
    return;
  } else {

  }
#line 849
  tmp___2 = kzalloc(152UL, 208U);
#line 849
  gma_encoder = (struct gma_encoder *)tmp___2;
#line 851
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 852
    return;
  } else {

  }
#line 854
  tmp___3 = kzalloc(728UL, 208U);
#line 854
  gma_connector = (struct gma_connector *)tmp___3;
#line 856
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 857
    goto failed_connector;
  } else {

  }
#line 859
  tmp___4 = kzalloc(32UL, 208U);
#line 859
  lvds_priv = (struct cdv_intel_lvds_priv *)tmp___4;
#line 860
  if ((unsigned long )lvds_priv == (unsigned long )((struct cdv_intel_lvds_priv *)0)) {
#line 861
    goto failed_lvds_priv;
  } else {

  }
#line 863
  gma_encoder->dev_priv = (void *)lvds_priv;
#line 865
  connector = & gma_connector->base;
#line 866
  encoder = & gma_encoder->base;
#line 869
  drm_connector_init(dev, connector, & cdv_intel_lvds_connector_funcs, 7);
#line 873
  drm_encoder_init(dev, encoder, & cdv_intel_lvds_enc_funcs, 3);
#line 878
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 879
  gma_encoder->type = 4;
#line 881
  drm_encoder_helper_add(encoder, & cdv_intel_lvds_helper_funcs);
#line 882
  drm_connector_helper_add(connector, & cdv_intel_lvds_connector_helper_funcs);
#line 884
  connector->display_info.subpixel_order = 1;
#line 885
  connector->interlace_allowed = 0;
#line 886
  connector->doublescan_allowed = 0;
#line 889
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 892
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 900
  gma_encoder->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
#line 903
  if ((unsigned long )gma_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 904
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
#line 906
    goto failed_blc_i2c;
  } else {

  }
#line 908
  (gma_encoder->i2c_bus)->slave_addr = 44U;
#line 909
  dev_priv->lvds_i2c_bus = gma_encoder->i2c_bus;
#line 922
  gma_encoder->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
#line 925
  if ((unsigned long )gma_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 926
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
#line 928
    goto failed_ddc;
  } else {

  }
#line 935
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
#line 936
  psb_intel_ddc_get_modes(connector, & (gma_encoder->ddc_bus)->adapter);
#line 938
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 938
  scan = (struct drm_display_mode *)__mptr;
#line 938
  goto ldv_40029;
  ldv_40028: ;
#line 939
  if ((scan->type & 8U) != 0U) {
#line 940
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 942
    goto out;
  } else {

  }
#line 938
  __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 938
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_40029: ;
#line 938
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 940
    goto ldv_40028;
  } else {

  }

#line 947
  if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 948
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
#line 950
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 951
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 953
      goto out;
    } else {

    }
  } else {

  }
#line 961
  lvds = REGISTER_READ(dev, 397696U);
#line 962
  pipe = (lvds & 1073741824U) != 0U;
#line 963
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
#line 965
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
#line 966
    mode_dev->panel_fixed_mode = cdv_intel_crtc_mode_get(dev, crtc);
#line 968
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 969
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 971
      goto out;
    } else {

    }
  } else {

  }
#line 976
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 977
    tmp___5 = ldv__builtin_expect((long )((int )drm_debug) & 1L, 0L);
#line 977
    if (tmp___5 != 0L) {
#line 977
      drm_ut_debug_printk("cdv_intel_lvds_init", "Found no modes on the lvds, ignoring the LVDS\n");
    } else {

    }
#line 979
    goto failed_find;
  } else {

  }
#line 986
  pwm = REGISTER_READ(dev, 397904U);
#line 987
  if (pipe == 1) {
#line 988
    pwm = pwm | 536870912U;
  } else {
#line 990
    pwm = pwm & 3758096383U;
  }
#line 991
  pwm = pwm | 2147483648U;
#line 992
  REGISTER_WRITE(dev, 397904U, pwm);
  out: 
#line 996
  mutex_unlock(& dev->mode_config.mutex);
#line 997
  drm_sysfs_connector_add(connector);
#line 998
  return;
  failed_find: 
#line 1001
  mutex_unlock(& dev->mode_config.mutex);
#line 1002
  printk("\vFailed find\n");
#line 1003
  if ((unsigned long )gma_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 1004
    psb_intel_i2c_destroy(gma_encoder->ddc_bus);
  } else {

  }
  failed_ddc: 
#line 1006
  printk("\vFailed DDC\n");
#line 1007
  if ((unsigned long )gma_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 1008
    psb_intel_i2c_destroy(gma_encoder->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
#line 1010
  printk("\vFailed BLC\n");
#line 1011
  drm_encoder_cleanup(encoder);
#line 1012
  drm_connector_cleanup(connector);
#line 1013
  kfree((void const   *)lvds_priv);
  failed_lvds_priv: 
#line 1015
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 1017
  kfree((void const   *)gma_encoder);
#line 1018
  return;
}
}
#line 1020
extern int ldv_probe_16(void) ;
#line 1021
extern int ldv_probe_17(void) ;
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_funcs_17(void) 
{ 
  void *tmp ;

  {
#line 1025
  tmp = ldv_zalloc(720UL);
#line 1025
  cdv_intel_lvds_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 1026
  return;
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_19(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1029
  tmp = ldv_zalloc(96UL);
#line 1029
  cdv_intel_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 1030
  tmp___0 = ldv_zalloc(208UL);
#line 1030
  cdv_intel_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 1031
  return;
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_18(void) 
{ 
  void *tmp ;

  {
#line 1034
  tmp = ldv_zalloc(720UL);
#line 1034
  cdv_intel_lvds_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 1035
  return;
}
}
#line 1037 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  struct drm_display_mode *ldvarg13 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1038
  tmp = ldv_zalloc(208UL);
#line 1038
  ldvarg13 = (struct drm_display_mode *)tmp;
#line 1040
  tmp___0 = __VERIFIER_nondet_int();
#line 1040
  switch (tmp___0) {
  case 0: ;
#line 1043
  if (ldv_state_variable_18 == 1) {
#line 1045
    cdv_intel_lvds_get_modes(cdv_intel_lvds_connector_helper_funcs_group0);
#line 1047
    ldv_state_variable_18 = 1;
  } else {

  }
#line 1050
  goto ldv_40051;
  case 1: ;
#line 1053
  if (ldv_state_variable_18 == 1) {
#line 1055
    cdv_intel_lvds_mode_valid(cdv_intel_lvds_connector_helper_funcs_group0, ldvarg13);
#line 1057
    ldv_state_variable_18 = 1;
  } else {

  }
#line 1060
  goto ldv_40051;
  case 2: ;
#line 1063
  if (ldv_state_variable_18 == 1) {
#line 1065
    gma_best_encoder(cdv_intel_lvds_connector_helper_funcs_group0);
#line 1067
    ldv_state_variable_18 = 1;
  } else {

  }
#line 1070
  goto ldv_40051;
  default: 
#line 1071
  ldv_stop();
  }
  ldv_40051: ;
#line 1075
  return;
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  struct drm_display_mode *ldvarg196 ;
  void *tmp ;
  int ldvarg198 ;
  int tmp___0 ;
  struct drm_display_mode *ldvarg197 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1078
  tmp = ldv_zalloc(208UL);
#line 1078
  ldvarg196 = (struct drm_display_mode *)tmp;
#line 1079
  tmp___0 = __VERIFIER_nondet_int();
#line 1079
  ldvarg198 = tmp___0;
#line 1080
  tmp___1 = ldv_zalloc(208UL);
#line 1080
  ldvarg197 = (struct drm_display_mode *)tmp___1;
#line 1082
  tmp___2 = __VERIFIER_nondet_int();
#line 1082
  switch (tmp___2) {
  case 0: ;
#line 1085
  if (ldv_state_variable_19 == 1) {
#line 1087
    cdv_intel_lvds_encoder_dpms(cdv_intel_lvds_helper_funcs_group0, ldvarg198);
#line 1089
    ldv_state_variable_19 = 1;
  } else {

  }
#line 1092
  goto ldv_40062;
  case 1: ;
#line 1095
  if (ldv_state_variable_19 == 1) {
#line 1097
    cdv_intel_lvds_mode_fixup(cdv_intel_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg197,
                              cdv_intel_lvds_helper_funcs_group1);
#line 1099
    ldv_state_variable_19 = 1;
  } else {

  }
#line 1102
  goto ldv_40062;
  case 2: ;
#line 1105
  if (ldv_state_variable_19 == 1) {
#line 1107
    cdv_intel_lvds_commit(cdv_intel_lvds_helper_funcs_group0);
#line 1109
    ldv_state_variable_19 = 1;
  } else {

  }
#line 1112
  goto ldv_40062;
  case 3: ;
#line 1115
  if (ldv_state_variable_19 == 1) {
#line 1117
    cdv_intel_lvds_mode_set(cdv_intel_lvds_helper_funcs_group0, cdv_intel_lvds_helper_funcs_group1,
                            ldvarg196);
#line 1119
    ldv_state_variable_19 = 1;
  } else {

  }
#line 1122
  goto ldv_40062;
  case 4: ;
#line 1125
  if (ldv_state_variable_19 == 1) {
#line 1127
    cdv_intel_lvds_prepare(cdv_intel_lvds_helper_funcs_group0);
#line 1129
    ldv_state_variable_19 = 1;
  } else {

  }
#line 1132
  goto ldv_40062;
  default: 
#line 1133
  ldv_stop();
  }
  ldv_40062: ;
#line 1137
  return;
}
}
#line 1139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  struct drm_encoder *ldvarg16 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1140
  tmp = ldv_zalloc(96UL);
#line 1140
  ldvarg16 = (struct drm_encoder *)tmp;
#line 1142
  tmp___0 = __VERIFIER_nondet_int();
#line 1142
  switch (tmp___0) {
  case 0: ;
#line 1145
  if (ldv_state_variable_16 == 2) {
#line 1147
    cdv_intel_lvds_enc_destroy(ldvarg16);
#line 1149
    ldv_state_variable_16 = 1;
#line 1150
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1153
  goto ldv_40073;
  case 1: ;
#line 1156
  if (ldv_state_variable_16 == 1) {
#line 1158
    ldv_probe_16();
#line 1160
    ldv_state_variable_16 = 2;
#line 1161
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1164
  goto ldv_40073;
  default: 
#line 1165
  ldv_stop();
  }
  ldv_40073: ;
#line 1169
  return;
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  uint64_t ldvarg9 ;
  int ldvarg12 ;
  int tmp ;
  struct drm_property *ldvarg10 ;
  void *tmp___0 ;
  uint32_t ldvarg7 ;
  bool ldvarg11 ;
  uint32_t ldvarg8 ;
  int tmp___1 ;

  {
#line 1173
  tmp = __VERIFIER_nondet_int();
#line 1173
  ldvarg12 = tmp;
#line 1174
  tmp___0 = ldv_zalloc(104UL);
#line 1174
  ldvarg10 = (struct drm_property *)tmp___0;
#line 1172
  memset((void *)(& ldvarg9), 0, 8UL);
#line 1175
  memset((void *)(& ldvarg7), 0, 4UL);
#line 1176
  memset((void *)(& ldvarg11), 0, 1UL);
#line 1177
  memset((void *)(& ldvarg8), 0, 4UL);
#line 1179
  tmp___1 = __VERIFIER_nondet_int();
#line 1179
  switch (tmp___1) {
  case 0: ;
#line 1182
  if (ldv_state_variable_17 == 1) {
#line 1184
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg12);
#line 1186
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1189
  if (ldv_state_variable_17 == 2) {
#line 1191
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg12);
#line 1193
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1196
  goto ldv_40086;
  case 1: ;
#line 1199
  if (ldv_state_variable_17 == 1) {
#line 1201
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg11);
#line 1203
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1206
  if (ldv_state_variable_17 == 2) {
#line 1208
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg11);
#line 1210
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1213
  goto ldv_40086;
  case 2: ;
#line 1216
  if (ldv_state_variable_17 == 1) {
#line 1218
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg10, ldvarg9);
#line 1220
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1223
  if (ldv_state_variable_17 == 2) {
#line 1225
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg10, ldvarg9);
#line 1227
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1230
  goto ldv_40086;
  case 3: ;
#line 1233
  if (ldv_state_variable_17 == 2) {
#line 1235
    cdv_intel_lvds_destroy(cdv_intel_lvds_connector_funcs_group0);
#line 1237
    ldv_state_variable_17 = 1;
#line 1238
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1241
  goto ldv_40086;
  case 4: ;
#line 1244
  if (ldv_state_variable_17 == 1) {
#line 1246
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
#line 1248
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1251
  if (ldv_state_variable_17 == 2) {
#line 1253
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
#line 1255
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1258
  goto ldv_40086;
  case 5: ;
#line 1261
  if (ldv_state_variable_17 == 1) {
#line 1263
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
#line 1265
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1268
  if (ldv_state_variable_17 == 2) {
#line 1270
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
#line 1272
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1275
  goto ldv_40086;
  case 6: ;
#line 1278
  if (ldv_state_variable_17 == 1) {
#line 1280
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg8, ldvarg7);
#line 1282
    ldv_state_variable_17 = 1;
  } else {

  }
#line 1285
  if (ldv_state_variable_17 == 2) {
#line 1287
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg8, ldvarg7);
#line 1289
    ldv_state_variable_17 = 2;
  } else {

  }
#line 1292
  goto ldv_40086;
  case 7: ;
#line 1295
  if (ldv_state_variable_17 == 1) {
#line 1297
    ldv_probe_17();
#line 1299
    ldv_state_variable_17 = 2;
#line 1300
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1303
  goto ldv_40086;
  default: 
#line 1304
  ldv_stop();
  }
  ldv_40086: ;
#line 1308
  return;
}
}
#line 1436 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_lvds.o.c.prepared"
void *ldv_kmem_cache_alloc_560(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1439
  ldv_check_alloc_flags(flags);
#line 1441
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1442
  return ((void *)0);
}
}
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_580(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 424 "include/drm/drm_dp_helper.h"
extern int i2c_dp_aux_add_bus(struct i2c_adapter * ) ;
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static struct ddi_regoff ddi_DP_train_table[2U]  = {      {33068U, 33060U, 33108U, 33096U, 33100U, 33104U, 33112U}, 
        {33324U, 33316U, 33364U, 33352U, 33356U, 33360U, 33368U}};
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint32_t dp_vswing_premph_table[8U]  = 
#line 325
  {      1429440852U,      16384U,      1431144788U,      8192U, 
        1432783188U,      0U,      1436205268U,      24576U};
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool is_edp(struct gma_encoder *encoder ) 
{ 


  {
#line 340
  return (encoder->type == 10);
}
}
#line 344
static void cdv_intel_dp_start_link_train(struct gma_encoder *encoder ) ;
#line 345
static void cdv_intel_dp_complete_link_train(struct gma_encoder *encoder ) ;
#line 346
static void cdv_intel_dp_link_down(struct gma_encoder *encoder ) ;
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_max_lane_count(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int max_lane_count ;

  {
#line 351
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 352
  max_lane_count = 4;
#line 354
  if ((unsigned int )intel_dp->dpcd[0] > 16U) {
#line 355
    max_lane_count = (int )intel_dp->dpcd[2] & 31;
#line 356
    switch (max_lane_count) {
    case 1: ;
    case 2: ;
    case 4: ;
#line 358
    goto ldv_39778;
    default: 
#line 360
    max_lane_count = 4;
    }
    ldv_39778: ;
  } else {

  }
#line 363
  return (max_lane_count);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_max_link_bw(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int max_link_bw ;

  {
#line 369
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 370
  max_link_bw = (int )intel_dp->dpcd[1];
#line 372
  switch (max_link_bw) {
  case 6: ;
  case 10: ;
#line 375
  goto ldv_39787;
  default: 
#line 377
  max_link_bw = 6;
#line 378
  goto ldv_39787;
  }
  ldv_39787: ;
#line 380
  return (max_link_bw);
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_link_clock(uint8_t link_bw ) 
{ 


  {
#line 386
  if ((unsigned int )link_bw == 10U) {
#line 387
    return (270000);
  } else {
#line 389
    return (162000);
  }
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_link_required(int pixel_clock , int bpp ) 
{ 


  {
#line 395
  return ((pixel_clock * bpp + 7) / 8);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_max_data_rate(int max_link_clock , int max_lanes ) 
{ 


  {
#line 401
  return (((max_link_clock * max_lanes) * 19) / 20);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_edp_panel_vdd_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  long tmp ;
  long tmp___0 ;

  {
#line 406
  dev = intel_encoder->base.dev;
#line 407
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 410
  if ((int )intel_dp->panel_on) {
#line 411
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 411
    if (tmp != 0L) {
#line 411
      drm_ut_debug_printk("cdv_intel_edp_panel_vdd_on", "Skip VDD on because of panel on\n");
    } else {

    }
#line 412
    return;
  } else {

  }
#line 414
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 414
  if (tmp___0 != 0L) {
#line 414
    drm_ut_debug_printk("cdv_intel_edp_panel_vdd_on", "\n");
  } else {

  }
#line 416
  pp = REGISTER_READ(dev, 397828U);
#line 418
  pp = pp | 8U;
#line 419
  REGISTER_WRITE(dev, 397828U, pp);
#line 420
  REGISTER_READ(dev, 397828U);
#line 421
  msleep((unsigned int )intel_dp->panel_power_up_delay);
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_edp_panel_vdd_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  long tmp ;

  {
#line 426
  dev = intel_encoder->base.dev;
#line 429
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 429
  if (tmp != 0L) {
#line 429
    drm_ut_debug_printk("cdv_intel_edp_panel_vdd_off", "\n");
  } else {

  }
#line 430
  pp = REGISTER_READ(dev, 397828U);
#line 432
  pp = pp & 4294967287U;
#line 433
  REGISTER_WRITE(dev, 397828U, pp);
#line 434
  REGISTER_READ(dev, 397828U);
#line 435
  return;
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_edp_panel_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  u32 idle_on_mask ;
  long tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  unsigned long timeout__ ;
  unsigned long tmp___2 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 441
  dev = intel_encoder->base.dev;
#line 442
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 443
  idle_on_mask = 2147483648U;
#line 445
  if ((int )intel_dp->panel_on) {
#line 446
    return (1);
  } else {

  }
#line 448
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 448
  if (tmp != 0L) {
#line 448
    drm_ut_debug_printk("cdv_intel_edp_panel_on", "\n");
  } else {

  }
#line 449
  pp = REGISTER_READ(dev, 397828U);
#line 450
  pp = pp & 65535U;
#line 452
  pp = pp | 2882338817U;
#line 453
  REGISTER_WRITE(dev, 397828U, pp);
#line 454
  REGISTER_READ(dev, 397828U);
#line 456
  tmp___2 = msecs_to_jiffies(1000U);
#line 456
  timeout__ = tmp___2 + (unsigned long )jiffies;
#line 456
  ret__ = 0;
#line 456
  goto ldv_39872;
  ldv_39871: ;
#line 456
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 456
    ret__ = -110;
#line 456
    goto ldv_39829;
  } else {

  }
#line 456
  __vpp_verify = (void const   *)0;
#line 456
  switch (4UL) {
  case 1UL: ;
#line 456
  switch (4UL) {
  case 1UL: 
#line 456
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 456
  goto ldv_39835;
  case 2UL: 
#line 456
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 456
  goto ldv_39835;
  case 4UL: 
#line 456
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 456
  goto ldv_39835;
  case 8UL: 
#line 456
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 456
  goto ldv_39835;
  default: 
#line 456
  __bad_percpu_size();
  }
  ldv_39835: 
#line 456
  pscr_ret__ = pfo_ret__;
#line 456
  goto ldv_39841;
  case 2UL: ;
#line 456
  switch (4UL) {
  case 1UL: 
#line 456
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 456
  goto ldv_39845;
  case 2UL: 
#line 456
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 456
  goto ldv_39845;
  case 4UL: 
#line 456
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 456
  goto ldv_39845;
  case 8UL: 
#line 456
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 456
  goto ldv_39845;
  default: 
#line 456
  __bad_percpu_size();
  }
  ldv_39845: 
#line 456
  pscr_ret__ = pfo_ret_____0;
#line 456
  goto ldv_39841;
  case 4UL: ;
#line 456
  switch (4UL) {
  case 1UL: 
#line 456
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 456
  goto ldv_39854;
  case 2UL: 
#line 456
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 456
  goto ldv_39854;
  case 4UL: 
#line 456
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 456
  goto ldv_39854;
  case 8UL: 
#line 456
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 456
  goto ldv_39854;
  default: 
#line 456
  __bad_percpu_size();
  }
  ldv_39854: 
#line 456
  pscr_ret__ = pfo_ret_____1;
#line 456
  goto ldv_39841;
  case 8UL: ;
#line 456
  switch (4UL) {
  case 1UL: 
#line 456
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 456
  goto ldv_39863;
  case 2UL: 
#line 456
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 456
  goto ldv_39863;
  case 4UL: 
#line 456
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 456
  goto ldv_39863;
  case 8UL: 
#line 456
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 456
  goto ldv_39863;
  default: 
#line 456
  __bad_percpu_size();
  }
  ldv_39863: 
#line 456
  pscr_ret__ = pfo_ret_____2;
#line 456
  goto ldv_39841;
  default: 
#line 456
  __bad_size_call_parameter();
#line 456
  goto ldv_39841;
  }
  ldv_39841: 
#line 456
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 456
  if (pscr_ret__ != tmp___3) {
#line 456
    msleep(1U);
  } else {

  }
  ldv_39872: 
#line 456
  tmp___4 = REGISTER_READ(dev, 397824U);
#line 456
  if ((tmp___4 & idle_on_mask) != idle_on_mask) {
#line 458
    goto ldv_39871;
  } else {

  }
  ldv_39829: ;
#line 456
  if (ret__ != 0) {
#line 457
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 457
    if (tmp___1 != 0L) {
#line 457
      tmp___0 = REGISTER_READ(dev, 397824U);
#line 457
      drm_ut_debug_printk("cdv_intel_edp_panel_on", "Error in Powering up eDP panel, status %x\n",
                          tmp___0);
    } else {

    }
#line 458
    intel_dp->panel_on = 0;
  } else {
#line 460
    intel_dp->panel_on = 1;
  }
#line 461
  msleep((unsigned int )intel_dp->panel_power_up_delay);
#line 463
  return (0);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_edp_panel_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  u32 idle_off_mask ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;
  uint32_t tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long timeout__ ;
  unsigned long tmp___3 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  long tmp___6 ;

  {
#line 468
  dev = intel_encoder->base.dev;
#line 469
  idle_off_mask = 2147483648U;
#line 470
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 472
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 472
  if (tmp != 0L) {
#line 472
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "\n");
  } else {

  }
#line 474
  pp = REGISTER_READ(dev, 397828U);
#line 476
  if ((pp & 1U) == 0U) {
#line 477
    return;
  } else {

  }
#line 479
  intel_dp->panel_on = 0;
#line 480
  pp = pp & 65535U;
#line 483
  pp = pp & 4294967294U;
#line 484
  pp = pp & 4294967287U;
#line 485
  pp = pp & 4294967291U;
#line 486
  REGISTER_WRITE(dev, 397828U, pp);
#line 487
  REGISTER_READ(dev, 397828U);
#line 488
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 488
  if (tmp___1 != 0L) {
#line 488
    tmp___0 = REGISTER_READ(dev, 397824U);
#line 488
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "PP_STATUS %x\n", tmp___0);
  } else {

  }
#line 490
  tmp___3 = msecs_to_jiffies(1000U);
#line 490
  timeout__ = tmp___3 + (unsigned long )jiffies;
#line 490
  ret__ = 0;
#line 490
  goto ldv_39933;
  ldv_39932: ;
#line 490
  if ((long )(timeout__ - (unsigned long )jiffies) < 0L) {
#line 490
    ret__ = -110;
#line 490
    goto ldv_39890;
  } else {

  }
#line 490
  __vpp_verify = (void const   *)0;
#line 490
  switch (4UL) {
  case 1UL: ;
#line 490
  switch (4UL) {
  case 1UL: 
#line 490
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 490
  goto ldv_39896;
  case 2UL: 
#line 490
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 490
  goto ldv_39896;
  case 4UL: 
#line 490
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 490
  goto ldv_39896;
  case 8UL: 
#line 490
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 490
  goto ldv_39896;
  default: 
#line 490
  __bad_percpu_size();
  }
  ldv_39896: 
#line 490
  pscr_ret__ = pfo_ret__;
#line 490
  goto ldv_39902;
  case 2UL: ;
#line 490
  switch (4UL) {
  case 1UL: 
#line 490
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 490
  goto ldv_39906;
  case 2UL: 
#line 490
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 490
  goto ldv_39906;
  case 4UL: 
#line 490
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 490
  goto ldv_39906;
  case 8UL: 
#line 490
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 490
  goto ldv_39906;
  default: 
#line 490
  __bad_percpu_size();
  }
  ldv_39906: 
#line 490
  pscr_ret__ = pfo_ret_____0;
#line 490
  goto ldv_39902;
  case 4UL: ;
#line 490
  switch (4UL) {
  case 1UL: 
#line 490
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 490
  goto ldv_39915;
  case 2UL: 
#line 490
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 490
  goto ldv_39915;
  case 4UL: 
#line 490
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 490
  goto ldv_39915;
  case 8UL: 
#line 490
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 490
  goto ldv_39915;
  default: 
#line 490
  __bad_percpu_size();
  }
  ldv_39915: 
#line 490
  pscr_ret__ = pfo_ret_____1;
#line 490
  goto ldv_39902;
  case 8UL: ;
#line 490
  switch (4UL) {
  case 1UL: 
#line 490
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 490
  goto ldv_39924;
  case 2UL: 
#line 490
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 490
  goto ldv_39924;
  case 4UL: 
#line 490
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 490
  goto ldv_39924;
  case 8UL: 
#line 490
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 490
  goto ldv_39924;
  default: 
#line 490
  __bad_percpu_size();
  }
  ldv_39924: 
#line 490
  pscr_ret__ = pfo_ret_____2;
#line 490
  goto ldv_39902;
  default: 
#line 490
  __bad_size_call_parameter();
#line 490
  goto ldv_39902;
  }
  ldv_39902: 
#line 490
  tmp___4 = atomic_read((atomic_t const   *)(& kgdb_active));
#line 490
  if (pscr_ret__ != tmp___4) {
#line 490
    msleep(1U);
  } else {

  }
  ldv_39933: 
#line 490
  tmp___5 = REGISTER_READ(dev, 397824U);
#line 490
  if ((tmp___5 & idle_off_mask) != 0U) {
#line 492
    goto ldv_39932;
  } else {

  }
  ldv_39890: ;
#line 490
  if (ret__ != 0) {
#line 491
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 491
    if (tmp___2 != 0L) {
#line 491
      drm_ut_debug_printk("cdv_intel_edp_panel_off", "Error in turning off Panel\n");
    } else {

    }
  } else {

  }
#line 494
  msleep((unsigned int )intel_dp->panel_power_cycle_delay);
#line 495
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 495
  if (tmp___6 != 0L) {
#line 495
    drm_ut_debug_printk("cdv_intel_edp_panel_off", "Over\n");
  } else {

  }
#line 496
  return;
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_edp_backlight_on(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  u32 pp ;
  long tmp ;

  {
#line 500
  dev = intel_encoder->base.dev;
#line 503
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 503
  if (tmp != 0L) {
#line 503
    drm_ut_debug_printk("cdv_intel_edp_backlight_on", "\n");
  } else {

  }
#line 510
  msleep(300U);
#line 511
  pp = REGISTER_READ(dev, 397828U);
#line 513
  pp = pp | 4U;
#line 514
  REGISTER_WRITE(dev, 397828U, pp);
#line 515
  gma_backlight_enable(dev);
#line 516
  return;
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_edp_backlight_off(struct gma_encoder *intel_encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  long tmp ;

  {
#line 520
  dev = intel_encoder->base.dev;
#line 521
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 524
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 524
  if (tmp != 0L) {
#line 524
    drm_ut_debug_printk("cdv_intel_edp_backlight_off", "\n");
  } else {

  }
#line 525
  gma_backlight_disable(dev);
#line 526
  msleep(10U);
#line 527
  pp = REGISTER_READ(dev, 397828U);
#line 529
  pp = pp & 4294967291U;
#line 530
  REGISTER_WRITE(dev, 397828U, pp);
#line 531
  msleep((unsigned int )intel_dp->backlight_off_delay);
#line 532
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int max_link_clock ;
  int tmp___0 ;
  int tmp___1 ;
  int max_lanes ;
  int tmp___2 ;
  struct drm_psb_private *dev_priv ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;

  {
#line 538
  tmp = gma_attached_encoder(connector);
#line 538
  encoder = tmp;
#line 539
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 540
  tmp___0 = cdv_intel_dp_max_link_bw(encoder);
#line 540
  tmp___1 = cdv_intel_dp_link_clock((int )((uint8_t )tmp___0));
#line 540
  max_link_clock = tmp___1;
#line 541
  tmp___2 = cdv_intel_dp_max_lane_count(encoder);
#line 541
  max_lanes = tmp___2;
#line 542
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 544
  tmp___3 = is_edp(encoder);
#line 544
  if ((int )tmp___3 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 545
    if (mode->hdisplay > (intel_dp->panel_fixed_mode)->hdisplay) {
#line 546
      return (29);
    } else {

    }
#line 547
    if (mode->vdisplay > (intel_dp->panel_fixed_mode)->vdisplay) {
#line 548
      return (29);
    } else {

    }
  } else {

  }
#line 553
  tmp___4 = is_edp(encoder);
#line 553
  if (tmp___4) {
#line 553
    tmp___5 = 0;
  } else {
#line 553
    tmp___5 = 1;
  }
#line 553
  if (tmp___5) {
#line 553
    tmp___6 = cdv_intel_dp_link_required(mode->clock, dev_priv->edp.bpp);
#line 553
    tmp___7 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
#line 553
    if (tmp___6 > tmp___7) {
#line 556
      return (15);
    } else {

    }
  } else {

  }
#line 558
  tmp___10 = is_edp(encoder);
#line 558
  if ((int )tmp___10) {
#line 559
    tmp___8 = cdv_intel_dp_link_required(mode->clock, 24);
#line 559
    tmp___9 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
#line 559
    if (tmp___8 > tmp___9) {
#line 561
      return (15);
    } else {

    }
  } else {

  }
#line 564
  if (mode->clock <= 9999) {
#line 565
    return (16);
  } else {

  }
#line 567
  return (0);
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint32_t pack_aux(uint8_t *src , int src_bytes ) 
{ 
  int i ;
  uint32_t v ;

  {
#line 574
  v = 0U;
#line 576
  if (src_bytes > 4) {
#line 577
    src_bytes = 4;
  } else {

  }
#line 578
  i = 0;
#line 578
  goto ldv_39964;
  ldv_39963: 
#line 579
  v = ((unsigned int )*(src + (unsigned long )i) << (3 - i) * 8) | v;
#line 578
  i = i + 1;
  ldv_39964: ;
#line 578
  if (i < src_bytes) {
#line 580
    goto ldv_39963;
  } else {

  }

#line 580
  return (v);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void unpack_aux(uint32_t src , uint8_t *dst , int dst_bytes ) 
{ 
  int i ;

  {
#line 587
  if (dst_bytes > 4) {
#line 588
    dst_bytes = 4;
  } else {

  }
#line 589
  i = 0;
#line 589
  goto ldv_39973;
  ldv_39972: 
#line 590
  *(dst + (unsigned long )i) = (uint8_t )(src >> (3 - i) * 8);
#line 589
  i = i + 1;
  ldv_39973: ;
#line 589
  if (i < dst_bytes) {
#line 591
    goto ldv_39972;
  } else {

  }

#line 596
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_aux_ch(struct gma_encoder *encoder , uint8_t *send , int send_bytes ,
                               uint8_t *recv , int recv_size ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint32_t output_reg ;
  struct drm_device *dev ;
  uint32_t ch_ctl ;
  uint32_t ch_data ;
  int i ;
  int recv_bytes ;
  uint32_t status ;
  uint32_t aux_clock_divider ;
  int try ;
  int precharge ;
  bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 598
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 599
  output_reg = intel_dp->output_reg;
#line 600
  dev = encoder->base.dev;
#line 601
  ch_ctl = output_reg + 16U;
#line 602
  ch_data = ch_ctl + 4U;
#line 615
  aux_clock_divider = 100U;
#line 617
  precharge = 4;
#line 618
  tmp = is_edp(encoder);
#line 618
  if ((int )tmp) {
#line 619
    precharge = 10;
  } else {

  }
#line 621
  tmp___1 = REGISTER_READ(dev, ch_ctl);
#line 621
  if ((int )tmp___1 < 0) {
#line 622
    tmp___0 = REGISTER_READ(dev, ch_ctl);
#line 622
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch not started status 0x%08x\n", tmp___0);
#line 624
    return (-16);
  } else {

  }
#line 628
  try = 0;
#line 628
  goto ldv_40001;
  ldv_40000: 
#line 630
  i = 0;
#line 630
  goto ldv_39995;
  ldv_39994: 
#line 631
  tmp___2 = pack_aux(send + (unsigned long )i, send_bytes - i);
#line 631
  REGISTER_WRITE(dev, ch_data + (uint32_t )i, tmp___2);
#line 630
  i = i + 4;
  ldv_39995: ;
#line 630
  if (i < send_bytes) {
#line 632
    goto ldv_39994;
  } else {

  }
#line 635
  REGISTER_WRITE(dev, ch_ctl, ((uint32_t )(((long )(send_bytes << 20) | (-0x7FFFFFFF-1)) | (long )(precharge << 16)) | aux_clock_divider) | 1375731712U);
  ldv_39998: 
#line 645
  status = REGISTER_READ(dev, ch_ctl);
#line 646
  if ((int )status >= 0) {
#line 647
    goto ldv_39997;
  } else {

  }
#line 648
  __const_udelay(429500UL);
#line 649
  goto ldv_39998;
  ldv_39997: 
#line 652
  REGISTER_WRITE(dev, ch_ctl, status | 1375731712U);
#line 657
  if ((status & 1073741824U) != 0U) {
#line 658
    goto ldv_39999;
  } else {

  }
#line 628
  try = try + 1;
  ldv_40001: ;
#line 628
  if (try <= 4) {
#line 630
    goto ldv_40000;
  } else {

  }
  ldv_39999: ;
#line 661
  if ((status & 1073741824U) == 0U) {
#line 662
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch not done status 0x%08x\n", status);
#line 663
    return (-16);
  } else {

  }
#line 669
  if ((status & 33554432U) != 0U) {
#line 670
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch receive error status 0x%08x\n", status);
#line 671
    return (-5);
  } else {

  }
#line 676
  if ((status & 268435456U) != 0U) {
#line 677
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 677
    if (tmp___3 != 0L) {
#line 677
      drm_ut_debug_printk("cdv_intel_dp_aux_ch", "dp_aux_ch timeout status 0x%08x\n",
                          status);
    } else {

    }
#line 678
    return (-110);
  } else {

  }
#line 682
  recv_bytes = (int )((status & 32505856U) >> 20);
#line 684
  if (recv_bytes > recv_size) {
#line 685
    recv_bytes = recv_size;
  } else {

  }
#line 687
  i = 0;
#line 687
  goto ldv_40003;
  ldv_40002: 
#line 688
  tmp___4 = REGISTER_READ(dev, ch_data + (uint32_t )i);
#line 688
  unpack_aux(tmp___4, recv + (unsigned long )i, recv_bytes - i);
#line 687
  i = i + 4;
  ldv_40003: ;
#line 687
  if (i < recv_bytes) {
#line 689
    goto ldv_40002;
  } else {

  }

#line 691
  return (recv_bytes);
}
}
#line 696 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_aux_native_write(struct gma_encoder *encoder , uint16_t address ,
                                         uint8_t *send , int send_bytes ) 
{ 
  int ret ;
  uint8_t msg[20U] ;
  int msg_bytes ;
  uint8_t ack ;
  size_t __len ;
  void *__ret ;

  {
#line 704
  if (send_bytes > 16) {
#line 705
    return (-1);
  } else {

  }
#line 706
  msg[0] = 128U;
#line 707
  msg[1] = (uint8_t )((int )address >> 8);
#line 708
  msg[2] = (uint8_t )address;
#line 709
  msg[3] = (unsigned int )((uint8_t )send_bytes) + 255U;
#line 710
  __len = (size_t )send_bytes;
#line 710
  __ret = __builtin_memcpy((void *)(& msg) + 4U, (void const   *)send, __len);
#line 711
  msg_bytes = send_bytes + 4;
  ldv_40019: 
#line 713
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, & ack, 1);
#line 714
  if (ret < 0) {
#line 715
    return (ret);
  } else {

  }
#line 716
  ack = (uint8_t )((int )ack >> 4);
#line 717
  if (((int )ack & 3) == 0) {
#line 718
    goto ldv_40018;
  } else
#line 719
  if (((int )ack & 3) == 2) {
#line 720
    __const_udelay(429500UL);
  } else {
#line 722
    return (-5);
  }
#line 723
  goto ldv_40019;
  ldv_40018: ;
#line 724
  return (send_bytes);
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_aux_native_write_1(struct gma_encoder *encoder , uint16_t address ,
                                           uint8_t byte ) 
{ 
  int tmp ;

  {
#line 732
  tmp = cdv_intel_dp_aux_native_write(encoder, (int )address, & byte, 1);
#line 732
  return (tmp);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_aux_native_read(struct gma_encoder *encoder , uint16_t address ,
                                        uint8_t *recv , int recv_bytes ) 
{ 
  uint8_t msg[4U] ;
  int msg_bytes ;
  uint8_t reply[20U] ;
  int reply_bytes ;
  uint8_t ack ;
  int ret ;
  size_t __len ;
  void *__ret ;

  {
#line 747
  msg[0] = 144U;
#line 748
  msg[1] = (uint8_t )((int )address >> 8);
#line 749
  msg[2] = (uint8_t )address;
#line 750
  msg[3] = (unsigned int )((uint8_t )recv_bytes) + 255U;
#line 752
  msg_bytes = 4;
#line 753
  reply_bytes = recv_bytes + 1;
  ldv_40040: 
#line 756
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
#line 758
  if (ret == 0) {
#line 759
    return (-71);
  } else {

  }
#line 760
  if (ret < 0) {
#line 761
    return (ret);
  } else {

  }
#line 762
  ack = (uint8_t )((int )reply[0] >> 4);
#line 763
  if (((int )ack & 3) == 0) {
#line 764
    __len = (size_t )(ret + -1);
#line 764
    __ret = __builtin_memcpy((void *)recv, (void const   *)(& reply) + 1U, __len);
#line 765
    return (ret + -1);
  } else
#line 767
  if (((int )ack & 3) == 2) {
#line 768
    __const_udelay(429500UL);
  } else {
#line 770
    return (-5);
  }
#line 771
  goto ldv_40040;
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_i2c_aux_ch(struct i2c_adapter *adapter , int mode , uint8_t write_byte ,
                                   uint8_t *read_byte ) 
{ 
  struct i2c_algo_dp_aux_data *algo_data ;
  struct cdv_intel_dp *intel_dp ;
  struct i2c_adapter  const  *__mptr ;
  struct gma_encoder *encoder ;
  uint16_t address ;
  uint8_t msg[5U] ;
  uint8_t reply[2U] ;
  unsigned int retry ;
  int msg_bytes ;
  int reply_bytes ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 778
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
#line 779
  __mptr = (struct i2c_adapter  const  *)adapter;
#line 779
  intel_dp = (struct cdv_intel_dp *)__mptr + 0xffffffffffffffd0UL;
#line 782
  encoder = intel_dp->encoder;
#line 783
  address = algo_data->address;
#line 792
  if ((mode & 4) != 0) {
#line 793
    msg[0] = 16U;
  } else {
#line 795
    msg[0] = 0U;
  }
#line 797
  if ((mode & 8) == 0) {
#line 798
    msg[0] = (uint8_t )((unsigned int )msg[0] | 64U);
  } else {

  }
#line 800
  msg[1] = (uint8_t )((int )address >> 8);
#line 801
  msg[2] = (uint8_t )address;
#line 803
  switch (mode) {
  case 2: 
#line 805
  msg[3] = 0U;
#line 806
  msg[4] = write_byte;
#line 807
  msg_bytes = 5;
#line 808
  reply_bytes = 1;
#line 809
  goto ldv_40060;
  case 4: 
#line 811
  msg[3] = 0U;
#line 812
  msg_bytes = 4;
#line 813
  reply_bytes = 2;
#line 814
  goto ldv_40060;
  default: 
#line 816
  msg_bytes = 3;
#line 817
  reply_bytes = 1;
#line 818
  goto ldv_40060;
  }
  ldv_40060: 
#line 821
  retry = 0U;
#line 821
  goto ldv_40076;
  ldv_40075: 
#line 822
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
#line 825
  if (ret < 0) {
#line 826
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 826
    if (tmp != 0L) {
#line 826
      drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_ch failed %d\n", ret);
    } else {

    }
#line 827
    return (ret);
  } else {

  }
#line 830
  switch (((int )reply[0] >> 4) & 3) {
  case 0: ;
#line 835
  goto ldv_40065;
  case 1: 
#line 837
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 837
  if (tmp___0 != 0L) {
#line 837
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_ch native nack\n");
  } else {

  }
#line 838
  return (-121);
  case 2: 
#line 840
  __const_udelay(429500UL);
#line 841
  goto ldv_40068;
  default: 
#line 843
  drm_err("cdv_intel_dp_i2c_aux_ch", "aux_ch invalid native reply 0x%02x\n", (int )reply[0]);
#line 845
  return (-121);
  }
  ldv_40065: ;
#line 848
  switch (((int )reply[0] >> 4) & 12) {
  case 0: ;
#line 850
  if (mode == 4) {
#line 851
    *read_byte = reply[1];
  } else {

  }
#line 853
  return (reply_bytes + -1);
  case 4: 
#line 855
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 855
  if (tmp___1 != 0L) {
#line 855
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_i2c nack\n");
  } else {

  }
#line 856
  return (-121);
  case 8: 
#line 858
  tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 858
  if (tmp___2 != 0L) {
#line 858
    drm_ut_debug_printk("cdv_intel_dp_i2c_aux_ch", "aux_i2c defer\n");
  } else {

  }
#line 859
  __const_udelay(429500UL);
#line 860
  goto ldv_40073;
  default: 
#line 862
  drm_err("cdv_intel_dp_i2c_aux_ch", "aux_i2c invalid reply 0x%02x\n", (int )reply[0]);
#line 863
  return (-121);
  }
  ldv_40073: ;
  ldv_40068: 
#line 821
  retry = retry + 1U;
  ldv_40076: ;
#line 821
  if (retry <= 4U) {
#line 823
    goto ldv_40075;
  } else {

  }
#line 867
  drm_err("cdv_intel_dp_i2c_aux_ch", "too many retries, giving up\n");
#line 868
  return (-121);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_i2c_init(struct gma_connector *connector , struct gma_encoder *encoder ,
                                 char const   *name ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  long tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 875
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 878
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 878
  if (tmp != 0L) {
#line 878
    drm_ut_debug_printk("cdv_intel_dp_i2c_init", "i2c_init %s\n", name);
  } else {

  }
#line 880
  intel_dp->algo.running = 0;
#line 881
  intel_dp->algo.address = 0U;
#line 882
  intel_dp->algo.aux_ch = & cdv_intel_dp_i2c_aux_ch;
#line 884
  memset((void *)(& intel_dp->adapter), 0, 1936UL);
#line 885
  intel_dp->adapter.owner = & __this_module;
#line 886
  intel_dp->adapter.class = 8U;
#line 887
  strncpy((char *)(& intel_dp->adapter.name), name, 47UL);
#line 888
  intel_dp->adapter.name[47UL] = 0;
#line 889
  intel_dp->adapter.algo_data = (void *)(& intel_dp->algo);
#line 890
  intel_dp->adapter.dev.parent = connector->base.kdev;
#line 892
  tmp___0 = is_edp(encoder);
#line 892
  if ((int )tmp___0) {
#line 893
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 894
  ret = i2c_dp_aux_add_bus(& intel_dp->adapter);
#line 895
  tmp___1 = is_edp(encoder);
#line 895
  if ((int )tmp___1) {
#line 896
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 898
  return (ret);
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_fixed_panel_mode(struct drm_display_mode *fixed_mode , struct drm_display_mode *adjusted_mode ) 
{ 


  {
#line 904
  adjusted_mode->hdisplay = fixed_mode->hdisplay;
#line 905
  adjusted_mode->hsync_start = fixed_mode->hsync_start;
#line 906
  adjusted_mode->hsync_end = fixed_mode->hsync_end;
#line 907
  adjusted_mode->htotal = fixed_mode->htotal;
#line 909
  adjusted_mode->vdisplay = fixed_mode->vdisplay;
#line 910
  adjusted_mode->vsync_start = fixed_mode->vsync_start;
#line 911
  adjusted_mode->vsync_end = fixed_mode->vsync_end;
#line 912
  adjusted_mode->vtotal = fixed_mode->vtotal;
#line 914
  adjusted_mode->clock = fixed_mode->clock;
#line 916
  drm_mode_set_crtcinfo(adjusted_mode, 1);
#line 917
  return;
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dp_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  int lane_count ;
  int clock ;
  int max_lane_count ;
  int tmp ;
  int max_clock ;
  int tmp___0 ;
  int bws[2U] ;
  int refclock ;
  int bpp ;
  bool tmp___1 ;
  int link_avail ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;

  {
#line 923
  dev_priv = (struct drm_psb_private *)(encoder->dev)->dev_private;
#line 924
  __mptr = (struct drm_encoder  const  *)encoder;
#line 924
  intel_encoder = (struct gma_encoder *)__mptr;
#line 925
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 927
  tmp = cdv_intel_dp_max_lane_count(intel_encoder);
#line 927
  max_lane_count = tmp;
#line 928
  tmp___0 = cdv_intel_dp_max_link_bw(intel_encoder);
#line 928
  max_clock = tmp___0 == 10;
#line 929
  bws[0] = 6;
#line 929
  bws[1] = 10;
#line 930
  refclock = mode->clock;
#line 931
  bpp = 24;
#line 933
  tmp___1 = is_edp(intel_encoder);
#line 933
  if ((int )tmp___1 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 934
    cdv_intel_fixed_panel_mode(intel_dp->panel_fixed_mode, adjusted_mode);
#line 935
    refclock = (intel_dp->panel_fixed_mode)->clock;
#line 936
    bpp = dev_priv->edp.bpp;
  } else {

  }
#line 939
  lane_count = 1;
#line 939
  goto ldv_40113;
  ldv_40112: 
#line 940
  clock = max_clock;
#line 940
  goto ldv_40110;
  ldv_40109: 
#line 941
  tmp___2 = cdv_intel_dp_link_clock((int )((uint8_t )bws[clock]));
#line 941
  tmp___3 = cdv_intel_dp_max_data_rate(tmp___2, lane_count);
#line 941
  link_avail = tmp___3;
#line 943
  tmp___5 = cdv_intel_dp_link_required(refclock, bpp);
#line 943
  if (tmp___5 <= link_avail) {
#line 944
    intel_dp->link_bw = (uint8_t )bws[clock];
#line 945
    intel_dp->lane_count = (uint8_t )lane_count;
#line 946
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
#line 947
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 947
    if (tmp___4 != 0L) {
#line 947
      drm_ut_debug_printk("cdv_intel_dp_mode_fixup", "Display port link bw %02x lane count %d clock %d\n",
                          (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    } else {

    }
#line 951
    return (1);
  } else {

  }
#line 940
  clock = clock - 1;
  ldv_40110: ;
#line 940
  if (clock >= 0) {
#line 942
    goto ldv_40109;
  } else {

  }
#line 939
  lane_count = lane_count << 1;
  ldv_40113: ;
#line 939
  if (lane_count <= max_lane_count) {
#line 941
    goto ldv_40112;
  } else {

  }
#line 955
  tmp___7 = is_edp(intel_encoder);
#line 955
  if ((int )tmp___7) {
#line 957
    intel_dp->lane_count = (uint8_t )max_lane_count;
#line 958
    intel_dp->link_bw = (uint8_t )bws[max_clock];
#line 959
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
#line 960
    tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 960
    if (tmp___6 != 0L) {
#line 960
      drm_ut_debug_printk("cdv_intel_dp_mode_fixup", "Force picking display port link bw %02x lane count %d clock %d\n",
                          (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    } else {

    }
#line 965
    return (1);
  } else {

  }
#line 967
  return (0);
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_reduce_ratio(uint32_t *num , uint32_t *den ) 
{ 
  uint64_t value ;
  uint64_t m ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 987
  m = (uint64_t )*num;
#line 988
  value = m * 8388608ULL;
#line 989
  __base = *den;
#line 989
  __rem = (uint32_t )(value % (uint64_t )__base);
#line 989
  value = value / (uint64_t )__base;
#line 989
  m = (uint64_t )__rem;
#line 990
  *num = (uint32_t )value;
#line 991
  *den = 8388608U;
#line 992
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_compute_m_n(int bpp , int nlanes , int pixel_clock , int link_clock ,
                                     struct cdv_intel_dp_m_n *m_n ) 
{ 


  {
#line 1001
  m_n->tu = 64U;
#line 1002
  m_n->gmch_m = (uint32_t )((pixel_clock * bpp + 7) >> 3);
#line 1003
  m_n->gmch_n = (uint32_t )(link_clock * nlanes);
#line 1004
  cdv_intel_reduce_ratio(& m_n->gmch_m, & m_n->gmch_n);
#line 1005
  m_n->link_m = (uint32_t )pixel_clock;
#line 1006
  m_n->link_n = (uint32_t )link_clock;
#line 1007
  cdv_intel_reduce_ratio(& m_n->link_m, & m_n->link_n);
#line 1008
  return;
}
}
#line 1011 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_mode_config *mode_config ;
  struct drm_encoder *encoder ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int lane_count ;
  int bpp ;
  struct cdv_intel_dp_m_n m_n ;
  int pipe ;
  struct list_head  const  *__mptr___0 ;
  struct gma_encoder *intel_encoder ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_encoder  const  *__mptr___1 ;
  bool tmp ;
  struct list_head  const  *__mptr___2 ;

  {
#line 1014
  dev = crtc->dev;
#line 1015
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1016
  mode_config = & dev->mode_config;
#line 1018
  __mptr = (struct drm_crtc  const  *)crtc;
#line 1018
  gma_crtc = (struct gma_crtc *)__mptr;
#line 1019
  lane_count = 4;
#line 1019
  bpp = 24;
#line 1021
  pipe = gma_crtc->pipe;
#line 1026
  __mptr___0 = (struct list_head  const  *)mode_config->encoder_list.next;
#line 1026
  encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
#line 1026
  goto ldv_40164;
  ldv_40163: ;
#line 1030
  if ((unsigned long )encoder->crtc != (unsigned long )crtc) {
#line 1031
    goto ldv_40159;
  } else {

  }
#line 1033
  __mptr___1 = (struct drm_encoder  const  *)encoder;
#line 1033
  intel_encoder = (struct gma_encoder *)__mptr___1;
#line 1034
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1035
  if (intel_encoder->type == 9) {
#line 1036
    lane_count = (int )intel_dp->lane_count;
#line 1037
    goto ldv_40162;
  } else {
#line 1038
    tmp = is_edp(intel_encoder);
#line 1038
    if ((int )tmp) {
#line 1039
      lane_count = (int )intel_dp->lane_count;
#line 1040
      bpp = dev_priv->edp.bpp;
#line 1041
      goto ldv_40162;
    } else {

    }
  }
  ldv_40159: 
#line 1026
  __mptr___2 = (struct list_head  const  *)encoder->head.next;
#line 1026
  encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_40164: ;
#line 1026
  if ((unsigned long )(& encoder->head) != (unsigned long )(& mode_config->encoder_list)) {
#line 1028
    goto ldv_40163;
  } else {

  }
  ldv_40162: 
#line 1050
  cdv_intel_dp_compute_m_n(bpp, lane_count, mode->clock, adjusted_mode->clock, & m_n);
#line 1054
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
#line 1057
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), m_n.gmch_n);
#line 1058
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), m_n.link_m);
#line 1059
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), m_n.link_n);
#line 1060
  return;
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct drm_crtc *crtc ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  long tmp ;
  uint32_t pfit_control ;
  bool tmp___0 ;

  {
#line 1067
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1067
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1068
  crtc = encoder->crtc;
#line 1069
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1069
  gma_crtc = (struct gma_crtc *)__mptr___0;
#line 1070
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1071
  dev = encoder->dev;
#line 1073
  intel_dp->DP = 0U;
#line 1074
  intel_dp->DP = intel_dp->DP | intel_dp->color_range;
#line 1076
  if ((int )adjusted_mode->flags & 1) {
#line 1077
    intel_dp->DP = intel_dp->DP | 8U;
  } else {

  }
#line 1078
  if ((adjusted_mode->flags & 4U) != 0U) {
#line 1079
    intel_dp->DP = intel_dp->DP | 16U;
  } else {

  }
#line 1081
  intel_dp->DP = intel_dp->DP | 805306368U;
#line 1083
  switch ((int )intel_dp->lane_count) {
  case 1: 
#line 1085
  intel_dp->DP = intel_dp->DP;
#line 1086
  goto ldv_40180;
  case 2: 
#line 1088
  intel_dp->DP = intel_dp->DP | 524288U;
#line 1089
  goto ldv_40180;
  case 4: 
#line 1091
  intel_dp->DP = intel_dp->DP | 1572864U;
#line 1092
  goto ldv_40180;
  }
  ldv_40180: ;
#line 1094
  if ((int )intel_dp->has_audio) {
#line 1095
    intel_dp->DP = intel_dp->DP | 64U;
  } else {

  }
#line 1097
  memset((void *)(& intel_dp->link_configuration), 0, 9UL);
#line 1098
  intel_dp->link_configuration[0] = intel_dp->link_bw;
#line 1099
  intel_dp->link_configuration[1] = intel_dp->lane_count;
#line 1104
  if ((unsigned int )intel_dp->dpcd[0] > 16U && (int )((signed char )intel_dp->dpcd[2]) < 0) {
#line 1106
    intel_dp->link_configuration[1] = (uint8_t )((unsigned int )intel_dp->link_configuration[1] | 128U);
#line 1107
    intel_dp->DP = intel_dp->DP | 262144U;
  } else {

  }
#line 1111
  if (gma_crtc->pipe == 1) {
#line 1112
    intel_dp->DP = intel_dp->DP | 1073741824U;
  } else {

  }
#line 1114
  REGISTER_WRITE(dev, intel_dp->output_reg, intel_dp->DP | 2147483648U);
#line 1115
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1115
  if (tmp != 0L) {
#line 1115
    drm_ut_debug_printk("cdv_intel_dp_mode_set", "DP expected reg is %x\n", intel_dp->DP);
  } else {

  }
#line 1116
  tmp___0 = is_edp(intel_encoder);
#line 1116
  if ((int )tmp___0) {
#line 1118
    cdv_intel_edp_panel_on(intel_encoder);
#line 1120
    if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
#line 1122
      pfit_control = 2147483648U;
    } else {
#line 1124
      pfit_control = 0U;
    }
#line 1126
    pfit_control = (uint32_t )(gma_crtc->pipe << 29) | pfit_control;
#line 1128
    REGISTER_WRITE(dev, 397872U, pfit_control);
  } else {

  }
#line 1130
  return;
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_sink_dpms(struct gma_encoder *encoder , int mode ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;
  long tmp ;

  {
#line 1136
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1140
  if ((unsigned int )intel_dp->dpcd[0] <= 16U) {
#line 1141
    return;
  } else {

  }
#line 1143
  if (mode != 0) {
#line 1144
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 2);
#line 1146
    if (ret != 1) {
#line 1147
      tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 1147
      if (tmp != 0L) {
#line 1147
        drm_ut_debug_printk("cdv_intel_dp_sink_dpms", "failed to write sink power state\n");
      } else {

      }
    } else {

    }
  } else {
#line 1153
    i = 0;
#line 1153
    goto ldv_40195;
    ldv_40194: 
#line 1154
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 1);
#line 1157
    if (ret == 1) {
#line 1158
      goto ldv_40193;
    } else {

    }
#line 1159
    __const_udelay(4295000UL);
#line 1153
    i = i + 1;
    ldv_40195: ;
#line 1153
    if (i <= 2) {
#line 1155
      goto ldv_40194;
    } else {

    }
    ldv_40193: ;
  }
#line 1161
  return;
}
}
#line 1164 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_prepare(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
#line 1166
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1166
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1167
  tmp = is_edp(intel_encoder);
#line 1167
  edp = (int )tmp;
#line 1169
  if (edp != 0) {
#line 1170
    cdv_intel_edp_backlight_off(intel_encoder);
#line 1171
    cdv_intel_edp_panel_off(intel_encoder);
#line 1172
    cdv_intel_edp_panel_vdd_on(intel_encoder);
  } else {

  }
#line 1175
  cdv_intel_dp_sink_dpms(intel_encoder, 0);
#line 1176
  cdv_intel_dp_link_down(intel_encoder);
#line 1177
  if (edp != 0) {
#line 1178
    cdv_intel_edp_panel_vdd_off(intel_encoder);
  } else {

  }
#line 1179
  return;
}
}
#line 1181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_commit(struct drm_encoder *encoder ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
#line 1183
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1183
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1184
  tmp = is_edp(intel_encoder);
#line 1184
  edp = (int )tmp;
#line 1186
  if (edp != 0) {
#line 1187
    cdv_intel_edp_panel_on(intel_encoder);
  } else {

  }
#line 1188
  cdv_intel_dp_start_link_train(intel_encoder);
#line 1189
  cdv_intel_dp_complete_link_train(intel_encoder);
#line 1190
  if (edp != 0) {
#line 1191
    cdv_intel_edp_backlight_on(intel_encoder);
  } else {

  }
#line 1192
  return;
}
}
#line 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  uint32_t dp_reg ;
  uint32_t tmp ;
  int edp ;
  bool tmp___0 ;

  {
#line 1197
  __mptr = (struct drm_encoder  const  *)encoder;
#line 1197
  intel_encoder = (struct gma_encoder *)__mptr;
#line 1198
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1199
  dev = encoder->dev;
#line 1200
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
#line 1200
  dp_reg = tmp;
#line 1201
  tmp___0 = is_edp(intel_encoder);
#line 1201
  edp = (int )tmp___0;
#line 1203
  if (mode != 0) {
#line 1204
    if (edp != 0) {
#line 1205
      cdv_intel_edp_backlight_off(intel_encoder);
#line 1206
      cdv_intel_edp_panel_vdd_on(intel_encoder);
    } else {

    }
#line 1208
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
#line 1209
    cdv_intel_dp_link_down(intel_encoder);
#line 1210
    if (edp != 0) {
#line 1211
      cdv_intel_edp_panel_vdd_off(intel_encoder);
#line 1212
      cdv_intel_edp_panel_off(intel_encoder);
    } else {

    }
  } else {
#line 1215
    if (edp != 0) {
#line 1216
      cdv_intel_edp_panel_on(intel_encoder);
    } else {

    }
#line 1217
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
#line 1218
    if ((int )dp_reg >= 0) {
#line 1219
      cdv_intel_dp_start_link_train(intel_encoder);
#line 1220
      cdv_intel_dp_complete_link_train(intel_encoder);
    } else {

    }
#line 1222
    if (edp != 0) {
#line 1223
      cdv_intel_edp_backlight_on(intel_encoder);
    } else {

    }
  }
#line 1225
  return;
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dp_aux_native_read_retry(struct gma_encoder *encoder , uint16_t address ,
                                               uint8_t *recv , int recv_bytes ) 
{ 
  int ret ;
  int i ;

  {
#line 1241
  i = 0;
#line 1241
  goto ldv_40230;
  ldv_40229: 
#line 1242
  ret = cdv_intel_dp_aux_native_read(encoder, (int )address, recv, recv_bytes);
#line 1244
  if (ret == recv_bytes) {
#line 1245
    return (1);
  } else {

  }
#line 1246
  __const_udelay(4295000UL);
#line 1241
  i = i + 1;
  ldv_40230: ;
#line 1241
  if (i <= 2) {
#line 1243
    goto ldv_40229;
  } else {

  }

#line 1249
  return (0);
}
}
#line 1257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dp_get_link_status(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  bool tmp ;

  {
#line 1259
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1260
  tmp = cdv_intel_dp_aux_native_read_retry(encoder, 514, (uint8_t *)(& intel_dp->link_status),
                                           6);
#line 1260
  return (tmp);
}
}
#line 1267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint8_t cdv_intel_dp_link_status(uint8_t *link_status , int r ) 
{ 


  {
#line 1270
  return (*(link_status + ((unsigned long )r + 0xfffffffffffffdfeUL)));
}
}
#line 1274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint8_t cdv_intel_get_adjust_request_voltage(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1277
  i = (lane >> 1) + 518;
#line 1278
  s = lane & 1 ? 4 : 0;
#line 1281
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1281
  l = tmp;
#line 1283
  return ((unsigned int )((uint8_t )((int )l >> s)) & 3U);
}
}
#line 1287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint8_t cdv_intel_get_adjust_request_pre_emphasis(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1290
  i = (lane >> 1) + 518;
#line 1291
  s = lane & 1 ? 6 : 2;
#line 1294
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1294
  l = tmp;
#line 1296
  return (((unsigned int )((uint8_t )((int )l >> s)) & 3U) << 3U);
}
}
#line 1331 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_get_adjust_train(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint8_t v ;
  uint8_t p ;
  int lane ;
  uint8_t this_v ;
  uint8_t tmp ;
  uint8_t this_p ;
  uint8_t tmp___0 ;

  {
#line 1333
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1334
  v = 0U;
#line 1335
  p = 0U;
#line 1338
  lane = 0;
#line 1338
  goto ldv_40264;
  ldv_40263: 
#line 1339
  tmp = cdv_intel_get_adjust_request_voltage((uint8_t *)(& intel_dp->link_status),
                                             lane);
#line 1339
  this_v = tmp;
#line 1340
  tmp___0 = cdv_intel_get_adjust_request_pre_emphasis((uint8_t *)(& intel_dp->link_status),
                                                      lane);
#line 1340
  this_p = tmp___0;
#line 1342
  if ((int )this_v > (int )v) {
#line 1343
    v = this_v;
  } else {

  }
#line 1344
  if ((int )this_p > (int )p) {
#line 1345
    p = this_p;
  } else {

  }
#line 1338
  lane = lane + 1;
  ldv_40264: ;
#line 1338
  if ((int )intel_dp->lane_count > lane) {
#line 1340
    goto ldv_40263;
  } else {

  }

#line 1348
  if ((unsigned int )v > 2U) {
#line 1349
    v = 7U;
  } else {

  }
#line 1351
  if ((unsigned int )p == 24U) {
#line 1352
    p = (uint8_t )((unsigned int )p | 32U);
  } else {

  }
#line 1354
  lane = 0;
#line 1354
  goto ldv_40267;
  ldv_40266: 
#line 1355
  intel_dp->train_set[lane] = (uint8_t )((int )v | (int )p);
#line 1354
  lane = lane + 1;
  ldv_40267: ;
#line 1354
  if (lane <= 3) {
#line 1356
    goto ldv_40266;
  } else {

  }

#line 1361
  return;
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static uint8_t cdv_intel_get_lane_status(uint8_t *link_status , int lane ) 
{ 
  int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
#line 1363
  i = (lane >> 1) + 514;
#line 1364
  s = (lane & 1) * 4;
#line 1365
  tmp = cdv_intel_dp_link_status(link_status, i);
#line 1365
  l = tmp;
#line 1367
  return ((unsigned int )((uint8_t )((int )l >> s)) & 15U);
}
}
#line 1372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_clock_recovery_ok(uint8_t *link_status , int lane_count ) 
{ 
  int lane ;
  uint8_t lane_status ;

  {
#line 1377
  lane = 0;
#line 1377
  goto ldv_40283;
  ldv_40282: 
#line 1378
  lane_status = cdv_intel_get_lane_status(link_status, lane);
#line 1379
  if (((int )lane_status & 1) == 0) {
#line 1380
    return (0);
  } else {

  }
#line 1377
  lane = lane + 1;
  ldv_40283: ;
#line 1377
  if (lane < lane_count) {
#line 1379
    goto ldv_40282;
  } else {

  }

#line 1382
  return (1);
}
}
#line 1390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_channel_eq_ok(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  uint8_t lane_align ;
  uint8_t lane_status ;
  int lane ;

  {
#line 1392
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1397
  lane_align = cdv_intel_dp_link_status((uint8_t *)(& intel_dp->link_status), 516);
#line 1399
  if (((int )lane_align & 1) == 0) {
#line 1400
    return (0);
  } else {

  }
#line 1401
  lane = 0;
#line 1401
  goto ldv_40293;
  ldv_40292: 
#line 1402
  lane_status = cdv_intel_get_lane_status((uint8_t *)(& intel_dp->link_status), lane);
#line 1403
  if (((int )lane_status & 7) != 7) {
#line 1404
    return (0);
  } else {

  }
#line 1401
  lane = lane + 1;
  ldv_40293: ;
#line 1401
  if ((int )intel_dp->lane_count > lane) {
#line 1403
    goto ldv_40292;
  } else {

  }

#line 1406
  return (1);
}
}
#line 1410 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dp_set_link_train(struct gma_encoder *encoder , uint32_t dp_reg_value ,
                                        uint8_t dp_train_pat ) 
{ 
  struct drm_device *dev ;
  int ret ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;

  {
#line 1415
  dev = encoder->base.dev;
#line 1417
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1419
  REGISTER_WRITE(dev, intel_dp->output_reg, dp_reg_value);
#line 1420
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1422
  ret = cdv_intel_dp_aux_native_write_1(encoder, 258, (int )dp_train_pat);
#line 1426
  if (ret != 1) {
#line 1427
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1427
    if (tmp != 0L) {
#line 1427
      drm_ut_debug_printk("cdv_intel_dp_set_link_train", "Failure in setting link pattern %x\n",
                          (int )dp_train_pat);
    } else {

    }
#line 1429
    return (0);
  } else {

  }
#line 1432
  return (1);
}
}
#line 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dplink_set_level(struct gma_encoder *encoder , uint8_t dp_train_pat ) 
{ 
  int ret ;
  struct cdv_intel_dp *intel_dp ;
  long tmp ;

  {
#line 1442
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1444
  ret = cdv_intel_dp_aux_native_write(encoder, 259, (uint8_t *)(& intel_dp->train_set),
                                      (int )intel_dp->lane_count);
#line 1449
  if ((int )intel_dp->lane_count != ret) {
#line 1450
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1450
    if (tmp != 0L) {
#line 1450
      drm_ut_debug_printk("cdv_intel_dplink_set_level", "Failure in setting level %d, lane_cnt= %d\n",
                          (int )intel_dp->train_set[0], (int )intel_dp->lane_count);
    } else {

    }
#line 1452
    return (0);
  } else {

  }
#line 1454
  return (1);
}
}
#line 1458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_set_vswing_premph(struct gma_encoder *encoder , uint8_t signal_level ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  struct ddi_regoff *ddi_reg ;
  int vswing ;
  int premph ;
  int index ;
  long tmp ;

  {
#line 1460
  dev = encoder->base.dev;
#line 1461
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1465
  if (intel_dp->output_reg == 409856U) {
#line 1466
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table);
  } else {
#line 1468
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table) + 1UL;
  }
#line 1470
  vswing = (int )signal_level & 3;
#line 1471
  premph = ((int )signal_level & 24) >> 3;
#line 1474
  if (vswing + premph > 3) {
#line 1475
    return;
  } else {

  }
#line 1477
  return;
#line 1479
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1479
  if (tmp != 0L) {
#line 1479
    drm_ut_debug_printk("cdv_intel_dp_set_vswing_premph", "Test2\n");
  } else {

  }
#line 1481
  cdv_sb_reset(dev);
#line 1484
  cdv_sb_write(dev, ddi_reg->VSwing5, 84226362U);
#line 1487
  cdv_sb_write(dev, ddi_reg->VSwing1, 1128292437U);
#line 1492
  index = (vswing + premph) * 2;
#line 1493
  if (premph == 1 && vswing == 1) {
#line 1494
    cdv_sb_write(dev, ddi_reg->VSwing2, 1433635156U);
  } else {
#line 1496
    cdv_sb_write(dev, ddi_reg->VSwing2, dp_vswing_premph_table[index]);
  }
#line 1499
  if (vswing + premph == 3) {
#line 1500
    cdv_sb_write(dev, ddi_reg->VSwing3, 1887445056U);
  } else {
#line 1502
    cdv_sb_write(dev, ddi_reg->VSwing3, 1082138688U);
  }
#line 1508
  cdv_sb_write(dev, ddi_reg->VSwing1, 3275776085U);
#line 1513
  cdv_sb_write(dev, ddi_reg->PreEmph1, 520290368U);
#line 1516
  index = premph * 2 + 1;
#line 1517
  cdv_sb_write(dev, ddi_reg->PreEmph2, dp_vswing_premph_table[index]);
#line 1518
  return;
}
}
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_start_link_train(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  int i ;
  uint8_t voltage ;
  bool clock_recovery ;
  int tries ;
  u32 reg ;
  uint32_t DP ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  long tmp___10 ;

  {
#line 1526
  dev = encoder->base.dev;
#line 1527
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1530
  clock_recovery = 0;
#line 1533
  DP = intel_dp->DP;
#line 1535
  DP = DP | 2147483648U;
#line 1536
  DP = DP & 3489660927U;
#line 1538
  reg = DP;
#line 1539
  reg = reg;
#line 1541
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
#line 1542
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1543
  gma_wait_for_vblank(dev);
#line 1545
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1545
  if (tmp != 0L) {
#line 1545
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Link config\n");
  } else {

  }
#line 1547
  cdv_intel_dp_aux_native_write(encoder, 256, (uint8_t *)(& intel_dp->link_configuration),
                                2);
#line 1551
  memset((void *)(& intel_dp->train_set), 0, 4UL);
#line 1552
  voltage = 0U;
#line 1553
  tries = 0;
#line 1554
  clock_recovery = 0;
#line 1556
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1556
  if (tmp___0 != 0L) {
#line 1556
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Start train\n");
  } else {

  }
#line 1557
  reg = DP;
  ldv_40338: 
#line 1562
  tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1562
  if (tmp___1 != 0L) {
#line 1562
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                        (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                        (int )intel_dp->link_configuration[1]);
  } else {

  }
#line 1567
  tmp___3 = cdv_intel_dp_set_link_train(encoder, reg, 1);
#line 1567
  if (tmp___3) {
#line 1567
    tmp___4 = 0;
  } else {
#line 1567
    tmp___4 = 1;
  }
#line 1567
  if (tmp___4) {
#line 1568
    tmp___2 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1568
    if (tmp___2 != 0L) {
#line 1568
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "Failure in aux-transfer setting pattern 1\n");
    } else {

    }
  } else {

  }
#line 1570
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
#line 1573
  cdv_intel_dplink_set_level(encoder, 1);
#line 1575
  __const_udelay(859000UL);
#line 1576
  tmp___5 = cdv_intel_dp_get_link_status(encoder);
#line 1576
  if (tmp___5) {
#line 1576
    tmp___6 = 0;
  } else {
#line 1576
    tmp___6 = 1;
  }
#line 1576
  if (tmp___6) {
#line 1577
    goto ldv_40334;
  } else {

  }
#line 1579
  tmp___7 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1579
  if (tmp___7 != 0L) {
#line 1579
    drm_ut_debug_printk("cdv_intel_dp_start_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                        (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                        (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                        (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  } else {

  }
#line 1583
  tmp___9 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
#line 1583
  if ((int )tmp___9) {
#line 1584
    tmp___8 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1584
    if (tmp___8 != 0L) {
#line 1584
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "PT1 train is done\n");
    } else {

    }
#line 1585
    clock_recovery = 1;
#line 1586
    goto ldv_40334;
  } else {

  }
#line 1590
  i = 0;
#line 1590
  goto ldv_40337;
  ldv_40336: ;
#line 1591
  if (((int )intel_dp->train_set[i] & 4) == 0) {
#line 1592
    goto ldv_40335;
  } else {

  }
#line 1590
  i = i + 1;
  ldv_40337: ;
#line 1590
  if ((int )intel_dp->lane_count > i) {
#line 1592
    goto ldv_40336;
  } else {

  }
  ldv_40335: ;
#line 1593
  if ((int )intel_dp->lane_count == i) {
#line 1594
    goto ldv_40334;
  } else {

  }
#line 1597
  if (((int )intel_dp->train_set[0] & 3) == (int )voltage) {
#line 1598
    tries = tries + 1;
#line 1599
    if (tries == 5) {
#line 1600
      goto ldv_40334;
    } else {

    }
  } else {
#line 1602
    tries = 0;
  }
#line 1603
  voltage = (unsigned int )intel_dp->train_set[0] & 3U;
#line 1606
  cdv_intel_get_adjust_train(encoder);
#line 1608
  goto ldv_40338;
  ldv_40334: ;
#line 1610
  if (! clock_recovery) {
#line 1611
    tmp___10 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1611
    if (tmp___10 != 0L) {
#line 1611
      drm_ut_debug_printk("cdv_intel_dp_start_link_train", "failure in DP patter 1 training, train set %x\n",
                          (int )intel_dp->train_set[0]);
    } else {

    }
  } else {

  }
#line 1614
  intel_dp->DP = DP;
#line 1615
  return;
}
}
#line 1618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_complete_link_train(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  bool channel_eq ;
  int tries ;
  int cr_tries ;
  u32 reg ;
  uint32_t DP ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;

  {
#line 1620
  dev = encoder->base.dev;
#line 1621
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1622
  channel_eq = 0;
#line 1625
  DP = intel_dp->DP;
#line 1628
  tries = 0;
#line 1629
  cr_tries = 0;
#line 1630
  channel_eq = 0;
#line 1632
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1632
  if (tmp != 0L) {
#line 1632
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "\n");
  } else {

  }
#line 1633
  reg = DP | 268435456U;
  ldv_40352: 
#line 1637
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1637
  if (tmp___0 != 0L) {
#line 1637
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                        (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                        (int )intel_dp->link_configuration[1]);
  } else {

  }
#line 1643
  tmp___2 = cdv_intel_dp_set_link_train(encoder, reg, 2);
#line 1643
  if (tmp___2) {
#line 1643
    tmp___3 = 0;
  } else {
#line 1643
    tmp___3 = 1;
  }
#line 1643
  if (tmp___3) {
#line 1645
    tmp___1 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1645
    if (tmp___1 != 0L) {
#line 1645
      drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "Failure in aux-transfer setting pattern 2\n");
    } else {

    }
  } else {

  }
#line 1649
  if (cr_tries > 5) {
#line 1650
    drm_err("cdv_intel_dp_complete_link_train", "failed to train DP, aborting\n");
#line 1651
    cdv_intel_dp_link_down(encoder);
#line 1652
    goto ldv_40350;
  } else {

  }
#line 1655
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
#line 1657
  cdv_intel_dplink_set_level(encoder, 2);
#line 1659
  __const_udelay(4295000UL);
#line 1660
  tmp___4 = cdv_intel_dp_get_link_status(encoder);
#line 1660
  if (tmp___4) {
#line 1660
    tmp___5 = 0;
  } else {
#line 1660
    tmp___5 = 1;
  }
#line 1660
  if (tmp___5) {
#line 1661
    goto ldv_40350;
  } else {

  }
#line 1663
  tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1663
  if (tmp___6 != 0L) {
#line 1663
    drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                        (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                        (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                        (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  } else {

  }
#line 1668
  tmp___7 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
#line 1668
  if (tmp___7) {
#line 1668
    tmp___8 = 0;
  } else {
#line 1668
    tmp___8 = 1;
  }
#line 1668
  if (tmp___8) {
#line 1669
    cdv_intel_dp_start_link_train(encoder);
#line 1670
    cr_tries = cr_tries + 1;
#line 1671
    goto ldv_40351;
  } else {

  }
#line 1674
  tmp___10 = cdv_intel_channel_eq_ok(encoder);
#line 1674
  if ((int )tmp___10) {
#line 1675
    tmp___9 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1675
    if (tmp___9 != 0L) {
#line 1675
      drm_ut_debug_printk("cdv_intel_dp_complete_link_train", "PT2 train is done\n");
    } else {

    }
#line 1676
    channel_eq = 1;
#line 1677
    goto ldv_40350;
  } else {

  }
#line 1681
  if (tries > 5) {
#line 1682
    cdv_intel_dp_link_down(encoder);
#line 1683
    cdv_intel_dp_start_link_train(encoder);
#line 1684
    tries = 0;
#line 1685
    cr_tries = cr_tries + 1;
#line 1686
    goto ldv_40351;
  } else {

  }
#line 1690
  cdv_intel_get_adjust_train(encoder);
#line 1691
  tries = tries + 1;
  ldv_40351: ;
#line 1693
  goto ldv_40352;
  ldv_40350: 
#line 1695
  reg = DP | 805306368U;
#line 1697
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
#line 1698
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1699
  cdv_intel_dp_aux_native_write_1(encoder, 258, 0);
#line 1700
  return;
}
}
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_link_down(struct gma_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  uint32_t DP ;
  uint32_t tmp ;
  long tmp___0 ;

  {
#line 1706
  dev = encoder->base.dev;
#line 1707
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1708
  DP = intel_dp->DP;
#line 1710
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
#line 1710
  if ((int )tmp >= 0) {
#line 1711
    return;
  } else {

  }
#line 1713
  tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1713
  if (tmp___0 != 0L) {
#line 1713
    drm_ut_debug_printk("cdv_intel_dp_link_down", "\n");
  } else {

  }
#line 1717
  DP = DP & 3489660927U;
#line 1718
  REGISTER_WRITE(dev, intel_dp->output_reg, DP | 536870912U);
#line 1720
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1722
  msleep(17U);
#line 1724
  REGISTER_WRITE(dev, intel_dp->output_reg, DP & 2147483647U);
#line 1725
  REGISTER_READ(dev, intel_dp->output_reg);
#line 1726
  return;
}
}
#line 1728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static enum drm_connector_status cdv_dp_detect(struct gma_encoder *encoder ) 
{ 
  struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  int tmp ;
  long tmp___0 ;

  {
#line 1730
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1733
  status = 2;
#line 1734
  tmp = cdv_intel_dp_aux_native_read(encoder, 0, (uint8_t *)(& intel_dp->dpcd), 4);
#line 1734
  if (tmp == 4) {
#line 1737
    if ((unsigned int )intel_dp->dpcd[0] != 0U) {
#line 1738
      status = 1;
    } else {

    }
  } else {

  }
#line 1740
  if ((unsigned int )status == 1U) {
#line 1741
    tmp___0 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 1741
    if (tmp___0 != 0L) {
#line 1741
      drm_ut_debug_printk("cdv_dp_detect", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                          (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                          (int )intel_dp->dpcd[3]);
    } else {

    }
  } else {

  }
#line 1744
  return (status);
}
}
#line 1754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static enum drm_connector_status cdv_intel_dp_detect(struct drm_connector *connector ,
                                                     bool force ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  int edp ;
  bool tmp___0 ;

  {
#line 1756
  tmp = gma_attached_encoder(connector);
#line 1756
  encoder = tmp;
#line 1757
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1759
  edid = (struct edid *)0;
#line 1760
  tmp___0 = is_edp(encoder);
#line 1760
  edp = (int )tmp___0;
#line 1762
  intel_dp->has_audio = 0;
#line 1764
  if (edp != 0) {
#line 1765
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 1766
  status = cdv_dp_detect(encoder);
#line 1767
  if ((unsigned int )status != 1U) {
#line 1768
    if (edp != 0) {
#line 1769
      cdv_intel_edp_panel_vdd_off(encoder);
    } else {

    }
#line 1770
    return (status);
  } else {

  }
#line 1773
  if (intel_dp->force_audio != 0) {
#line 1774
    intel_dp->has_audio = intel_dp->force_audio > 0;
  } else {
#line 1776
    edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1777
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1778
      intel_dp->has_audio = drm_detect_monitor_audio(edid);
#line 1779
      kfree((void const   *)edid);
    } else {

    }
  }
#line 1782
  if (edp != 0) {
#line 1783
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 1785
  return (1);
}
}
#line 1788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_get_modes(struct drm_connector *connector ) 
{ 
  struct gma_encoder *intel_encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  int ret ;
  int edp ;
  bool tmp___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct drm_display_mode *mode ;
  bool tmp___1 ;

  {
#line 1790
  tmp = gma_attached_encoder(connector);
#line 1790
  intel_encoder = tmp;
#line 1791
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
#line 1792
  edid = (struct edid *)0;
#line 1793
  ret = 0;
#line 1794
  tmp___0 = is_edp(intel_encoder);
#line 1794
  edp = (int )tmp___0;
#line 1797
  edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1798
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1799
    drm_mode_connector_update_edid_property(connector, edid);
#line 1800
    ret = drm_add_edid_modes(connector, edid);
#line 1801
    kfree((void const   *)edid);
  } else {

  }
#line 1804
  tmp___1 = is_edp(intel_encoder);
#line 1804
  if ((int )tmp___1) {
#line 1805
    dev = connector->dev;
#line 1806
    dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1808
    cdv_intel_edp_panel_vdd_off(intel_encoder);
#line 1809
    if (ret != 0) {
#line 1810
      if (edp != 0 && (unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 1812
        __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 1812
        newmode = (struct drm_display_mode *)__mptr;
#line 1812
        goto ldv_40392;
        ldv_40391: ;
#line 1814
        if ((newmode->type & 8U) != 0U) {
#line 1815
          intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)newmode);
#line 1817
          goto ldv_40390;
        } else {

        }
#line 1812
        __mptr___0 = (struct list_head  const  *)newmode->head.next;
#line 1812
        newmode = (struct drm_display_mode *)__mptr___0;
        ldv_40392: ;
#line 1812
        if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
#line 1814
          goto ldv_40391;
        } else {

        }
        ldv_40390: ;
      } else {

      }
#line 1822
      return (ret);
    } else {

    }
#line 1824
    if ((unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1825
      intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
#line 1827
      if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1828
        (intel_dp->panel_fixed_mode)->type = (intel_dp->panel_fixed_mode)->type | 8U;
      } else {

      }
    } else {

    }
#line 1832
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1834
      mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)intel_dp->panel_fixed_mode);
#line 1835
      drm_mode_probed_add(connector, mode);
#line 1836
      return (1);
    } else {

    }
  } else {

  }
#line 1840
  return (ret);
}
}
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dp_detect_audio(struct drm_connector *connector ) 
{ 
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  bool has_audio ;
  int edp ;
  bool tmp___0 ;

  {
#line 1846
  tmp = gma_attached_encoder(connector);
#line 1846
  encoder = tmp;
#line 1847
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1849
  has_audio = 0;
#line 1850
  tmp___0 = is_edp(encoder);
#line 1850
  edp = (int )tmp___0;
#line 1852
  if (edp != 0) {
#line 1853
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
#line 1855
  edid = drm_get_edid(connector, & intel_dp->adapter);
#line 1856
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 1857
    has_audio = drm_detect_monitor_audio(edid);
#line 1858
    kfree((void const   *)edid);
  } else {

  }
#line 1860
  if (edp != 0) {
#line 1861
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
#line 1863
  return (has_audio);
}
}
#line 1867 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static int cdv_intel_dp_set_property(struct drm_connector *connector , struct drm_property *property ,
                                     uint64_t val ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;
  bool has_audio ;
  struct drm_crtc *crtc ;

  {
#line 1871
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
#line 1872
  tmp = gma_attached_encoder(connector);
#line 1872
  encoder = tmp;
#line 1873
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
#line 1876
  ret = drm_object_property_set_value(& connector->base, property, val);
#line 1877
  if (ret != 0) {
#line 1878
    return (ret);
  } else {

  }
#line 1880
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
#line 1881
    i = (int )val;
#line 1884
    if (intel_dp->force_audio == i) {
#line 1885
      return (0);
    } else {

    }
#line 1887
    intel_dp->force_audio = i;
#line 1889
    if (i == 0) {
#line 1890
      has_audio = cdv_intel_dp_detect_audio(connector);
    } else {
#line 1892
      has_audio = i > 0;
    }
#line 1894
    if ((int )intel_dp->has_audio == (int )has_audio) {
#line 1895
      return (0);
    } else {

    }
#line 1897
    intel_dp->has_audio = has_audio;
#line 1898
    goto done;
  } else {

  }
#line 1901
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
#line 1902
    if ((uint64_t )(intel_dp->color_range != 0U) == val) {
#line 1903
      return (0);
    } else {

    }
#line 1905
    intel_dp->color_range = val != 0ULL ? 256U : 0U;
#line 1906
    goto done;
  } else {

  }
#line 1909
  return (-22);
  done: ;
#line 1912
  if ((unsigned long )encoder->base.crtc != (unsigned long )((struct drm_crtc *)0)) {
#line 1913
    crtc = encoder->base.crtc;
#line 1914
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, (crtc->primary)->fb);
  } else {

  }
#line 1919
  return (0);
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_destroy(struct drm_connector *connector ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  bool tmp___0 ;

  {
#line 1925
  tmp = gma_attached_encoder(connector);
#line 1925
  gma_encoder = tmp;
#line 1926
  intel_dp = (struct cdv_intel_dp *)gma_encoder->dev_priv;
#line 1928
  tmp___0 = is_edp(gma_encoder);
#line 1928
  if ((int )tmp___0) {
#line 1930
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 1931
      kfree((void const   *)intel_dp->panel_fixed_mode);
#line 1932
      intel_dp->panel_fixed_mode = (struct drm_display_mode *)0;
    } else {

    }
  } else {

  }
#line 1935
  i2c_del_adapter(& intel_dp->adapter);
#line 1936
  drm_sysfs_connector_remove(connector);
#line 1937
  drm_connector_cleanup(connector);
#line 1938
  kfree((void const   *)connector);
#line 1939
  return;
}
}
#line 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_encoder_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 1943
  drm_encoder_cleanup(encoder);
#line 1944
  return;
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static struct drm_encoder_helper_funcs  const  cdv_intel_dp_helper_funcs  = 
#line 1946
     {& cdv_intel_dp_dpms, 0, 0, & cdv_intel_dp_mode_fixup, & cdv_intel_dp_prepare,
    & cdv_intel_dp_commit, & cdv_intel_dp_mode_set, 0, 0, 0};
#line 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static struct drm_connector_funcs  const  cdv_intel_dp_connector_funcs  = 
#line 1954
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_dp_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_dp_set_property, & cdv_intel_dp_destroy, 0};
#line 1962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static struct drm_connector_helper_funcs  const  cdv_intel_dp_connector_helper_funcs  =    {& cdv_intel_dp_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& cdv_intel_dp_mode_valid),
    & gma_best_encoder};
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static struct drm_encoder_funcs  const  cdv_intel_dp_enc_funcs  =    {0, & cdv_intel_dp_encoder_destroy};
#line 1973 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_intel_dp_add_properties(struct drm_connector *connector ) 
{ 


  {
#line 1975
  cdv_intel_attach_force_audio_property(connector);
#line 1976
  cdv_intel_attach_broadcast_rgb_property(connector);
#line 1977
  return;
}
}
#line 1980 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static bool cdv_intel_dpc_is_edp(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct child_device_config *p_child ;
  int i ;

  {
#line 1982
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1986
  if (dev_priv->child_dev_num == 0) {
#line 1987
    return (0);
  } else {

  }
#line 1989
  i = 0;
#line 1989
  goto ldv_40437;
  ldv_40436: 
#line 1990
  p_child = dev_priv->child_dev + (unsigned long )i;
#line 1992
  if ((unsigned int )p_child->dvo_port == 8U && (unsigned int )p_child->device_type == 30918U) {
#line 1994
    return (1);
  } else {

  }
#line 1989
  i = i + 1;
  ldv_40437: ;
#line 1989
  if (dev_priv->child_dev_num > i) {
#line 1991
    goto ldv_40436;
  } else {

  }

#line 1996
  return (0);
}
}
#line 2004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
static void cdv_disable_intel_clock_gating(struct drm_device *dev ) 
{ 
  u32 reg_value ;

  {
#line 2007
  reg_value = REGISTER_READ(dev, 25088U);
#line 2009
  reg_value = reg_value | 1124083776U;
#line 2016
  REGISTER_WRITE(dev, 25088U, reg_value);
#line 2018
  __const_udelay(2147500UL);
#line 2020
  return;
}
}
#line 2022 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct cdv_intel_dp *intel_dp ;
  char const   *name ;
  int type ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  int ret ;
  struct edp_power_seq cur ;
  u32 pp_on ;
  u32 pp_off ;
  u32 pp_div ;
  u32 pwm_ctrl ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;

  {
#line 2029
  name = (char const   *)0;
#line 2030
  type = 10;
#line 2032
  tmp = kzalloc(152UL, 208U);
#line 2032
  gma_encoder = (struct gma_encoder *)tmp;
#line 2033
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 2034
    return;
  } else {

  }
#line 2035
  tmp___0 = kzalloc(728UL, 208U);
#line 2035
  gma_connector = (struct gma_connector *)tmp___0;
#line 2036
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 2037
    goto err_connector;
  } else {

  }
#line 2038
  tmp___1 = kzalloc(2048UL, 208U);
#line 2038
  intel_dp = (struct cdv_intel_dp *)tmp___1;
#line 2039
  if ((unsigned long )intel_dp == (unsigned long )((struct cdv_intel_dp *)0)) {
#line 2040
    goto err_priv;
  } else {

  }
#line 2042
  if (output_reg == 410112) {
#line 2042
    tmp___2 = cdv_intel_dpc_is_edp(dev);
#line 2042
    if ((int )tmp___2) {
#line 2043
      type = 14;
    } else {

    }
  } else {

  }
#line 2045
  connector = & gma_connector->base;
#line 2046
  encoder = & gma_encoder->base;
#line 2048
  drm_connector_init(dev, connector, & cdv_intel_dp_connector_funcs, type);
#line 2049
  drm_encoder_init(dev, encoder, & cdv_intel_dp_enc_funcs, 2);
#line 2051
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 2053
  if (type == 10) {
#line 2054
    gma_encoder->type = 9;
  } else {
#line 2056
    gma_encoder->type = 10;
  }
#line 2059
  gma_encoder->dev_priv = (void *)intel_dp;
#line 2060
  intel_dp->encoder = gma_encoder;
#line 2061
  intel_dp->output_reg = (uint32_t )output_reg;
#line 2063
  drm_encoder_helper_add(encoder, & cdv_intel_dp_helper_funcs);
#line 2064
  drm_connector_helper_add(connector, & cdv_intel_dp_connector_helper_funcs);
#line 2066
  connector->polled = 1U;
#line 2067
  connector->interlace_allowed = 0;
#line 2068
  connector->doublescan_allowed = 0;
#line 2070
  drm_sysfs_connector_add(connector);
#line 2073
  switch (output_reg) {
  case 409856: 
#line 2075
  name = "DPDDC-B";
#line 2076
  gma_encoder->ddi_select = 32769U;
#line 2077
  goto ldv_40458;
  case 410112: 
#line 2079
  name = "DPDDC-C";
#line 2080
  gma_encoder->ddi_select = 32770U;
#line 2081
  goto ldv_40458;
  }
  ldv_40458: 
#line 2084
  cdv_disable_intel_clock_gating(dev);
#line 2086
  cdv_intel_dp_i2c_init(gma_connector, gma_encoder, name);
#line 2088
  cdv_intel_dp_add_properties(connector);
#line 2090
  tmp___7 = is_edp(gma_encoder);
#line 2090
  if ((int )tmp___7) {
#line 2096
    pp_on = REGISTER_READ(dev, 397828U);
#line 2097
    pp_on = pp_on & 65535U;
#line 2098
    pp_on = pp_on | 2882338816U;
#line 2100
    REGISTER_WRITE(dev, 397828U, pp_on);
#line 2102
    pwm_ctrl = REGISTER_READ(dev, 397904U);
#line 2103
    pwm_ctrl = pwm_ctrl | 536870912U;
#line 2104
    REGISTER_WRITE(dev, 397904U, pwm_ctrl);
#line 2106
    pp_on = REGISTER_READ(dev, 397832U);
#line 2107
    pp_off = REGISTER_READ(dev, 397836U);
#line 2108
    pp_div = REGISTER_READ(dev, 397840U);
#line 2111
    cur.t1_t3 = (u16 )((pp_on & 536805376U) >> 16);
#line 2114
    cur.t8 = (unsigned int )((u16 )pp_on) & 8191U;
#line 2117
    cur.t9 = (unsigned int )((u16 )pp_off) & 8191U;
#line 2120
    cur.t10 = (u16 )((pp_off & 536805376U) >> 16);
#line 2123
    cur.t11_t12 = (unsigned int )((u16 )pp_div) & 31U;
#line 2126
    tmp___3 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2126
    if (tmp___3 != 0L) {
#line 2126
      drm_ut_debug_printk("cdv_intel_dp_init", "cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                          (int )cur.t1_t3, (int )cur.t8, (int )cur.t9, (int )cur.t10,
                          (int )cur.t11_t12);
    } else {

    }
#line 2130
    intel_dp->panel_power_up_delay = (int )((unsigned int )cur.t1_t3 / 10U);
#line 2131
    intel_dp->backlight_on_delay = (int )((unsigned int )cur.t8 / 10U);
#line 2132
    intel_dp->backlight_off_delay = (int )((unsigned int )cur.t9 / 10U);
#line 2133
    intel_dp->panel_power_down_delay = (int )((unsigned int )cur.t10 / 10U);
#line 2134
    intel_dp->panel_power_cycle_delay = ((int )cur.t11_t12 + -1) * 100;
#line 2136
    tmp___4 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2136
    if (tmp___4 != 0L) {
#line 2136
      drm_ut_debug_printk("cdv_intel_dp_init", "panel power up delay %d, power down delay %d, power cycle delay %d\n",
                          intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,
                          intel_dp->panel_power_cycle_delay);
    } else {

    }
#line 2140
    tmp___5 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2140
    if (tmp___5 != 0L) {
#line 2140
      drm_ut_debug_printk("cdv_intel_dp_init", "backlight on delay %d, off delay %d\n",
                          intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);
    } else {

    }
#line 2144
    cdv_intel_edp_panel_vdd_on(gma_encoder);
#line 2145
    ret = cdv_intel_dp_aux_native_read(gma_encoder, 0, (uint8_t *)(& intel_dp->dpcd),
                                       4);
#line 2148
    cdv_intel_edp_panel_vdd_off(gma_encoder);
#line 2149
    if (ret == 0) {
#line 2151
      printk("\016[drm] failed to retrieve link info, disabling eDP\n");
#line 2152
      cdv_intel_dp_encoder_destroy(encoder);
#line 2153
      cdv_intel_dp_destroy(connector);
#line 2154
      goto err_priv;
    } else {
#line 2156
      tmp___6 = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 2156
      if (tmp___6 != 0L) {
#line 2156
        drm_ut_debug_printk("cdv_intel_dp_init", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                            (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                            (int )intel_dp->dpcd[3]);
      } else {

      }
    }
  } else {

  }
#line 2166
  return;
  err_priv: 
#line 2169
  kfree((void const   *)gma_connector);
  err_connector: 
#line 2171
  kfree((void const   *)gma_encoder);
#line 2172
  return;
}
}
#line 2174
extern int ldv_probe_14(void) ;
#line 2175
extern int ldv_probe_12(void) ;
#line 2178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_connector_funcs_14(void) 
{ 
  void *tmp ;

  {
#line 2179
  tmp = ldv_zalloc(720UL);
#line 2179
  cdv_intel_dp_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 2180
  return;
}
}
#line 2182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_15(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2183
  tmp = ldv_zalloc(96UL);
#line 2183
  cdv_intel_dp_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 2184
  tmp___0 = ldv_zalloc(208UL);
#line 2184
  cdv_intel_dp_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 2185
  return;
}
}
#line 2187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_13(void) 
{ 
  void *tmp ;

  {
#line 2188
  tmp = ldv_zalloc(720UL);
#line 2188
  cdv_intel_dp_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 2189
  return;
}
}
#line 2191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  struct drm_display_mode *ldvarg120 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2192
  tmp = ldv_zalloc(208UL);
#line 2192
  ldvarg120 = (struct drm_display_mode *)tmp;
#line 2194
  tmp___0 = __VERIFIER_nondet_int();
#line 2194
  switch (tmp___0) {
  case 0: ;
#line 2197
  if (ldv_state_variable_13 == 1) {
#line 2199
    cdv_intel_dp_get_modes(cdv_intel_dp_connector_helper_funcs_group0);
#line 2201
    ldv_state_variable_13 = 1;
  } else {

  }
#line 2204
  goto ldv_40485;
  case 1: ;
#line 2207
  if (ldv_state_variable_13 == 1) {
#line 2209
    cdv_intel_dp_mode_valid(cdv_intel_dp_connector_helper_funcs_group0, ldvarg120);
#line 2211
    ldv_state_variable_13 = 1;
  } else {

  }
#line 2214
  goto ldv_40485;
  case 2: ;
#line 2217
  if (ldv_state_variable_13 == 1) {
#line 2219
    gma_best_encoder(cdv_intel_dp_connector_helper_funcs_group0);
#line 2221
    ldv_state_variable_13 = 1;
  } else {

  }
#line 2224
  goto ldv_40485;
  default: 
#line 2225
  ldv_stop();
  }
  ldv_40485: ;
#line 2229
  return;
}
}
#line 2231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  struct drm_encoder *ldvarg152 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2232
  tmp = ldv_zalloc(96UL);
#line 2232
  ldvarg152 = (struct drm_encoder *)tmp;
#line 2234
  tmp___0 = __VERIFIER_nondet_int();
#line 2234
  switch (tmp___0) {
  case 0: ;
#line 2237
  if (ldv_state_variable_12 == 2) {
#line 2239
    cdv_intel_dp_encoder_destroy(ldvarg152);
#line 2241
    ldv_state_variable_12 = 1;
#line 2242
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2245
  goto ldv_40494;
  case 1: ;
#line 2248
  if (ldv_state_variable_12 == 1) {
#line 2250
    ldv_probe_12();
#line 2252
    ldv_state_variable_12 = 2;
#line 2253
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2256
  goto ldv_40494;
  default: 
#line 2257
  ldv_stop();
  }
  ldv_40494: ;
#line 2261
  return;
}
}
#line 2263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  struct drm_display_mode *ldvarg160 ;
  void *tmp ;
  struct drm_display_mode *ldvarg161 ;
  void *tmp___0 ;
  int ldvarg162 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2264
  tmp = ldv_zalloc(208UL);
#line 2264
  ldvarg160 = (struct drm_display_mode *)tmp;
#line 2265
  tmp___0 = ldv_zalloc(208UL);
#line 2265
  ldvarg161 = (struct drm_display_mode *)tmp___0;
#line 2266
  tmp___1 = __VERIFIER_nondet_int();
#line 2266
  ldvarg162 = tmp___1;
#line 2268
  tmp___2 = __VERIFIER_nondet_int();
#line 2268
  switch (tmp___2) {
  case 0: ;
#line 2271
  if (ldv_state_variable_15 == 1) {
#line 2273
    cdv_intel_dp_dpms(cdv_intel_dp_helper_funcs_group0, ldvarg162);
#line 2275
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2278
  goto ldv_40504;
  case 1: ;
#line 2281
  if (ldv_state_variable_15 == 1) {
#line 2283
    cdv_intel_dp_mode_fixup(cdv_intel_dp_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg161,
                            cdv_intel_dp_helper_funcs_group1);
#line 2285
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2288
  goto ldv_40504;
  case 2: ;
#line 2291
  if (ldv_state_variable_15 == 1) {
#line 2293
    cdv_intel_dp_commit(cdv_intel_dp_helper_funcs_group0);
#line 2295
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2298
  goto ldv_40504;
  case 3: ;
#line 2301
  if (ldv_state_variable_15 == 1) {
#line 2303
    cdv_intel_dp_mode_set(cdv_intel_dp_helper_funcs_group0, cdv_intel_dp_helper_funcs_group1,
                          ldvarg160);
#line 2305
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2308
  goto ldv_40504;
  case 4: ;
#line 2311
  if (ldv_state_variable_15 == 1) {
#line 2313
    cdv_intel_dp_prepare(cdv_intel_dp_helper_funcs_group0);
#line 2315
    ldv_state_variable_15 = 1;
  } else {

  }
#line 2318
  goto ldv_40504;
  default: 
#line 2319
  ldv_stop();
  }
  ldv_40504: ;
#line 2323
  return;
}
}
#line 2325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  uint64_t ldvarg62 ;
  bool ldvarg64 ;
  uint32_t ldvarg60 ;
  uint32_t ldvarg61 ;
  struct drm_property *ldvarg63 ;
  void *tmp ;
  int ldvarg65 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2330
  tmp = ldv_zalloc(104UL);
#line 2330
  ldvarg63 = (struct drm_property *)tmp;
#line 2331
  tmp___0 = __VERIFIER_nondet_int();
#line 2331
  ldvarg65 = tmp___0;
#line 2326
  memset((void *)(& ldvarg62), 0, 8UL);
#line 2327
  memset((void *)(& ldvarg64), 0, 1UL);
#line 2328
  memset((void *)(& ldvarg60), 0, 4UL);
#line 2329
  memset((void *)(& ldvarg61), 0, 4UL);
#line 2333
  tmp___1 = __VERIFIER_nondet_int();
#line 2333
  switch (tmp___1) {
  case 0: ;
#line 2336
  if (ldv_state_variable_14 == 1) {
#line 2338
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg65);
#line 2340
    ldv_state_variable_14 = 1;
  } else {

  }
#line 2343
  if (ldv_state_variable_14 == 2) {
#line 2345
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg65);
#line 2347
    ldv_state_variable_14 = 2;
  } else {

  }
#line 2350
  goto ldv_40520;
  case 1: ;
#line 2353
  if (ldv_state_variable_14 == 1) {
#line 2355
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg64);
#line 2357
    ldv_state_variable_14 = 1;
  } else {

  }
#line 2360
  if (ldv_state_variable_14 == 2) {
#line 2362
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg64);
#line 2364
    ldv_state_variable_14 = 2;
  } else {

  }
#line 2367
  goto ldv_40520;
  case 2: ;
#line 2370
  if (ldv_state_variable_14 == 1) {
#line 2372
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg63, ldvarg62);
#line 2374
    ldv_state_variable_14 = 1;
  } else {

  }
#line 2377
  if (ldv_state_variable_14 == 2) {
#line 2379
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg63, ldvarg62);
#line 2381
    ldv_state_variable_14 = 2;
  } else {

  }
#line 2384
  goto ldv_40520;
  case 3: ;
#line 2387
  if (ldv_state_variable_14 == 2) {
#line 2389
    cdv_intel_dp_destroy(cdv_intel_dp_connector_funcs_group0);
#line 2391
    ldv_state_variable_14 = 1;
#line 2392
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2395
  goto ldv_40520;
  case 4: ;
#line 2398
  if (ldv_state_variable_14 == 1) {
#line 2400
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg61,
                                            ldvarg60);
#line 2402
    ldv_state_variable_14 = 1;
  } else {

  }
#line 2405
  if (ldv_state_variable_14 == 2) {
#line 2407
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg61,
                                            ldvarg60);
#line 2409
    ldv_state_variable_14 = 2;
  } else {

  }
#line 2412
  goto ldv_40520;
  case 5: ;
#line 2415
  if (ldv_state_variable_14 == 1) {
#line 2417
    ldv_probe_14();
#line 2419
    ldv_state_variable_14 = 2;
#line 2420
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2423
  goto ldv_40520;
  default: 
#line 2424
  ldv_stop();
  }
  ldv_40520: ;
#line 2428
  return;
}
}
#line 2556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/cdv_intel_dp.o.c.prepared"
void *ldv_kmem_cache_alloc_580(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2559
  ldv_check_alloc_flags(flags);
#line 2561
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2562
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_intel_drv.h"
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
void oaktrail_hdmi_setup(struct drm_device *dev ) ;
#line 246
void oaktrail_hdmi_teardown(struct drm_device *dev ) ;
#line 249
void oaktrail_hdmi_save(struct drm_device *dev ) ;
#line 250
void oaktrail_hdmi_restore(struct drm_device *dev ) ;
#line 251
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
#line 725 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/psb_drv.h"
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_output_init(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 256
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 257
  if (dev_priv->iLVDS_enable != 0U) {
#line 258
    oaktrail_lvds_init(dev, & dev_priv->mode_dev);
  } else {
#line 260
    dev_err((struct device  const  *)dev->dev, "DSI is not supported\n");
  }
#line 261
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 262
    oaktrail_hdmi_init(dev, & dev_priv->mode_dev);
  } else {

  }
#line 264
  psb_intel_sdvo_init(dev, 397632);
#line 266
  return (0);
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_save_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  int i ;
  u32 pp_stat ;

  {
#line 411
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 412
  regs = & dev_priv->regs;
#line 413
  p = (struct psb_pipe *)(& regs->pipe);
#line 418
  regs->ldv_40416.psb.saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
#line 419
  regs->ldv_40416.psb.saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
#line 420
  regs->ldv_40416.psb.saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
#line 421
  regs->ldv_40416.psb.saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
#line 422
  regs->ldv_40416.psb.saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
#line 423
  regs->ldv_40416.psb.saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
#line 424
  regs->ldv_40416.psb.saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
#line 425
  regs->ldv_40416.psb.saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
#line 428
  p->conf = ioread32((void *)dev_priv->vdc_reg + 458760U);
#line 429
  p->src = ioread32((void *)dev_priv->vdc_reg + 393244U);
#line 430
  p->fp0 = ioread32((void *)dev_priv->vdc_reg + 61504U);
#line 431
  p->fp1 = ioread32((void *)dev_priv->vdc_reg + 61508U);
#line 432
  p->dpll = ioread32((void *)dev_priv->vdc_reg + 61460U);
#line 433
  p->htotal = ioread32((void *)dev_priv->vdc_reg + 393216U);
#line 434
  p->hblank = ioread32((void *)dev_priv->vdc_reg + 393220U);
#line 435
  p->hsync = ioread32((void *)dev_priv->vdc_reg + 393224U);
#line 436
  p->vtotal = ioread32((void *)dev_priv->vdc_reg + 393228U);
#line 437
  p->vblank = ioread32((void *)dev_priv->vdc_reg + 393232U);
#line 438
  p->vsync = ioread32((void *)dev_priv->vdc_reg + 393236U);
#line 439
  regs->ldv_40416.psb.saveBCLRPAT_A = ioread32((void *)dev_priv->vdc_reg + 393248U);
#line 440
  p->cntr = ioread32((void *)dev_priv->vdc_reg + 459136U);
#line 441
  p->stride = ioread32((void *)dev_priv->vdc_reg + 459144U);
#line 442
  p->addr = ioread32((void *)dev_priv->vdc_reg + 459140U);
#line 443
  p->surf = ioread32((void *)dev_priv->vdc_reg + 459164U);
#line 444
  p->linoff = ioread32((void *)dev_priv->vdc_reg + 459140U);
#line 445
  p->tileoff = ioread32((void *)dev_priv->vdc_reg + 459172U);
#line 448
  regs->ldv_40416.psb.saveDSPACURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458880U);
#line 449
  regs->ldv_40416.psb.saveDSPACURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458884U);
#line 450
  regs->ldv_40416.psb.saveDSPACURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458888U);
#line 453
  i = 0;
#line 453
  goto ldv_40025;
  ldv_40024: 
#line 454
  p->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
#line 453
  i = i + 1;
  ldv_40025: ;
#line 453
  if (i <= 255) {
#line 455
    goto ldv_40024;
  } else {

  }

#line 456
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 457
    oaktrail_hdmi_save(dev);
  } else {

  }
#line 460
  regs->ldv_40416.psb.savePERF_MODE = ioread32((void *)dev_priv->vdc_reg + 8436U);
#line 463
  regs->ldv_40416.psb.savePP_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397828U);
#line 464
  regs->ldv_40416.psb.savePFIT_PGM_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397876U);
#line 465
  regs->ldv_40416.psb.savePFIT_AUTO_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397880U);
#line 466
  regs->saveBLC_PWM_CTL = ioread32((void *)dev_priv->vdc_reg + 397908U);
#line 467
  regs->saveBLC_PWM_CTL2 = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 468
  regs->ldv_40416.psb.saveLVDS = ioread32((void *)dev_priv->vdc_reg + 397696U);
#line 469
  regs->ldv_40416.psb.savePFIT_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397872U);
#line 470
  regs->ldv_40416.psb.savePP_ON_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397832U);
#line 471
  regs->ldv_40416.psb.savePP_OFF_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397836U);
#line 472
  regs->ldv_40416.psb.savePP_DIVISOR = ioread32((void *)dev_priv->vdc_reg + 397840U);
#line 475
  regs->ldv_40416.psb.saveOV_OVADD = ioread32((void *)dev_priv->vdc_reg + 196608U);
#line 476
  regs->ldv_40416.psb.saveOV_OGAMC0 = ioread32((void *)dev_priv->vdc_reg + 196644U);
#line 477
  regs->ldv_40416.psb.saveOV_OGAMC1 = ioread32((void *)dev_priv->vdc_reg + 196640U);
#line 478
  regs->ldv_40416.psb.saveOV_OGAMC2 = ioread32((void *)dev_priv->vdc_reg + 196636U);
#line 479
  regs->ldv_40416.psb.saveOV_OGAMC3 = ioread32((void *)dev_priv->vdc_reg + 196632U);
#line 480
  regs->ldv_40416.psb.saveOV_OGAMC4 = ioread32((void *)dev_priv->vdc_reg + 196628U);
#line 481
  regs->ldv_40416.psb.saveOV_OGAMC5 = ioread32((void *)dev_priv->vdc_reg + 196624U);
#line 484
  regs->ldv_40416.psb.saveHISTOGRAM_INT_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397928U);
#line 486
  regs->ldv_40416.psb.saveHISTOGRAM_LOGIC_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397920U);
#line 488
  regs->ldv_40416.psb.savePWM_CONTROL_LOGIC = ioread32((void *)dev_priv->vdc_reg + 397904U);
#line 490
  if (dev_priv->iLVDS_enable != 0U) {
#line 492
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397828U);
    ldv_40027: 
#line 495
    pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 496
    if ((int )pp_stat < 0) {
#line 498
      goto ldv_40027;
    } else {

    }
#line 499
    iowrite32(1476395008U, (void *)dev_priv->vdc_reg + 459136U);
#line 501
    iowrite32(0U, (void *)dev_priv->vdc_reg + 459164U);
#line 504
    msleep(4U);
#line 507
    iowrite32(0U, (void *)dev_priv->vdc_reg + 458760U);
#line 509
    msleep(8U);
#line 512
    iowrite32(0U, (void *)dev_priv->vdc_reg + 61460U);
  } else {

  }
#line 514
  return (0);
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_restore_display_registers(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  u32 pp_stat ;
  int i ;

  {
#line 525
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 526
  regs = & dev_priv->regs;
#line 527
  p = (struct psb_pipe *)(& regs->pipe);
#line 532
  iowrite32(regs->ldv_40416.psb.saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
#line 533
  iowrite32(regs->ldv_40416.psb.saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
#line 534
  iowrite32(regs->ldv_40416.psb.saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
#line 535
  iowrite32(regs->ldv_40416.psb.saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
#line 536
  iowrite32(regs->ldv_40416.psb.saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
#line 537
  iowrite32(regs->ldv_40416.psb.saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
#line 538
  iowrite32(regs->ldv_40416.psb.saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
#line 539
  iowrite32(regs->ldv_40416.psb.saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
#line 542
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
#line 545
  iowrite32(p->fp0, (void *)dev_priv->vdc_reg + 61504U);
#line 546
  iowrite32(p->fp1, (void *)dev_priv->vdc_reg + 61508U);
#line 549
  iowrite32(p->dpll, (void *)dev_priv->vdc_reg + 61460U);
#line 550
  __const_udelay(644250UL);
#line 553
  iowrite32(p->htotal, (void *)dev_priv->vdc_reg + 393216U);
#line 554
  iowrite32(p->hblank, (void *)dev_priv->vdc_reg + 393220U);
#line 555
  iowrite32(p->hsync, (void *)dev_priv->vdc_reg + 393224U);
#line 556
  iowrite32(p->vtotal, (void *)dev_priv->vdc_reg + 393228U);
#line 557
  iowrite32(p->vblank, (void *)dev_priv->vdc_reg + 393232U);
#line 558
  iowrite32(p->vsync, (void *)dev_priv->vdc_reg + 393236U);
#line 559
  iowrite32(p->src, (void *)dev_priv->vdc_reg + 393244U);
#line 560
  iowrite32(regs->ldv_40416.psb.saveBCLRPAT_A, (void *)dev_priv->vdc_reg + 393248U);
#line 563
  iowrite32(regs->ldv_40416.psb.savePERF_MODE, (void *)dev_priv->vdc_reg + 8436U);
#line 566
  if (dev_priv->iLVDS_enable != 0U) {
#line 567
    iowrite32(p->conf, (void *)dev_priv->vdc_reg + 458760U);
  } else {

  }
#line 570
  iowrite32(p->linoff, (void *)dev_priv->vdc_reg + 459140U);
#line 571
  iowrite32(p->stride, (void *)dev_priv->vdc_reg + 459144U);
#line 572
  iowrite32(p->tileoff, (void *)dev_priv->vdc_reg + 459172U);
#line 575
  iowrite32(p->cntr, (void *)dev_priv->vdc_reg + 459136U);
#line 576
  iowrite32(p->surf, (void *)dev_priv->vdc_reg + 459164U);
#line 579
  iowrite32(regs->ldv_40416.psb.saveDSPACURSOR_CTRL, (void *)dev_priv->vdc_reg + 458880U);
#line 580
  iowrite32(regs->ldv_40416.psb.saveDSPACURSOR_POS, (void *)dev_priv->vdc_reg + 458888U);
#line 581
  iowrite32(regs->ldv_40416.psb.saveDSPACURSOR_BASE, (void *)dev_priv->vdc_reg + 458884U);
#line 584
  i = 0;
#line 584
  goto ldv_40038;
  ldv_40037: 
#line 585
  iowrite32(p->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
#line 584
  i = i + 1;
  ldv_40038: ;
#line 584
  if (i <= 255) {
#line 586
    goto ldv_40037;
  } else {

  }

#line 587
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 588
    oaktrail_hdmi_restore(dev);
  } else {

  }
#line 590
  if (dev_priv->iLVDS_enable != 0U) {
#line 591
    iowrite32(regs->saveBLC_PWM_CTL2, (void *)dev_priv->vdc_reg + 397904U);
#line 592
    iowrite32(regs->ldv_40416.psb.saveLVDS, (void *)dev_priv->vdc_reg + 397696U);
#line 593
    iowrite32(regs->ldv_40416.psb.savePFIT_CONTROL, (void *)dev_priv->vdc_reg + 397872U);
#line 594
    iowrite32(regs->ldv_40416.psb.savePFIT_PGM_RATIOS, (void *)dev_priv->vdc_reg + 397876U);
#line 595
    iowrite32(regs->ldv_40416.psb.savePFIT_AUTO_RATIOS, (void *)dev_priv->vdc_reg + 397880U);
#line 596
    iowrite32(regs->saveBLC_PWM_CTL, (void *)dev_priv->vdc_reg + 397908U);
#line 597
    iowrite32(regs->ldv_40416.psb.savePP_ON_DELAYS, (void *)dev_priv->vdc_reg + 397832U);
#line 598
    iowrite32(regs->ldv_40416.psb.savePP_OFF_DELAYS, (void *)dev_priv->vdc_reg + 397836U);
#line 599
    iowrite32(regs->ldv_40416.psb.savePP_DIVISOR, (void *)dev_priv->vdc_reg + 397840U);
#line 600
    iowrite32(regs->ldv_40416.psb.savePP_CONTROL, (void *)dev_priv->vdc_reg + 397828U);
  } else {

  }
  ldv_40040: 
#line 605
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 606
  if ((pp_stat & 134217728U) != 0U) {
#line 608
    goto ldv_40040;
  } else {

  }

  ldv_40042: 
#line 610
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
#line 611
  if ((pp_stat & 268435456U) != 0U) {
#line 613
    goto ldv_40042;
  } else {

  }
#line 614
  iowrite32(regs->ldv_40416.psb.saveOV_OVADD, (void *)dev_priv->vdc_reg + 196608U);
#line 615
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC0, (void *)dev_priv->vdc_reg + 196644U);
#line 616
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC1, (void *)dev_priv->vdc_reg + 196640U);
#line 617
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC2, (void *)dev_priv->vdc_reg + 196636U);
#line 618
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC3, (void *)dev_priv->vdc_reg + 196632U);
#line 619
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC4, (void *)dev_priv->vdc_reg + 196628U);
#line 620
  iowrite32(regs->ldv_40416.psb.saveOV_OGAMC5, (void *)dev_priv->vdc_reg + 196624U);
#line 623
  iowrite32(regs->ldv_40416.psb.saveHISTOGRAM_INT_CONTROL_REG, (void *)dev_priv->vdc_reg + 397928U);
#line 625
  iowrite32(regs->ldv_40416.psb.saveHISTOGRAM_LOGIC_CONTROL_REG, (void *)dev_priv->vdc_reg + 397920U);
#line 627
  iowrite32(regs->ldv_40416.psb.savePWM_CONTROL_LOGIC, (void *)dev_priv->vdc_reg + 397904U);
#line 629
  return (0);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_power_down(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;

  {
#line 640
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 644
  pwr_mask = 12U;
#line 645
  outl(pwr_mask, (int )(dev_priv->ospm_base + 32U));
  ldv_40051: 
#line 648
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
#line 649
  if ((pwr_sts & pwr_mask) == pwr_mask) {
#line 650
    goto ldv_40050;
  } else {
#line 652
    __const_udelay(42950UL);
  }
#line 653
  goto ldv_40051;
  ldv_40050: ;
#line 654
  return (0);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_power_up(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  u32 pwr_cnt ;

  {
#line 664
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 665
  pwr_mask = 12U;
#line 668
  pwr_cnt = inl((int )(dev_priv->ospm_base + 32U));
#line 669
  pwr_cnt = ~ pwr_mask & pwr_cnt;
#line 670
  outl(pwr_cnt, (int )(dev_priv->ospm_base + 32U));
  ldv_40060: 
#line 673
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
#line 674
  if ((pwr_sts & pwr_mask) == 0U) {
#line 675
    goto ldv_40059;
  } else {
#line 677
    __const_udelay(42950UL);
  }
#line 678
  goto ldv_40060;
  ldv_40059: ;
#line 679
  return (0);
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static struct psb_offset  const  oaktrail_regmap[2U]  = {      {61504U, 61508U, 459136U, 458760U, 393244U, 61460U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459164U, 459164U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static int oaktrail_chip_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  int ret ;
  int tmp ;

  {
#line 736
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 739
  tmp = pci_enable_msi_exact(dev->pdev, 1);
#line 739
  if (tmp != 0) {
#line 740
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
#line 742
  dev_priv->regmap = (struct psb_offset  const  *)(& oaktrail_regmap);
#line 744
  ret = mid_chip_setup(dev);
#line 745
  if (ret < 0) {
#line 746
    return (ret);
  } else {

  }
#line 747
  if (! dev_priv->has_gct) {
#line 749
    psb_intel_opregion_init(dev);
#line 750
    psb_intel_init_bios(dev);
  } else {

  }
#line 752
  gma_intel_setup_gmbus(dev);
#line 753
  oaktrail_hdmi_setup(dev);
#line 754
  return (0);
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
static void oaktrail_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;

  {
#line 759
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 761
  gma_intel_teardown_gmbus(dev);
#line 762
  oaktrail_hdmi_teardown(dev);
#line 763
  if (! dev_priv->has_gct) {
#line 764
    psb_intel_destroy_bios(dev);
  } else {

  }
#line 765
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
struct psb_ops  const  oaktrail_chip_ops  = 
#line 767
     {"Oaktrail", 1U, 2, 2, 524288, 2, 1, 2, 0, & oaktrail_helper_funcs, & psb_intel_crtc_funcs,
    0, & oaktrail_chip_setup, & oaktrail_teardown, 0, & oaktrail_output_init, 0, 0,
    0, & oaktrail_save_display_registers, & oaktrail_restore_display_registers, & oaktrail_power_up,
    & oaktrail_power_down, 0, 0, 0, 1};
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_initialize_psb_ops_11(void) 
{ 
  void *tmp ;

  {
#line 799
  tmp = ldv_zalloc(2992UL);
#line 799
  oaktrail_chip_ops_group0 = (struct drm_device *)tmp;
#line 800
  return;
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  int tmp ;

  {
#line 804
  tmp = __VERIFIER_nondet_int();
#line 804
  switch (tmp) {
  case 0: ;
#line 807
  if (ldv_state_variable_11 == 1) {
#line 809
    oaktrail_teardown(oaktrail_chip_ops_group0);
#line 811
    ldv_state_variable_11 = 1;
  } else {

  }
#line 814
  goto ldv_40079;
  case 1: ;
#line 817
  if (ldv_state_variable_11 == 1) {
#line 819
    oaktrail_chip_setup(oaktrail_chip_ops_group0);
#line 821
    ldv_state_variable_11 = 1;
  } else {

  }
#line 824
  goto ldv_40079;
  case 2: ;
#line 827
  if (ldv_state_variable_11 == 1) {
#line 829
    oaktrail_save_display_registers(oaktrail_chip_ops_group0);
#line 831
    ldv_state_variable_11 = 1;
  } else {

  }
#line 834
  goto ldv_40079;
  case 3: ;
#line 837
  if (ldv_state_variable_11 == 1) {
#line 839
    oaktrail_restore_display_registers(oaktrail_chip_ops_group0);
#line 841
    ldv_state_variable_11 = 1;
  } else {

  }
#line 844
  goto ldv_40079;
  case 4: ;
#line 847
  if (ldv_state_variable_11 == 1) {
#line 849
    oaktrail_power_down(oaktrail_chip_ops_group0);
#line 851
    ldv_state_variable_11 = 1;
  } else {

  }
#line 854
  goto ldv_40079;
  case 5: ;
#line 857
  if (ldv_state_variable_11 == 1) {
#line 859
    oaktrail_output_init(oaktrail_chip_ops_group0);
#line 861
    ldv_state_variable_11 = 1;
  } else {

  }
#line 864
  goto ldv_40079;
  case 6: ;
#line 867
  if (ldv_state_variable_11 == 1) {
#line 869
    oaktrail_power_up(oaktrail_chip_ops_group0);
#line 871
    ldv_state_variable_11 = 1;
  } else {

  }
#line 874
  goto ldv_40079;
  default: 
#line 875
  ldv_stop();
  }
  ldv_40079: ;
#line 879
  return;
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_device.o.c.prepared"
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1010
  ldv_check_alloc_flags(flags);
#line 1012
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1013
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_620(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) ;
#line 255
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) ;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static bool mrst_lvds_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 270
static bool mrst_sdvo_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) ;
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static struct gma_limit_t  const  mrst_limits[4U]  = {      {{19750, 120000}, {0, 0}, {0, 0}, {20, 34}, {0, 0}, {0, 0}, {0, 0}, {2, 8}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{19750, 120000}, {0, 0}, {0, 0}, {12, 20}, {0, 0}, {0, 0}, {0, 0}, {2, 7}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{19750, 120000}, {0, 0}, {0, 0}, {10, 17}, {0, 0}, {0, 0}, {0, 0}, {2, 8}, {0,
                                                                                  0,
                                                                                  0},
      & mrst_lvds_find_best_pll}, 
        {{0, 0}, {1400000, 2800000}, {3, 7}, {80, 137}, {0, 0}, {0, 0}, {0, 0}, {1, 2},
      {200000, 10, 10}, & mrst_sdvo_find_best_pll}};
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static u32 const   oaktrail_m_converts[26U]  = 
#line 304
  {      43U,      21U,      42U,      53U, 
        26U,      13U,      38U,      51U, 
        25U,      44U,      54U,      59U, 
        29U,      46U,      55U,      27U, 
        45U,      22U,      11U,      37U, 
        18U,      9U,      36U,      50U, 
        57U,      28U};
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static struct gma_limit_t  const  *mrst_limit(struct drm_crtc *crtc , int refclk ) 
{ 
  struct gma_limit_t  const  *limit ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 313
  limit = (struct gma_limit_t  const  *)0;
#line 314
  dev = crtc->dev;
#line 315
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 317
  tmp___0 = gma_pipe_has_type(crtc, 4);
#line 317
  if ((int )tmp___0) {
#line 317
    goto _L;
  } else {
#line 317
    tmp___1 = gma_pipe_has_type(crtc, 7);
#line 317
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
#line 319
      switch (dev_priv->core_freq) {
      case 100U: 
#line 321
      limit = (struct gma_limit_t  const  *)(& mrst_limits);
#line 322
      goto ldv_39861;
      case 166U: 
#line 324
      limit = (struct gma_limit_t  const  *)(& mrst_limits) + 1UL;
#line 325
      goto ldv_39861;
      case 200U: 
#line 327
      limit = (struct gma_limit_t  const  *)(& mrst_limits) + 2UL;
#line 328
      goto ldv_39861;
      }
      ldv_39861: ;
    } else {
#line 330
      tmp = gma_pipe_has_type(crtc, 3);
#line 330
      if ((int )tmp) {
#line 331
        limit = (struct gma_limit_t  const  *)(& mrst_limits) + 3UL;
      } else {
#line 333
        limit = (struct gma_limit_t  const  *)0;
#line 334
        dev_err((struct device  const  *)dev->dev, "mrst_limit Wrong display type.\n");
      }
    }
  }
#line 337
  return (limit);
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static void mrst_lvds_clock(int refclk , struct gma_clock_t *clock ) 
{ 


  {
#line 343
  clock->dot = (clock->m * refclk) / (clock->p1 * 14);
#line 344
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static void mrst_print_pll(struct gma_clock_t *clock ) 
{ 
  long tmp ;

  {
#line 348
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 348
  if (tmp != 0L) {
#line 348
    drm_ut_debug_printk("mrst_print_pll", "dotclock=%d,  m=%d, m1=%d, m2=%d, n=%d, p1=%d, p2=%d\n",
                        clock->dot, clock->m, clock->m1, clock->m2, clock->n, clock->p1,
                        clock->p2);
  } else {

  }
#line 349
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static bool mrst_sdvo_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_clock_t clock ;
  u32 target_vco ;
  u32 actual_freq ;
  s32 freq_error ;
  s32 min_error ;

  {
#line 359
  min_error = 100000;
#line 361
  memset((void *)best_clock, 0, 36UL);
#line 363
  clock.m = limit->m.min;
#line 363
  goto ldv_39893;
  ldv_39892: 
#line 364
  clock.n = limit->n.min;
#line 364
  goto ldv_39889;
  ldv_39888: 
#line 366
  clock.p1 = limit->p1.min;
#line 366
  goto ldv_39887;
  ldv_39886: 
#line 369
  clock.p = clock.p1 * (int )limit->p2.p2_slow;
#line 370
  target_vco = (u32 )(clock.p * target);
#line 373
  if ((u32 )limit->vco.max < target_vco) {
#line 374
    goto ldv_39884;
  } else {

  }
#line 376
  if ((u32 )limit->vco.min > target_vco) {
#line 377
    goto ldv_39885;
  } else {

  }
#line 379
  actual_freq = (u32 )((clock.m * refclk) / (clock.n * clock.p));
#line 381
  freq_error = (s32 )(10000U - (u32 )(target * 10000) / actual_freq);
#line 384
  if (- min_error > freq_error) {
#line 387
    goto ldv_39884;
  } else {

  }
#line 390
  if (freq_error < 0) {
#line 391
    freq_error = - freq_error;
  } else {

  }
#line 393
  if (freq_error < min_error) {
#line 394
    min_error = freq_error;
#line 395
    *best_clock = clock;
  } else {

  }
  ldv_39885: 
#line 367
  clock.p1 = clock.p1 + 1;
  ldv_39887: ;
#line 366
  if (clock.p1 <= (int )limit->p1.max) {
#line 369
    goto ldv_39886;
  } else {

  }
  ldv_39884: 
#line 365
  clock.n = clock.n + 1;
  ldv_39889: ;
#line 364
  if (clock.n <= (int )limit->n.max) {
#line 366
    goto ldv_39888;
  } else {

  }

#line 399
  if (min_error == 0) {
#line 400
    goto ldv_39891;
  } else {

  }
#line 363
  clock.m = clock.m + 1;
  ldv_39893: ;
#line 363
  if (clock.m <= (int )limit->m.max) {
#line 365
    goto ldv_39892;
  } else {

  }
  ldv_39891: ;
#line 403
  return (min_error == 0);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static bool mrst_lvds_find_best_pll(struct gma_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct gma_clock_t *best_clock ) 
{ 
  struct gma_clock_t clock ;
  int err ;
  int this_err ;
  long ret ;
  int __x___0 ;

  {
#line 415
  err = target;
#line 417
  memset((void *)best_clock, 0, 36UL);
#line 419
  clock.m = limit->m.min;
#line 419
  goto ldv_39912;
  ldv_39911: 
#line 420
  clock.p1 = limit->p1.min;
#line 420
  goto ldv_39909;
  ldv_39908: 
#line 424
  mrst_lvds_clock(refclk, & clock);
#line 426
  __x___0 = clock.dot - target;
#line 426
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 426
  this_err = (int )ret;
#line 427
  if (this_err < err) {
#line 428
    *best_clock = clock;
#line 429
    err = this_err;
  } else {

  }
#line 421
  clock.p1 = clock.p1 + 1;
  ldv_39909: ;
#line 420
  if (clock.p1 <= (int )limit->p1.max) {
#line 422
    goto ldv_39908;
  } else {

  }
#line 419
  clock.m = clock.m + 1;
  ldv_39912: ;
#line 419
  if (clock.m <= (int )limit->m.max) {
#line 421
    goto ldv_39911;
  } else {

  }

#line 433
  return (err != target);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static void oaktrail_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  int i ;
  int need_aux ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 444
  dev = crtc->dev;
#line 445
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 446
  __mptr = (struct drm_crtc  const  *)crtc;
#line 446
  gma_crtc = (struct gma_crtc *)__mptr;
#line 447
  pipe = gma_crtc->pipe;
#line 448
  map = dev_priv->regmap + (unsigned long )pipe;
#line 451
  tmp = gma_pipe_has_type(crtc, 3);
#line 451
  need_aux = (int )tmp;
#line 453
  tmp___0 = gma_pipe_has_type(crtc, 6);
#line 453
  if ((int )tmp___0) {
#line 454
    oaktrail_crtc_hdmi_dpms(crtc, mode);
#line 455
    return;
  } else {

  }
#line 458
  tmp___1 = gma_power_begin(dev, 1);
#line 458
  if (tmp___1) {
#line 458
    tmp___2 = 0;
  } else {
#line 458
    tmp___2 = 1;
  }
#line 458
  if (tmp___2) {
#line 459
    return;
  } else {

  }
#line 464
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: 
#line 468
  i = 0;
#line 468
  goto ldv_39932;
  ldv_39931: 
#line 470
  temp = REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 471
  if ((int )temp >= 0) {
#line 472
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp, i);
#line 473
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 475
    __const_udelay(644250UL);
#line 476
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp | 2147483648U, i);
#line 478
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 480
    __const_udelay(644250UL);
#line 481
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp | 2147483648U, i);
#line 483
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 485
    __const_udelay(644250UL);
  } else {

  }
#line 489
  temp = REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 490
  if ((int )temp >= 0) {
#line 491
    REGISTER_WRITE_WITH_AUX(dev, map->conf, temp | 2147483648U, i);
  } else {

  }
#line 496
  temp = REGISTER_READ_WITH_AUX(dev, map->cntr, i);
#line 497
  if ((int )temp >= 0) {
#line 498
    REGISTER_WRITE_WITH_AUX(dev, map->cntr, temp | 2147483648U, i);
#line 502
    tmp___3 = REGISTER_READ_WITH_AUX(dev, map->base, i);
#line 502
    REGISTER_WRITE_WITH_AUX(dev, map->base, tmp___3, i);
  } else {

  }
#line 468
  i = i + 1;
  ldv_39932: ;
#line 468
  if (i <= need_aux) {
#line 470
    goto ldv_39931;
  } else {

  }
#line 507
  gma_crtc_load_lut(crtc);
#line 512
  goto ldv_39934;
  case 3: 
#line 518
  i = 0;
#line 518
  goto ldv_39937;
  ldv_39936: 
#line 520
  REGISTER_WRITE_WITH_AUX(dev, 463872U, 2147483648U, i);
#line 522
  temp = REGISTER_READ_WITH_AUX(dev, map->cntr, i);
#line 523
  if ((int )temp < 0) {
#line 524
    REGISTER_WRITE_WITH_AUX(dev, map->cntr, temp & 2147483647U, i);
#line 527
    tmp___4 = REGISTER_READ(dev, map->base);
#line 527
    REGISTER_WRITE_WITH_AUX(dev, map->base, tmp___4, i);
#line 529
    REGISTER_READ_WITH_AUX(dev, map->base, i);
  } else {

  }
#line 533
  temp = REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 534
  if ((int )temp < 0) {
#line 535
    REGISTER_WRITE_WITH_AUX(dev, map->conf, temp & 2147483647U, i);
#line 537
    REGISTER_READ_WITH_AUX(dev, map->conf, i);
  } else {

  }
#line 540
  gma_wait_for_vblank(dev);
#line 542
  temp = REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 543
  if ((int )temp < 0) {
#line 544
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, temp & 2147483647U, i);
#line 546
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
  } else {

  }
#line 550
  __const_udelay(644250UL);
#line 518
  i = i + 1;
  ldv_39937: ;
#line 518
  if (i <= need_aux) {
#line 520
    goto ldv_39936;
  } else {

  }

#line 552
  goto ldv_39934;
  }
  ldv_39934: 
#line 556
  REGISTER_WRITE(dev, 458800U, 16256U);
#line 557
  REGISTER_WRITE(dev, 458804U, 1066337284U);
#line 558
  REGISTER_WRITE(dev, 458808U, 67374852U);
#line 559
  REGISTER_WRITE(dev, 458812U, 0U);
#line 560
  REGISTER_WRITE(dev, 458832U, 67372036U);
#line 561
  REGISTER_WRITE(dev, 458836U, 67372036U);
#line 562
  REGISTER_WRITE(dev, 458840U, 120U);
#line 563
  tmp___5 = REGISTER_READ(dev, 459776U);
#line 563
  REGISTER_WRITE(dev, 459776U, tmp___5 | 49216U);
#line 565
  gma_power_end(dev);
#line 566
  return;
}
}
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static int oaktrail_panel_fitter_pipe(struct drm_device *dev ) 
{ 
  u32 pfit_control ;

  {
#line 576
  pfit_control = REGISTER_READ(dev, 397872U);
#line 579
  if ((int )pfit_control >= 0) {
#line 580
    return (-1);
  } else {

  }
#line 581
  return ((int )(pfit_control >> 29) & 3);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static int oaktrail_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode , int x ,
                                  int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct gma_clock_t clock ;
  struct gma_limit_t  const  *limit ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_mipi ;
  struct drm_mode_config *mode_config ;
  struct gma_encoder *gma_encoder ;
  uint64_t scalingType ;
  struct drm_connector *connector ;
  int i ;
  int need_aux ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___4 ;
  int offsetX ;
  int offsetY ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  int sdvo_pixel_multiply ;

  {
#line 590
  dev = crtc->dev;
#line 591
  __mptr = (struct drm_crtc  const  *)crtc;
#line 591
  gma_crtc = (struct gma_crtc *)__mptr;
#line 592
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 593
  pipe = gma_crtc->pipe;
#line 594
  map = dev_priv->regmap + (unsigned long )pipe;
#line 595
  refclk = 0;
#line 598
  dpll = 0U;
#line 598
  fp = 0U;
#line 599
  is_sdvo = 0;
#line 600
  is_lvds = 0;
#line 601
  is_mipi = 0;
#line 602
  mode_config = & dev->mode_config;
#line 603
  gma_encoder = (struct gma_encoder *)0;
#line 604
  scalingType = 1ULL;
#line 607
  tmp = gma_pipe_has_type(crtc, 3);
#line 607
  need_aux = (int )tmp;
#line 609
  tmp___1 = gma_pipe_has_type(crtc, 6);
#line 609
  if ((int )tmp___1) {
#line 610
    tmp___0 = oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);
#line 610
    return (tmp___0);
  } else {

  }
#line 612
  tmp___2 = gma_power_begin(dev, 1);
#line 612
  if (tmp___2) {
#line 612
    tmp___3 = 0;
  } else {
#line 612
    tmp___3 = 1;
  }
#line 612
  if (tmp___3) {
#line 613
    return (0);
  } else {

  }
#line 615
  __len = 208UL;
#line 615
  if (__len > 63UL) {
#line 615
    __ret = __memcpy((void *)(& gma_crtc->saved_mode), (void const   *)mode, __len);
  } else {
#line 615
    __ret = __builtin_memcpy((void *)(& gma_crtc->saved_mode), (void const   *)mode,
                             __len);
  }
#line 618
  __len___0 = 208UL;
#line 618
  if (__len___0 > 63UL) {
#line 618
    __ret___0 = __memcpy((void *)(& gma_crtc->saved_adjusted_mode), (void const   *)adjusted_mode,
                         __len___0);
  } else {
#line 618
    __ret___0 = __builtin_memcpy((void *)(& gma_crtc->saved_adjusted_mode), (void const   *)adjusted_mode,
                                 __len___0);
  }
#line 622
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
#line 622
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
#line 622
  goto ldv_39991;
  ldv_39990: ;
#line 623
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
#line 624
    goto ldv_39985;
  } else {

  }
#line 626
  gma_encoder = gma_attached_encoder(connector);
#line 628
  switch (gma_encoder->type) {
  case 4: 
#line 630
  is_lvds = 1;
#line 631
  goto ldv_39987;
  case 3: 
#line 633
  is_sdvo = 1;
#line 634
  goto ldv_39987;
  case 7: 
#line 636
  is_mipi = 1;
#line 637
  goto ldv_39987;
  }
  ldv_39987: ;
  ldv_39985: 
#line 622
  __mptr___1 = (struct list_head  const  *)connector->head.next;
#line 622
  connector = (struct drm_connector *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_39991: ;
#line 622
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 624
    goto ldv_39990;
  } else {

  }
#line 642
  i = 0;
#line 642
  goto ldv_39994;
  ldv_39993: 
#line 643
  REGISTER_WRITE_WITH_AUX(dev, 463872U, 2147483648U, i);
#line 642
  i = i + 1;
  ldv_39994: ;
#line 642
  if (i <= need_aux) {
#line 644
    goto ldv_39993;
  } else {

  }
#line 646
  tmp___4 = oaktrail_panel_fitter_pipe(dev);
#line 646
  if (tmp___4 == pipe) {
#line 647
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
#line 649
  i = 0;
#line 649
  goto ldv_39997;
  ldv_39996: 
#line 650
  REGISTER_WRITE_WITH_AUX(dev, map->src, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)),
                          i);
#line 649
  i = i + 1;
  ldv_39997: ;
#line 649
  if (i <= need_aux) {
#line 651
    goto ldv_39996;
  } else {

  }

#line 654
  if ((unsigned long )gma_encoder != (unsigned long )((struct gma_encoder *)0)) {
#line 655
    drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                  & scalingType);
  } else {

  }
#line 658
  if (scalingType == 2ULL) {
#line 662
    offsetX = 0;
#line 662
    offsetY = 0;
#line 664
    offsetX = (adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2;
#line 666
    offsetY = (adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2;
#line 669
    i = 0;
#line 669
    goto ldv_40002;
    ldv_40001: 
#line 670
    REGISTER_WRITE_WITH_AUX(dev, map->htotal, (uint32_t )((mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)),
                            i);
#line 672
    REGISTER_WRITE_WITH_AUX(dev, map->vtotal, (uint32_t )((mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)),
                            i);
#line 674
    REGISTER_WRITE_WITH_AUX(dev, map->hblank, (uint32_t )(((adjusted_mode->crtc_hblank_start - offsetX) + -1) | (((adjusted_mode->crtc_hblank_end - offsetX) + -1) << 16)),
                            i);
#line 677
    REGISTER_WRITE_WITH_AUX(dev, map->hsync, (uint32_t )(((adjusted_mode->crtc_hsync_start - offsetX) + -1) | (((adjusted_mode->crtc_hsync_end - offsetX) + -1) << 16)),
                            i);
#line 680
    REGISTER_WRITE_WITH_AUX(dev, map->vblank, (uint32_t )(((adjusted_mode->crtc_vblank_start - offsetY) + -1) | (((adjusted_mode->crtc_vblank_end - offsetY) + -1) << 16)),
                            i);
#line 683
    REGISTER_WRITE_WITH_AUX(dev, map->vsync, (uint32_t )(((adjusted_mode->crtc_vsync_start - offsetY) + -1) | (((adjusted_mode->crtc_vsync_end - offsetY) + -1) << 16)),
                            i);
#line 669
    i = i + 1;
    ldv_40002: ;
#line 669
    if (i <= need_aux) {
#line 671
      goto ldv_40001;
    } else {

    }

  } else {
#line 688
    i = 0;
#line 688
    goto ldv_40005;
    ldv_40004: 
#line 689
    REGISTER_WRITE_WITH_AUX(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)),
                            i);
#line 691
    REGISTER_WRITE_WITH_AUX(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)),
                            i);
#line 693
    REGISTER_WRITE_WITH_AUX(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)),
                            i);
#line 695
    REGISTER_WRITE_WITH_AUX(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)),
                            i);
#line 697
    REGISTER_WRITE_WITH_AUX(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)),
                            i);
#line 699
    REGISTER_WRITE_WITH_AUX(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)),
                            i);
#line 688
    i = i + 1;
    ldv_40005: ;
#line 688
    if (i <= need_aux) {
#line 690
      goto ldv_40004;
    } else {

    }

  }
#line 706
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 708
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 712
  pipeconf = REGISTER_READ(dev, map->conf);
#line 715
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 716
  dspcntr = dspcntr | 1073741824U;
#line 718
  if (pipe == 0) {
#line 719
    dspcntr = dspcntr;
  } else {
#line 721
    dspcntr = dspcntr | 16777216U;
  }
#line 723
  if ((int )is_mipi) {
#line 724
    goto oaktrail_crtc_mode_set_exit;
  } else {

  }
#line 727
  dpll = 0U;
#line 729
  refclk = (int )is_sdvo ? 96000 : (int )(dev_priv->core_freq * 1000U);
#line 730
  limit = mrst_limit(crtc, refclk);
#line 731
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
#line 734
  if ((int )is_sdvo) {
#line 736
    clock.p1 = (int )(1L << (clock.p1 + -1));
#line 737
    clock.m = clock.m + -2;
#line 738
    clock.n = (int )(1L << (clock.n + -1));
  } else {

  }
#line 741
  if (! ok) {
#line 742
    drm_err("oaktrail_crtc_mode_set", "Failed to find proper PLL settings");
  } else {

  }
#line 744
  mrst_print_pll(& clock);
#line 746
  if ((int )is_sdvo) {
#line 747
    fp = (u32 )((clock.n << 16) | clock.m);
  } else {
#line 749
    fp = oaktrail_m_converts[clock.m + -10] << 8;
  }
#line 751
  dpll = dpll | 268435456U;
#line 754
  dpll = dpll | 2147483648U;
#line 756
  if ((int )is_lvds) {
#line 757
    dpll = dpll | 134217728U;
  } else {
#line 759
    dpll = dpll | 67108864U;
  }
#line 761
  if ((int )is_sdvo) {
#line 762
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
#line 765
    dpll = dpll | 1073741824U;
#line 766
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
#line 773
  if ((int )is_sdvo) {
#line 774
    dpll = (u32 )(clock.p1 << 16) | dpll;
  } else {
#line 776
    dpll = (u32 )((1 << (clock.p1 + -2)) << 17) | dpll;
  }
#line 778
  dpll = dpll | 2147483648U;
#line 780
  if ((int )dpll < 0) {
#line 781
    i = 0;
#line 781
    goto ldv_40012;
    ldv_40011: 
#line 782
    REGISTER_WRITE_WITH_AUX(dev, map->fp0, fp, i);
#line 783
    REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll & 2147483647U, i);
#line 784
    REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 786
    __const_udelay(644250UL);
#line 781
    i = i + 1;
    ldv_40012: ;
#line 781
    if (i <= need_aux) {
#line 783
      goto ldv_40011;
    } else {

    }

  } else {

  }
#line 790
  i = 0;
#line 790
  goto ldv_40015;
  ldv_40014: 
#line 791
  REGISTER_WRITE_WITH_AUX(dev, map->fp0, fp, i);
#line 792
  REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll, i);
#line 793
  REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 795
  __const_udelay(644250UL);
#line 798
  REGISTER_WRITE_WITH_AUX(dev, map->dpll, dpll, i);
#line 799
  REGISTER_READ_WITH_AUX(dev, map->dpll, i);
#line 801
  __const_udelay(644250UL);
#line 803
  REGISTER_WRITE_WITH_AUX(dev, map->conf, pipeconf, i);
#line 804
  REGISTER_READ_WITH_AUX(dev, map->conf, i);
#line 805
  gma_wait_for_vblank(dev);
#line 807
  REGISTER_WRITE_WITH_AUX(dev, map->cntr, dspcntr, i);
#line 808
  gma_wait_for_vblank(dev);
#line 790
  i = i + 1;
  ldv_40015: ;
#line 790
  if (i <= need_aux) {
#line 792
    goto ldv_40014;
  } else {

  }

  oaktrail_crtc_mode_set_exit: 
#line 812
  gma_power_end(dev);
#line 813
  return (0);
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
static int oaktrail_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_crtc *gma_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 819
  dev = crtc->dev;
#line 820
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 821
  __mptr = (struct drm_crtc  const  *)crtc;
#line 821
  gma_crtc = (struct gma_crtc *)__mptr;
#line 822
  __mptr___0 = (struct drm_framebuffer  const  *)(crtc->primary)->fb;
#line 822
  psbfb = (struct psb_framebuffer *)__mptr___0;
#line 823
  pipe = gma_crtc->pipe;
#line 824
  map = dev_priv->regmap + (unsigned long )pipe;
#line 828
  ret = 0;
#line 831
  if ((unsigned long )(crtc->primary)->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 832
    descriptor.modname = "gma500_gfx";
#line 832
    descriptor.function = "oaktrail_pipe_set_base";
#line 832
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared";
#line 832
    descriptor.format = "No FB bound\n";
#line 832
    descriptor.lineno = 832U;
#line 832
    descriptor.flags = 0U;
#line 832
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 832
    if (tmp != 0L) {
#line 832
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No FB bound\n");
    } else {

    }
#line 833
    return (0);
  } else {

  }
#line 836
  tmp___0 = gma_power_begin(dev, 1);
#line 836
  if (tmp___0) {
#line 836
    tmp___1 = 0;
  } else {
#line 836
    tmp___1 = 1;
  }
#line 836
  if (tmp___1) {
#line 837
    return (0);
  } else {

  }
#line 839
  start = (unsigned long )(psbfb->gtt)->offset;
#line 840
  offset = (unsigned long )(((crtc->primary)->fb)->pitches[0] * (unsigned int )y + (unsigned int )((((crtc->primary)->fb)->bits_per_pixel / 8) * x));
#line 842
  REGISTER_WRITE(dev, map->stride, ((crtc->primary)->fb)->pitches[0]);
#line 844
  dspcntr = REGISTER_READ(dev, map->cntr);
#line 845
  dspcntr = dspcntr & 3288334335U;
#line 847
  switch (((crtc->primary)->fb)->bits_per_pixel) {
  case 8: 
#line 849
  dspcntr = dspcntr | 134217728U;
#line 850
  goto ldv_40040;
  case 16: ;
#line 852
  if (((crtc->primary)->fb)->depth == 15U) {
#line 853
    dspcntr = dspcntr | 268435456U;
  } else {
#line 855
    dspcntr = dspcntr | 335544320U;
  }
#line 856
  goto ldv_40040;
  case 24: ;
  case 32: 
#line 859
  dspcntr = dspcntr | 402653184U;
#line 860
  goto ldv_40040;
  default: 
#line 862
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
#line 863
  ret = -22;
#line 864
  goto pipe_set_base_exit;
  }
  ldv_40040: 
#line 866
  REGISTER_WRITE(dev, map->cntr, dspcntr);
#line 868
  REGISTER_WRITE(dev, map->base, (uint32_t )offset);
#line 869
  REGISTER_READ(dev, map->base);
#line 870
  REGISTER_WRITE(dev, map->surf, (uint32_t )start);
#line 871
  REGISTER_READ(dev, map->surf);
  pipe_set_base_exit: 
#line 874
  gma_power_end(dev);
#line 875
  return (ret);
}
}
#line 878 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs  = 
#line 878
     {& oaktrail_crtc_dpms, & gma_crtc_prepare, & gma_crtc_commit, & gma_crtc_mode_fixup,
    & oaktrail_crtc_mode_set, & oaktrail_pipe_set_base, 0, 0, 0};
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
struct gma_clock_funcs  const  mrst_clock_funcs  =    {& mrst_lvds_clock, & mrst_limit, & gma_pll_is_valid};
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_initialize_drm_crtc_helper_funcs_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 896
  tmp = ldv_zalloc(136UL);
#line 896
  oaktrail_helper_funcs_group0 = (struct drm_framebuffer *)tmp;
#line 897
  tmp___0 = ldv_zalloc(1048UL);
#line 897
  oaktrail_helper_funcs_group1 = (struct drm_crtc *)tmp___0;
#line 898
  tmp___1 = ldv_zalloc(208UL);
#line 898
  oaktrail_helper_funcs_group2 = (struct drm_display_mode *)tmp___1;
#line 899
  return;
}
}
#line 901 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_initialize_gma_clock_funcs_9(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 902
  tmp = ldv_zalloc(1048UL);
#line 902
  mrst_clock_funcs_group0 = (struct drm_crtc *)tmp;
#line 903
  tmp___0 = ldv_zalloc(36UL);
#line 903
  mrst_clock_funcs_group1 = (struct gma_clock_t *)tmp___0;
#line 904
  return;
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  int ldvarg83 ;
  int tmp ;
  int ldvarg82 ;
  int tmp___0 ;
  int ldvarg78 ;
  int tmp___1 ;
  int ldvarg80 ;
  int tmp___2 ;
  int ldvarg84 ;
  int tmp___3 ;
  struct drm_display_mode *ldvarg79 ;
  void *tmp___4 ;
  struct drm_display_mode *ldvarg81 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 907
  tmp = __VERIFIER_nondet_int();
#line 907
  ldvarg83 = tmp;
#line 908
  tmp___0 = __VERIFIER_nondet_int();
#line 908
  ldvarg82 = tmp___0;
#line 909
  tmp___1 = __VERIFIER_nondet_int();
#line 909
  ldvarg78 = tmp___1;
#line 910
  tmp___2 = __VERIFIER_nondet_int();
#line 910
  ldvarg80 = tmp___2;
#line 911
  tmp___3 = __VERIFIER_nondet_int();
#line 911
  ldvarg84 = tmp___3;
#line 912
  tmp___4 = ldv_zalloc(208UL);
#line 912
  ldvarg79 = (struct drm_display_mode *)tmp___4;
#line 913
  tmp___5 = ldv_zalloc(208UL);
#line 913
  ldvarg81 = (struct drm_display_mode *)tmp___5;
#line 915
  tmp___6 = __VERIFIER_nondet_int();
#line 915
  switch (tmp___6) {
  case 0: ;
#line 918
  if (ldv_state_variable_10 == 1) {
#line 920
    oaktrail_pipe_set_base(oaktrail_helper_funcs_group1, ldvarg84, ldvarg83, oaktrail_helper_funcs_group0);
#line 922
    ldv_state_variable_10 = 1;
  } else {

  }
#line 925
  goto ldv_40065;
  case 1: ;
#line 928
  if (ldv_state_variable_10 == 1) {
#line 930
    oaktrail_crtc_dpms(oaktrail_helper_funcs_group1, ldvarg82);
#line 932
    ldv_state_variable_10 = 1;
  } else {

  }
#line 935
  goto ldv_40065;
  case 2: ;
#line 938
  if (ldv_state_variable_10 == 1) {
#line 940
    gma_crtc_mode_fixup(oaktrail_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg81,
                        oaktrail_helper_funcs_group2);
#line 942
    ldv_state_variable_10 = 1;
  } else {

  }
#line 945
  goto ldv_40065;
  case 3: ;
#line 948
  if (ldv_state_variable_10 == 1) {
#line 950
    gma_crtc_commit(oaktrail_helper_funcs_group1);
#line 952
    ldv_state_variable_10 = 1;
  } else {

  }
#line 955
  goto ldv_40065;
  case 4: ;
#line 958
  if (ldv_state_variable_10 == 1) {
#line 960
    oaktrail_crtc_mode_set(oaktrail_helper_funcs_group1, oaktrail_helper_funcs_group2,
                           ldvarg79, ldvarg78, ldvarg80, oaktrail_helper_funcs_group0);
#line 962
    ldv_state_variable_10 = 1;
  } else {

  }
#line 965
  goto ldv_40065;
  case 5: ;
#line 968
  if (ldv_state_variable_10 == 1) {
#line 970
    gma_crtc_prepare(oaktrail_helper_funcs_group1);
#line 972
    ldv_state_variable_10 = 1;
  } else {

  }
#line 975
  goto ldv_40065;
  default: 
#line 976
  ldv_stop();
  }
  ldv_40065: ;
#line 980
  return;
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  struct gma_limit_t *ldvarg148 ;
  void *tmp ;
  int ldvarg146 ;
  int tmp___0 ;
  int ldvarg147 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 983
  tmp = ldv_zalloc(88UL);
#line 983
  ldvarg148 = (struct gma_limit_t *)tmp;
#line 984
  tmp___0 = __VERIFIER_nondet_int();
#line 984
  ldvarg146 = tmp___0;
#line 985
  tmp___1 = __VERIFIER_nondet_int();
#line 985
  ldvarg147 = tmp___1;
#line 987
  tmp___2 = __VERIFIER_nondet_int();
#line 987
  switch (tmp___2) {
  case 0: ;
#line 990
  if (ldv_state_variable_9 == 1) {
#line 992
    gma_pll_is_valid(mrst_clock_funcs_group0, (struct gma_limit_t  const  *)ldvarg148,
                     mrst_clock_funcs_group1);
#line 994
    ldv_state_variable_9 = 1;
  } else {

  }
#line 997
  goto ldv_40079;
  case 1: ;
#line 1000
  if (ldv_state_variable_9 == 1) {
#line 1002
    mrst_lvds_clock(ldvarg147, mrst_clock_funcs_group1);
#line 1004
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1007
  goto ldv_40079;
  case 2: ;
#line 1010
  if (ldv_state_variable_9 == 1) {
#line 1012
    mrst_limit(mrst_clock_funcs_group0, ldvarg146);
#line 1014
    ldv_state_variable_9 = 1;
  } else {

  }
#line 1017
  goto ldv_40079;
  default: 
#line 1018
  ldv_stop();
  }
  ldv_40079: ;
#line 1022
  return;
}
}
#line 1150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_crtc.o.c.prepared"
void *ldv_kmem_cache_alloc_620(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1153
  ldv_check_alloc_flags(flags);
#line 1155
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1156
  return ((void *)0);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_640(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 524 "include/linux/i2c.h"
extern struct i2c_adapter *i2c_get_adapter(int  ) ;
#line 197 "include/linux/pm_runtime.h"
__inline static int pm_request_idle(struct device *dev ) 
{ 
  int tmp ;

  {
#line 199
  tmp = __pm_runtime_idle(dev, 1);
#line 199
  return (tmp);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_set_power(struct drm_device *dev , struct gma_encoder *gma_encoder ,
                                    bool on ) 
{ 
  u32 pp_status ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 270
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 272
  tmp = gma_power_begin(dev, 1);
#line 272
  if (tmp) {
#line 272
    tmp___0 = 0;
  } else {
#line 272
    tmp___0 = 1;
  }
#line 272
  if (tmp___0) {
#line 273
    return;
  } else {

  }
#line 275
  if ((int )on) {
#line 276
    tmp___1 = REGISTER_READ(dev, 397828U);
#line 276
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_39847: 
#line 279
    pp_status = REGISTER_READ(dev, 397824U);
#line 280
    if ((pp_status & 3221225472U) == 1073741824U) {
#line 282
      goto ldv_39847;
    } else {

    }
#line 281
    dev_priv->is_lvds_on = 1;
#line 282
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
#line 283
      (*((dev_priv->ops)->lvds_bl_power))(dev, 1);
    } else {

    }
  } else {
#line 285
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
#line 286
      (*((dev_priv->ops)->lvds_bl_power))(dev, 0);
    } else {

    }
#line 287
    tmp___2 = REGISTER_READ(dev, 397828U);
#line 287
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_39849: 
#line 290
    pp_status = REGISTER_READ(dev, 397824U);
#line 291
    if ((int )pp_status < 0) {
#line 293
      goto ldv_39849;
    } else {

    }
#line 292
    dev_priv->is_lvds_on = 0;
#line 293
    pm_request_idle(& (dev->pdev)->dev);
  }
#line 295
  gma_power_end(dev);
#line 296
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  struct drm_device *dev ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
#line 300
  dev = encoder->dev;
#line 301
  __mptr = (struct drm_encoder  const  *)encoder;
#line 301
  gma_encoder = (struct gma_encoder *)__mptr;
#line 303
  if (mode == 0) {
#line 304
    oaktrail_lvds_set_power(dev, gma_encoder, 1);
  } else {
#line 306
    oaktrail_lvds_set_power(dev, gma_encoder, 0);
  }
#line 307
  return;
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct drm_crtc *crtc ;
  u32 lvds_port ;
  uint64_t v ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 315
  dev = encoder->dev;
#line 316
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 317
  mode_dev = & dev_priv->mode_dev;
#line 318
  mode_config = & dev->mode_config;
#line 319
  connector = (struct drm_connector *)0;
#line 320
  crtc = encoder->crtc;
#line 322
  v = 1ULL;
#line 324
  tmp = gma_power_begin(dev, 1);
#line 324
  if (tmp) {
#line 324
    tmp___0 = 0;
  } else {
#line 324
    tmp___0 = 1;
  }
#line 324
  if (tmp___0) {
#line 325
    return;
  } else {

  }
#line 332
  tmp___1 = REGISTER_READ(dev, 397696U);
#line 332
  lvds_port = (tmp___1 & 1073709055U) | 2147516416U;
#line 339
  if ((int )mode_dev->panel_wants_dither || (unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 340
    lvds_port = lvds_port | 33554432U;
  } else {

  }
#line 342
  REGISTER_WRITE(dev, 397696U, lvds_port);
#line 345
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
#line 345
  connector = (struct drm_connector *)__mptr + 0xffffffffffffffe8UL;
#line 345
  goto ldv_39878;
  ldv_39877: ;
#line 346
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {

  } else {

  }
#line 345
  __mptr___0 = (struct list_head  const  *)connector->head.next;
#line 345
  connector = (struct drm_connector *)__mptr___0 + 0xffffffffffffffe8UL;
  ldv_39878: ;
#line 345
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
#line 347
    goto ldv_39877;
  } else {

  }

#line 350
  if ((unsigned long )connector == (unsigned long )((struct drm_connector *)0)) {
#line 351
    drm_err("oaktrail_lvds_mode_set", "Couldn\'t find connector when setting mode");
#line 352
    return;
  } else {

  }
#line 355
  drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                & v);
#line 360
  if (v == 2ULL) {
#line 361
    REGISTER_WRITE(dev, 397872U, 0U);
  } else
#line 362
  if (v == 3ULL) {
#line 363
    if (mode->vdisplay != adjusted_mode->crtc_vdisplay || mode->hdisplay != adjusted_mode->crtc_hdisplay) {
#line 365
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay == mode->hdisplay * adjusted_mode->crtc_vdisplay) {
#line 367
        REGISTER_WRITE(dev, 397872U, 2147483648U);
      } else
#line 368
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay > mode->hdisplay * adjusted_mode->crtc_vdisplay) {
#line 371
        REGISTER_WRITE(dev, 397872U, 2281701376U);
      } else {
#line 374
        REGISTER_WRITE(dev, 397872U, 2348810240U);
      }
    } else {
#line 377
      REGISTER_WRITE(dev, 397872U, 2147483648U);
    }
  } else {
#line 379
    REGISTER_WRITE(dev, 397872U, 2147483648U);
  }
#line 381
  gma_power_end(dev);
#line 382
  return;
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_prepare(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 386
  dev = encoder->dev;
#line 387
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 388
  __mptr = (struct drm_encoder  const  *)encoder;
#line 388
  gma_encoder = (struct gma_encoder *)__mptr;
#line 389
  mode_dev = & dev_priv->mode_dev;
#line 391
  tmp = gma_power_begin(dev, 1);
#line 391
  if (tmp) {
#line 391
    tmp___0 = 0;
  } else {
#line 391
    tmp___0 = 1;
  }
#line 391
  if (tmp___0) {
#line 392
    return;
  } else {

  }
#line 394
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
#line 395
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
#line 397
  oaktrail_lvds_set_power(dev, gma_encoder, 0);
#line 398
  gma_power_end(dev);
#line 399
  return;
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static u32 oaktrail_lvds_get_max_backlight(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  u32 ret ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
#line 403
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 406
  tmp___0 = gma_power_begin(dev, 0);
#line 406
  if ((int )tmp___0) {
#line 407
    tmp = REGISTER_READ(dev, 397908U);
#line 407
    ret = (tmp >> 17) * 2U;
#line 411
    gma_power_end(dev);
  } else {
#line 413
    ret = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
#line 417
  return (ret);
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_commit(struct drm_encoder *encoder ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct gma_encoder *gma_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
#line 422
  dev = encoder->dev;
#line 423
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 424
  __mptr = (struct drm_encoder  const  *)encoder;
#line 424
  gma_encoder = (struct gma_encoder *)__mptr;
#line 425
  mode_dev = & dev_priv->mode_dev;
#line 427
  if (mode_dev->backlight_duty_cycle == 0) {
#line 428
    tmp = oaktrail_lvds_get_max_backlight(dev);
#line 428
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
#line 430
  oaktrail_lvds_set_power(dev, gma_encoder, 1);
#line 431
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static struct drm_encoder_helper_funcs  const  oaktrail_lvds_helper_funcs  = 
#line 433
     {& oaktrail_lvds_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & oaktrail_lvds_prepare,
    & oaktrail_lvds_commit, & oaktrail_lvds_mode_set, 0, 0, 0};
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
static void oaktrail_lvds_get_configuration_mode(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct drm_display_mode *mode ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_timing_info *ti ;
  void *tmp ;

  {
#line 446
  mode = (struct drm_display_mode *)0;
#line 447
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 448
  ti = & dev_priv->gct_data.DTD;
#line 450
  mode_dev->panel_fixed_mode = (struct drm_display_mode *)0;
#line 453
  if ((int )dev_priv->has_gct) {
#line 454
    tmp = kzalloc(208UL, 208U);
#line 454
    mode = (struct drm_display_mode *)tmp;
#line 455
    if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 456
      return;
    } else {

    }
#line 458
    mode->hdisplay = ((int )ti->hactive_hi << 8) | (int )ti->hactive_lo;
#line 459
    mode->vdisplay = ((int )ti->vactive_hi << 8) | (int )ti->vactive_lo;
#line 460
    mode->hsync_start = mode->hdisplay + (((int )ti->hsync_offset_hi << 8) | (int )ti->hsync_offset_lo);
#line 463
    mode->hsync_end = mode->hsync_start + (((int )ti->hsync_pulse_width_hi << 8) | (int )ti->hsync_pulse_width_lo);
#line 466
    mode->htotal = mode->hdisplay + (((int )ti->hblank_hi << 8) | (int )ti->hblank_lo);
#line 468
    mode->vsync_start = mode->vdisplay + (((int )ti->vsync_offset_hi << 4) | (int )ti->vsync_offset_lo);
#line 471
    mode->vsync_end = mode->vsync_start + (((int )ti->vsync_pulse_width_hi << 4) | (int )ti->vsync_pulse_width_lo);
#line 474
    mode->vtotal = mode->vdisplay + (((int )ti->vblank_hi << 8) | (int )ti->vblank_lo);
#line 476
    mode->clock = (int )ti->pixel_clock * 10;
#line 488
    mode_dev->panel_fixed_mode = mode;
  } else {

  }
#line 492
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 493
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
#line 497
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 498
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 499
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
#line 504
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 505
    return;
  } else {

  }
#line 507
  drm_mode_set_name(mode_dev->panel_fixed_mode);
#line 508
  drm_mode_set_crtcinfo(mode_dev->panel_fixed_mode, 0);
#line 509
  return;
}
}
#line 518 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_psb_private *dev_priv ;
  struct edid *edid ;
  struct i2c_adapter *i2c_adap ;
  struct drm_display_mode *scan ;
  void *tmp ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
#line 525
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 530
  tmp = kzalloc(152UL, 208U);
#line 530
  gma_encoder = (struct gma_encoder *)tmp;
#line 531
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 532
    return;
  } else {

  }
#line 534
  tmp___0 = kzalloc(728UL, 208U);
#line 534
  gma_connector = (struct gma_connector *)tmp___0;
#line 535
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 536
    goto failed_connector;
  } else {

  }
#line 538
  connector = & gma_connector->base;
#line 539
  encoder = & gma_encoder->base;
#line 540
  dev_priv->is_lvds_on = 1;
#line 541
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
#line 545
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
#line 548
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 549
  gma_encoder->type = 4;
#line 551
  drm_encoder_helper_add(encoder, & oaktrail_lvds_helper_funcs);
#line 552
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
#line 554
  connector->display_info.subpixel_order = 1;
#line 555
  connector->interlace_allowed = 0;
#line 556
  connector->doublescan_allowed = 0;
#line 558
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
#line 561
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
#line 565
  mode_dev->panel_wants_dither = 0;
#line 566
  if ((int )dev_priv->has_gct) {
#line 567
    mode_dev->panel_wants_dither = (dev_priv->gct_data.Panel_Port_Control & 33554432U) != 0U;
  } else {

  }
#line 569
  if ((unsigned int )*((unsigned char *)dev_priv + 864UL) != 0U) {
#line 570
    mode_dev->panel_wants_dither = 1;
  } else {

  }
#line 582
  mutex_lock_nested(& dev->mode_config.mutex, 0U);
#line 583
  i2c_adap = i2c_get_adapter((dev_priv->ops)->i2c_bus);
#line 584
  if ((unsigned long )i2c_adap == (unsigned long )((struct i2c_adapter *)0)) {
#line 585
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
  } else {

  }
#line 590
  if ((unsigned long )i2c_adap != (unsigned long )((struct i2c_adapter *)0)) {
#line 591
    edid = drm_get_edid(connector, i2c_adap);
#line 592
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 593
      drm_mode_connector_update_edid_property(connector, edid);
#line 595
      drm_add_edid_modes(connector, edid);
#line 596
      kfree((void const   *)edid);
    } else {

    }
#line 599
    __mptr = (struct list_head  const  *)connector->probed_modes.next;
#line 599
    scan = (struct drm_display_mode *)__mptr;
#line 599
    goto ldv_39931;
    ldv_39930: ;
#line 600
    if ((scan->type & 8U) != 0U) {
#line 601
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
#line 603
      goto out;
    } else {

    }
#line 599
    __mptr___0 = (struct list_head  const  *)scan->head.next;
#line 599
    scan = (struct drm_display_mode *)__mptr___0;
    ldv_39931: ;
#line 599
    if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
#line 601
      goto ldv_39930;
    } else {

    }

  } else {

  }
#line 611
  oaktrail_lvds_get_configuration_mode(dev, mode_dev);
#line 613
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 614
    (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
#line 615
    goto out;
  } else {

  }
#line 619
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 620
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
#line 621
    goto failed_find;
  } else {

  }
  out: 
#line 625
  mutex_unlock(& dev->mode_config.mutex);
#line 627
  drm_sysfs_connector_add(connector);
#line 628
  return;
  failed_find: 
#line 631
  mutex_unlock(& dev->mode_config.mutex);
#line 633
  descriptor.modname = "gma500_gfx";
#line 633
  descriptor.function = "oaktrail_lvds_init";
#line 633
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared";
#line 633
  descriptor.format = "No LVDS modes found, disabling.\n";
#line 633
  descriptor.lineno = 633U;
#line 633
  descriptor.flags = 0U;
#line 633
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 633
  if (tmp___1 != 0L) {
#line 633
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No LVDS modes found, disabling.\n");
  } else {

  }
#line 634
  if ((unsigned long )gma_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
#line 635
    psb_intel_i2c_destroy(gma_encoder->ddc_bus);
  } else {

  }
#line 639
  drm_encoder_cleanup(encoder);
#line 640
  drm_connector_cleanup(connector);
#line 641
  kfree((void const   *)gma_connector);
  failed_connector: 
#line 643
  kfree((void const   *)gma_encoder);
#line 644
  return;
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 649
  tmp = ldv_zalloc(96UL);
#line 649
  oaktrail_lvds_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 650
  tmp___0 = ldv_zalloc(208UL);
#line 650
  oaktrail_lvds_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 651
  return;
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  int ldvarg176 ;
  int tmp ;
  struct drm_display_mode *ldvarg174 ;
  void *tmp___0 ;
  struct drm_display_mode *ldvarg175 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 654
  tmp = __VERIFIER_nondet_int();
#line 654
  ldvarg176 = tmp;
#line 655
  tmp___0 = ldv_zalloc(208UL);
#line 655
  ldvarg174 = (struct drm_display_mode *)tmp___0;
#line 656
  tmp___1 = ldv_zalloc(208UL);
#line 656
  ldvarg175 = (struct drm_display_mode *)tmp___1;
#line 658
  tmp___2 = __VERIFIER_nondet_int();
#line 658
  switch (tmp___2) {
  case 0: ;
#line 661
  if (ldv_state_variable_8 == 1) {
#line 663
    oaktrail_lvds_dpms(oaktrail_lvds_helper_funcs_group0, ldvarg176);
#line 665
    ldv_state_variable_8 = 1;
  } else {

  }
#line 668
  goto ldv_39946;
  case 1: ;
#line 671
  if (ldv_state_variable_8 == 1) {
#line 673
    psb_intel_lvds_mode_fixup(oaktrail_lvds_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg175,
                              oaktrail_lvds_helper_funcs_group1);
#line 675
    ldv_state_variable_8 = 1;
  } else {

  }
#line 678
  goto ldv_39946;
  case 2: ;
#line 681
  if (ldv_state_variable_8 == 1) {
#line 683
    oaktrail_lvds_commit(oaktrail_lvds_helper_funcs_group0);
#line 685
    ldv_state_variable_8 = 1;
  } else {

  }
#line 688
  goto ldv_39946;
  case 3: ;
#line 691
  if (ldv_state_variable_8 == 1) {
#line 693
    oaktrail_lvds_mode_set(oaktrail_lvds_helper_funcs_group0, oaktrail_lvds_helper_funcs_group1,
                           ldvarg174);
#line 695
    ldv_state_variable_8 = 1;
  } else {

  }
#line 698
  goto ldv_39946;
  case 4: ;
#line 701
  if (ldv_state_variable_8 == 1) {
#line 703
    oaktrail_lvds_prepare(oaktrail_lvds_helper_funcs_group0);
#line 705
    ldv_state_variable_8 = 1;
  } else {

  }
#line 708
  goto ldv_39946;
  default: 
#line 709
  ldv_stop();
  }
  ldv_39946: ;
#line 713
  return;
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_lvds.o.c.prepared"
void *ldv_kmem_cache_alloc_640(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 844
  ldv_check_alloc_flags(flags);
#line 846
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 847
  return ((void *)0);
}
}
#line 64 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_660(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 826 "include/linux/pci.h"
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 1431 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1433
  dev_set_drvdata(& pdev->dev, data);
#line 1434
  return;
}
}
#line 247 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.16-rc1.tar.xz/linux-3.16-rc1/drivers/gpu/drm/gma500/oaktrail.h"
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) ;
#line 248
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) ;
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static struct oaktrail_hdmi_limit  const  oaktrail_hdmi_limit  =    {{320000, 1650000}, {1, 15}, {1, 64}, {2, 4095}};
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_audio_enable(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
#line 350
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 351
  hdmi_dev = dev_priv->hdmi_priv;
#line 353
  writel(103U, (void volatile   *)hdmi_dev->regs + 4096U);
#line 354
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
#line 356
  writel(16U, (void volatile   *)hdmi_dev->regs + 20904U);
#line 357
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
#line 359
  writel(1U, (void volatile   *)hdmi_dev->regs + 16384U);
#line 360
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
#line 361
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_audio_disable(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
#line 365
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 366
  hdmi_dev = dev_priv->hdmi_priv;
#line 368
  writel(0U, (void volatile   *)hdmi_dev->regs + 20904U);
#line 369
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
#line 371
  writel(0U, (void volatile   *)hdmi_dev->regs + 16384U);
#line 372
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
#line 374
  writel(71U, (void volatile   *)hdmi_dev->regs + 4096U);
#line 375
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
#line 376
  return;
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static unsigned int htotal_calculate(struct drm_display_mode *mode ) 
{ 
  u32 htotal ;
  u32 new_crtc_htotal ;
  long tmp ;

  {
#line 382
  htotal = (u32 )((mode->crtc_hdisplay + -1) | ((mode->crtc_htotal + -1) << 16));
#line 388
  new_crtc_htotal = (u32 )(((mode->crtc_htotal + -1) * 200000) / mode->clock);
#line 390
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 390
  if (tmp != 0L) {
#line 390
    drm_ut_debug_printk("htotal_calculate", "new crtc htotal 0x%4x\n", new_crtc_htotal);
  } else {

  }
#line 391
  return ((u32 )(mode->crtc_hdisplay + -1) | (new_crtc_htotal << 16));
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_find_dpll(struct drm_crtc *crtc , int target , int refclk ,
                                    struct oaktrail_hdmi_clock *best_clock ) 
{ 
  int np_min ;
  int np_max ;
  int nr_min ;
  int nr_max ;
  int np ;
  int nr ;
  int nf ;
  int __x ;
  int __d ;
  long tmp ;

  {
#line 400
  np_min = (((int )oaktrail_hdmi_limit.vco.min + target * 10) + -1) / (target * 10);
#line 401
  np_max = (int )oaktrail_hdmi_limit.vco.max / (target * 10);
#line 402
  if ((int )oaktrail_hdmi_limit.np.min > np_min) {
#line 403
    np_min = oaktrail_hdmi_limit.np.min;
  } else {

  }
#line 404
  if ((int )oaktrail_hdmi_limit.np.max < np_max) {
#line 405
    np_max = oaktrail_hdmi_limit.np.max;
  } else {

  }
#line 407
  nr_min = ((refclk * 1000 + (target * 10) * np_max) + -1) / ((target * 10) * np_max);
#line 408
  nr_max = ((refclk * 1000 + (target * 10) * np_min) + -1) / ((target * 10) * np_min);
#line 409
  if ((int )oaktrail_hdmi_limit.nr.min > nr_min) {
#line 410
    nr_min = oaktrail_hdmi_limit.nr.min;
  } else {

  }
#line 411
  if ((int )oaktrail_hdmi_limit.nr.max < nr_max) {
#line 412
    nr_max = oaktrail_hdmi_limit.nr.max;
  } else {

  }
#line 414
  np = ((refclk * 1000 + (target * 10) * nr_max) + -1) / ((target * 10) * nr_max);
#line 415
  nr = ((refclk * 1000 + (target * 10) * np) + -1) / ((target * 10) * np);
#line 416
  __x = ((target * 10) * np) * nr;
#line 416
  __d = refclk;
#line 416
  nf = __x > 0 ? (__d / 2 + __x) / __d : (__x - __d / 2) / __d;
#line 417
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 417
  if (tmp != 0L) {
#line 417
    drm_ut_debug_printk("oaktrail_hdmi_find_dpll", "np, nr, nf %d %d %d\n", np, nr,
                        nf);
  } else {

  }
#line 423
  best_clock->np = np;
#line 424
  best_clock->nr = nr + -1;
#line 425
  best_clock->nf = nf << 14;
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void scu_busy_loop(void *scu_base ) 
{ 
  u32 status ;
  u32 loop_count ;
  long tmp ;

  {
#line 430
  status = 0U;
#line 431
  loop_count = 0U;
#line 433
  status = readl((void const volatile   *)scu_base + 4U);
#line 434
  goto ldv_39783;
  ldv_39782: 
#line 435
  __const_udelay(4295UL);
#line 436
  status = readl((void const volatile   *)scu_base + 4U);
#line 437
  loop_count = loop_count + 1U;
#line 439
  if (loop_count > 1000U) {
#line 440
    tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 440
    if (tmp != 0L) {
#line 440
      drm_ut_debug_printk("scu_busy_loop", "SCU IPC timed out");
    } else {

    }
#line 441
    return;
  } else {

  }
  ldv_39783: ;
#line 434
  if ((int )status & 1) {
#line 436
    goto ldv_39782;
  } else {

  }

#line 441
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_reset(struct drm_device *dev ) 
{ 
  void *base ;
  unsigned long scu_ipc_mmio ;
  int scu_len ;

  {
#line 455
  scu_ipc_mmio = 4279353344UL;
#line 456
  scu_len = 1024;
#line 458
  base = ioremap((unsigned long long )scu_ipc_mmio, (unsigned long )scu_len);
#line 459
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 460
    drm_err("oaktrail_hdmi_reset", "failed to map scu mmio\n");
#line 461
    return;
  } else {

  }
#line 465
  writel(4279357720U, (void volatile   *)base + 12U);
#line 466
  writel(2147483615U, (void volatile   *)base + 128U);
#line 467
  writel(270341U, (void volatile   *)base);
#line 468
  scu_busy_loop(base);
#line 471
  writel(4279357720U, (void volatile   *)base + 12U);
#line 472
  writel(2147483647U, (void volatile   *)base + 128U);
#line 473
  writel(270341U, (void volatile   *)base);
#line 474
  scu_busy_loop(base);
#line 476
  iounmap((void volatile   *)base);
#line 477
  return;
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) 
{ 
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int pipe ;
  int htot_reg ;
  int hblank_reg ;
  int hsync_reg ;
  int vtot_reg ;
  int vblank_reg ;
  int vsync_reg ;
  int dspsize_reg ;
  int dsppos_reg ;
  int pipesrc_reg ;
  int pipeconf_reg ;
  int refclk ;
  struct oaktrail_hdmi_clock clock ;
  u32 dspcntr ;
  u32 pipeconf ;
  u32 dpll ;
  u32 temp ;
  int dspcntr_reg ;
  bool tmp ;
  int tmp___0 ;
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
#line 485
  dev = crtc->dev;
#line 486
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 487
  hdmi_dev = dev_priv->hdmi_priv;
#line 488
  pipe = 1;
#line 489
  htot_reg = pipe == 0 ? 393216 : 397312;
#line 490
  hblank_reg = pipe == 0 ? 393220 : 397316;
#line 491
  hsync_reg = pipe == 0 ? 393224 : 397320;
#line 492
  vtot_reg = pipe == 0 ? 393228 : 397324;
#line 493
  vblank_reg = pipe == 0 ? 393232 : 397328;
#line 494
  vsync_reg = pipe == 0 ? 393236 : 397332;
#line 495
  dspsize_reg = pipe == 0 ? 459152 : 463248;
#line 496
  dsppos_reg = pipe == 0 ? 459148 : 463244;
#line 497
  pipesrc_reg = pipe == 0 ? 393244 : 397340;
#line 498
  pipeconf_reg = pipe == 0 ? 458760 : 462856;
#line 502
  dspcntr_reg = 463232;
#line 504
  tmp = gma_power_begin(dev, 1);
#line 504
  if (tmp) {
#line 504
    tmp___0 = 0;
  } else {
#line 504
    tmp___0 = 1;
  }
#line 504
  if (tmp___0) {
#line 505
    return (0);
  } else {

  }
#line 508
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 511
  dpll = REGISTER_READ(dev, 24576U);
#line 512
  if ((dpll & 16U) == 0U) {
#line 513
    REGISTER_WRITE(dev, 24576U, dpll | 24U);
#line 514
    REGISTER_WRITE(dev, 24580U, 0U);
#line 515
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
#line 517
  __const_udelay(644250UL);
#line 520
  oaktrail_hdmi_reset(dev);
#line 523
  refclk = 25000;
#line 524
  oaktrail_hdmi_find_dpll(crtc, adjusted_mode->clock, refclk, & clock);
#line 527
  dpll = REGISTER_READ(dev, 24576U);
#line 528
  dpll = dpll & 4293984255U;
#line 529
  dpll = dpll & 4294967271U;
#line 530
  REGISTER_WRITE(dev, 24576U, 8U);
#line 531
  REGISTER_WRITE(dev, 24580U, (uint32_t )((clock.nf << 6) | clock.nr));
#line 532
  REGISTER_WRITE(dev, 24588U, (uint32_t )((clock.nf >> 14) + -1));
#line 533
  REGISTER_WRITE(dev, 24576U, ((u32 )(clock.np << 16) | dpll) | 3U);
#line 534
  REGISTER_WRITE(dev, 24596U, 2147483648U);
#line 535
  REGISTER_WRITE(dev, 24584U, 2147811586U);
#line 536
  __const_udelay(644250UL);
#line 539
  writel(509U, (void volatile   *)hdmi_dev->regs + 4100U);
#line 540
  writel(1U, (void volatile   *)hdmi_dev->regs + 8192U);
#line 541
  writel(0U, (void volatile   *)hdmi_dev->regs + 8200U);
#line 542
  writel(8U, (void volatile   *)hdmi_dev->regs + 12592U);
#line 543
  writel(25167888U, (void volatile   *)hdmi_dev->regs + 4124U);
#line 545
  temp = htotal_calculate(adjusted_mode);
#line 546
  REGISTER_WRITE(dev, (uint32_t )htot_reg, temp);
#line 547
  REGISTER_WRITE(dev, (uint32_t )hblank_reg, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 548
  REGISTER_WRITE(dev, (uint32_t )hsync_reg, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 549
  REGISTER_WRITE(dev, (uint32_t )vtot_reg, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 550
  REGISTER_WRITE(dev, (uint32_t )vblank_reg, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 551
  REGISTER_WRITE(dev, (uint32_t )vsync_reg, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 552
  REGISTER_WRITE(dev, (uint32_t )pipesrc_reg, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
#line 554
  REGISTER_WRITE(dev, 12544U, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
#line 555
  REGISTER_WRITE(dev, 12548U, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
#line 556
  REGISTER_WRITE(dev, 12552U, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
#line 557
  REGISTER_WRITE(dev, 12556U, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
#line 558
  REGISTER_WRITE(dev, 12560U, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
#line 559
  REGISTER_WRITE(dev, 12564U, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
#line 560
  REGISTER_WRITE(dev, 12572U, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
#line 562
  temp = (u32 )(adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start);
#line 563
  writel((u32 )((adjusted_mode->crtc_hdisplay + -1) << 16) | temp, (void volatile   *)hdmi_dev->regs + 12544U);
#line 565
  REGISTER_WRITE(dev, (uint32_t )dspsize_reg, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
#line 566
  REGISTER_WRITE(dev, (uint32_t )dsppos_reg, 0U);
#line 570
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
#line 571
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
#line 575
  dspcntr = REGISTER_READ(dev, (uint32_t )dspcntr_reg);
#line 576
  dspcntr = dspcntr | 1073741824U;
#line 577
  dspcntr = dspcntr | 16777216U;
#line 578
  dspcntr = dspcntr | 2147483648U;
#line 581
  pipeconf = REGISTER_READ(dev, (uint32_t )pipeconf_reg);
#line 582
  pipeconf = pipeconf | 2147483648U;
#line 584
  REGISTER_WRITE(dev, (uint32_t )pipeconf_reg, pipeconf);
#line 585
  REGISTER_READ(dev, (uint32_t )pipeconf_reg);
#line 587
  REGISTER_WRITE(dev, 14344U, pipeconf);
#line 588
  REGISTER_READ(dev, 14344U);
#line 589
  gma_wait_for_vblank(dev);
#line 591
  REGISTER_WRITE(dev, (uint32_t )dspcntr_reg, dspcntr);
#line 592
  gma_wait_for_vblank(dev);
#line 594
  gma_power_end(dev);
#line 596
  return (0);
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) 
{ 
  struct drm_device *dev ;
  u32 temp ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 601
  dev = crtc->dev;
#line 604
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 604
  if (tmp != 0L) {
#line 604
    drm_ut_debug_printk("oaktrail_crtc_hdmi_dpms", "%s %d\n", "oaktrail_crtc_hdmi_dpms",
                        mode);
  } else {

  }
#line 606
  switch (mode) {
  case 3: 
#line 608
  REGISTER_WRITE(dev, 463872U, 2147483648U);
#line 611
  temp = REGISTER_READ(dev, 463232U);
#line 612
  if ((int )temp < 0) {
#line 613
    REGISTER_WRITE(dev, 463232U, temp & 2147483647U);
#line 614
    REGISTER_READ(dev, 463232U);
#line 616
    tmp___0 = REGISTER_READ(dev, 463260U);
#line 616
    REGISTER_WRITE(dev, 463260U, tmp___0);
#line 617
    REGISTER_READ(dev, 463260U);
  } else {

  }
#line 621
  temp = REGISTER_READ(dev, 462856U);
#line 622
  if ((int )temp < 0) {
#line 623
    REGISTER_WRITE(dev, 462856U, temp & 2147483647U);
#line 624
    REGISTER_READ(dev, 462856U);
  } else {

  }
#line 628
  temp = REGISTER_READ(dev, 14344U);
#line 629
  if ((int )temp < 0) {
#line 630
    REGISTER_WRITE(dev, 14344U, temp & 2147483647U);
#line 631
    REGISTER_READ(dev, 14344U);
  } else {

  }
#line 635
  __const_udelay(644250UL);
#line 638
  temp = REGISTER_READ(dev, 24576U);
#line 639
  if ((temp & 16U) == 0U) {
#line 640
    REGISTER_WRITE(dev, 24576U, temp | 24U);
#line 641
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
#line 645
  __const_udelay(644250UL);
#line 647
  goto ldv_39830;
  case 0: ;
  case 1: ;
  case 2: 
#line 652
  temp = REGISTER_READ(dev, 24576U);
#line 653
  if ((temp & 16U) != 0U) {
#line 654
    REGISTER_WRITE(dev, 24576U, temp & 4294967271U);
#line 655
    temp = REGISTER_READ(dev, 24584U);
#line 656
    REGISTER_WRITE(dev, 24584U, temp | 2147483906U);
#line 657
    REGISTER_READ(dev, 24584U);
  } else {

  }
#line 660
  __const_udelay(644250UL);
#line 663
  temp = REGISTER_READ(dev, 462856U);
#line 664
  if ((int )temp >= 0) {
#line 665
    REGISTER_WRITE(dev, 462856U, temp | 2147483648U);
#line 666
    REGISTER_READ(dev, 462856U);
  } else {

  }
#line 670
  temp = REGISTER_READ(dev, 14344U);
#line 671
  if ((int )temp >= 0) {
#line 672
    REGISTER_WRITE(dev, 14344U, temp | 2147483648U);
#line 673
    REGISTER_READ(dev, 14344U);
  } else {

  }
#line 676
  gma_wait_for_vblank(dev);
#line 679
  temp = REGISTER_READ(dev, 463232U);
#line 680
  if ((int )temp >= 0) {
#line 681
    REGISTER_WRITE(dev, 463232U, temp | 2147483648U);
#line 683
    tmp___1 = REGISTER_READ(dev, 463260U);
#line 683
    REGISTER_WRITE(dev, 463260U, tmp___1);
#line 684
    REGISTER_READ(dev, 463260U);
  } else {

  }
#line 687
  gma_crtc_load_lut(crtc);
  }
  ldv_39830: 
#line 691
  REGISTER_WRITE(dev, 458800U, 16319U);
#line 694
  REGISTER_WRITE(dev, 458804U, 1065880074U);
#line 697
  REGISTER_WRITE(dev, 458808U, 184944648U);
#line 700
  REGISTER_WRITE(dev, 458832U, 134415364U);
#line 703
  REGISTER_WRITE(dev, 458836U, 67372036U);
#line 706
  REGISTER_WRITE(dev, 459776U, 16384U);
#line 708
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ 
  int dpms_mode ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;

  {
#line 713
  dpms_mode = -1;
#line 715
  dev = encoder->dev;
#line 716
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 717
  hdmi_dev = dev_priv->hdmi_priv;
#line 720
  if (dpms_mode == mode) {
#line 721
    return;
  } else {

  }
#line 723
  if (mode != 0) {
#line 724
    temp = 0U;
  } else {
#line 726
    temp = 153U;
  }
#line 728
  dpms_mode = mode;
#line 729
  writel(temp, (void volatile   *)hdmi_dev->regs + 12288U);
#line 730
  return;
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static int oaktrail_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 


  {
#line 735
  if (mode->clock > 165000) {
#line 736
    return (15);
  } else {

  }
#line 737
  if (mode->clock <= 19999) {
#line 738
    return (16);
  } else {

  }
#line 740
  if ((mode->flags & 32U) != 0U) {
#line 741
    return (8);
  } else {

  }
#line 743
  return (0);
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static enum drm_connector_status oaktrail_hdmi_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ 
  enum drm_connector_status status ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;
  long tmp ;

  {
#line 750
  dev = connector->dev;
#line 751
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 752
  hdmi_dev = dev_priv->hdmi_priv;
#line 755
  temp = readl((void const volatile   *)hdmi_dev->regs + 4104U);
#line 756
  tmp = ldv__builtin_expect((drm_debug & 4U) != 0U, 0L);
#line 756
  if (tmp != 0L) {
#line 756
    drm_ut_debug_printk("oaktrail_hdmi_detect", "HDMI_HSR %x\n", temp);
  } else {

  }
#line 758
  if ((int )temp & 1) {
#line 759
    status = 1;
  } else {
#line 761
    status = 2;
  }
#line 763
  return (status);
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static unsigned char const   raw_edid[128U]  = 
#line 766
  {      0U,      255U,      255U,      255U, 
        255U,      255U,      255U,      0U, 
        16U,      172U,      47U,      160U, 
        83U,      85U,      51U,      48U, 
        22U,      19U,      1U,      3U, 
        14U,      58U,      36U,      120U, 
        234U,      233U,      245U,      172U, 
        81U,      48U,      180U,      37U, 
        17U,      80U,      84U,      165U, 
        75U,      0U,      129U,      128U, 
        169U,      64U,      113U,      79U, 
        179U,      0U,      1U,      1U, 
        1U,      1U,      1U,      1U, 
        1U,      1U,      40U,      60U, 
        128U,      160U,      112U,      176U, 
        35U,      64U,      48U,      32U, 
        54U,      0U,      70U,      108U, 
        33U,      0U,      0U,      26U, 
        0U,      0U,      0U,      255U, 
        0U,      71U,      78U,      55U, 
        50U,      49U,      57U,      53U, 
        82U,      48U,      51U,      85U, 
        83U,      10U,      0U,      0U, 
        0U,      252U,      0U,      68U, 
        69U,      76U,      76U,      32U, 
        50U,      55U,      48U,      57U, 
        87U,      10U,      32U,      32U, 
        0U,      0U,      0U,      253U, 
        0U,      56U,      76U,      30U, 
        83U,      17U,      0U,      10U, 
        32U,      32U,      32U,      32U, 
        32U,      32U,      0U,      141U};
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static int oaktrail_hdmi_get_modes(struct drm_connector *connector ) 
{ 
  struct i2c_adapter *i2c_adap ;
  struct edid *edid ;
  int ret ;

  {
#line 784
  ret = 0;
#line 791
  i2c_adap = i2c_get_adapter(3);
#line 792
  if ((unsigned long )i2c_adap == (unsigned long )((struct i2c_adapter *)0)) {
#line 793
    drm_err("oaktrail_hdmi_get_modes", "No ddc adapter available!\n");
#line 794
    edid = (struct edid *)(& raw_edid);
  } else {
#line 796
    edid = (struct edid *)(& raw_edid);
  }
#line 800
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
#line 801
    drm_mode_connector_update_edid_property(connector, edid);
#line 802
    ret = drm_add_edid_modes(connector, edid);
  } else {

  }
#line 804
  return (ret);
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ 
  struct drm_device *dev ;

  {
#line 811
  dev = encoder->dev;
#line 813
  oaktrail_hdmi_audio_enable(dev);
#line 814
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_destroy(struct drm_connector *connector ) 
{ 


  {
#line 819
  return;
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static struct drm_encoder_helper_funcs  const  oaktrail_hdmi_helper_funcs  = 
#line 822
     {& oaktrail_hdmi_dpms, 0, 0, & gma_encoder_mode_fixup, & gma_encoder_prepare, & gma_encoder_commit,
    & oaktrail_hdmi_mode_set, 0, 0, 0};
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static struct drm_connector_helper_funcs  const  oaktrail_hdmi_connector_helper_funcs  =    {& oaktrail_hdmi_get_modes,
    (enum drm_mode_status (*)(struct drm_connector * , struct drm_display_mode * ))(& oaktrail_hdmi_mode_valid),
    & gma_best_encoder};
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static struct drm_connector_funcs  const  oaktrail_hdmi_connector_funcs  = 
#line 837
     {& drm_helper_connector_dpms, 0, 0, 0, & oaktrail_hdmi_detect, & drm_helper_probe_single_connector_modes,
    0, & oaktrail_hdmi_destroy, 0};
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static void oaktrail_hdmi_enc_destroy(struct drm_encoder *encoder ) 
{ 


  {
#line 846
  drm_encoder_cleanup(encoder);
#line 847
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
static struct drm_encoder_funcs  const  oaktrail_hdmi_enc_funcs  =    {0, & oaktrail_hdmi_enc_destroy};
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ 
  struct gma_encoder *gma_encoder ;
  struct gma_connector *gma_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 861
  tmp = kzalloc(152UL, 208U);
#line 861
  gma_encoder = (struct gma_encoder *)tmp;
#line 862
  if ((unsigned long )gma_encoder == (unsigned long )((struct gma_encoder *)0)) {
#line 863
    return;
  } else {

  }
#line 865
  tmp___0 = kzalloc(728UL, 208U);
#line 865
  gma_connector = (struct gma_connector *)tmp___0;
#line 866
  if ((unsigned long )gma_connector == (unsigned long )((struct gma_connector *)0)) {
#line 867
    goto failed_connector;
  } else {

  }
#line 869
  connector = & gma_connector->base;
#line 870
  encoder = & gma_encoder->base;
#line 871
  drm_connector_init(dev, connector, & oaktrail_hdmi_connector_funcs, 3);
#line 875
  drm_encoder_init(dev, encoder, & oaktrail_hdmi_enc_funcs, 2);
#line 879
  gma_connector_attach_encoder(gma_connector, gma_encoder);
#line 881
  gma_encoder->type = 6;
#line 882
  drm_encoder_helper_add(encoder, & oaktrail_hdmi_helper_funcs);
#line 883
  drm_connector_helper_add(connector, & oaktrail_hdmi_connector_helper_funcs);
#line 885
  connector->display_info.subpixel_order = 1;
#line 886
  connector->interlace_allowed = 0;
#line 887
  connector->doublescan_allowed = 0;
#line 888
  drm_sysfs_connector_add(connector);
#line 889
  _dev_info((struct device  const  *)dev->dev, "HDMI initialised.\n");
#line 891
  return;
  failed_connector: 
#line 894
  kfree((void const   *)gma_encoder);
#line 895
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_hdmi_setup(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int ret ;
  void *tmp ;

  {
#line 904
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 909
  pdev = pci_get_device(32902U, 2061U, (struct pci_dev *)0);
#line 910
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 911
    return;
  } else {

  }
#line 913
  tmp = kzalloc(96UL, 208U);
#line 913
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 914
  if ((unsigned long )hdmi_dev == (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 915
    dev_err((struct device  const  *)dev->dev, "failed to allocate memory\n");
#line 916
    goto out;
  } else {

  }
#line 920
  ret = pci_enable_device(pdev);
#line 921
  if (ret != 0) {
#line 922
    dev_err((struct device  const  *)dev->dev, "failed to enable hdmi controller\n");
#line 923
    goto free;
  } else {

  }
#line 926
  hdmi_dev->mmio = (unsigned int )pdev->resource[0].start;
#line 927
  hdmi_dev->mmio_len = pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? ((unsigned int )pdev->resource[0].end - (unsigned int )pdev->resource[0].start) + 1U : 0U;
#line 928
  hdmi_dev->regs = ioremap((resource_size_t )hdmi_dev->mmio, (unsigned long )hdmi_dev->mmio_len);
#line 929
  if ((unsigned long )hdmi_dev->regs == (unsigned long )((void *)0)) {
#line 930
    dev_err((struct device  const  *)dev->dev, "failed to map hdmi mmio\n");
#line 931
    goto free;
  } else {

  }
#line 934
  hdmi_dev->dev = pdev;
#line 935
  pci_set_drvdata(pdev, (void *)hdmi_dev);
#line 938
  ret = oaktrail_hdmi_i2c_init(hdmi_dev->dev);
#line 939
  if (ret != 0) {
#line 940
    dev_err((struct device  const  *)dev->dev, "HDMI I2C initialization failed\n");
  } else {

  }
#line 942
  dev_priv->hdmi_priv = hdmi_dev;
#line 943
  oaktrail_hdmi_audio_disable(dev);
#line 945
  _dev_info((struct device  const  *)dev->dev, "HDMI hardware present.\n");
#line 947
  return;
  free: 
#line 950
  kfree((void const   *)hdmi_dev);
  out: ;
#line 952
  return;
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_hdmi_teardown(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct pci_dev *pdev ;

  {
#line 957
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 958
  hdmi_dev = dev_priv->hdmi_priv;
#line 961
  if ((unsigned long )hdmi_dev != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
#line 962
    pdev = hdmi_dev->dev;
#line 963
    pci_set_drvdata(pdev, (void *)0);
#line 964
    oaktrail_hdmi_i2c_exit(pdev);
#line 965
    iounmap((void volatile   *)hdmi_dev->regs);
#line 966
    kfree((void const   *)hdmi_dev);
#line 967
    pci_dev_put(pdev);
  } else {

  }
#line 969
  return;
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_hdmi_save(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
#line 974
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 975
  hdmi_dev = dev_priv->hdmi_priv;
#line 976
  regs = & dev_priv->regs.ldv_40416.psb;
#line 977
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
#line 981
  hdmi_dev->saveDPLL_CTRL = ioread32((void *)dev_priv->vdc_reg + 24576U);
#line 982
  hdmi_dev->saveDPLL_DIV_CTRL = ioread32((void *)dev_priv->vdc_reg + 24580U);
#line 983
  hdmi_dev->saveDPLL_ADJUST = ioread32((void *)dev_priv->vdc_reg + 24588U);
#line 984
  hdmi_dev->saveDPLL_UPDATE = ioread32((void *)dev_priv->vdc_reg + 24596U);
#line 985
  hdmi_dev->saveDPLL_CLK_ENABLE = ioread32((void *)dev_priv->vdc_reg + 24584U);
#line 988
  pipeb->conf = ioread32((void *)dev_priv->vdc_reg + 462856U);
#line 989
  pipeb->src = ioread32((void *)dev_priv->vdc_reg + 397340U);
#line 990
  pipeb->htotal = ioread32((void *)dev_priv->vdc_reg + 397312U);
#line 991
  pipeb->hblank = ioread32((void *)dev_priv->vdc_reg + 397316U);
#line 992
  pipeb->hsync = ioread32((void *)dev_priv->vdc_reg + 397320U);
#line 993
  pipeb->vtotal = ioread32((void *)dev_priv->vdc_reg + 397324U);
#line 994
  pipeb->vblank = ioread32((void *)dev_priv->vdc_reg + 397328U);
#line 995
  pipeb->vsync = ioread32((void *)dev_priv->vdc_reg + 397332U);
#line 997
  hdmi_dev->savePCH_PIPEBCONF = ioread32((void *)dev_priv->vdc_reg + 14344U);
#line 998
  hdmi_dev->savePCH_PIPEBSRC = ioread32((void *)dev_priv->vdc_reg + 12572U);
#line 999
  hdmi_dev->savePCH_HTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12544U);
#line 1000
  hdmi_dev->savePCH_HBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12548U);
#line 1001
  hdmi_dev->savePCH_HSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12552U);
#line 1002
  hdmi_dev->savePCH_VTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12556U);
#line 1003
  hdmi_dev->savePCH_VBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12560U);
#line 1004
  hdmi_dev->savePCH_VSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12564U);
#line 1007
  pipeb->cntr = ioread32((void *)dev_priv->vdc_reg + 463232U);
#line 1008
  pipeb->stride = ioread32((void *)dev_priv->vdc_reg + 463240U);
#line 1009
  pipeb->addr = ioread32((void *)dev_priv->vdc_reg + 463236U);
#line 1010
  pipeb->surf = ioread32((void *)dev_priv->vdc_reg + 463260U);
#line 1011
  pipeb->linoff = ioread32((void *)dev_priv->vdc_reg + 463236U);
#line 1012
  pipeb->tileoff = ioread32((void *)dev_priv->vdc_reg + 463268U);
#line 1015
  regs->saveDSPBCURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458944U);
#line 1016
  regs->saveDSPBCURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458948U);
#line 1017
  regs->saveDSPBCURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458952U);
#line 1020
  i = 0;
#line 1020
  goto ldv_39915;
  ldv_39914: 
#line 1021
  pipeb->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
#line 1020
  i = i + 1;
  ldv_39915: ;
#line 1020
  if (i <= 255) {
#line 1022
    goto ldv_39914;
  } else {

  }

#line 1027
  return;
}
}
#line 1025 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void oaktrail_hdmi_restore(struct drm_device *dev ) 
{ 
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
#line 1027
  dev_priv = (struct drm_psb_private *)dev->dev_private;
#line 1028
  hdmi_dev = dev_priv->hdmi_priv;
#line 1029
  regs = & dev_priv->regs.ldv_40416.psb;
#line 1030
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
#line 1034
  iowrite32(hdmi_dev->saveDPLL_CTRL, (void *)dev_priv->vdc_reg + 24576U);
#line 1035
  iowrite32(hdmi_dev->saveDPLL_DIV_CTRL, (void *)dev_priv->vdc_reg + 24580U);
#line 1036
  iowrite32(hdmi_dev->saveDPLL_ADJUST, (void *)dev_priv->vdc_reg + 24588U);
#line 1037
  iowrite32(hdmi_dev->saveDPLL_UPDATE, (void *)dev_priv->vdc_reg + 24596U);
#line 1038
  iowrite32(hdmi_dev->saveDPLL_CLK_ENABLE, (void *)dev_priv->vdc_reg + 24584U);
#line 1039
  __const_udelay(644250UL);
#line 1042
  iowrite32(pipeb->src, (void *)dev_priv->vdc_reg + 397340U);
#line 1043
  iowrite32(pipeb->htotal, (void *)dev_priv->vdc_reg + 397312U);
#line 1044
  iowrite32(pipeb->hblank, (void *)dev_priv->vdc_reg + 397316U);
#line 1045
  iowrite32(pipeb->hsync, (void *)dev_priv->vdc_reg + 397320U);
#line 1046
  iowrite32(pipeb->vtotal, (void *)dev_priv->vdc_reg + 397324U);
#line 1047
  iowrite32(pipeb->vblank, (void *)dev_priv->vdc_reg + 397328U);
#line 1048
  iowrite32(pipeb->vsync, (void *)dev_priv->vdc_reg + 397332U);
#line 1050
  iowrite32(hdmi_dev->savePCH_PIPEBSRC, (void *)dev_priv->vdc_reg + 12572U);
#line 1051
  iowrite32(hdmi_dev->savePCH_HTOTAL_B, (void *)dev_priv->vdc_reg + 12544U);
#line 1052
  iowrite32(hdmi_dev->savePCH_HBLANK_B, (void *)dev_priv->vdc_reg + 12548U);
#line 1053
  iowrite32(hdmi_dev->savePCH_HSYNC_B, (void *)dev_priv->vdc_reg + 12552U);
#line 1054
  iowrite32(hdmi_dev->savePCH_VTOTAL_B, (void *)dev_priv->vdc_reg + 12556U);
#line 1055
  iowrite32(hdmi_dev->savePCH_VBLANK_B, (void *)dev_priv->vdc_reg + 12560U);
#line 1056
  iowrite32(hdmi_dev->savePCH_VSYNC_B, (void *)dev_priv->vdc_reg + 12564U);
#line 1058
  iowrite32(pipeb->conf, (void *)dev_priv->vdc_reg + 462856U);
#line 1059
  iowrite32(hdmi_dev->savePCH_PIPEBCONF, (void *)dev_priv->vdc_reg + 14344U);
#line 1062
  iowrite32(pipeb->linoff, (void *)dev_priv->vdc_reg + 463236U);
#line 1063
  iowrite32(pipeb->stride, (void *)dev_priv->vdc_reg + 463240U);
#line 1064
  iowrite32(pipeb->tileoff, (void *)dev_priv->vdc_reg + 463268U);
#line 1065
  iowrite32(pipeb->cntr, (void *)dev_priv->vdc_reg + 463232U);
#line 1066
  iowrite32(pipeb->surf, (void *)dev_priv->vdc_reg + 463260U);
#line 1069
  iowrite32(regs->saveDSPBCURSOR_CTRL, (void *)dev_priv->vdc_reg + 458944U);
#line 1070
  iowrite32(regs->saveDSPBCURSOR_POS, (void *)dev_priv->vdc_reg + 458952U);
#line 1071
  iowrite32(regs->saveDSPBCURSOR_BASE, (void *)dev_priv->vdc_reg + 458948U);
#line 1074
  i = 0;
#line 1074
  goto ldv_39926;
  ldv_39925: 
#line 1075
  iowrite32(pipeb->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
#line 1074
  i = i + 1;
  ldv_39926: ;
#line 1074
  if (i <= 255) {
#line 1076
    goto ldv_39925;
  } else {

  }

#line 1081
  return;
}
}
#line 1078
extern int ldv_probe_4(void) ;
#line 1079
extern int ldv_probe_5(void) ;
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_helper_funcs_6(void) 
{ 
  void *tmp ;

  {
#line 1083
  tmp = ldv_zalloc(720UL);
#line 1083
  oaktrail_hdmi_connector_helper_funcs_group0 = (struct drm_connector *)tmp;
#line 1084
  return;
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_connector_funcs_5(void) 
{ 
  void *tmp ;

  {
#line 1087
  tmp = ldv_zalloc(720UL);
#line 1087
  oaktrail_hdmi_connector_funcs_group0 = (struct drm_connector *)tmp;
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_initialize_drm_encoder_helper_funcs_7(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1091
  tmp = ldv_zalloc(96UL);
#line 1091
  oaktrail_hdmi_helper_funcs_group0 = (struct drm_encoder *)tmp;
#line 1092
  tmp___0 = ldv_zalloc(208UL);
#line 1092
  oaktrail_hdmi_helper_funcs_group1 = (struct drm_display_mode *)tmp___0;
#line 1093
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct drm_display_mode *ldvarg127 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1096
  tmp = ldv_zalloc(208UL);
#line 1096
  ldvarg127 = (struct drm_display_mode *)tmp;
#line 1098
  tmp___0 = __VERIFIER_nondet_int();
#line 1098
  switch (tmp___0) {
  case 0: ;
#line 1101
  if (ldv_state_variable_6 == 1) {
#line 1103
    oaktrail_hdmi_get_modes(oaktrail_hdmi_connector_helper_funcs_group0);
#line 1105
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1108
  goto ldv_39946;
  case 1: ;
#line 1111
  if (ldv_state_variable_6 == 1) {
#line 1113
    oaktrail_hdmi_mode_valid(oaktrail_hdmi_connector_helper_funcs_group0, ldvarg127);
#line 1115
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1118
  goto ldv_39946;
  case 2: ;
#line 1121
  if (ldv_state_variable_6 == 1) {
#line 1123
    gma_best_encoder(oaktrail_hdmi_connector_helper_funcs_group0);
#line 1125
    ldv_state_variable_6 = 1;
  } else {

  }
#line 1128
  goto ldv_39946;
  default: 
#line 1129
  ldv_stop();
  }
  ldv_39946: ;
#line 1133
  return;
}
}
#line 1135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_4(void) 
{ 
  struct drm_encoder *ldvarg177 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1136
  tmp = ldv_zalloc(96UL);
#line 1136
  ldvarg177 = (struct drm_encoder *)tmp;
#line 1138
  tmp___0 = __VERIFIER_nondet_int();
#line 1138
  switch (tmp___0) {
  case 0: ;
#line 1141
  if (ldv_state_variable_4 == 2) {
#line 1143
    oaktrail_hdmi_enc_destroy(ldvarg177);
#line 1145
    ldv_state_variable_4 = 1;
#line 1146
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1149
  goto ldv_39955;
  case 1: ;
#line 1152
  if (ldv_state_variable_4 == 1) {
#line 1154
    ldv_probe_4();
#line 1156
    ldv_state_variable_4 = 2;
#line 1157
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1160
  goto ldv_39955;
  default: 
#line 1161
  ldv_stop();
  }
  ldv_39955: ;
#line 1165
  return;
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  int ldvarg5 ;
  int tmp ;
  struct drm_display_mode *ldvarg3 ;
  void *tmp___0 ;
  struct drm_display_mode *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1168
  tmp = __VERIFIER_nondet_int();
#line 1168
  ldvarg5 = tmp;
#line 1169
  tmp___0 = ldv_zalloc(208UL);
#line 1169
  ldvarg3 = (struct drm_display_mode *)tmp___0;
#line 1170
  tmp___1 = ldv_zalloc(208UL);
#line 1170
  ldvarg4 = (struct drm_display_mode *)tmp___1;
#line 1172
  tmp___2 = __VERIFIER_nondet_int();
#line 1172
  switch (tmp___2) {
  case 0: ;
#line 1175
  if (ldv_state_variable_7 == 1) {
#line 1177
    oaktrail_hdmi_dpms(oaktrail_hdmi_helper_funcs_group0, ldvarg5);
#line 1179
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1182
  goto ldv_39965;
  case 1: ;
#line 1185
  if (ldv_state_variable_7 == 1) {
#line 1187
    gma_encoder_mode_fixup(oaktrail_hdmi_helper_funcs_group0, (struct drm_display_mode  const  *)ldvarg4,
                           oaktrail_hdmi_helper_funcs_group1);
#line 1189
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1192
  goto ldv_39965;
  case 2: ;
#line 1195
  if (ldv_state_variable_7 == 1) {
#line 1197
    gma_encoder_commit(oaktrail_hdmi_helper_funcs_group0);
#line 1199
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1202
  goto ldv_39965;
  case 3: ;
#line 1205
  if (ldv_state_variable_7 == 1) {
#line 1207
    oaktrail_hdmi_mode_set(oaktrail_hdmi_helper_funcs_group0, oaktrail_hdmi_helper_funcs_group1,
                           ldvarg3);
#line 1209
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1212
  goto ldv_39965;
  case 4: ;
#line 1215
  if (ldv_state_variable_7 == 1) {
#line 1217
    gma_encoder_prepare(oaktrail_hdmi_helper_funcs_group0);
#line 1219
    ldv_state_variable_7 = 1;
  } else {

  }
#line 1222
  goto ldv_39965;
  default: 
#line 1223
  ldv_stop();
  }
  ldv_39965: ;
#line 1227
  return;
}
}
#line 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  uint32_t ldvarg212 ;
  int ldvarg214 ;
  int tmp ;
  uint32_t ldvarg211 ;
  bool ldvarg213 ;
  int tmp___0 ;

  {
#line 1231
  tmp = __VERIFIER_nondet_int();
#line 1231
  ldvarg214 = tmp;
#line 1230
  memset((void *)(& ldvarg212), 0, 4UL);
#line 1232
  memset((void *)(& ldvarg211), 0, 4UL);
#line 1233
  memset((void *)(& ldvarg213), 0, 1UL);
#line 1235
  tmp___0 = __VERIFIER_nondet_int();
#line 1235
  switch (tmp___0) {
  case 0: ;
#line 1238
  if (ldv_state_variable_5 == 2) {
#line 1240
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg214);
#line 1242
    ldv_state_variable_5 = 2;
  } else {

  }
#line 1245
  if (ldv_state_variable_5 == 1) {
#line 1247
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg214);
#line 1249
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1252
  goto ldv_39979;
  case 1: ;
#line 1255
  if (ldv_state_variable_5 == 2) {
#line 1257
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg213);
#line 1259
    ldv_state_variable_5 = 2;
  } else {

  }
#line 1262
  if (ldv_state_variable_5 == 1) {
#line 1264
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg213);
#line 1266
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1269
  goto ldv_39979;
  case 2: ;
#line 1272
  if (ldv_state_variable_5 == 2) {
#line 1274
    oaktrail_hdmi_destroy(oaktrail_hdmi_connector_funcs_group0);
#line 1276
    ldv_state_variable_5 = 1;
#line 1277
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1280
  goto ldv_39979;
  case 3: ;
#line 1283
  if (ldv_state_variable_5 == 2) {
#line 1285
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg212, ldvarg211);
#line 1287
    ldv_state_variable_5 = 2;
  } else {

  }
#line 1290
  if (ldv_state_variable_5 == 1) {
#line 1292
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg212, ldvarg211);
#line 1294
    ldv_state_variable_5 = 1;
  } else {

  }
#line 1297
  goto ldv_39979;
  case 4: ;
#line 1300
  if (ldv_state_variable_5 == 1) {
#line 1302
    ldv_probe_5();
#line 1304
    ldv_state_variable_5 = 2;
#line 1305
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1308
  goto ldv_39979;
  default: 
#line 1309
  ldv_stop();
  }
  ldv_39979: ;
#line 1313
  return;
}
}
#line 1441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi.o.c.prepared"
void *ldv_kmem_cache_alloc_660(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1444
  ldv_check_alloc_flags(flags);
#line 1446
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1447
  return ((void *)0);
}
}
#line 68 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 86 "include/linux/completion.h"
__inline static void reinit_completion(struct completion *x ) 
{ 


  {
#line 88
  x->done = 0U;
#line 89
  return;
}
}
#line 99
extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_680(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 182
void disable_suitable_irq_1(int line , void *data ) ;
#line 183
void activate_suitable_irq_1(int line , void *data ) ;
#line 205
void choose_interrupt_1(void) ;
#line 209
int ldv_irq_1(int state , int line , void *data ) ;
#line 449 "include/linux/i2c.h"
__inline static void *i2c_get_adapdata(struct i2c_adapter  const  *dev ) 
{ 
  void *tmp ;

  {
#line 451
  tmp = dev_get_drvdata(& dev->dev);
#line 451
  return (tmp);
}
}
#line 507
extern int i2c_add_numbered_adapter(struct i2c_adapter * ) ;
#line 123 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_684(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) ;
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 149
void ldv_free_irq_685(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static void hdmi_i2c_irq_enable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  u32 temp ;

  {
#line 301
  temp = readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 302
  temp = temp | 28U;
#line 303
  writel(temp, (void volatile   *)hdmi_dev->regs + 4100U);
#line 304
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 305
  return;
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static void hdmi_i2c_irq_disable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 


  {
#line 309
  writel(0U, (void volatile   *)hdmi_dev->regs + 4100U);
#line 310
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static int xfer_read(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
#line 315
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
#line 315
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 316
  i2c_dev = hdmi_dev->i2c_dev;
#line 319
  i2c_dev->status = 0;
#line 320
  i2c_dev->msg = pmsg;
#line 321
  i2c_dev->buf_offset = 0;
#line 322
  reinit_completion(& i2c_dev->complete);
#line 325
  temp = (u32 )(((int )pmsg->len << 20) | 13);
#line 326
  writel(temp, (void volatile   *)hdmi_dev->regs + 4672U);
#line 327
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 329
  goto ldv_39749;
  ldv_39748: 
#line 330
  wait_for_completion_interruptible_timeout(& i2c_dev->complete, 2500UL);
  ldv_39749: ;
#line 329
  if (i2c_dev->status != 2) {
#line 331
    goto ldv_39748;
  } else {

  }

#line 333
  return (0);
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static int xfer_write(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ 


  {
#line 341
  return (0);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static int oaktrail_hdmi_i2c_access(struct i2c_adapter *adap , struct i2c_msg *pmsg ,
                                    int num ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  int i ;

  {
#line 348
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
#line 348
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 349
  i2c_dev = hdmi_dev->i2c_dev;
#line 352
  mutex_lock_nested(& i2c_dev->i2c_lock, 0U);
#line 355
  writel(34656U, (void volatile   *)hdmi_dev->regs + 4352U);
#line 358
  hdmi_i2c_irq_enable(hdmi_dev);
#line 359
  i = 0;
#line 359
  goto ldv_39764;
  ldv_39763: ;
#line 360
  if ((unsigned int )pmsg->len != 0U && (unsigned long )pmsg->buf != (unsigned long )((__u8 *)0U)) {
#line 361
    if ((int )pmsg->flags & 1) {
#line 362
      xfer_read(adap, pmsg);
    } else {
#line 364
      xfer_write(adap, pmsg);
    }
  } else {

  }
#line 366
  pmsg = pmsg + 1;
#line 359
  i = i + 1;
  ldv_39764: ;
#line 359
  if (i < num) {
#line 361
    goto ldv_39763;
  } else {

  }
#line 370
  hdmi_i2c_irq_disable(hdmi_dev);
#line 372
  mutex_unlock(& i2c_dev->i2c_lock);
#line 374
  return (i);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static u32 oaktrail_hdmi_i2c_func(struct i2c_adapter *adapter ) 
{ 


  {
#line 379
  return (3U);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static struct i2c_algorithm  const  oaktrail_hdmi_i2c_algorithm  =    {& oaktrail_hdmi_i2c_access, 0, & oaktrail_hdmi_i2c_func};
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static struct i2c_adapter oaktrail_hdmi_i2c_adapter  = 
#line 387
     {& __this_module, 8U, & oaktrail_hdmi_i2c_algorithm, 0, {{{{0U}}, 0U, 0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                            {0}, 0, 0, 0, 0, 0, 0,
                                                            0}, 0, 0, {0, 0, {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0, 0,
                                                                              {{0}},
                                                                              {{{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               {{0,
                                                                                 0},
                                                                                0UL,
                                                                                0,
                                                                                0,
                                                                                0UL,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               0,
                                                                               0},
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0,
                                                                              (unsigned char)0},
                                                                       0, 0, {{0},
                                                                              {{{{{0U}},
                                                                                 0U,
                                                                                 0U,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                              {0,
                                                                               0},
                                                                              0, 0,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                       0, 0, 0, 0,
                                                                       {{0}, (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        (_Bool)0,
                                                                        {{{{{0U}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}, {0U,
                                                                                 {{{{{{0U}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}}},
                                                                        0, (_Bool)0,
                                                                        (_Bool)0,
                                                                        {{0, 0}, 0UL,
                                                                         0, 0, 0UL,
                                                                         0, 0, 0,
                                                                         {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0},
                                                                         {0, {0, 0},
                                                                          0, 0, 0UL}},
                                                                        0UL, {{0L},
                                                                              {0,
                                                                               0},
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                        {{{{{{0U}},
                                                                            0U, 0U,
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                         {0, 0}},
                                                                        {0}, {0},
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        0, 0, 0, 0,
                                                                        0UL, 0UL,
                                                                        0UL, 0UL,
                                                                        0, 0, 0},
                                                                       0, 0, 0, 0,
                                                                       0ULL, 0UL,
                                                                       0, {0, 0},
                                                                       0, 0, {0, 0},
                                                                       0, {0}, 0U,
                                                                       0U, {{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                       {0, 0}, {0,
                                                                                {0,
                                                                                 0},
                                                                                {{0}}},
                                                                       0, 0, 0, 0,
                                                                       (_Bool)0, (_Bool)0},
    3, {'o', 'a', 'k', 't', 'r', 'a', 'i', 'l', '_', 'h', 'd', 'm', 'i', '_', 'i',
        '2', 'c', '\000'}, {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
                                 {0, 0}}}, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0},
                                                                        0, 0, 0UL}}}},
                                            {0, 0}, 0, 0, 0, {0, {0, 0}, 0, 0, 0UL}},
    {0, 0}, 0};
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static void hdmi_i2c_read(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  struct hdmi_i2c_dev *i2c_dev ;
  struct i2c_msg *msg ;
  u8 *buf ;
  u32 temp ;
  int i ;
  int offset ;
  size_t __len ;
  void *__ret ;

  {
#line 397
  i2c_dev = hdmi_dev->i2c_dev;
#line 398
  msg = i2c_dev->msg;
#line 399
  buf = msg->buf;
#line 403
  offset = i2c_dev->buf_offset;
#line 404
  i = 0;
#line 404
  goto ldv_39784;
  ldv_39783: 
#line 405
  temp = readl((void const volatile   *)hdmi_dev->regs + (unsigned long )((i + 1152) * 4));
#line 406
  __len = 4UL;
#line 406
  if (__len > 63UL) {
#line 406
    __ret = __memcpy((void *)buf + (unsigned long )(i * 4 + offset), (void const   *)(& temp),
                     __len);
  } else {
#line 406
    __ret = __builtin_memcpy((void *)buf + (unsigned long )(i * 4 + offset), (void const   *)(& temp),
                             __len);
  }
#line 404
  i = i + 1;
  ldv_39784: ;
#line 404
  if (i <= 15) {
#line 406
    goto ldv_39783;
  } else {

  }
#line 408
  i2c_dev->buf_offset = i2c_dev->buf_offset + 64;
#line 411
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 412
  writel(temp | 8U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 413
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 416
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 417
  writel(temp | 2U, (void volatile   *)hdmi_dev->regs + 4672U);
#line 418
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 420
  i2c_dev->status = 1;
#line 421
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static void hdmi_i2c_transaction_done(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 
  struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
#line 426
  i2c_dev = hdmi_dev->i2c_dev;
#line 430
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 431
  writel(temp | 4U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 432
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 435
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 436
  writel(temp & 4294967294U, (void volatile   *)hdmi_dev->regs + 4672U);
#line 437
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
#line 439
  i2c_dev->status = 2;
#line 440
  return;
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static irqreturn_t oaktrail_hdmi_i2c_handler(int this_irq , void *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 stat ;

  {
#line 445
  hdmi_dev = (struct oaktrail_hdmi_dev *)dev;
#line 446
  i2c_dev = hdmi_dev->i2c_dev;
#line 449
  stat = readl((void const volatile   *)hdmi_dev->regs + 4108U);
#line 451
  if ((int )stat & 1) {
#line 452
    writel(stat | 1U, (void volatile   *)hdmi_dev->regs + 4108U);
#line 453
    readl((void const volatile   *)hdmi_dev->regs + 4108U);
  } else {

  }
#line 456
  if ((stat & 8U) != 0U) {
#line 457
    hdmi_i2c_read(hdmi_dev);
  } else {

  }
#line 459
  if ((stat & 4U) != 0U) {
#line 460
    hdmi_i2c_transaction_done(hdmi_dev);
  } else {

  }
#line 462
  complete(& i2c_dev->complete);
#line 464
  return (1);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
static void oaktrail_hdmi_i2c_gpio_fix(void) 
{ 
  void *base ;
  unsigned int gpio_base ;
  int gpio_len ;
  u32 temp ;
  long tmp ;
  long tmp___0 ;

  {
#line 474
  gpio_base = 4279418880U;
#line 475
  gpio_len = 4096;
#line 478
  base = ioremap((unsigned long long )gpio_base, (unsigned long )gpio_len);
#line 479
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 480
    drm_err("oaktrail_hdmi_i2c_gpio_fix", "gpio ioremap fail\n");
#line 481
    return;
  } else {

  }
#line 484
  temp = readl((void const volatile   *)base + 68U);
#line 485
  tmp = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 485
  if (tmp != 0L) {
#line 485
    drm_ut_debug_printk("oaktrail_hdmi_i2c_gpio_fix", "old gpio val %x\n", temp);
  } else {

  }
#line 486
  writel(temp | 2560U, (void volatile   *)base + 68U);
#line 487
  temp = readl((void const volatile   *)base + 68U);
#line 488
  tmp___0 = ldv__builtin_expect((drm_debug & 2U) != 0U, 0L);
#line 488
  if (tmp___0 != 0L) {
#line 488
    drm_ut_debug_printk("oaktrail_hdmi_i2c_gpio_fix", "new gpio val %x\n", temp);
  } else {

  }
#line 490
  iounmap((void volatile   *)base);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
#line 499
  tmp = pci_get_drvdata(dev);
#line 499
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 501
  tmp___0 = kzalloc(296UL, 208U);
#line 501
  i2c_dev = (struct hdmi_i2c_dev *)tmp___0;
#line 502
  if ((unsigned long )i2c_dev == (unsigned long )((struct hdmi_i2c_dev *)0)) {
#line 503
    drm_err("oaktrail_hdmi_i2c_init", "Can\'t allocate interface\n");
#line 504
    ret = -12;
#line 505
    goto exit;
  } else {

  }
#line 508
  i2c_dev->adap = & oaktrail_hdmi_i2c_adapter;
#line 509
  i2c_dev->status = 0;
#line 510
  init_completion(& i2c_dev->complete);
#line 511
  __mutex_init(& i2c_dev->i2c_lock, "&i2c_dev->i2c_lock", & __key);
#line 512
  i2c_set_adapdata(& oaktrail_hdmi_i2c_adapter, (void *)hdmi_dev);
#line 513
  hdmi_dev->i2c_dev = i2c_dev;
#line 516
  oaktrail_hdmi_i2c_gpio_fix();
#line 519
  ret = ldv_request_irq_684(dev->irq, & oaktrail_hdmi_i2c_handler, 128UL, (char const   *)(& oaktrail_hdmi_i2c_adapter.name),
                            (void *)hdmi_dev);
#line 521
  if (ret != 0) {
#line 522
    drm_err("oaktrail_hdmi_i2c_init", "Failed to request IRQ for I2C controller\n");
#line 523
    goto err;
  } else {

  }
#line 527
  ret = i2c_add_numbered_adapter(& oaktrail_hdmi_i2c_adapter);
#line 528
  return (ret);
  err: 
#line 531
  kfree((void const   *)i2c_dev);
  exit: ;
#line 533
  return (ret);
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) 
{ 
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  void *tmp ;

  {
#line 541
  tmp = pci_get_drvdata(dev);
#line 541
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
#line 542
  i2c_del_adapter(& oaktrail_hdmi_i2c_adapter);
#line 544
  i2c_dev = hdmi_dev->i2c_dev;
#line 545
  kfree((void const   *)i2c_dev);
#line 546
  ldv_free_irq_685(dev->irq, (void *)hdmi_dev);
#line 547
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 551
  if ((unsigned long )handler == (unsigned long )(& oaktrail_hdmi_i2c_handler)) {
#line 552
    return (1);
  } else {

  }
#line 554
  return (0);
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 559
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 560
    ldv_irq_1_0 = 0;
#line 561
    return;
  } else {

  }
#line 563
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 564
    ldv_irq_1_1 = 0;
#line 565
    return;
  } else {

  }
#line 567
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 568
    ldv_irq_1_2 = 0;
#line 569
    return;
  } else {

  }
#line 571
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 572
    ldv_irq_1_3 = 0;
#line 573
    return;
  } else {

  }
#line 575
  return;
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 580
  if (ldv_irq_1_0 == 0) {
#line 581
    ldv_irq_line_1_0 = line;
#line 582
    ldv_irq_data_1_0 = data;
#line 583
    ldv_irq_1_0 = 1;
#line 584
    return;
  } else {

  }
#line 586
  if (ldv_irq_1_1 == 0) {
#line 587
    ldv_irq_line_1_1 = line;
#line 588
    ldv_irq_data_1_1 = data;
#line 589
    ldv_irq_1_1 = 1;
#line 590
    return;
  } else {

  }
#line 592
  if (ldv_irq_1_2 == 0) {
#line 593
    ldv_irq_line_1_2 = line;
#line 594
    ldv_irq_data_1_2 = data;
#line 595
    ldv_irq_1_2 = 1;
#line 596
    return;
  } else {

  }
#line 598
  if (ldv_irq_1_3 == 0) {
#line 599
    ldv_irq_line_1_3 = line;
#line 600
    ldv_irq_data_1_3 = data;
#line 601
    ldv_irq_1_3 = 1;
#line 602
    return;
  } else {

  }
#line 604
  return;
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 609
  tmp = __VERIFIER_nondet_int();
#line 609
  switch (tmp) {
  case 0: 
#line 611
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 613
  goto ldv_39838;
  case 1: 
#line 615
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 617
  goto ldv_39838;
  case 2: 
#line 619
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 621
  goto ldv_39838;
  case 3: 
#line 623
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 625
  goto ldv_39838;
  default: 
#line 626
  ldv_stop();
  }
  ldv_39838: ;
#line 628
  return;
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_initialize_i2c_algorithm_3(void) 
{ 
  void *tmp ;

  {
#line 633
  tmp = ldv_zalloc(1936UL);
#line 633
  oaktrail_hdmi_i2c_algorithm_group0 = (struct i2c_adapter *)tmp;
#line 634
  return;
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;

  {
#line 638
  if (state != 0) {
#line 639
    tmp = __VERIFIER_nondet_int();
#line 639
    switch (tmp) {
    case 0: ;
#line 641
    if (state == 1) {
#line 642
      LDV_IN_INTERRUPT = 2;
#line 643
      irq_retval = oaktrail_hdmi_i2c_handler(line, data);
#line 644
      LDV_IN_INTERRUPT = 1;
#line 645
      return (state);
    } else {

    }
#line 648
    goto ldv_39853;
    default: 
#line 649
    ldv_stop();
    }
    ldv_39853: ;
  } else {

  }
#line 652
  return (state);
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_main_exported_3(void) 
{ 
  int ldvarg142 ;
  int tmp ;
  struct i2c_msg *ldvarg143 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 658
  tmp = __VERIFIER_nondet_int();
#line 658
  ldvarg142 = tmp;
#line 659
  tmp___0 = ldv_zalloc(16UL);
#line 659
  ldvarg143 = (struct i2c_msg *)tmp___0;
#line 661
  tmp___1 = __VERIFIER_nondet_int();
#line 661
  switch (tmp___1) {
  case 0: ;
#line 664
  if (ldv_state_variable_3 == 1) {
#line 666
    oaktrail_hdmi_i2c_access(oaktrail_hdmi_i2c_algorithm_group0, ldvarg143, ldvarg142);
#line 668
    ldv_state_variable_3 = 1;
  } else {

  }
#line 671
  goto ldv_39861;
  case 1: ;
#line 674
  if (ldv_state_variable_3 == 1) {
#line 676
    oaktrail_hdmi_i2c_func(oaktrail_hdmi_i2c_algorithm_group0);
#line 678
    ldv_state_variable_3 = 1;
  } else {

  }
#line 681
  goto ldv_39861;
  default: 
#line 682
  ldv_stop();
  }
  ldv_39861: ;
#line 686
  return;
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void *ldv_kmem_cache_alloc_680(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 817
  ldv_check_alloc_flags(flags);
#line 819
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 820
  return ((void *)0);
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
__inline static int ldv_request_irq_684(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 846
  tmp = request_irq(irq, handler, flags, name, dev);
#line 846
  ldv_func_res = tmp;
#line 848
  tmp___0 = reg_check_1(handler);
#line 848
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 849
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 852
  return (ldv_func_res);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/dscv/ri/43_2a/drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.o.c.prepared"
void ldv_free_irq_685(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 858
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 860
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 861
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/9064/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
